Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


21. Class Hierarchies
22. Run-Time Type Information
23. Templates
47h 26m remaining
22. Run-Time Type Information
Premature optimization is the root of all evil.

– Donald Knuth

On the other hand, we cannot ignore efficiency.

– Jon Bentley

• Introduction

• Class Hierarchy Navigation

dynamic cast; Multiple Inheritance; static_cast and dynamic_cast; Recovering an Interface

• Double Dispatch and Visitors

Double Dispatch; Visitors

• Construction and Destruction

• Type Identification

Extended Type Information

• Uses and Misuses of RTTI

• Advice

22.1. Introduction
In general, a class is constructed from a lattice of base classes. Such a class lattice is often called a class hierarchy. We try to design classes so that users need not be unduly concerned about the way a class is composed out of other classes. In particular, the virtual call mechanism ensures that when we call a function f() on an object, the same function is called whichever class in the hierarchy provided the declaration of f() used for the call and whichever class defined it. This chapter explains how to gain information about the total object given only the interface provided by a base class.

22.2. Class Hierarchy Navigation
A plausible use of the Ival_boxes defined in §21.2 would be to hand them to a system that controlled a screen and have that system hand objects back to the application program whenever some activity had occurred. We will refer to the combination of GUI library and operating system facilities that control the screen as the system. Objects passed back and forth between the system and the application are commonly referred to as widgets or controls. This is how many user interfaces work. From a language point of view, it is important that the system does not know about our Ival_boxes. The system’s interfaces are specified in terms of the system’s own classes and objects rather than our application’s classes. This is necessary and proper. However, it does have the unpleasant effect that we lose information about the type of objects passed to the system and later returned to us.

Recovering the “lost” type of an object requires us to somehow ask the object to reveal its type. Any operation on an object requires us to have a pointer or reference of a suitable type for the object. Consequently, the most obvious and useful operation for inspecting the type of an object at run time is a type conversion operation that returns a valid pointer if the object is of the expected type and a null pointer if it isn’t. The dynamic_cast operator does exactly that. For example, assume that “the system” invokes my_event_handler() with a pointer to a BBwindow, where an activity has occurred. I then might invoke my application code using Ival_box’s do_something():

Click here to view code image

void my_event_handler(BBwindow* pw)
{
     if (auto pb = dynamic_cast<Ival_box*>(pw)) {  // does pw point to an Ival_box?
           //...
          int x = pb–>get_value();  // use the Ival_box
           //...
     }
     else {
           //... oops! cope with unexpected event ...
     }
}
One way of explaining what is going on here is that dynamic_cast translates from the implementation-oriented language of the user-interface system to the language of the application. It is important to note what is not mentioned in this example: the actual type of the object. The object will be a particular kind of Ival_box, say, an Ival_slider, implemented by a particular kind of BBwindow, say, a BBslider. It is neither necessary nor desirable to make the actual type of the object explicit in this interaction between “the system” and the application. An interface exists to represent the essentials of an interaction. In particular, a well-designed interface hides inessential details.

Graphically, the action of pb=dynamic_cast<Ival_box*>(pw) can be represented like this: The arrows from pw and pb represent the pointers into the object passed, whereas the rest of the arrows represent the inheritance relationships between the different parts of the object passed.

The use of type information at run time is conventionally referred to as “run-time type information,” often abbreviated to RTTI.

Casting from a base class to a derived class is often called a downcast because of the convention of drawing inheritance trees growing from the root down. Similarly, a cast from a derived class to a base is called an upcast. A cast that goes from a base to a sibling class, like the cast from BBwindow to Ival_box, is called a crosscast.

22.2.1. dynamic_cast
The dynamic_cast operator takes two operands: a type bracketed by < and >, and a pointer or reference bracketed by ( and ). Consider first the pointer case:

dynamic_cast<T*>(p)
If p is of type T* or of a type D* where T is a base class of D, the result is exactly as if we had simply assigned p to a T*. For example:

Click here to view code image

class BB_ival_slider : public Ival_slider, protected BBslider {
      //...
};

void f(BB_ival_slider* p)
{
     Ival_slider* pi1 = p;                                      // OK
     Ival_slider* pi2 = dynamic_cast<Ival_slider*>(p);          // OK

     BBslider* pbb1 = p;                                        // error: BBslider is a protected base
     BBslider* pbb2 = dynamic_cast<BBslider*>(p);               // OK: pbb2 becomes nullptr
}
This (the upcast) is the uninteresting case. However, it is reassuring to know that dynamic_cast doesn’t allow accidental violation of the protection of private and protected base classes. Since a dynamic_cast used as an upcast is exactly like a simple assignment, it implies no overhead and is sensitive to its lexical context.

The purpose of dynamic_cast is to deal with the case in which the correctness of the conversion cannot be determined by the compiler. In that case, dynamic_cast<T*>(p) looks at the object pointed to by p (if any). If that object is of class T or has a unique base class of type T, then dynamic_cast returns a pointer of type T* to that object; otherwise, nullptr is returned. If the value of p is nullptr, dynamic_cast<T*>(p) returns nullptr. Note the requirement that the conversion must be to a uniquely identified object. It is possible to construct examples where the conversion fails and nullptr is returned because the object pointed to by p has more than one subobject representing bases of type T (§22.2).

A dynamic_cast requires a pointer or a reference to a polymorphic type in order to do a downcast or a crosscast. For example:

Click here to view code image

class My_slider: public Ival_slider {     // polymorphic base (Ival_slider has virtual functions)
      //...
};

class My_date : public Date {             // base not polymorphic (Date has no virtual functions)
      //...
};

void g(Ival_box* pb, Date* pd)
{
     My_slider* pd1 = dynamic_cast<My_slider*>(pb);      // OK (an Ival_slider is an Ival_box)
     My_date* pd2 = dynamic_cast<My_date*>(pd);          // error: Date not polymorphic
}
Requiring the pointer’s type to be polymorphic simplifies the implementation of dynamic_cast because it makes it easy to find a place to hold the necessary information about the object’s type. A typical implementation will attach a “type information object” (§22.5) to an object by placing a pointer to the type information in the virtual function table for the object’s class (§3.2.3). For example:



The dashed arrow represents an offset that allows the start of the complete object to be found given only a pointer to a polymorphic subobject. It is clear that dynamic_cast can be efficiently implemented. All that is involved are a few comparisons of type_info objects representing base classes; no expensive lookups or string comparisons are needed.

Restricting dynamic_cast to polymorphic types also makes sense from a logical point of view. That is, if an object has no virtual functions, it cannot safely be manipulated without knowledge of its exact type. Consequently, care should be taken not to get such an object into a context in which its type isn’t known. If its type is known, we don’t need to use dynamic_cast.

The target type of dynamic_cast need not be polymorphic. This allows us to wrap a concrete type in a polymorphic type, say, for transmission through an object I/O system (§22.2.4), and then “unwrap” the concrete type later. For example:

Click here to view code image

class Io_obj {             // base class for object I/O system
     virtual Io_obj* clone() = 0;
};

class Io_date : public Date, public Io_obj { };

void f(Io_obj* pio)
{
     Date* pd = dynamic_cast<Date*>(pio);
      //...
}
A dynamic_cast to void* can be used to determine the address of the beginning of an object of polymorphic type. For example:

Click here to view code image

void g(Ival_box* pb, Date* pd)
{
     void* pb2 = dynamic_cast<void*>(pb);    // OK
     void* pd2 = dynamic_cast<void*>(pd);    // error: Date not polymorphic
}
The object representing a base class, such as Ival_box, in a derived class object is not necessarily the first subobject in that object of the most derived class. So, pb does not necessarily hold the same address as pb2.

Such casts are only useful for interaction with very low-level functions (only such functions deal with void*s). There is no dynamic_cast from void* (because there would be no way of knowing where to find the vptr; §22.2.3).

22.2.1.1. dynamic_cast to Reference
To get polymorphic behavior, an object must be manipulated through a pointer or a reference. When a dynamic_cast is used for a pointer type, a nullptr indicates failure. That is neither feasible nor desirable for references.

Given a pointer result, we must consider the possibility that the result is nullptr, that is, that the pointer doesn’t point to an object. Consequently, the result of a dynamic_cast of a pointer should always be explicitly tested. For a pointer p, dynamic_cast<T*>(p) can be seen as the question “Is the object pointed to by p, if any, of type T?” For example:

Click here to view code image

void fp(Ival_box* p)
{
     if (Ival_slider* is = dynamic_cast<Ival_slider*>(p)) {    // does p point to an Ival_slider?
           //... use is ...
     }
     else {
           //... *p not a slider; handle alternatives ...
     }
}
On the other hand, we may legitimately assume that a reference refers to an object (§7.7.4). Consequently, dynamic_cast<T&>(r) of a reference r is not a question but an assertion: “The object referred to by r is of type T.” The result of a dynamic_cast for a reference is implicitly tested by the implementation of dynamic_cast itself. If the operand of a dynamic_cast to a reference isn’t of the expected type, a bad_cast exception is thrown. For example:

Click here to view code image

void fr(Ival_box& r)
{
     Ival_slider& is = dynamic_cast<Ival_slider&>(r);      // r references an Ival_slider!
      //... use is ...
}
The difference in results of a failed dynamic pointer cast and a failed dynamic reference cast reflects a fundamental difference between references and pointers. If a user wants to protect against bad casts to references, a suitable handler must be provided. For example:

Click here to view code image

void g(BB_ival_slider& slider, BB_ival_dial& dial)
{
     try {
           fp(&slider);      // pointer to BB_ival_slider passed as Ival_box*
           fr(slider);       // reference to BB_ival_slider passed as Ival_box&
           fp(&dial);        // pointer to BB_ival_dial passed as Ival_box*
           fr(dial);         // dial passed as Ival_box
     }
     catch (bad_cast) {  //§30.4.1.1
            //...
     }
}
The calls to fp() and the first call to fr() will return normally (assuming that fp() really can cope with a BB_ival_dial), but the second call of fr() will cause a bad_cast exception that will be caught by g().

Explicit tests against nullptr can easily be accidentally omitted. If that worries you, you can write a conversion function that throws an exception instead of returning nullptr in case of failure.

22.2.2. Multiple Inheritance
When only single inheritance is used, a class and its base classes constitute a tree rooted in a single base class. This is simple but often constraining. When multiple inheritance is used, there is no single root. In itself, this doesn’t complicate matters much. However, if a class appears more than once in a hierarchy, we must be a bit careful when we refer to the object or objects that represent that class.

Naturally, we try to keep hierarchies as simple as our application allows (and no simpler). However, once a nontrivial hierarchy has been constructed, we sometimes need to navigate it to find a specific class to use. This need occurs in two variants:

• Sometimes, we want to explicitly name a base class for use as an interface, for example, to resolve an ambiguity or to call a specific function without relying on the virtual function mechanism (an explicitly qualified call; §21.3.3).

• Sometimes, we want to obtain a pointer to a subobject of a hierarchy given a pointer to another, for example, to get a pointer to the complete derived class object from a pointer to a base (a downcast; §22.2.1) or to get a pointer to a base class object from a pointer to another base (a crosscast; §22.2.4).

Here, we consider how to navigate a class hierarchy using type conversions (casts) to gain a pointer of the desired type. To illustrate the mechanisms available and the rules that guide them, consider a lattice containing both a replicated base and a virtual base:

Click here to view code image

class Component
     : public virtual Storable { /* ... */ };
class Receiver
     : public Component { /* ... */ };
class Transmitter
     : public Component { /* ... */ };
class Radio
     : public Receiver, public Transmitter { /* ... */ };
or graphically:



Here, a Radio object has two subobjects of class Component. Consequently, a dynamic_cast from Storable to Component within a Radio will be ambiguous and return a 0. There is simply no way of knowing which Component the programmer wanted:

Click here to view code image

void h1(Radio& r)
{
     Storable* ps = &r;  // a Radio has a unique Storable
      //...
     Component* pc = dynamic_cast<Component*>(ps);           // pc = 0; a Radio has two Components
      //...
}
In general – and typically – a programmer (and a compiler looking at a single translation unit) does not know the complete class lattice. Instead, code is written with the knowledge of some sublattice. For example, a programmer might know only about the Transmitter part of a Radio and write:

Click here to view code image

void h2(Storable* ps)        // ps might or might not point to a Component
{
     if (Component* pc = dynamic_cast<Component*>(ps)) {
           // we have a component!
     }
     else {
           // it wasn't a Component
     }
}
The ambiguity for a pointer to a Radio object is not in general detectable at compile time.

This kind of run-time ambiguity detection is needed only for virtual bases. For ordinary bases, there is always a unique subobject of a given cast (or none) when downcasting (that is, toward a derived class; §22.2). The equivalent ambiguity for virtual bases occurs when upcasting (that is, toward a base), but such ambiguities are caught at compile time.

22.2.3. static_cast and dynamic_cast
A dynamic_cast can cast from a polymorphic virtual base class to a derived class or a sibling class (§22.2.1). A static_cast (§11.5.2) does not examine the object it casts from, so it cannot:

Click here to view code image

void g(Radio& r)
{
     Receiver* prec = &r;                      // Receiver is an ordinary base of Radio
     Radio* pr = static_cast<Radio*>(prec);    // OK, unchecked
     pr = dynamic_cast<Radio*>(prec);          // OK, run-time checked

     Storable* ps = &r;                        // Storable is a virtual base of Radio
     pr = static_cast<Radio*>(ps);             // error: cannot cast from virtual base
     pr = dynamic_cast<Radio* >(ps);           // OK, run-time checked
}
The dynamic_cast requires a polymorphic operand because there is no information stored in a non-polymorphic object that can be used to find the objects for which it represents a base. In particular, an object of a type with layout constraints determined by some other language – such as Fortran or C – may be used as a virtual base class. For objects of such types, only static type information will be available. However, the information needed to provide run-time type identification includes the information needed to implement the dynamic_cast.

Why would anyone want to use a static_cast for class hierarchy navigation? There is a run-time cost associated with the use of a dynamic_cast (§22.2.1). More significantly, there are millions of lines of code that were written before dynamic_cast became available. This code relies on alternative ways of making sure that a cast is valid, so the checking done by dynamic_cast is seen as redundant. However, such code is typically written using the C-style cast (§11.5.3); often obscure errors remain. Where possible, use the safer dynamic_cast.

The compiler cannot assume anything about the memory pointed to by a void*. This implies that dynamic_cast – which must look into an object to determine its type – cannot cast from a void*. For that, a static_cast is needed. For example:

Click here to view code image

Radio* f1(void* p)
{
     Storable* ps = static_cast<Storable*>(p);      // trust the programmer
     return dynamic_cast<Radio*>(ps);
}
Both dynamic_cast and static_cast respect const and access controls. For example:

Click here to view code image

class Users : private set<Person> { /∗ ... ∗/ };

void f2(Users* pu, const Receiver* pcr)
{
     static_cast<set<Person>*>(pu);              // error: access violation
     dynamic_cast<set<Person>*>(pu);             // error: access violation
     static_cast<Receiver*>(pcr);                // error: can't cast away const
     dynamic_cast<Receiver*>(pcr);               // error: can't cast away const

     Receiver* pr = const_cast<Receiver*>(pcr);  // OK
      //...
}
It is not possible to cast to a private base class using static_cast or reinterpret_cast, and “casting away const” (or volatile) requires a const_cast (§11.5.2). Even then, using the result is safe only provided the object wasn’t originally declared const (or volatile) (§16.2.9).

22.2.4. Recovering an Interface
From a design perspective, dynamic_cast (§22.2.1) can be seen as a mechanism for asking an object if it provides a given interface.

As an example, consider a simple object I/O system. Users want to read objects from a stream, determine that they are of the expected types, and then use them. For example:

Click here to view code image

void user()
{
      //... open file assumed to hold shapes, and attach ss as an istream for that file ...

     unique_ptr<Io_obj> p {get_obj(ss)};  // read object from stream

     if (auto sp = dynamic_cast<Shape*>(p.get())) {
           sp–>draw();    // use the Shape
            //...
     }
     else {
            // oops: non-shape in Shape file
     }
}
The function user() deals with shapes exclusively through the abstract class Shape and can therefore use every kind of shape. The use of dynamic_cast is essential because the object I/O system can deal with many other kinds of objects, and the user may accidentally have opened a file containing perfectly good objects of classes that the user has never heard of.

I used unique_ptr<Io_obj> (§5.2.1, §34.3.1) so that I would not forget to delete the object allocated by get_obj().

This object I/O system assumes that every object read or written is of a class derived from Io_obj. Class Io_obj must be a polymorphic type to allow the user of get_obj() to use dynamic_cast to recover the “true type” of a returned object. For example:

Click here to view code image

class Io_obj {
public:
     virtual Io_obj* clone() const =0;    // polymorphic
     virtual ~Io_obj() {}
};
The critical function in the object I/O system is get_obj(), which reads data from an istream and creates class objects based on that data. Assume that the data representing an object on an input stream is prefixed by a string identifying the object’s class. The job of get_obj() is to read that string and call a function capable of reading and creating an object of the right class. For example:

using Pf = Io_obj*(istream&);       // pointer to function returning an Io_obj*

map<string,Pf> io_map;              // maps strings to creation functions

string get_word(istream& is);       // read a word from is; throw Read_error if the read failed

Io_obj* get_obj(istream& is)
{
     string str = get_word(is);     // read initial word
     if (auto f = io_map[str])      // look up str to get function
          return f(is);             // call function
     throw Unknown_class{};         // no match for str
}
The map called io_map holds pairs of name strings and functions that can construct objects of the class with that name.

We could derive class Shape from Io_obj as needed by user():

class Shape : public Io_obj {
      //...
};
However, it would be more interesting (and in many cases more realistic) to use an already defined Shape (§3.2.4) unchanged:

Click here to view code image

struct Io_circle : Circle, Io_obj {
     Io_circle(istream&);                                                  // initialize from input stream
     Io_circle* clone() const { return new Io_circle{*this}; }             // use copy constructor
     static Io_obj* new_circle(istream& is) { return new Io_circle{is}; }  // for io_map
};
This is an example of how a class can be fitted into a hierarchy using an abstract class with less foresight than would have been required to build it as a node class in the first place (§21.2.2).

The Io_circle(istream&) constructor initializes an object with data from its istream argument. The new_circle() function is the one put into the io_map to make the class known to the object I/O system. For example:

io_map["Io_circle"]=&Io_circle::new_circle;    // somewhere
Other shapes are constructed in the same way:

Click here to view code image

class Io_triangle : public Triangle, public Io_obj {
      //...
};

io_map["Io_triangle"]=&Io_triangle::new_triangle;      // somewhere
If the provision of the object I/O scaffolding becomes tedious, a template might help:

Click here to view code image

template<typename T>
struct Io : T, Io_obj {
public:
     Io(istream&);                                             // initialize from input stream
     Io* clone() const override { return new Io{*this}; }
     static Io* new_io(istream& is) { return new Io{is}; }     // for io_map
};
Given this, we can define Io_circle:

using Io_circle = Io<Circle>;
We still need to define Io<Circle>::Io(istream&) explicitly, though, because it needs to know about the details of Circle. Note that Io<Circle>::Io(istream&) does not have access to T’s private or protected data. The idea is that the transmission format for a type X is what is needed to construct an X using one of X’s constructors. The information of the stream is not necessarily the sequence of X’s member values.

The Io template is an example of a way to fit concrete types into a class hierarchy by providing a handle that is a node in that hierarchy. It derives from its template parameter to allow casting from Io_obj. For example:

void f(io<Shape>& ios)
{
     Shape* ps = &ios;
      //...
}
Unfortunately, deriving from the template argument precludes using Io for a built-in type:

Click here to view code image

using Io_date = Io<Date>;       // wrap concrete type
using Io_int = Io<int>;         // error: cannot derive from built-in type
This problem can be handled by making the user’s object a member of Io_obj:

Click here to view code image

template<typename T>
struct Io :Io_obj {
     T val;

     Io(istream&);                                              // initialize from input stream
     Io* clone() const override { return new Io{*this}; }
     static Io* new_io(istream& is) { return new Io{is}; }      // for io_map
};
Now we can handle

using Io_int = Io<int>;      // wrap built-in type
Having made the value a member rather than a base, we can no longer directly cast an Io_obj<X> to an X, so we provide a function to do that:

Click here to view code image

template<typename T>
T* get_val<T>(Io_obj* p)
{
     if (auto pp = dynamic_cast<Io<T>*>(p))
          return &pp–>val;
     return nullptr;
}
The user() function now becomes:

Click here to view code image

void user()
{
      //... open file assumed to hold shapes, and attach ss as an istream for that file ...

     unique_ptr<Io_obj> p {get_obj(ss)};  // read object from stream

     if (auto sp = get_val<Shape>(p.get())) {
          sp–>draw();      // use the Shape
           //...
     }
     else {
           //... oops: cope with non-shape in Shape file ...
     }
}
This simple object I/O system does not do everything anyone ever wanted, but it almost fits on a single page and the key mechanisms have many uses. It is a blueprint for the “receiver end” of a system for transmitting arbitrary objects across a communication channel in a type-safe manner. More generally, these techniques can be used to invoke a function based on a string supplied by a user and to manipulate objects of unknown type through interfaces discovered through run-time type identification.

In general, the sender part of such an object I/O system will also use RTTI. Consider:

class Face : public Shape {
public:
     Shape* outline;
     array<Shape*> eyes;
     Shape* mouth;

      //...
};
To correctly write out the Shape pointed to by outline, we need to figure out which kind of Shape it is. That’s a job for typeid() (§22.5). In general, we must also keep a table of (pointer,unique identifier) pairs to be able to transmit linked data structures and to avoid duplicating objects pointed to by more than one pointer (or reference).

22.3. Double Dispatch and Visitors
Classical object-oriented programming is based on selecting a virtual function based on the dynamic type (the type of the most derived class) of an object given only a pointer or a reference to an interface (a base class). In particular, C++ can do this run-time lookup (also called a dynamic dispatch) for one type at a time. In this, C++ resembles Simula and Smalltalk and more recent languages, such as Java and C#. Not being able to select a function based on two dynamic types can be a serious limitation. Also, a virtual function must be a member function. This implies that we cannot add a virtual function to a class hierarchy without modifying the base class(es) that provides the interface and all derived classes that should be affected. This too can be a serious problem. This section describes the basic workarounds for these problems:

§22.3.1 Double Dispatch shows how to select a virtual function based on two types.

§22.3.2 Visitors shows how to use double dispatch to add multiple functions to a class hierarchy with only a single additional virtual function in the hierarchy.

Most realistic examples of these techniques occur when we deal with data structures, such as vectors or graphs or pointers to objects of polymorphic types. In such cases, the actual type of an object (e.g., a vector element or a graph node) can only be known dynamically by (implicitly or explicitly) inspecting the interface provided by a base class.

22.3.1. Double Dispatch
Consider how to select a function based on two arguments. For example:

Click here to view code image

void do_something(Shape& s1, Shape& s2)
{
     if (s1.intersect(s2)) {
            // the two shapes overlap
     }
      //...
}
We would like this to work for any two classes in the class hierarchy rooted in Shape, such as Circle and Triangle.

The basic strategy is to do a virtual function call to select the right function for s1 and then do a second call to select the right function for s2. To simplify, I will leave out the calculation of whether the two shapes actually intersect and just write the code skeleton for selecting the right functions. First we define Shape with a function for intersection:

Click here to view code image

class Circle;
class Triangle;

class Shape {
public:
     virtual bool intersect(const Shape&) const =0;
     virtual bool intersect(const Circle&) const =0;
     virtual bool intersect(const Triangle&) const =0;
};
Next we need to define Circle and Triangle to override those virtual functions:

Click here to view code image

class Circle : public Shape {
public:
     bool intersect(const Shape&) const override;
     bool intersect(const Circle&) const override;
     bool intersect(const Triangle&) const override

};

class Triangle : public Shape {
public:
     bool intersect(const Shape&) const override;
     bool intersect(const Circle&) const override;
     bool intersect(const Triangle&) const override;
};
Now each class can handle all possible classes in the Shape hierarchy, so we just have to decide what should be done for each combination:

Click here to view code image

bool Circle::intersect(const Shape& s) const { return s.intersect(*this); }
bool Circle::intersect(const Circle&) const { cout <<"intersect(circle,circle)\n"; return true; }
bool Circle::intersect(const Triangle&) const { cout <<"intersect(triangle,circle)\n"; return true; }

bool Triangle::intersect(const Shape& s) const { return s.intersect(*this); }
bool Triangle::intersect(const Circle&) const { cout <<"intersect(circle,triangle)\n"; return true; }
bool Triangle::intersect(const Triangle&) const { cout <<"intersect(triangle,triangle)\n"; return true; }
The interesting functions here are Circle::intersect(const Shape&) and Triangle::intersect(const Shape&). These need to handle a Shape& argument because that argument must refer to a derived class. The technique is to simply do a virtual call with the arguments in the reverse order. That done, we are in one of the four functions that can actually do an intersection calculation.

We can test this by making a vector of all pairs of Shape* values and calling intersect() for those:

Click here to view code image

void test(Triangle& t, Circle& c)
{
     vector<pair<Shape*,Shape*>> vs { {&t,&t}, {&t,&c}, {&c,&t}, {&c,&c} };
     for (auto p : vs)
           p.first–>intersect(*p.second);
}
Using Shape*s ensures that we rely on run-time resolution of the types. We get:

intersect(triangle,triangle)
intersect(triangle,circle)
intersect(circle,triangle)
intersect(circle,circle)
If you consider this elegant, you need to raise your standards, but it gets the task done. As the class hierarchy grows, the need for virtual functions grows exponentially. That is not acceptable in most cases. Expanding this to three or more arguments is trivial, but tedious. Worst of all, each new operation and each new derived class require a modification to every class in the hierarchy: this double-dispatch technique is highly intrusive. I would have preferred to declare a simple nonmember intersect(Shape&,Shape&) function with overriders specified for desired combinations of particular shapes. That is possible [Pirkelbauer,2009], but not in C++11.

The awkwardness of double dispatch does not make the problem it is trying to address less important. It is not unusual to want an action, such as intersect(x,y), that depends on the types of two (or more) operands. Workarounds abound. For example, finding the intersection of rectangles is simple and efficient. So, for many applications, people have found it sufficient to define a “bounding box” for each shape and then calculate intersections on bounding boxes. For example:

Click here to view code image

class Shape {
public:
     virtual Rectangle box() const = 0;       // the rectangle encloses the shape
      //...
};

class Circle : public Shape {
public:
     Rectangle box() const override;
      //...
};

class Triangle : public Shape {
public:
     Rectangle box() const override;
      //...
};

bool intersect(const Rectangle&, const Rectangle&);     // simple to calculate

bool intersect(const Shape& s1, const Shape& s2)
{
     return intersect(s1.box(),s2.box());
}
Another technique is to precompute a lookup table for combinations of types [Stroustrup,1994]:

Click here to view code image

bool intersect(const Shape& s1, const Shape& s2)
{
     auto i = index(type_id(s1),type_id(s2));
     return intersect_tbl[i](s1,s2);
}
Variations of this idea are widely used. Many variants use precomputed values stored in objects to speed up type identification (§27.4.2).

22.3.2. Visitors
The visitor pattern [Gamma,1994] is a partial solution to the exponential growth of virtual functions and overriders and the unpleasent intrusiveness of the (too) simple double-dispatch technique.

Consider how to apply two (or more) operations to every class in a class hierarchy. Basically, we will do a double dispatch for a hierarchy of nodes and a hierarchy of operations to select the correct operation for the correct node. The operations are called visitors; here they are defined in classes derived from class Visitor. The nodes are a hierarchy of classes with a virtual function accept() that takes Visitor&s. For this example, I use a hierarchy of Nodes that describe language constructs, as is common in tools based on abstract syntax trees (ASTs):

Click here to view code image

class Visitor;

class Node {
public:
     virtual void accept(Visitor&) = 0;
};

class Expr : public Node {
public:
     void accept(Visitor&) override;
};

class Stmt : public Node {
public:
     void accept(Visitor&) override;
};
So far, so good: the Node hierarchy simply provides a virtual function accept() that takes a Visitor& argument representing what should be done to a Node of a given type.

I do not use const here, because in general an operation from a Visitor may update either the Node “visited” or the Visitor itself.

Now the Node’s accept() performs the double-dispatch trick and passes the Node itself to the Visitor’s accept():

Click here to view code image

void Expr::accept(Visitor& v) { v.accept(*this); }
void Stmt::accept(Visitor& v) { v.accept(*this); }
The Visitor declares a set of operations:

class Visitor {
public:
     virtual void accept(Expr&) = 0;
     virtual void accept(Stmt&) = 0;
};
We can then define sets of operations by deriving from Visitor and overriding its accept() functions. For example:

Click here to view code image

struct Do1_visitor : public Visitor {
     void accept(Expr&) override { cout << "do1 to Expr\n"; }
     void accept(Stmt&) override { cout << "do1 to Stmt\n"; }
};

struct Do2_visitor : public Visitor {
     void accept(Expr&) override { cout << "do2 to Expr\n"; }
     void accept(Stmt&) override { cout << "do2 to Stmt\n"; }
};
We can test by making a vector of pairs of pointers to ensure that run-time type resolution is used:

Click here to view code image

Do1_visitor do1;
Do2_visitor do2;

void test(Expr& e, Stmt& s)
{
     vector<pair<Node,Visitor>> vn {{&e,&do1}, {&s,&do1}, {&e,&do2}, {&s,&do2}};
     for (auto p : vn)
           p.first>accept(p.second);
}
We get:

do1 to Expr
do1 to Stmt
do2 to Expr
do2 to Stmt
As opposed to the simple double dispatch, the visitor pattern is heavily used in real-world programming. It is only mildly intrusive (the accept() function), and many variations on the basic idea are used. However, many operations on class hierarchies are hard to express as visitors. For example, an operation that needs access to multiple nodes of different types in a graph cannot be trivially implemented as a visitor. So, I consider the visitor pattern an inelegant workaround. Alternatives exist, for example, [Solodkyy,2012], but not in plain C++11.

Most alternatives to visitors in C++ are based on the idea of explicit iteration over a homogeneous data structure (e.g., a vector or a graph of nodes containing pointers to polymorphic types). At each element or node, a call of a virtual function can perform the desired operation, or some optimization based on stored data can be applied (e.g., see §27.4.2).

22.4. Construction and Destruction
A class object is more than simply a region of memory (§6.4). A class object is built from “raw memory” by its constructors, and it reverts to “raw memory” as its destructors are executed. Construction is bottom-up, destruction is top-down, and a class object is an object to the extent that it has been constructed or destroyed. This order is necessary to ensure that an object is not accessed before it has been initialized. It is unwise to try to access base and member objects early or out of order through “clever” pointer manipulation (§17.2.3). The order of construction and destruction is reflected in the rules for RTTI, exception handling (§13.3), and virtual functions (§20.3.2).

It is unwise to rely on details of the order of construction and destruction, but you can observe that order by calling virtual functions, dynamic_cast (§22.2), or typeid (§22.5) at a point where the object isn’t complete. At such a point in a constructor, the (dynamic) type of the object reflects only what is constructed so far. For example, if the constructor for Component in the hierarchy from §22.2.2 calls a virtual function, it will invoke a version defined for Storable or Component, but not one from Receiver, Transmitter, or Radio. At that point of construction, the object isn’t yet a Radio. Similarly, calling a virtual function from a destructor will reflect only what is still not destroyed. It is best to avoid calling virtual functions during construction and destruction.

22.5. Type Identification
The dynamic_cast operator serves most needs for information about the type of an object at run time. Importantly, it ensures that code written using it works correctly with classes derived from those explicitly mentioned by the programmer. Thus, dynamic_cast preserves flexibility and extensibility in a manner similar to virtual functions.

However, it is occasionally essential to know the exact type of an object. For example, we might like to know the name of the object’s class or its layout. The typeid operator serves this purpose by yielding an object representing the type of its operand. Had typeid() been a function, its declaration would have looked something like this:

Click here to view code image

class type_info;
const type_info& typeid(expression);      // pseudo declaration
That is, typeid() returns a reference to a standard-library type called type_info defined in <typeinfo>:

• Given the name of a type as its operand, typeid(type_name) returns a reference to a type_info that represents the type_name; type_name must be a completely defined type (§8.2.2).

• Given an expression as its operand, typeid(expr) returns a reference to a type_info that represents the type of the object denoted by the expr; the expr must refer to a completely defined type (§8.2.2). If the value of expr is nullptr, typeid(expr) throws a std::bad_typeid.

A typeid() can find the type of an object referred to by a reference or a pointer:

Click here to view code image

void f(Shape& r, Shape* p)
{
     typeid(r);       // type of the object referred to by r
     typeid(*p);      // type of the object pointed to by p
     typeid(p);       // type of the pointer, that is, Shape* (uncommon, except as a mistake)
}
If the operand of typeid() is a pointer or a reference of a polymorphic type with the value nullptr, typeid() throws a std::bad_typeid. If the operand of typeid() has a nonpolymorphic type or is not an lvalue, the result is determined at compile time without evaluating the operand expression.

If the object denoted by a dereferenced pointer or a reference is a polymorphic type, the type_info returned is that of the most derived class for the object, that is, the type used when the object was defined. For example:

Click here to view code image

struct Poly {    // polymorphic base class
     virtual void f();
      //...
};

struct Non_poly { /* ... */ };  // no virtual functions

struct D1
     : Poly { /* ... */ };
struct D2
     : Non_poly { /* ... */ };
void f(Non_poly& npr, Poly& pr)
{
     cout << typeid(npr).name() << '\n';   // writes something like "Non_poly"
     cout << typeid(pr).name() << '\n';    // name of Poly or a class derived from Poly
}

void g()
{
     D1 d1;
     D2 d2;
     f(d2,d1);   // writes "Non_poly D1"
     f(*static_cast<Poly*>(nullptr),*static_cast<Null_poly*>(nullptr));  // oops!
}
That last call will print just Non_poly (because typeid(npr) is not evaluated) before throwing a bad_typeid.

The definition of type_info looks like this:

Click here to view code image

class type_info {
      // data
public:
     virtual ~type_info();                                   // is polymorphic

     bool operator==(const type_info&) const noexcept;     // can be compared
     bool operator!=(const type_info&) const noexcept;

     bool before(const type_info&) const noexcept;         // ordering
     size_t hash_code() const noexcept;                    // for use by unordered_map and the like
     const char* name() const noexcept;                    // name of type

     type_info(const type_info&) = delete;                 // prevent copying
     type_info& operator=(const type_info&) = delete;      // prevent copying
};
The before() function allows type_infos to be sorted. In particular, it allows type_ids to be used as keys for ordered containers (such as map). There is no relation between the relationships defined by before and inheritance relationships. The hash_code() function allows type_ids be used as keys for hash tables (such as unordered_map).

It is not guaranteed that there is only one type_info object for each type in the system. In fact, where dynamically linked libraries are used, it can be hard for an implementation to avoid duplicate type_info objects. Consequently, we should use == on type_info objects to test equality, rather than == on pointers to such objects.

We sometimes want to know the exact type of an object so as to perform some service on the whole object (and not just on one of its bases). Ideally, such services are presented as virtual functions so that the exact type needn’t be known. In some cases, no common interface can be assumed for every object manipulated, so the detour through the exact type becomes necessary (§22.5.1). Another, much simpler use has been to obtain the name of a class for diagnostic output:

#include<typeinfo>

void g(Component* p)
{
     cout << typeid(*p).name();
}
The character representation of a class’s name is implementation-defined. This C-style string resides in memory owned by the system, so the programmer should not attempt to delete[] it.

22.5.1. Extended Type Information
A type_info object contains only minimal information. Therefore, finding the exact type of an object is often just the first step to acquiring and using more detailed information about that type.

Consider how an implementation or a tool could make information about types available to users at run time. Suppose I have a tool that generates descriptions of object layouts for each class used. I can put these descriptors into a map to allow user code to find the layout information:

Click here to view code image

#include <typeinfo>

map<string, Layout> layout_table;

void f(B* p)
{
     Layout& x = layout_table[typeid(*p).name()];  // find the Layout based on *p's name
      //... use x ...
}
The resulting data structure looks like this:



Someone else might provide a completely different kind of information:

Click here to view code image

unordered_map<type_index,Icon> icon_table;      //§31.4.3.2

void g(B* p)
{
     Icon& i = icon_table[type_index{typeid(*p)}];
      //... use i ...
}
The type_index is a standard-library type for comparing and hashing type_info objects (§35.5.4).

The resulting data structure looks like this:



Associating typeids with information without modifying system headers allows several people or tools to associate different information with types independently of each other. This is important because the likelihood that someone can come up with a single set of information that satisfies every user is close to zero.

22.6. Uses and Misuses of RTTI
We should use explicit run-time type information only when necessary. Static (compile-time) checking is safer, implies less overhead, and – where applicable – leads to better-structured programs. Interfaces based on virtual functions combine static type checking with a run-time lookup in a way that gives both type safety and flexibility. However, programmers sometimes overlook these alternatives and use RTTI where it is unsuitable. For example, RTTI can be used to write thinly disguised switch-statements:

Click here to view code image

 // misuse of run-time type information:

void rotate(const Shape& r)
{
     if (typeid(r) == typeid(Circle)) {
            // do nothing
     }
     else if (typeid(r) == typeid(Triangle)) {
            //... rotate triangle ...
     }
     else if (typeid(r) == typeid(Square)) {
            //... rotate square ...
     }
      //...
}
Using dynamic_cast rather than typeid would improve this code only marginally. Either way, this code is syntactically ugly and also inefficient in that it performs an expensive operation repeatedly.

Unfortunately, this is not a strawman example; such code really does get written. For many people trained in languages without equivalents to class hierachies and virtual functions, there is an almost irresistible urge to organize software as a set of switch-statements. This urge should usually be resisted. Use virtual functions (§3.2.3, §20.3.2) rather than RTTI to handle most cases when run-time discrimination based on type is needed.

Many examples of proper use of RTTI arise when some service code is expressed in terms of one class and a user wants to add functionality through derivation. The use of Ival_box in §22.2 is an example of this. If the user is willing and able to modify the definitions of the library classes, say BBwindow, then the use of RTTI can be avoided; otherwise, it is needed. Even if the user is willing to modify the base classes (e.g., to add a virtual function), such modification may cause its own problems. For example, it may be necessary to introduce dummy implementations of virtual functions in classes for which those functions are not needed or not meaningful. A use of RTTI to implement a simple object I/O system can be found in §22.2.4.

For people with a background in languages that rely heavily on dynamic type checking, such as Smalltalk, pre-generics Java, or Lisp, it is tempting to use RTTI in conjunction with overly general types. Consider:

Click here to view code image

 // misuse of run-time type information:

class Object {   // polymorphic
      //...
};

class Container : public Object {
public:
     void put(Object*);
     Object* get();
      //...
};

class Ship : public Object { /* ... */ };

Ship* f(Ship* ps, Container* c)
{
     c–>put(ps);                                // put the Ship into the container
      //...
     Object* p = c–>get();                      // retrieve an Object from the container
     if (Ship* q = dynamic_cast<Ship*>(p)) {    // run-time check that the Object is a Ship
           return q;
     }
     else {
             //... do something else (typically, error handling) ...
     }
}
Here, class Object is an unnecessary implementation artifact. It is overly general because it does not correspond to an abstraction in the application domain and forces the application programmer to use an implementation-level abstraction (Object). Problems of this kind are often better solved by using container templates that hold only a single kind of pointer:

Click here to view code image

Ship* f(Ship* ps, vector<Ship*>& c)
{
     c.push_back(ps);           // put the Ship into the container
      //...
     Ship p = c.back();       // retrieve a Ship from the container
     c.pop_back();
     return p;
}
This style of code is less error-prone (better statically type checked) and less verbose than a pure-Object-based alternative. Combined with the use of virtual functions, this technique handles most cases. In a template, a template argument T takes the place of Object and enables static type checking (§27.2).

22.7. Advice
[1] Use virtual functions to ensure that the same operation is performed independently of which interface is used for an object; §22.1.

[2] Use dynamic_cast where class hierarchy navigation is unavoidable; §22.2.

[3] Use dynamic_cast for type-safe explicit navigation of a class hierarchy; §22.2.1.

[4] Use dynamic_cast to a reference type when failure to find the required class is considered a failure; §22.2.1.1.

[5] Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative; §22.2.1.1.

[6] Use double dispatch or the visitor pattern to express operations on two dynamic types (unless you need an optimized lookup); §22.3.1.

[7] Don’t call virtual functions during construction or destruction; §22.4.

[8] Use typeid to implement extended type information; §22.5.1.

[9] Use typeid to find the type of an object (and not to find an interface to an object); §22.5.

[10] Prefer virtual functions to repeated switch-statements based on typeid or dynamic_cast; §22.6.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


22. Run-Time Type Information
23. Templates
24. Generic Programming
47h 26m remaining
23. Templates
Your quote here.

– B. Stroustrup

• Introduction and Overview

• A Simple String Template

Defining a Template; Template Instantiation

• Type Checking

Type Equivalence; Error Detection

• Class Template Members

Data Members; Member Functions; Member Type Aliases; static Members; Member Types; Member Templates; Friends

• Function Templates

Function Template Arguments; Function Template Argument Deduction; Function Template Overloading

• Template Aliases

• Source Code Organization

Linkage

• Advice

23.1. Introduction and Overview
Templates provide direct support for generic programming (§3.4) in the form of programming using types as parameters. The C++ template mechanism allows a type or a value to be a parameter in the definition of a class, a function, or a type alias. Templates provide a straightforward way to represent a wide range of general concepts and simple ways to combine them. The resulting classes and functions can match handwritten, less general code in run-time and space efficiency.

A template depends only on the properties that it actually uses from its parameter types and does not require types used as arguments to be explicitly related. In particular, the argument types used for a template need not be part of an inheritance hierarchy. Built-in types are acceptable and very common as template arguments.

The composition offered by templates is type-safe (no object can be implicitly used in a way that disagrees with its definition), but unfortunately, a template’s requirements on its arguments cannot be simply and directly stated in code (§24.3).

Every major standard-library abstraction is represented as a template (for example, string, ostream, regex, complex, list, map, unique_ptr, thread, future, tuple, and function), and so are the key operations (for example, string comparisons, the output operator <<, complex arithmetic operations, list insertions and deletions, and sort()). This makes the library chapters (Part IV) of this book a rich source of examples of templates and programming techniques relying on them.

Here, templates are introduced with the primary focus on techniques needed for the design, implementation, and use of the standard library. The standard library requires a greater degree of generality, flexibility, and efficiency than does most software. Consequently, techniques that can be used in the design and implementation of the standard library are effective and efficient in the design of solutions to a wide variety of problems. These techniques enable an implementer to hide sophisticated implementations behind simple interfaces and to expose complexity to the user when the user has a specific need for it.

Templates and the fundamental techniques for using them are the focus of this and the following six chapters. This chapter focuses on the most basic template facilities and fundamental programming techniques for using them:

§23.2   A Simple String Template: The basic mechanisms for defining and using class templates are introduced through the example of a string template.

§23.3   Type Checking: The basic rules of type equivalence and type checking as they apply to templates.

§23.4   Class Template Members: How members of a class template are defined and used.

§23.5   Function Templates: How to define and use function templates. How overloading is resolved for function templates and ordinary functions.

§23.6   Template Aliases: Template aliases provide a powerful mechanism for hiding implementation details and cleaning up the notation used for templates.

§23.7   Source Code Organization: How to organize templates into source files.

Chapter 24, Generic Programming, presents the basic technique of generic programming, and the fundamental idea of concepts (requirements on template arguments) is explored:

§24.2   Algorithms and Lifting: An example of the basic technique for developing a generic algorithm from concrete examples.

§24.3   Concepts: Introduces and discusses the fundamental notion of a concept, that is, a set of requirements that a template can impose on its template arguments.

§24.4   Making Concepts Concrete: Presents techniques for using concepts expressed as compile-time predicates.

Chapter 25, Specialization, discusses template argument passing and the notion of specialization:

§25.2   Template Parameters and Arguments: What can be a template argument: types, values, and templates. How to specify and use default template arguments.

§25.3   Specialization: Special versions, called specializations, of a template for a specific set of template arguments can be generated from the templates by the compiler or be provided by the programmer.

Chapter 26, Instantiation, presents issues related to generation of template specialization (instances) and name binding:

§26.2   Template Instantiation: The rules for when and how a compiler generates specializations from a template definition and how to specify them manually.

§26.3   Name Binding: The rules for determining to which entity a name used in a template definition refers.

Chapter 27, Templates and Hierarchies, discusses the relation between the generic programming techniques supported by templates and the object-oriented techniques supported by class hierarchies. The emphasis is on how to use them in combination:

§27.2   Parameterization and Hierarchy: Templates and class hierarchies are two ways of representing sets of related abstractions. How do we choose between them?

§27.3   Hierarchies of Class Templates: Why it is usually a bad idea simply to add template parameters to an existing class hierarchy?

§27.4   Template Parameters as Base Classes: Presents techniques for composing interfaces and data structures for type safety and performance.

Chapter 28, Metaprogramming, concentrates on the use of templates as a means of generating functions and classes:

§28.2   Type Functions: Functions that take types as arguments or return types as results.

§28.3   Compile-time Control Structures: How to express selection and recursion for type functions, and some rules of thumb for their use.

§28.4   Conditional Definition: enable_if: How to conditionally define functions and overload templates using (almost) arbitrary predicates.

§28.5   A Compile-time List: Tuple: How to build and access lists with elements of (almost) arbitrary types.

§28.6   Variadic templates: How (in a statically type-safe manner) to define templates that take arbitrary numbers of template arguments of arbitrary types.

§28.7   SI Units Example: This example uses simple metaprogramming techniques in combination with other programming techniques to provide a library for computations that are (at compile time) checked for correct use of the meters, kilograms, and seconds system of units.

Chapter 29, A Matrix Design, demonstrates how various template features can be used in combination to address a challenging design task:

§29.2   A Matrix Template: How to define an N-dimensional matrix with flexible and type-safe initialization, subscription, and submatrices.

§29.3   Matrix Arithmetic Operations: How to provide simple arithmetic operations on an N-dimensional matrix.

§29.4   Matrix Implementation: Some useful implementation techniques.

§29.5   Solving Linear Equations: An example of simple matrix use.

Templates were introduced early (§3.4.1, §3.4.2) and used throughout this book, so I assume that you have some familiarity with them.

23.2. A Simple String Template
Consider a string of characters. A string is a class that holds characters and provides operations such as subscripting, concatenation, and comparison that we usually associate with the notion of a “string.” We would like to provide that behavior for many different kinds of characters. For example, strings of signed characters, of unsigned characters, of Chinese characters, of Greek characters, etc., are useful in various contexts. Thus, we want to represent the notion of “string” with minimal dependence on a specific kind of character. The definition of a string relies on the fact that a character can be copied, and little else (§24.3). Thus, we can make a more general string type by taking the string of char from §19.3 and making the character type a parameter:

Click here to view code image

template<typename C>
class String {
public:
     String();
     // ...
     C& operator[](int n) { return ptr[n]; }
      // unchecked element access
     String& operator+=(C c);                     // add c at end
private:
     static const int short_max = 15;      // for the short-string optimization (§19.3.3)
     int sz;                               // number of Cs
     char ptr;
     union {
         int space;                        // unused allocated space
         C ch[short_max+1];                // leave space for terminating 0
     };
     // ...
};
The template<typename C> prefix specifies that a template is being declared and that a type argument C will be used in the declaration. After its introduction, C is used exactly like other type names. The scope of C extends to the end of the declaration prefixed by template<typename C>. You may prefer the shorter and equivalent form template<class C>. In either case, C is a type name; it need not be the name of a class. Mathematicians will recognize template<typename C> as a variant of the traditional “for all C” or more specifically “for all types C” or even “for all C, such that C is a type.” If you think along those lines, you will note that C++ lacks a fully general mechanism for specifying the required properties of a template parameter C. That is, we can’t say “for all C, such that ...” where the “...” is a set of requirements for C. In other words, C++ does not offer a direct way to say what kind of type a template argument C is supposed to be (§24.3).

The name of a class template followed by a type bracketed by < > is the name of a class (as defined by the template) and can be used exactly like other class names. For example:

Click here to view code image

String<char> cs;
String<unsigned char> us;
String<wchar_t> ws;

struct Jchar { /* ... */ };    // Japanese character

String<Jchar> js;
Except for the special syntax of its name, String<char> works exactly as if it had been defined using the definition of class String in §19.3. Making String a template allows us to provide the facilities we had for String of char for Strings of any kind of character. For example, if we use the standard-library map and the String template, the word-counting example from §19.2.1 becomes:

Click here to view code image

int main()  // count the occurrences of each word on input
{
     map<String<char>,int> m;
     for (String<char> buf; cin>>buf; )
           ++m[buf];
      //... write out result ...
}
The version for our Japanese-character type Jchar would be:

Click here to view code image

int main()  // count the occurrences of each word on input
{
     map<String<Jchar>,int> m;
     for (String<Jchar> buf; cin>>buf; )
           ++m[buf];
      //... write out result ...
}
The standard library provides the template class basic_string that is similar to the templatized String (§19.3, §36.3). In the standard library, string is a synonym for basic_string<char> (§36.3):

using string = std::basic_string<char>;
This allows us to write the word-counting program like this:

Click here to view code image

int main()  // count the occurrences of each word on input
{
     map<string,int> m;
     for (string buf; cin>>buf; )
           ++m[buf];
      //... write out result ...
}
In general, type aliases (§6.5) are useful for shortening the long names of classes generated from templates. Also, we often prefer not to know the details of how a type is defined, and an alias allows us to hide the fact that a type is generated from a template.

23.2.1. Defining a Template
A class generated from a class template is a perfectly ordinary class. Thus, use of a template does not imply any run-time mechanisms beyond what is used for an equivalent “handwritten” class. In fact, using a template can lead to a decrease of code generated because code for a member function of a class template is only generated if that member is used (§26.2.1).

In addition to class templates, C++ offers function templates (§3.4.2, §23.5). I will introduce most of the “mechanics” of templates in the context of class templates and postpone detailed discussion of function templates to §23.5. A template is a specification of how to generate something given suitable template arguments; the language mechanisms for doing that generation (instantiation (§26.2) and specialization (§25.3)) don’t care much whether a class or a function is generated. So, unless otherwise stated, the rules for templates apply equally to class templates and function templates. Templates can also be defined as aliases (§23.6), but other plausible constructs, such as namespace templates, are not provided.

There are people who make semantic distinctions between the terms class template and template class. I don’t; that would be too subtle: please consider those terms interchangeable. Similarly, I consider function template interchangeable with template function.

When designing a class template, it is usually a good idea to debug a particular class, such as String, before turning it into a template such as String<C>. By doing so, we handle many design problems and most of the code errors in the context of a concrete example. This kind of debugging is familiar to all programmers, and most people cope better with a concrete example than with an abstract concept. Later, we can deal with any problems that might arise from generalization without being distracted by more conventional errors. Similarly, when trying to understand a template, it is often useful to imagine its behavior for a particular type argument such as char before trying to comprehend the template in its full generality. This also fits with the philosophy that a generic component should be developed as a generalization of one or more concrete examples, rather than simply being designed from first principles (§24.2).

Members of a class template are declared and defined exactly as they would have been for a non-template class. A template member need not be defined within the template class itself. In that case, its definition must be provided somewhere else, just as for non-template class members (§16.2.1). Members of a template class are themselves templates parameterized by the parameters of their template class. When such a member is defined outside its class, it must explicitly be declared a template. For example:

Click here to view code image

template<typename C>
String<C>::String()  // String<C>'s constructor
     :sz{0}, ptr{ch}  // short string: point to ch
{
     ch[0] = {};  // terminating 0 of the appropriate character type
}

template<typename C>
String<C>& String<C>::operator+=(C c)
{
      //... add c to the end of this string ...
     return *this;
}
A template parameter, such as C, is a parameter rather than the name of a specific type. However, that doesn’t affect the way we write the template code using the name. Within the scope of String<C>, qualification with <C> is redundant for the name of the template itself, so String<C>::String is the name for the constructor.

Just as there can be only one function defining a class member function in a program, there can be only one function template defining a class template member function in a program. However, specialization (§25.3) enables us to provide alternative implementations for a template given specific template arguments. For functions, we can also use overloading to provide different definitions for different argument types (§23.5.3).

It is not possible to overload a class template name, so if a class template is declared in a scope, no other entity can be declared there with the same name. For example:

Click here to view code image

template<typename T>
class String { /* ... */ };

class String { /* ... */ };     // error: double definition
A type used as a template argument must provide the interface expected by the template. For example, a type used as an argument to String must provide the usual copy operations (§17.5, §36.2.2). Note that there is no requirement that different arguments for the same template parameter should be related by inheritance. See also §25.2.1 (template type parameters), §23.5.2 (template parameter deduction), and §24.3 (requirements on template arguments).

23.2.2. Template Instantiation
The process of generating a class or a function from a template plus a template argument list is often called template instantiation (§26.2). A version of a template for a specific template argument list is called a specialization.

In general, it is the implementation’s job – not the programmer’s – to ensure that specializations of a template are generated for each template argument list used. For example:

Click here to view code image

String<char> cs;

void f()
{
     String<Jchar> js;

     cs = "It's the implementation's job to figure out what code needs to be generated";
}
For this, the implementation generates declarations for classes String<char> and String<Jchar>, for their destructors and default constructors, and for String<char>::operator=(char*). Other member functions are not used and will not be generated. Generated classes are perfectly ordinary classes that obey all the usual rules for classes. Similarly, generated functions are ordinary functions that obey all the usual rules for functions.

Obviously, templates provide a powerful way of generating lots of code from relatively short definitions. Consequently, a certain amount of caution is in order to avoid flooding memory with almost identical function definitions (§25.3). On the other hand, templates can be written to enable otherwise unachievable quality of generated code. In particular, composition using templates combined with simple inlining can be used to eliminate many direct and indirect function calls. For example, that is how simple operations on critical data structures (such as < in a sort() and + for scalars in a matrix computation) are reduced to single machine instructions in heavily parameterized libraries. Thus, incautious use of templates leading to the generation of very similar large functions can cause code bloat, whereas use of templates to enable inlining of tiny functions can lead to significant code shrinkage (and speedup) compared to alternatives. In particular, the code generated for a simple < or [] is often a single machine instruction, which is both much faster than any function call and smaller than the code needed to invoke a function and receive its result.

23.3. Type Checking
Template instantiation takes a template plus a set of template arguments and generates code from them. Because so much information is available at instantiation time, weaving together the information from the template definition and the template argument types provides wonderful degrees of flexibility and can yield unparalleled run-time performance. Unfortunately, this flexibility also implies complexity of type checking and difficulties for accurate reporting of type errors.

Type checking is done on the code generated by template instantiation (exactly as if the programmer had expanded the templates by hand). This generated code may contain much that the user of a template has never heard of (such as names of details of a template implementation) and often happens uncomfortably late in the build process. This mismatch between what the programmer sees/writes and what the compiler type checks can be a major problem, and we need to design our programs to minimize its consequences.

The fundamental weakness of the template mechanism is that it is not possible to directly express requirements on a template argument. For example, we cannot say:

Click here to view code image

template<Container Cont, typename Elem>
    requires Equal_comparable<Cont::value_type,Elem>()    // requirements for types Cont and Elem
int find_index(Cont& c, Elem e);                          // find the index of e in c
That is, we have no way in C++ itself to directly say that Cont should be a type that can act as a container and that the type Elem should be a type that allows us to compare a value to an element of Cont. Work is being done to make this possible in future versions of C++ (without loss of flexibility, without loss of run-time performance, and without significant increases in compile time [Sutton,2011]), but for now we will have to do without.

The first step in dealing effectively with problems related to template argument passing is to establish a framework and vocabulary for discussing requirements. Think of a set of requirements on template arguments as a predicate. For example, we can think of “C must be a container” as a predicate that takes a type, C, as an argument and returns true if C is a container (however we may have defined “container”) and false if it is not. For example, Container<vector<int>>() and Container<list<string>>() should be true whereas Container<int>() and Container<shared_ptr<string>>() should be false. We call such a predicate a concept. A concept is not (yet) a language construct in C++; it is a notion that we can use to reason about requirements on template arguments, use in comments, and sometimes support with our own code (§24.3).

For starters, think of a concept as a design tool: specify Container<T>() as a set of comments saying what properties a type T must have for Container<T>() to be true. For example:

• T must have a subscript operator ([]).

• T must have a size() member function.

• T must have a member type value_type which is the type of its elements.

Note that this list is incomplete (e.g., what does [] take as an argument and what does it return?) and fails to address most semantic issues (e.g., what does [] actually do?). However, even a partial set of requirements can be useful; even something very simple allows us to hand-check our uses and catch obvious errors. For example, Container<int>() is obviously false because int does not have a subscript operator. I will return to the design of concepts (§24.3), consider techniques for supporting concepts in code (§24.4), and give an example of a set of useful concepts (§24.3.2). For now, just note that C++ does not directly support concepts, but that does not mean that concepts don’t exist: for every working template, the designer had some concepts in mind for its arguments. Dennis Ritchie famously said, “C is a strongly typed, weakly checked language.” You could say the same about C++’s templates, except that the checking of template argument requirements (concepts) is actually done, but it is done too late in the compilation process and at an unhelpfully low level of abstraction.

23.3.1. Type Equivalence
Given a template, we can generate types by supplying template arguments. For example:

Click here to view code image

String<char> s1;
String<unsigned char> s2;
String<int> s3;

using Uchar = unsigned char;
using uchar = unsigned char;

String<Uchar> s4;
String<uchar> s5;
String<char> s6;

template<typename T, int N>          //§25.2.2
    class Buffer;
Buffer<String<char>,10> b1;
Buffer<char,10> b2;
Buffer<char,20–10> b3;
When using the same set of template arguments for a template, we always refer to the same generated type. However, what does “the same” mean in this context? Aliases do not introduce new types, so String<Uchar> and String<uchar> are the same type as String<unsigned char>. Conversely, because char and unsigned char are different types (§6.2.3), String<char> and String<unsigned char> are different types.

The compiler can evaluate constant expressions (§10.4), so Buffer<char,20–10> is recognized to be the same type as Buffer<char,10>.

Types generated from a single template by different template arguments are different types. In particular, generated types from related arguments are not automatically related. For example, assume that a Circle is a kind of Shape:

Click here to view code image

Shape* p {new Circle(p,100)};               // Circle* converts to Shape*
vector<Shape>* q {new vector<Circle>{}};    // error: no vector<Circle>* to vector<Shape>* conversion
vector<Shape> vs {vector<Circle>{}};        // error: no vector<Circle> to vector<Shape> conversion
vector<Shape*> vs {vector<Circle*>{}};      // error: no vector<Circle*> to vector<Shape*> conversion
Had such conversions been allowed, type errors would have resulted (§27.2.1). If conversions between generated classes are needed, the programmer can define them (§27.2.2).

23.3.2. Error Detection
A template is defined and then later used in combination with a set of template arguments. When the template is defined, the definition is checked for syntax errors and possibly also for other errors that can be detected in isolation from a particular set of template arguments. For example:

Click here to view code image

template<typename T>
struct Link {
     Link* pre;
     Link* suc                 // syntax error: missing semicolon
     T val;
};

template<typename T>
class List {
     Link<T>* head;
public:
     List() :head{7} { }                                  // error: pointer initialized with int
     List(const T& t) : head{new Link<T>{0,o,t}} { }      // error: undefined identifier o
      //...
     void print_all() const;
};
A compiler can catch simple semantic errors at the point of definition or later at the point of use. Users generally prefer early detection, but not all “simple” errors are easy to detect. Here, I made three “mistakes”:

• A simple syntax error: Leaving out a semicolon at the end of a declaration.

• A simple type error: Independently of what the template parameter is, a pointer cannot be initialized by the integer 7.

• A name lookup error: The identifier o (a mistyped 0, of course) cannot be an argument to Link<T>’s constructor because there is no such name in scope.

A name used in a template definition must either be in scope or in some reasonably obvious way depend on a template parameter (§26.3). The most common and obvious ways of depending on a template parameter T are to explicitly use the name T, to use a member of a T, and to take an argument of type T. For example:

Click here to view code image

template<typename T>
void List<T>::print_all() const
{
     for (Link<T>* p = head; p; p=p–>suc)     // p depends on T
           cout << p->val;                   //<< depends on T
}
Errors that relate to the use of template parameters cannot be detected until the template is used. For example:

Click here to view code image

class Rec {
     string name;
     string address;
};

void f(const List<int>& li, const List<Rec>& lr)
{
     li.print_all();
     lr.print_all();
}
The li.print_all() checks out fine, but lr.print_all() gives a type error because there is no << output operator defined for Rec. The earliest that errors relating to a template parameter can be detected is at the first point of use of the template for a particular template argument. That point is called the first point of instantiation (§26.3.3). The implementation is allowed to postpone essentially all checking until the program is linked, and for some errors link time is also the earliest point when complete checking is possible. Independently of when checking is done, the same set of rules is checked. Naturally, users prefer early checking.

23.4. Class Template Members
Exactly like a class, a template class can have members of several kinds:

• Data members (variable and constant); §23.4.1

• Member functions; §23.4.2

• Member type aliases; §23.6

• static members (function and data); §23.4.4

• Member types (e.g., a member class); §23.4.5

• Member templates (e.g., a member class template); §23.4.6.3

In addition, a class template can declare friends, just as an “ordinary class” can; §23.4.7.

The rules for class template members are those for their generated classes. That is, if you want to know what the rules of a template member are, just look for the rules for a member of an ordinary class (Chapter 16, Chapter 17, and Chapter 20); that will answer most questions.

23.4.1. Data Members
As for an “ordinary class,” a class template can have data members of any type. A non-static data member can be initialized in its definition (§17.4.4) or in a constructor (§16.2.5). For example:

template<typename T>
struct X {
     int m1 = 7;
     T m2;
     X(const T& x) :m2{x} { }
};

X<int> xi {9};
X<string> xs {"Rapperswil"};
Non-static data members can be const, but unfortunately not constexpr.

23.4.2. Member Functions
As for an “ordinary class,” a non-static member function of a class template can be defined in-class or outside the class. For example:

Click here to view code image

template<typename T>
struct X {
     void mf1() { /* ... */ }            // defined in-class
     void mf2();
};

template<typename T>
void X<T>::mf2() { /* ... */ }           // defined out of class
Similarly, a member function of a template can be virtual or not. However, a virtual member function cannot also be a member function template (§23.4.6.2).

23.4.3. Member Type Aliases
Member type aliases, whether introduced using using or typedef (§6.5), play a major role in the design of class templates. They define related types of a class in a way that is easy to access from outside the class. For example, we specify a container’s iterator and element types as aliases:

Click here to view code image

template<typename T>
class Vector {
public:
     using value_type = T;
     using iterator = Vector_iter<T>;     // Vector_iter is defined elsewhere
      //...
};
The template argument name, T, is only accessible to the template itself, so for other code to refer to the element type, we must provide an alias.

Type aliases play a major role in generic programming by allowing the designer of classes to provide common names for types in different classes (and class templates) with common semantics. Type names as member aliases are often referred to as associated types. The value_type and iterator names are borrowed from the standard library’s container design (§33.1.3). If a class is missing a desired member alias, a trait can be used to compensate (§28.2.4).

23.4.4. static Members
A static data or function member that is not defined in-class must have a unique definition in a program. For example:

Click here to view code image

template<typename T>
struct X {
     static constexpr Point p {100,250};  // Point must be a literal type (§10.4.3)
     static const int m1 = 7;
     static int m2 = 8;                   // error: not const
     static int m3;
     static void f1() { /* ... */ }
     static void f2();
};

template<typename T> int X<T>::m1 = 88;           // error: two initializers
template<typename T> int X<T>::m3 = 99;

template<typename T> void X<T>::f2() { /* ... */ }
As for non-template classes, a const or conexpr static data member of literal type can be initialized in-class and need not be defined outside the class (§17.4.5, §iso.9.2).

A static member need only be defined if it is used (§iso.3.2, §iso.9.4.2, §16.2.12). For example:

template<typename T>
struct X {
     static int a;
     static int b;
};

int* p = &X<int>::a;
If this is all the mention of X<int> in a program, we will get a “not defined” error for X<int>::a, but not for X<int>::b.

23.4.5. Member Types
As for an “ordinary class,” we can define types as members. As usual, such a type can be a class or an enumeration. For example:

Click here to view code image

template<typename T>
struct X {
     enum E1 { a, b };
     enum E2;                  // error: underlying type not known
     enum class E3;
     enum E4 : char;

     struct C1 { /* ... */ };
     struct C2;
};

template<typename T>
enum class X<T>::E3 { a, b };            // needed

template<typename T>
enum X<T>::E4 : char { x, y };          // needed

template<typename T>
struct X<T>::C2 { /* ... */ };           // needed
The out-of-class definition of a member enumeration is only allowed for an enumeration for which we know the underlying type (§8.4).

As usual, the enumerators of a non-class enum are placed in the scope of the enumeration; that is, for a member enumeration, the enumerators are in the scope of its class.

23.4.6. Member Templates
A class or a class template can have members that are themselves templates. This allows us to represent related types with a pleasing degree of control and flexibility. For example, complex numbers are best represented as pairs of values of some scalar type:

Click here to view code image

template<typename Scalar>
class complex {
     Scalar re, im;
public:
     complex() :re{}, im{} {}                     // default constructor
     template<typename T>
         complex(T rr, T ii =0) :re{rr}, im{ii} { }

     complex(const complex&) = default;           // copy constructor
     template<typename T>
           complex(const complex<T>& c) : re{c.real()}, im{c.imag()} { }
      //...
};
This allows mathematically meaningful conversions among complex types, while prohibiting the undesirable narrowing conversions (§10.5.2.6):

Click here to view code image

complex<float> cf;                     // default value
complex<double> cd {cf};               // OK: uses float to double conversion
complex<float> cf2 {cd};               // error: no implicit double->float conversion

complex<float> cf3 {2.0,3.0};          // error: no implicit double->float conversion
complex<double> cd2 {2.0F,3.0F};       // OK: uses float to double conversion

class Quad {
      // no conversion to int
};

complex<Quad> cq;
complex<int> ci {cq};                // error: no Quad to int conversion
Given this definition of complex, we can construct a complex<T1> from a complex<T2> or from a pair of T2 values if and only if we can construct a T1 from a T2. That seems reasonable.

Be warned that the narrowing error in the complex<double> to complex<float> case will not be caught until the instantiation of complex<float>’s template constructors and then only because I used the {} initialization syntax (§6.3.5) in the constructor’s member initializers. That syntax does not allow narrowing.

Using the (old) () syntax would leave us open to narrowing errors. For example:

Click here to view code image

template<typename Scalar>
class complex {                 // old style
     Scalar re, im;
public:
     complex() :re(0), im(0) { }
     template<typename T>
     complex(T rr, T ii =0) :re(rr), im(ii) { }

     complex(const complex&) = default;              // copyconstructor
     template<typename T>
         complex(const complex<T>& c) : re(c.real()), im(c.imag()) { }
      //...
};

complex<float> cf4 {2.1,2.9};   // ouch! narrows
complex<float> cf5 {cd};        // ouch! narrows
I consider this yet another reason to be consistent in the use of the {} notation for initialization.

23.4.6.1. Templates and Constructors
To minimize the chances of confusion, I explicitly added a default copy constructor. Leaving it out would not change the meaning of the definition: complex would still get a default copy constructor. For technical reasons, a template constructor is never used to generate a copy constructor, so without the explicitly declared copy constructor, a default copy constructor would have been generated. Similarly, copy assignments, move constructors, and move assignments (§17.5.1, §17.6, §19.3.1) must be defined as non-template operators or the default versions will be generated.

23.4.6.2. Templates and virtual
A member template cannot be virtual. For example:

Click here to view code image

class Shape {
      //...
     template<typename T>
         virtual bool intersect(const T&) const =0;     // error: virtual template
};
This must be illegal. If it were allowed, the traditional virtual function table technique for implementing virtual functions (§3.2.3) could not be used. The linker would have to add a new entry to the virtual table for class Shape each time someone called intersect() with a new argument type. Complicating the implementation of the linker in this way was considered unacceptable. In particular, handling dynamic linking would require implementation techniques rather different from what is most commonly used.

23.4.6.3. Use of Nesting
In general, it is a good idea to keep information as local as possible. That way, a name is easier to find and less likely to interfere with anything else in a program. This line of thinking leads to types being defined as members. Doing so is often a good idea. However, for members of class templates we must consider if the parameterization is appropriate for a member type. Formally, a member of a template depends on all of a template’s arguments. That can have unfortunate side effects in cases where the behavior of the member does not in fact use every template argument. A famous example is a link type of a linked list. Consider:

Click here to view code image

template<typename T, typename Allocator>
class List {
private:
     struct Link {
          T val;
          Link* succ;
          Link* prev;
     };
      //...
};
Here, Link is an implementation detail of List. Thus, it seems a perfect example of a type best defined in the scope of List and even kept private. This has been a popular design and generally works very well. But surprisingly, it can imply performance cost compared to using a nonlocal Link type. Assume that no member of Link depends on the Allocator parameter, and that we need List<double,My_allocator> and List<double,Your_allocator>. Now List<double,My_allocator>::Link and List<double,Your_allocator>::Link are different types, so code using them cannot (without clever optimizers) be identical. That is, making Link a member when it uses only one of List’s two template parameters implies some code bloat. This leads us to consider a design where Link isn’t a member:

Click here to view code image

template<typename T, typename Allocator>
class List;

template<typename T>
class Link {
     template<typename U, typename A>
         friend class List;
     T val;
     Link* succ;
     Link* prev;
};

template<typename T, typename Allocator>
class List {
      //...
};
I made all members of Link private and granted List access. Except for making the name Link nonlocal, this preserves the design intent that Link is an implementation detail of List.

But what if a nested class is not considered an implementation detail? That is, what if we need an associated type that is meant for a variety of users? Consider:

Click here to view code image

template<typename T, typename A>
class List {
public:
     class Iterator {
          Link<T>* current_position;
     public:
           //... usual iterator operations ...
     };

     Iterator<T,A> begin();
     Iterator<T,A> end();
      //...
};
Here, the member type List<T,A>::Iterator (obviously) does not use the second template argument A. However, because Iterator is a member and therefore formally depends on A (the compiler doesn’t know anything to the contrary), we can’t write a function to process Lists independently of how they were constructed using allocators:

Click here to view code image

void fct(List<int>::Iterator b, List<int>::Iterator e)  // error: List takes two arguments
{
     auto p = find(b,e,17);
      //...
}

void user(List<int,My_allocator>& lm, List<int,Your_allocator>& ly)
{
     fct(lm.begin(),lm.end());
     fct(ly.begin(),ly.end());
}
Instead, we need to write a function template with a dependence on the allocator argument:

Click here to view code image

void fct(List<int,My_allocator>::Iterator b, List<int,My_allocator>::Iterator e)
{

     auto p = find(b,e,17);
      //...
}
However, that breaks our user():

void user(List<int,My_allocator>& lm, List<int,Your_allocator>& ly)
{
     fct(lm.begin(),lm.end());
     fct(ly.begin(),ly.end());      // error: fct takes List<int,My_allocator>::Iterators
}
We could make fct a template and generate separate specializations for each allocator. However, that would generate a new specialization for every use of Iterator, so this could lead to significant code bloat [Tsafrir,2009]. Again, we solve the problem by moving Link out of the class template:

Click here to view code image

template<typename T>
struct Iterator {
     Link<T>* current_position;
};

template<typename T, typename A>
class List {
public:
     Iterator<T> begin();
     Iterator<T> end();
      //...
};
This makes iterators for every List with the same first template argument interchangeable as far as their types are concerned. In this case, that was exactly what we wanted. Our user() now works as defined. Had fct() been defined to be a function template, there would have been only one copy (instantiation) of the definition of fct(). My rule of thumb is “Avoid nested types in templates unless they genuinely rely on every template parameter.” This is a special case of the general rule to avoid unnecessary dependencies in code.

23.4.7. Friends
As shown in §23.4.6.3, a template class can designate functions as friends. Consider the Matrix and Vector example from §19.4. Typically, both Matrix and Vector will be templates:

Click here to view code image

template<typename T> class Matrix;

template<typename T>
class Vector {
     T v[4];
public:
     friend Vector operator*<>(const Matrix<T>&, const Vector&);
      //...
};

template<typename T>
class Matrix {
     Vector<T> v[4];
public:
     friend Vector<T> operator*<>(const Matrix&, const Vector<T>&);
      //...
};
The <> after the name of the friend function is needed to make clear that the friend is a template function. Without the <>, a non-template function would be assumed. The multiplication operator can then be defined to access data from Vector and Matrix directly:

Click here to view code image

template<typename T>
Vector<T> operator*(const Matrix<T>& m, const Vector<T>& v)
{
     Vector<T> r;
      //... use m.v[i] and v.v[i] for direct access to elements ...
     return r;
}
Friends do not affect the scope in which the template class is defined, nor do they affect the scope in which the template is used. Instead, friend functions and operators are found using a lookup based on their argument types (§14.2.4, §18.2.5, §iso.11.3). Like a member function, a friend function is instantiated only if it is used (§26.2.1).

Like other classes, a class template can designate other classes as friends. For example:

Click here to view code image

class C;
using C2 = C;

template<typename T>
class My_class {
     friend C;              // OK: C is a class
     friend C2;             // OK: C2 is an alias for a class
     friend C3;             // error: no class C3 in scope
     friend class C4;       // OK: introduces a new class C4
};
Naturally, the interesting cases are those where the friend depends on a template argument. For example:

Click here to view code image

template<typename T>
class my_other_class {
     friend T;                 // my argument is my friend!
     friend My_class<T>;       // My_class with the corresponding argument is my friend
     friend class T;           // error: redundant "class"
};
As ever, friendship is neither inherited nor transitive (§19.4). For example, C has not become a friend of My_other_class<int> even though My_class<int> is a friend and C is a friend of My_class<int>.

We cannot directly make a template a friend of a class, but we can make a friend declaration a template. For example:

Click here to view code image

template<typename T, typename A>
class List;

template<typename T>
class Link {
     template<typename U, typename A>
         friend class List;
      //...
};
Unfortunately, there is no way of saying that Link<X> should only be a friend of List<X>.

Friend classes are designed to allow the representation of small clusters of closely related concepts. A complicated pattern of friendship is almost certainly a design error.

23.5. Function Templates
For many people, the first and most obvious use of templates is to define and use container classes such as vector (§31.4), list (§31.4.2), and map (§31.4.3). Soon after, the need for function templates to manipulate such containers arises. Sorting a vector is a simple example:

Click here to view code image

template<typename T> void sort(vector<T>&);           // declaration

void f(vector<int>& vi, vector<string>& vs)
{
     sort(vi);   // sort(vector<int>&);
     sort(vs);   // sort(vector<string>&);
}
When a function template is called, the types of the function arguments determine which version of the template is used; that is, the template arguments are deduced from the function arguments (§23.5.2).

Naturally, the function template must be defined somewhere (§23.7):

Click here to view code image

template<typename T>
void sort(vector<T>& v)                      // definition
      // Shell sort (Knuth, Vol. 3, pg. 84)
{
     const size_t n = v.size();

     for (int gap=n/2; 0<gap; gap/=2)
           for (int i=gap; i<n; i++)
                 for (int j=i–gap; 0<=j; j–=gap)
                       if (v[j+gap]<v[j]) {    // swap v[j] and v[j+gap]
                              T temp = v[j];
                              v[j] = v[j+gap];
                              v[j+gap] = temp;
                       }
}
Please compare this definition to the sort() defined in §12.5. This templatized version is cleaner and shorter because it can rely on more information about the type of the elements it sorts. Typically, it is also faster because it doesn’t rely on a pointer to function for the comparison. This implies that no indirect function calls are needed and that inlining a simple < is easy.

A further simplification is to use the standard-library template swap() (§35.5.2) to reduce the action to its natural form:

if (v[j+gap]<v[j])
       swap(v[j],v[j+gap]);
This does not introduce any new overhead. Better yet, the standard-library swap() uses move semantics, so we may see a speedup (§35.5.2).

In this example, operator < is used for comparison. However, not every type has a < operator. This limits the use of this version of sort(), but the limitation is easily avoided by adding an argument (see §25.2.3). For example:

Click here to view code image

template<typename T, typename Compare = std::less<T>>
void sort(vector<T>& v)      // definition
      // Shell sort (Knuth, Vol. 3, pg. 84)
{
     Compare cmp;                       // make a default Compare object
     const size_t n = v.size();

     for (int gap=n/2; 0<gap; gap/=2)
           for (int i=gap; i<n; i++)
                 for (int j=i–gap; 0<=j; j–=gap)
                       if (cmp(v[j+gap],v[j]))
                            swap(v[j],v[j+gap]);
}
We can now sort using the default comparison operation (<) or supply our own:

Click here to view code image

struct No_case {
     bool operator()(const string& a, const string& b) const;         // compare case insensitive
};

void f(vector<int>& vi, vector<string>& vs)
{
     sort(vi);                            // sort(vector<int>&)
     sort<int,std::greater<int>>(vi);     // sort(vector<int>&) using greater

     sort(vs);                            // sort(vector<string>&)
     sort<string,No_case>(vs);            // sort(vector<string>&) using No_case
}
Unfortunately, the rule that only trailing template arguments can be specified leads us to have to specify (rather than deduce) the element type when we specify the comparison operations.

The explicit specification of function template arguments is explained in §23.5.2.

23.5.1. Function Template Arguments
Function templates are essential for writing generic algorithms to be applied to a wide variety of container types (§3.4.2, §32.2). The ability to deduce template arguments for a call from the function arguments is crucial.

A compiler can deduce type and non-type arguments from a call, provided the function argument list uniquely identifies the set of template arguments. For example:

Click here to view code image

template<typename T, int max>
struct Buffer {
     T buf[max];
public:
      //...
};

template<typename T, int max>
T& lookup(Buffer<T,max>& b, const char* p);

Record& f(Buffer<string,128>& buf, const char* p)
{
     return lookup(buf,p);  // use the lookup() where T is string and i is 128
}
Here, lookup()’s T is deduced to be string and max is deduced to be 128.

Note that class template parameters are never deduced. The reason is that the flexibility provided by several constructors for a class would make such deduction impossible in many cases and obscure in many more. Instead, specialization (§25.3) provides a mechanism for implicitly choosing between alternative definitions of a template. If we need to create an object of a deduced type, we can often do that by calling a function to do the deduction (and creation). For example, consider a simple variant of the standard library’s make_pair() (§34.2.4.1):

Click here to view code image

template<typename T1, typename T2>
pair<T1,T2> make_pair(T1 a, T2 b)
{
     return {a,b};
}

auto x = make_pair(1,2);                      // x is a pair<int,int>
auto y = make_pair(string("New York"),7.7);   // y is a pair<string,double>
If a template argument cannot be deduced from the function arguments (§23.5.2), we must specify it explicitly. This is done in the same way that template arguments are explicitly specified for a template class (§25.2, §25.3). For example:

Click here to view code image

template<typename T>
T* create();            // make a T and return a pointer to it

void f()
{
     vector<int> v;             // class, template argument int
     int* p = create<int>();    // function, template argument int
     int* q = create();         // error: can't deduce template argument
}
This use of explicit specification to provide a return type for a function template is very common. It allows us to define families of object creation functions (e.g., create()) and conversion functions (e.g., §27.2.2). The syntax for static_cast, dynamic_cast, etc. (§11.5.2, §22.2.1), matches the explicitly qualified function template syntax.

Default template arguments can be used to simplify explicit qualification in some cases (§25.2.5.1).

23.5.2. Function Template Argument Deduction
A compiler can deduce a type template argument, T or TT, and a non-type template argument, I, from a template function argument with a type composed of the following constructs (§iso.14.8.2.1):

T

const T

volatile T

T*

T&

T[constant_expression]

type[I]

class_template_name<T>

class_template_name<I>

TT<T>

T<I>

T<>

T type::*

T T::*

type T::*

T (*)(args)

type(T::*)(args)

T(type::*)(args)

type (type::*)(args_TI)

T (T::*)(args_TI)

type(T::*)(args_TI)

T (type::*)(args_TI)

type (*)(args_TI)

 

Here, args_TI is a parameter list from which a T or an I can be determined by recursive application of these rules, and args is a parameter list that does not allow deduction. If not all parameters can be deduced in this way, a call is ambiguous. For example:

Click here to view code image

template<typename T, typename U>
void f(const T*, U(*)(U));

int g(int);

void h(const char* p)
{
     f(p,g);        // T is char, U is int
     f(p,h);        // error: can't deduce U
}
Looking at the arguments of the first call of f(), we easily deduce the template arguments. Looking at the second call of f(), we see that h() doesn’t match the pattern U(*)(U) because h()’s argument and return types differ.

If a template parameter can be deduced from more than one function argument, the same type must be the result of each deduction. Otherwise, the call is an error. For example:

Click here to view code image

template<typename T>
void f(T i, T* p);

void g(int i)
{
     f(i,&i);            // OK
     f(i,"Remember!");   // error, ambiguous: T is int or T is const char?
}
23.5.2.1. Reference Deduction
It can be useful to have different actions taken for lvalues and rvalues. Consider a class for holding an {integer,pointer} pair:

Click here to view code image

template<typename T>
class Xref {
public:
     Xref(int i, T* p)       // store a pointer: Xref is the owner
           :index{i}, elem{p}, owner{true}
     {}

     Xref(int i, T& r)       // store a pointer to r, owned by someone else
           :index{i}, elem{&r}, owner{false}
     {}

     Xref(int i, T&& r)      // move r into Xref, Xref is the owner
           :index{i}, elem{new T{move(r)}}, owner{true}
     {}


     ~Xref()
     {
           if(owned) delete elem;
     }
      //...
private:
     int index;
     T* elem;
     bool owned;
};
So:

Click here to view code image

string x {"There and back again"};

Xref<string> r1 {7,"Here"};                  // r1 owns a copy of string{"Here"}
Xref<string> r2 {9,x};                       // r2 just refers to x
Xref<string> r3 {3,new string{"There"}};     // r3 owns the string{"There"}
Here, r1 picks Xref(int,string&&) because x is an rvalue. Similarly, r2 picks Xref(int,string&) because x is an lvalue.

Lvalues and rvalues are distinguished by template argument deduction: an lvalue of type X is deduced as an X& and an rvalue as X. This differs from the binding of values to non-template argument rvalue references (§12.2.1) but is especially useful for argument forwarding (§35.5.1). Consider writing a factory function that make Xrefs on the free store and returns unique_ptrs to them:

Click here to view code image

template<typename T>
    T&& std::forward(typename remove_reference<T>::type& t) noexcept;  //§35.5.1
template<typename T>
    T&& std::forward(typename remove_reference<T>::type&& t) noexcept;
template<typename TT, typename A>
unique_ptr<TT> make_unique(int i, A&& a)     // simple variant of make_shared (§34.3.2)
{
    return unique_ptr<TT>{new TT{i,forward<A>(a)}};
}
We want make_unique<T>(arg) to construct a T from an arg without making any spurious copies. To do that, it is essential that the lvalue/rvalue distinction is maintained. Consider:

auto p1 = make_unique<Xref<string>>(7,"Here");
"Here" is an rvalue, so forward(string&&) is called, passing along an rvalue, so that Xref(int,string&&) is called to move from the string holding "Here".

The more interesting (subtle) case is:

auto p2 = make_unique<Xref<string>>(9,x);
Here, x is an lvalue, so forward(string&) is called, passing along an lvalue: forward()’s T is deduced to string& so that the return value becomes string& &&, which means string& (§7.7.3). Thus, Xref(int,string&) is called for the lvalue x, so that x is copied.

Unfortunately, make_unique() is not part of the standard library, but it is widely supported nevertheless. Defining a make_unique() that can take arbitrary arguments is relatively easy using a variadic template for forwarding (§28.6.3).

23.5.3. Function Template Overloading
We can declare several function templates with the same name and even declare a combination of function templates and ordinary functions with the same name. When an overloaded function is called, overload resolution is necessary to find the right function or function template to invoke. For example:

Click here to view code image

template<typename T>
     T sqrt(T);
template<typename T>
     complex<T> sqrt(complex<T>);
double sqrt(double);

void f(complex<double> z)
{
     sqrt(2);      // sqrt<int>(int)
     sqrt(2.0);    // sqrt(double)
     sqrt(z);      // sqrt<double>(complex<double>)
}
In the same way that a function template is a generalization of the notion of a function, the rules for resolution in the presence of function templates are generalizations of the function overload resolution rules. Basically, for each template we find the specialization that is best for the set of function arguments. Then, we apply the usual function overload resolution rules to these specializations and all ordinary functions (§iso.14.8.3):

[1] Find the set of function template specializations (§23.2.2) that will take part in overload resolution. Do this by considering each function template and deciding which template arguments, if any, would be used if no other function templates or functions of the same name were in scope. For the call sqrt(z), this makes sqrt<double>(complex<double>) and sqrt<complex<double>>(complex<double>) candidates. See also §23.5.3.2.

[2] If two function templates can be called and one is more specialized than the other (§25.3.3), consider only the most specialized template function in the following steps. For the call sqrt(z), this means that sqrt<double>(complex<double>) is preferred over sqrt<complex<double>>(complex<double>): any call that matches sqrt<T>(complex<T>) also matches sqrt<T>(T).

[3] Do overload resolution for this set of functions, plus any ordinary functions, as for ordinary functions (§12.3). If a function template’s argument has been determined by template argument deduction (§23.5.2), that argument cannot also have promotions, standard conversions, or user-defined conversions applied. For sqrt(2), sqrt<int>(int) is an exact match, so it is preferred over sqrt(double).

[4] If a function and a specialization are equally good matches, the function is preferred. Consequently, sqrt(double) is preferred over sqrt<double>(double) for sqrt(2.0).

[5] If no match is found, the call is an error. If we end up with two or more equally good matches, the call is ambiguous and is an error.

For example:

Click here to view code image

template<typename T>
T max(T,T);

const int s = 7;

void k()
{
     max(1,2);        // max<int>(1,2)
     max('a','b');    // max<char>('a','b')
     max(2.7,4.9);    // max<double>(2.7,4.9)
     max(s,7);        // max<int>(int{s},7) (trivial conversion used)

     max('a',1);      // error: ambiguous: max<char,char>() or max<int,int>()?
     max(2.7,4);      // error: ambiguous: max<double,double>() or max<int,int>()?
}
The problem with the last two calls is that we don’t apply promotions and standard conversions until after template parameters have been uniquely determined. There is no rule telling the compiler to prefer one resolution over the other. In most cases, it is probably good that the language rules leave subtle decisions in the hands of the programmer. The alternative to surprising ambiguity errors is surprising results from unexpected resolutions. People’s “intuitions” about overload resolution differ dramatically, so it is impossible to design a perfectly intuitive set of overload resolution rules.

23.5.3.1. Ambiguity Resolution
We could resolve the two ambiguities by explicit qualification:

Click here to view code image

void f()
{
     max<int>('a',1);           // max<int>(int('a'),1)
     max<double>(2.7,4);        // max<double>(2.7,double(4))
}
Alternatively, we could add suitable declarations:

Click here to view code image

inline int max(int i, int j) { return max<int>(i,j); }
inline double max(int i, double d) { return max<double>(i,d); }
inline double max(double d, int i) { return max<double>(d,i); }
inline double max(double d1, double d2) { return max<double>(d1,d2); }

void g()
{
     max('a',1);       // max(int('a'),1)
     max(2.7,4);       // max(2.7,4)
}
For ordinary functions, ordinary overloading rules (§12.3) apply, and the use of inline ensures that no extra overhead is imposed.

The definition of max() is trivial, so we could have implemented the comparison directly rather than calling a specialization of max(). However, using an explicit specialization of the template is an easy way of defining such resolution functions and can help maintenance by avoiding almost identical code in several functions.

23.5.3.2. Argument Substitution Failure
When looking for a best match for a set of arguments for a function template, the compiler considers whether the argument can be used in the way required by the complete function template declaration (including the return type). For example:

Click here to view code image

template<typename Iter>
typename Iter::value_type mean(Iter first, Iter last);

void f(vector<int>& v, int* p, int n)
{
     auto x = mean(v.begin(),v.end());    // OK
     auto y = mean(p,p+n);                // error
}
Here, the initialization of x succeeds because the arguments match and vector<int>::iterator has a member called value_type. The initialization of y fails because even though the arguments match, int* does not have a member called value_type, so we cannot say:

int*::value_type mean(int*,int*);      // int* does not have a member called value_type
However, what if there were another definition of mean()?

Click here to view code image

template<typename Iter>
typename Iter::value_type mean(Iter first, Iter last);      //#1

template<typename T>
T mean(T*,T*);                                              //#2

void f(vector<int>& v, int* p, int n)
{
     auto x = mean(v.begin(),v.end());       // OK: call #1
     auto y = mean(p,p+n);                   // OK: call #2
}
This works: both initializations succeed. But why didn’t we get an error when trying to match mean(p,p+n) with the first template definition? The arguments match perfectly, but by substituting in the actual template argument (int*), we get the function declaration:

int*::value_type mean(int*,int*);    // int* does not have a member called value_type
That is garbage, of course: a pointer does not have a member value_type. Fortunately, considering this possible declaration is not by itself an error. There is a language rule (§iso.14.8.2) that says that such a substitution failure is not an error. It simply causes the template to be ignored; that is, the template does not contribute a specialization to the overload set. That done, mean(p,p+n) matches declaration #2, which is called.

Without the “substitution error is not a failure” rule, we would get compile-time errors even when error-free alternatives (such as #2) are available. More, this rule gives us a general tool for selecting among templates. Techniques based on this rule are described in §28.4. In particular, the standard library provides enable_if to simplify conditional definition of templates (§35.4.2).

The rule is known under the unpronounceable acronym SFINAE (Substitution Failure Is Not An Error). SFINAE is often used as a verb with the “F” pronounced as a “v”: “I SFINAEd away that constructor.” That sounds quite impressive, but I tend to avoid this jargon. “The constructor was eliminated by a substitution failure” is clearer for most people and does less violence to the English language.

So, if – in the process of generating a candidate function to resolve a function call – the compiler finds itself generating a template specialization that would be nonsensical, that candidate is not entered into the overloading set. A template specialization is considered nonsensical if it would lead to a type error. In this, we consider only a declaration; template function definitions and the definition of class members are not considered (or generated) unless they are actually used. For example:

Click here to view code image

template<typename Iter>
Iter mean(Iter first, Iter last)                         //#1
{
     typename Iter::value_type = *first;
      //...
}

template<typename T>
T* mean(T*,T*);                                           //#2

void f(vector<int>& v, int* p, int n)
{
     auto x = mean(v.begin(),v.end());        // OK: call #1
     auto y = mean(p,p+n);                    // error: ambiguous
}
The declaration of mean() #1 is fine for mean(p,p+n). The compiler does not start to instantiate the body of that mean() and eliminate it because of the type error.

Here, the result is an ambiguity error. Had mean() #2 not been present, declaration #1 would have been chosen and we would have suffered an instantiation-time error. Thus, a function may be chosen as the best match yet still fail to compile.

23.5.3.3. Overloading and Derivation
The overload resolution rules ensure that function templates interact properly with inheritance:

Click here to view code image

template<typename T>
    class B { /* ... */ };
template<typename T>
    class D : public B<T> { /* ... */ };

template<typename T> void f(B<T>*);

void g(B<int>* pb, D<int>* pd)
{
     f(pb);          // f<int>(pb) of course
     f(pd);          // f<int>(static_cast<B<int>*>(pd));
                     // standard conversion D<int>* to B<int>* used
}
In this example, the function template f() accepts a B<T>* for any type T. We have an argument of type D<int>*, so the compiler easily deduces that by choosing T to be int, the call can be uniquely resolved to a call of f(B<int>*).

23.5.3.4. Overloading and Non-Deduced Parameters
A function argument that is not involved in the deduction of a template parameter is treated exactly as an argument of a non-template function. In particular, the usual conversion rules hold. Consider:

Click here to view code image

template<typename T, typename C>
T get_nth(C& p, int n);    // get the nth element
This function presumably returns the value of the nth element of a container of type C. Because C has to be deduced from an actual argument of get_nth() in a call, conversions are not applicable to the first argument. However, the second argument is perfectly ordinary, so the full range of possible conversions is considered. For example:

Click here to view code image

struct Index {
     operator int();
      //...
};

void f(vector<int>& v, short s, Index i)
{
     int i1 = get_nth<int>(v,2);  // exact match
     int i2 = get_nth<int>(v,s);  // standard conversion: short to int
     int i3 = get_nth<int>(v,i);  // user-defined conversion: Index to int
}
This notation is sometimes called explicit specialization (§23.5.1).

23.6. Template Aliases
We can define an alias for a type with the using syntax or with the typedef syntax (§6.5). The using syntax is more general in the important sense that it can be used to define an alias for a template with some of its arguments bound. Consider:

Click here to view code image

template<typename T, typename Allocator = allocator<T>> vector;

using Cvec = vector<char>;                       // both arguments are bound

Cvec vc = {'a', 'b', 'c'};                       // vc is a vector<char,allocator<char>>

template<typename T>
using Vec = vector<T,My_alloc<T>>;               // vector using my allocator (2nd argument is bound)

Vec<int> fib = {0, 1, 1, 2, 3, 5, 8, 13};        // fib is a vector<int,My_alloc<int>>
In general, if we bind all arguments of a template, we get a type, but if we bind only some, we get a template. Note that what we get from using in an alias definition is always an alias. That is, when we use the alias, it is completely equivalent to a use of the original template. For example:

Click here to view code image

vector<char,alloc<char>> vc2 = vc;              // vc2 and vc are of the same type
vector<int,My_alloc<int>> verbose = fib;        // verbose and fib are of the same type
The equivalence of the alias and the original template implies that if you specialize the template, you (correctly) get the specializations when you use the alias. For example:

Click here to view code image

template<int>
struct int_exact_traits {    // idea: int_exact_traits<N>::type is a type with exactly N bits
     using type = int;
};

template<>
struct int_exact_traits<8> {
     using type = char;
};
template<>
struct int_exact_traits<16> {
     using type = short;
};

template<int N>
using int_exact = typename int_exact_traits<N>::type;    // define alias for convenient notation

int_exact<8> a = 7;   // int_exact<8> is an int with 8 bits
If specializations did not get used through the alias, we couldn’t claim that int_exact was simply an alias for int_exact_traits<N>::type; they would behave differently. On the other hand, you cannot define a specialization of an alias. If you had been able to, it would have been rather easy for a human reader to get confused about what was specialized, so no syntax is provided for specializing an alias.

23.7. Source Code Organization
There are three reasonably obvious ways of organizing code using templates:

[1] Include template definitions before their use in a translation unit.

[2] Include template declarations (only) before their use in a translation unit. Include definitions of templates later in the translation unit (potentially after their use).

[3] Include template declarations (only) before their use in a translation unit. Define the templates in some other translation unit.

For technical and historical reasons, option [3], the separate compilation of template definitions and their uses, is not offered. By far the most common approach is to include (usually #include) the definition of the templates you use in every translation unit in which you use them and rely on your implementation to optimize compile times and eliminate object code duplication. For example, I might provide a template out() in a header out.h:

 // file out.h:

        #include<iostream>

        template<typename T>
        void out(const T& t)
        {
             std::cerr << t;
        }
We would #include this header wherever out() was needed. For example:

 // file user1.cpp:

        #include "out.h"
         // use out()
and

 // file user2.cpp:

        #include "out.h"
         // use out()
That is, the definition of out() and all declarations on which it depends are #included in several different compilation units. It is up to the compiler to generate code when needed (only) and to optimize the process of reading redundant definitions. This strategy treats template functions the same way as inline functions.

An obvious problem with this strategy is that users may accidentally come to depend on declarations included only for the benefit of the definition of out(). This danger can be limited by taking approach [2] “include template definitions later,” by using namespaces, by avoiding macros, and generally by reducing the amount of information included. The ideal is to minimize a template definition’s dependency on its environment.

To use the “include template definitions later” approach for our simple out() example, we first split out.h into two. The declarations go into a .h file:

 // file outdecl.h:

        template<typename T>
        void out(const T& t);
The definitions go into out.cpp:

 // file out.cpp:

        #include<iostream>

        template<typename T>
        void out(const T& t)
        {
             std::cerr << t;
        }
A user now #includes both:

 // file user3.cpp:

        #include "out.h"
         // use out()
        #include "out.cpp"
This minimizes the chances of the implementation of the templates having undesirable effects on the user code. Unfortunately, it also increases the chances that something in the user code (say, a macro) will have an undesirable effect on the template definitions.

As ever, non-inline, non-template functions and static members (§16.2.12) must have a unique definition in some compilation unit. This implies that such members are best not used for templates that are otherwise included in many translation units. As shown with out(), the definition of a template function may be replicated in different translation units, so beware of contexts that might subtly change the meaning of a definition:

 // file user1.cpp:

        #include "out.h"
         // use out()
and

 // file user4.cpp:

        #define std MyLib
        #include "out.c"
         // use out()
This sneaky and error-prone use of a macro changes the definition of out so that user4.cpp’s definition differs from user1.cpp’s. This is an error, but it is an error that an implementation may not catch. This kind of error can be very hard to detect in large programs, so be careful to minimize context dependencies of templates and be very suspicious about macros (§12.6).

If you need more control over the context of instantiation, you can use explicit instantiation and extern templates (§26.2.2).

23.7.1. Linkage
The rules for linkage of templates are the rules for linkage of the generated classes and functions (§15.2, §15.2.3). This implies that if the layout of a class template or the definition of an inline function template changes, all code that uses that class or function must be recompiled.

For templates defined in header files and included “everywhere” this can imply a lot of recompilation because templates tend to include a lot of information in header files, more than non-template code using .cpp files. In particular, if dynamically linked libraries are used, care has to be taken that all uses of a template are consistently defined.

Sometimes, it is possible to minimize the exposure to changes in complicated template libraries by encapsulating their use in functions with non-template interfaces. For example, I might like to implement some computations using a general numerical library supporting a wide variety of types (e.g., Chapter 29, §40.4, §40.5, §40.6). However, I often know the type used for my calculations. For example, in a program I may consistently use doubles and vector<double>. In that case, I could define:

Click here to view code image

double accum(const vector<double>& v)
{
    return accumulate(v.begin(),v.end(),0.0);
}
Given that, I can use the simple non-templated declaration of accum() in my code:

double accum(const vector<double>& v);
The dependence on std::accumulate has disappeared into a .cpp file that is not seen by the rest of my code. Also, I suffer the compilation-time overhead of a #include<numeric> only in that .cpp file.

Note that I took the opportunity to simplify the interface to accum() compared to std::accumulate(). The generality that is a key attribute of good template libraries can be seen as a source of complexity in a particular application.

I suspect that I would not use this technique for standard-library templates. Those are stable over years and known to the implementations. In particular, I did not bother to try to encapsulate vector<double>. However, for more complex, esoteric, or frequently changing template libraries, such encapsulation can be useful.

23.8. Advice
[1] Use templates to express algorithms that apply to many argument types; §23.1.

[2] Use templates to express containers; §23.2.

[3] Note that template<class T> and template<typename T> are synonymous; §23.2.

[4] When defining a template, first design and debug a non-template version; later generalize by adding parameters; §23.2.1.

[5] Templates are type-safe, but checking happens too late; §23.3.

[6] When designing a template, carefully consider the concepts (requirements) assumed for its template arguments; §23.3.

[7] If a class template should be copyable, give it a non-template copy constructor and a non-template copy assignment; §23.4.6.1.

[8] If a class template should be movable, give it a non-template move constructor and a non-template move assignment; §23.4.6.1.

[9] A virtual function member cannot be a template member function; §23.4.6.2.

[10] Define a type as a member of a template only if it depends on all the class template’s arguments; §23.4.6.3.

[11] Use function templates to deduce class template argument types; §23.5.1.

[12] Overload function templates to get the same semantics for a variety of argument types; §23.5.3.

[13] Use argument substitution failure to provide just the right set of functions for a program; §23.5.3.2.

[14] Use template aliases to simplify notation and hide implementation details; §23.6.

[15] There is no separate compilation of templates: #include template definitions in every translation unit that uses them; §23.7.

[16] Use ordinary functions as interfaces to code that cannot deal with templates; §23.7.1.

[17] Separately compile large templates and templates with nontrivial context dependencies; §23.7.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


23. Templates
24. Generic Programming
25. Specialization
47h 26m remaining
24. Generic Programming
Now is a good time to put your work on a firm theoretical basis.

– Sam Morgan

• Introduction

• Algorithms and Lifting

• Concepts

Discovering a Concept; Concepts and Constraints

• Making Concepts Concrete

Axioms; Multi-argument Concepts; Value Concepts; Constraints Checks; Template Definition Checking

• Advice

24.1. Introduction
What are templates for? In other words, what programming techniques are effective when you use templates? Templates offer:

• The ability to pass types (as well as values and templates) as arguments without loss of information. This implies excellent opportunities for inlining, of which current implementations take great advantage.

• Delayed type checking (done at instantiation time). This implies opportunities to weave together information from different contexts.

• The ability to pass constant values as arguments. This implies the ability to do compile-time computation.

In other words, templates provide a powerful mechanism for compile-time computation and type manipulation that can lead to very compact and efficient code. Remember that types (classes) can contain both code and values.

The first and most common use of templates is to support generic programming, that is, programming focused on the design, implementation, and use of general algorithms. Here, “general” means that an algorithm can be designed to accept a wide variety of types as long as they meet the algorithm’s requirements on its arguments. The template is C++’s main support for generic programming. Templates provide (compile-time) parametric polymorphism.

There are many definitions of “generic programming.” Thus, the term can be confusing. However, in the context of C++, “generic programming” implies an emphasis on the design of general algorithms implemented using templates.

Focusing more on generative techniques (seeing templates as type and function generators) and relying on type functions to express compile-time computation are called template metaprogramming, which is the subject of Chapter 28.

The type checking provided for templates checks the use of arguments in the template definition rather than against an explicit interface (in a template declaration). This provides a compile-time variant of what is often called duck typing (“If it walks like a duck and it quacks like a duck, it’s a duck”). Or – using more technical terminology – we operate on values, and the presence and meaning of an operation depend solely on its operand values. This differs from the alternative view that objects have types, which determine the presence and meaning of operations. Values “live” in objects. This is the way objects (e.g., variables) work in C++, and only values that meet an object’s requirements can be put into it. What is done at compile time using templates does not involve objects, only values. In particular, there are no variables at compile time. Thus, template programming resembles programming in dynamically-typed programming languages, but the run-time cost is zero, and errors that in a run-time typed language manifest themselves as exceptions become compile-time errors in C++.

A key aspect of generic programming, metaprogramming, and probably all uses of templates is the uniform handling of built-in types and user-defined types. For example, an accumulate() operation does not care whether the types of values it adds up are ints, complex<double>s, or Matrixes. What it cares about is that they can be added using the + operator. The use of a type as a template argument does not imply or require the use of a class hierarchy or any form of run-time self-identification of the type of an object. This is logically pleasing and essential for high-performance applications.

This section focuses on two aspects of generic programming:

• Lifting: generalizing an algorithm to allow the greatest (reasonable) range of argument types (§24.2), that is, to limit an algorithm’s (or a class’s) dependency on properties to what is essential

• Concepts: carefully and precisely specifying the requirements of an algorithm (or a class) on its arguments (§24.3)

24.2. Algorithms and Lifting
A function template is a generalization of an ordinary function in the sense that it can perform its actions on a variety of data types and use a variety of operations passed as arguments to implement those actions. An algorithm is a procedure or formula for solving a problem: a finite series of computation steps to produce a result. Thus, a function template is often called an algorithm.

How do we get from a function doing specific operations on specific data to an algorithm doing more general operations on a variety of data types? The most effective way of getting a good algorithm is to generalize from one – and preferably more – concrete example. Such generalization is called lifting: that is, lifting a general algorithm from specific functions. It is important to go from the concrete to the abstract while maintaining performance and keeping an eye on what is reasonable. Overly clever programmers can generalize to an absurd extent to try to cover every eventuality. Thus, trying to abstract from first principles in the absence of concrete examples typically leads to bloated, hard-to-use code.

I will illustrate the process of lifting by a concrete example. Consider:

Click here to view code image

double add_all(double* array, int n)
     // one concrete algorithm on array of doubles
{
    double s {0};
    for (int i = 0; i<n; ++i)
          s = s + array[i];
    return s;
}
Obviously, this computes the sum of the doubles in the argument array. Also consider:

Click here to view code image

struct Node {
     Node* next;
     int data;
};

int sum_elements(Node* first, Node* last)
      // another concrete algorithm on list of ints
{
     int s = 0;
     while (first!=last) {
           s += first–>data;
           first = first–>next;
     }
     return s;
}
This computes the sum of the ints in the singly-linked list implemented by the Nodes.

These two code fragments differ in detail and in style, but an experienced programmer will immediately say, “Well, this is just two implementations of the accumulate algorithm.” This is a popular algorithm. Like most popular algorithms, it has many names, including reduce, fold, sum, and aggregate. However, let us try to develop a general algorithm from the two concrete examples in stages, so as to get a feel for the process of lifting. First we try to abstract away the data types so that we don’t have to be specific about

• double vs. int, or

• array vs. linked list.

To do so, I write some pseudo code:

Click here to view code image

 // pseudo code:

T sum(data)
     // somehow parameterize by the value type and the container type
{
    T s = 0
    while (not at end) {
               s = s + current value
               get next data element
    }
    return s
}
To make this concrete, we need three operations to access the “container” data structure:

• Not at end

• Get current value

• Get next data element

For the actual data, we also need three operations:

• Initialize to zero

• Add

• Return the result

Obviously, this is rather imprecise, but we can turn it into code:

Click here to view code image

 // concrete STL-like code:

template<typename Iter, typename
Val sum(Iter first, Iter last)
{
     Val s = 0;
     while (first!=last) {
           s = s + *first;
           ++first;
     }
     return s;
}
Here, I took advantage of knowing the usual STL way of representing a sequence of values (§4.5). The sequence is represented as a pair of iterators supporting three operations:

• * for accessing the current value

• ++ for moving forward to the next element

• != for comparing iterators to check if we are at the end of a sequence

We now have an algorithm (a function template) that can be used for both arrays and linked lists and for both ints and doubles. The array example works immediately because double* is an example of an iterator:

double ad[] = {1,2,3,4};
double s = sum<double*,double>(ad,ad+4);
To use the handcrafted singly-linked list, we need to provide an iterator for it:

Click here to view code image

struct Node { Node next; int data; };
struct Node_iter { Node pos; };

Node_iter operator++(Node_iter& p) { return p.pos=p.pos>next; }
int operator(Node_iter p) { return p.pos>data; }
bool operator!=(Node_iter p, Node_iter q) { return p.pos != q.pos; }

void test(Node lst)
{
     int s = sum<Node_iter,int>(lst,nullptr);
}
I use the nullptr as the end iterator. I use an explicit template argument (here, <Node_iter,int>) to allow a caller to specify the type to use for the accumulator variable.

What we have so far is more general than a lot of real-world code. For example, sum() would work for lists of floating-point numbers (of all precisions), for arrays of integers (of all ranges), and for many other types, such as a vector<char>. Importantly, sum() is as efficient as the handcrafted functions we started from. We do not want to achieve generality at the cost of performance.

The experienced programmer will note that sum() can be generalized further. In particular, the use of an extra template argument is awkward, and we required the initial value 0. We can solve that by letting the caller supply an initial value and then deduce Val:

Click here to view code image

template<typename Iter, typename Val>
Val accumulate(Iter first, Iter last, Val s)
{
     while (first!=last) {
           s = s + *first;
           ++first;
     }
     return s;
}

double ad[] = {1,2,3,4};
double s1 = accumulate(ad,ad+4,0.0);   // accumulate in a double
double s2 = accumulate(ad,ad+4,0);     // accumulate in an int
But why +? We sometimes want to multiply elements. In fact, there seem to be quite a few operations we might want to apply to the elements of a sequence. This leads to a further generalization:

Click here to view code image

template<typename Iter, typename Val, typename Oper>
Val accumulate(Iter first, Iter last, Val s, Oper op)
{
     while (first!=last) {
           s = op(s,*first);
           ++first;
     }
     return s;
}
We now use the argument op to combine element values with the accumulator. For example:

Click here to view code image

double ad[] = {1,2,3,4};
double s1 = accumulate(ad,ad+4,0.0,std::plus<double>{});      // as before
double s2 = accumulate(ad,ad+4,1.0,std::multiply<double>);
The standard library provides common operations, such as plus and multiply, as function objects to be used as arguments. Here, we see the utility of having the caller supply the initial value: 0 and * don’t go well together for accumulation. The standard library offers a further generalization of accumulate() that allows a user to provide an alternative to = for combining the result of the “addition” and the accumulator (§40.6).

Lifting is a skill that requires knowledge of an application domain and some experience. The most important single guide for designing algorithms is to lift them from concrete examples without adding features (notation or run-time cost) that would impair their use. The standard-library algorithms are the results of lifting done with great attention to performance issues.

24.3. Concepts
What are a template’s requirements for its arguments? In other words, what does the template code assume about its argument types? Or conversely, what must a type provide to be acceptable as an argument to a template? The possibilities are infinite because we can build classes and templates with arbitrary properties, for example:

• Types that provide – but not +

• Types that can copy but not move values

• Types for which copy operations do not copy (§17.5.1.3)

• Types for which == compares equality and others for which compare() does that

• Types that define addition as a member function plus() and others that define it as a non-member function operator+()

In that direction lies chaos. If every class has a unique interface, it becomes difficult to write templates that can take many different types. Conversely, if each template’s requirements are unique, it becomes difficult to define types that can be used with many templates. We would have to remember and keep track of a multitude of interfaces; that’s feasible for a tiny program, but unmanageable for real-world libraries and programs. What we need to do is to identify a small number of concepts (sets of requirements) that can be used for many templates and many types as arguments. The ideal is a kind of “plug compatibility” as we know it from the physical world, with a small number of standard plug designs.

24.3.1. Discovering a Concept
As an example, consider the String class template from §23.2:

template<typename C>
class String {
      //...
};
What is required of a type, X, for it to be used as an argument to String: String<X>? More generally, what does it take to be a character in such a character string class? An experienced designer will have a small number of likely answers to that question and start the design based on those. However, let us consider how we might answer it from first principles. We proceed through three stages of analysis:

[1] First, we look at our (initial) implementation and determine which properties (operations, functions, member types, etc.) it uses from its parameter types (and the meaning of those operations). The resulting list is the minimal requirements for that particular template implementation.

[2] Next, we look at plausible alternative template implementations and list their requirements on their template arguments. Doing so, we may decide that we should place more or stricter requirements on the template arguments to allow for alternative implementations. Alternatively, we might decide to prefer an implementation that makes fewer and/or simpler requirements.

[3] Finally, we look at the resulting list (or lists) of required properties and compare it to lists of requirements (concepts) that we have used for other templates. We try to find simple, preferably common, concepts that can express what would otherwise be many long lists of requirements. The aim here is to make our design benefit from general work on classification. The resulting concepts are easier to give meaningful names and easier to remember. They should also maximize the degree of interoperability of templates and types by limiting variations in concepts to what is essential.

The first two steps are – for fundamental reasons – very similar to the way we generalize (“lift”) concrete algorithms into generic algorithms (§24.2). The last step counteracts the temptation to provide each algorithm with a set of argument requirements that exactly match its implementation. Such requirement lists are overspecialized and not stable: each change to the implementation would imply changes to the requirements documented as part of the algorithm’s interface.

For String<C>, first consider the operations actually performed on the parameter C by the implementation of String (§19.3). That will be the minimal set of requirements for that implementation of String:

[1] Cs are copied by copy assignment and copy initialization.

[2] String compares Cs using == and !=.

[3] String makes arrays of Cs (that implies default construction of Cs).

[4] String takes the address of Cs.

[5] Cs are destroyed when a String is destroyed.

[6] String has >> and << operators that somehow must read and write Cs.

Requirements [4] and [5] are technical requirements that we usually assume for all data types, and I will not discuss types that fail to meet them; such types are almost all overly clever artifacts. The first requirement – that values can be copied – is not true for a few important types, such as std::unique_ptr, that represent real resources (§5.2.1, §34.3.1). However, it is true for almost all “ordinary types,” so we require it. The ability to invoke a copy operation goes together with the semantic requirement that a copy really is a copy of the original, that is, that – except for taking the address – the two copies behave identically. Therefore, the ability to copy usually (as for our String) goes together with the requirement to provide == with the usual semantics.

By requiring assignment, we imply that a const type cannot be used as a template argument. For example, String<const char> is not guaranteed to work. That’s fine in this case, as in most cases. Having assignment means that an algorithm can use temporary variables of its argument type, create containers of objects of an argument type, etc. It does not imply that we cannot use const to specify interfaces. For example:

Click here to view code image

template<typename T>
bool operator==(const String<T>& s1, const String<T>& s2)
{
     if (s1.size()!=s2.size()) return false;
     for (auto i = 0; i!=s1.size(); ++i)
           if (s1[i]!=s2[i]) return false;
     return true;
}
For String<X> we require that objects of type X can be copied. Independently, through the consts in its argument types, operator==() promises not to write to the X elements.

Should we require a move for an element type C? After all, we provide move operations for String<C>. We could, but it’s not essential: what we do with a C can be handled by copying, and if some copy is implicitly turned into a move (e.g., when we returned a C), so much the better. In particular, potentially important examples, such as String<String<char>>, will work fine (correctly and efficiently) without adding move operations to the requirements.

So far, so good, but the last requirement (that we can read and write Cs using >> and <<) seems excessive. Do we really read and write every kind of string? Maybe it would be better to say that if we read and write a String<X>, then X must provide >> and <<? That is, instead of placing a requirement on C for the whole String, we require it (only) for Strings that we actually read and write.

This is an important and fundamental design choice: we can place a requirement on class template arguments (so that they apply to all class members) or just to template arguments on individual class function members. The latter is more flexible, but also more verbose (we have to express the requirement for each function that needs it) and harder for a programmer to remember.

Looking at the list of requirements so far, I note the absence of a couple of operations that are common for “ordinary characters” in “ordinary strings”:

[1] No ordering (e.g., <)

[2] No conversion to an integer value

After this initial analysis we can consider which “well-known concepts” (§24.3.2) our lists of requirements relate to. The central concept for “ordinary types” is regular. A regular type is a type that

• you can copy (using assignment or initialization) with the proper copy semantics (§17.5.1.3),

• you can default construct,

• doesn’t have problems with various minor technical requirements (such as taking the address of a variable),

• you can compare for equality (using == and !=).

That seems an excellent choice for our String template arguments. I considered leaving out the equality comparisons but decided that copying without equality is rarely useful. Typically, Regular is the safe bet, and thinking about the meaning of == can help avoid errors in the definition of copying. All the built-in types are regular.

But does it make sense to leave out ordering (<) for String? Consider how we use strings. The desired use of a template (such as String) should determine its requirements on its arguments. We do compare strings extensively, and in addition we use comparisons indirectly when we sort sequences of strings, we put strings into sets, etc. Also, the standard-library string does provide <. It is usually a good idea to look to the standard for inspiration. So, we require not just Regular for our String, but also ordering. That’s the concept Ordered.

Interestingly, there has been quite some debate on whether Regular should require < or not. It seems that most types related to numbers have a natural order. For example, characters are encoded in bit patterns that can be interpreted as integers, and any sequence of values can be lexicographically ordered. However, many types do not have a natural order (e.g., complex numbers and images) even though we could define one. Other types have several natural orderings, but no unique best ordering (e.g., records may be ordered by name or by address). Finally, some (reasonable) types simply don’t have an order. For example, consider:

enum class rsp { rock, scissors, paper };
The rock-scissors-and-paper game critically depends on

• scissors<rock,

• rock<paper, and

• paper<scissors.

However, our String is not supposed to take an arbitrary type as its character type; it is supposed to take a type that supports string operations (such as comparisons, sorting, and I/O), so I decided to require ordering.

Adding a default constructor and the == and < operator, to our requirements for String’s template argument allows us to provide several useful operations for String. In fact, the more we require of a template argument type, the easier the various tasks become for the template implementer and the more services the template can offer to its users. On the other hand, it is important not to load down a template with requirements that are only used rarely and by specific operations: each requirement places a burden on the implementer of argument types and limits the set of types that can be used as arguments. So, for String<X> we require:

• Ordered<X>

• >> and << for X (only) if we use String<X>’s >> and <<

• Convertibility to an integer (only) if we define and use a conversion operation from X

So far, we have expressed our requirement of a character type for String in terms of syntactic properties, such as X must provide copy operations, ==, and <. In addition, we must require that these operations have the right semantics; for example, a copy operation makes a copy, == (equality) compares for equality, and < (less than) provides ordering. Often, this semantics involves relations among the operations. For example, for the standard library, we have (§31.2.2.1):

• The result of a copy compares equal to anything the original compares equal to (a==b implies T{a}==T{b}) and the copy is independent of its source (§17.5.1.3).

• A less-than comparison (e.g., <) provides a strict weak order (§31.2.2.1).

The semantics are defined in English text or (better still) mathematics, but unfortunately we have no way of expressing semantic requirements in C++ itself (but see §24.4.1). For the standard library, you can find the semantic requirements written in formalized English in the ISO standard.

24.3.2. Concepts and Constraints
A concept is not an arbitrary collection of properties. Most lists of properties of a type (or a set of types) do not define a coherent and useful concept. To be useful as a concept, a list of requirements has to reflect the needs of a set of algorithms or a set of operations of a template class. In many fields of endeavor, people have designed or discovered concepts describing the fundamental concepts of the field (the technical use of the word “concept” in C++ was chosen with this common usage in mind). There seem to be surprisingly few concepts that make sense. For example, algebra builds on concepts such as monad, field, and ring, whereas the STL relies on concepts such as forward iterator, bidirectional iterator, and random-access iterator. Finding a new concept in a field is a major accomplishment; it is not something you should expect to do every year. Mostly, you find concepts by examining the foundational texts of a field of study or an application domain. The set of concepts used in this book are described in §24.4.4.

“Concepts” is a very general idea that does not inherently have anything to do with templates. Even K&R C [Kernighan,1978] had concepts in the sense that signed integral type is the language’s generalization of the idea of an integer in memory. Our requirements on template arguments are concepts (however expressed), so most interesting issues related to concepts come in the context of templates.

I see a concept as a carefully crafted entity that reflects fundamental properties of an application domain. Consequently, there should be only few concepts, and these can act as a guideline for the design of algorithms and types. The analogy is with physical plugs and sockets; we want the minimal number to simplify our lives and to keep design and construction costs down. This ideal can conflict with the ideal of minimal requirements for each individual generic algorithm (§24.2) and each individual parameterized class. Furthermore, the ideal can conflict with the ideal of providing absolutely minimal interfaces to classes (§16.2.3) and even with what some programmers regard as their right to write their code “exactly as they like.” However, we don’t get plug compatibility without effort and some form of standard.

I set the bar for being a concept very high: I require generality, some stability, usability across many algorithms, semantic consistency, and more. In fact, many simple constraints that we’d like for template arguments don’t qualify as concepts according to my criteria. I think that is unavoidable. In particular, we write many templates that do not reflect general algorithms or widely applicable types. Instead, they are implementation details, and their arguments only have to reflect the necessary details of a template intended for a single use in a single implementation of something. I call requirements for such template arguments constraints or (if you must) ad hoc concepts. One way to look at constraints is to consider them incomplete (partial) specifications of an interface. Often, a partial specification can be useful and much better than no specification.

As an example, consider a library for experimenting with balancing strategies for balanced binary trees. The tree takes a balancer, Balance, as a template argument:

Click here to view code image

template<typename Node, typename Balance>
struct node_base {  // base of balanced tree
      //...
}
A balancer is simply a class that provides three operations on nodes. For example:

Click here to view code image

struct Red_black_balance {
      //...
     template<typename Node> static void add_fixup(Node* x);
     template<typename Node> static void touch(Node* x);
     template<typename Node> static void detach(Node* x);
};
Obviously, we’d like to say what’s required of node_base’s arguments, but a balancer is not meant to be a widely used and easily understood interface; it’s meant to be used only as a detail of a particular implementation of balanced trees. This idea of a balancer (I hesitate to use the word “concept”) is unlikely to be used elsewhere or even to survive a major rewrite of the balanced tree implementation unchanged. It would be hard to pin down the exact semantics of a balancer. For starters, the semantics of Balancer would critically depend on the semantics of Node. In those aspects, a Balancer differs from a proper concept, such as Random_access_iterator. We can, however, still use the minimal specification of a balancer, “provides those three functions on nodes,” as a constraint on arguments to a node_base.

Note the way “semantics” keep cropping up in the discussion of concepts. I find that “Can I write out a semiformal semantics?” to be the question that is most helpful when it comes to deciding whether something is a concept or simply an ad hoc collection of constraints on a type (or set of types). If I can write out a meaningful semantic specification, I have a concept. If not, what I have is a constraint that may be useful but shouldn’t be expected to be stable or widely useful.

24.4. Making Concepts Concrete
Unfortunately, C++ does not have specific language facilities for directly expressing concepts. However, handling “concepts” as a design notion only and presenting them informally as comments is not ideal. For starters, compilers do not understand comments, so requirements expressed only as comments must be checked by the programmer and cannot help the compiler provide good error messages. Experience shows that even though concepts cannot be represented perfectly without direct language support, we can approximate them using code that performs compile-time checks of template argument properties.

A concept is a predicate; that is, we think of a concept as a compile-time function that looks at a set of template arguments and returns true if they meet the concept’s requirements and false if they don’t. So, we implement a concept as a constexpr function. Here, I will use the term constraints check to refer to a call of a constexpr predicate that checks a concept for a set of types and values. In contrast to proper concepts, a constraints check does not deal with semantic issues; it simply checks assumptions about syntactic properties.

Consider our String; its character type argument is supposed to be Ordered:

Click here to view code image

template<typename C>
class String {
     static_assert(Ordered<C>(),"String's character type is not ordered");
      //...
};
When String<X> is instantiated for a type X, the static_assert will be executed by the compiler. If Ordered<X>() returns true, the compilation proceeds, generating exactly the code it would have without the assert. Otherwise, the error message is produced.

At first glance, this looks rather reasonable for a workaround. I’d rather have said:

template<Ordered C>
class String {
      //...
};
However, that is for the future, so let us see how to define the predicate Ordered<T>():

Click here to view code image

template<typename T>
constexpr bool Ordered()
{
    return Regular<T>() && Totally_ordered<T>();
}
That is, a type is Ordered if it is both Regular and Totally_ordered. Let us “dig down” to see what that means:

Click here to view code image

template<typename T>
constexpr bool Totally_ordered()
{
     return Equality_comparable<T>()    // has == and !=
           && Has_less<T>() && Boolean<Less_result<T>>()
           && Has_greater<T>() && Boolean<Greater_result<T>>()
           && Has_less_equal<T>() && Boolean<Less_equal_result<T>>()
           && Has_greater_equal<T>() && Boolean<Greater_equal_result<T>>();
}

template<typename T>
constexpr bool Equality_comparable()
{
    return Has_equal<T>() && Boolean<Equal_result<T>>()
         && Has_not_equal<T>() && Boolean<Not_equal_result<T>>();
}
So, a type T is ordered if it is regular and provides the usual six comparison operations. The comparison operations have to deliver results that can be converted to bool. The comparison operators are also supposed to have their proper mathematical meaning. The C++ standard precisely specifies what that means (§31.2.2.1, §iso.25.4).

Has_equal is implemented using enable_if and the techniques described in §28.4.4.

I capitalize my constraints names (e.g., Regular) even though doing so violates my “house style” of capitalizing type and template names, but not functions. However, concepts are even more fundamental than types, so I feel a need to emphasize them. I also keep them in a separate namespace (Estd) in the hope that very similar names will eventually become part of the language or the standard library.

Digging a bit further into the set of useful concepts, we can define Regular:

Click here to view code image

template<typename T>
constexpr bool Regular()
{
    return Semiregular<T>() && Equality_comparable<T>();
}
Equality_comparable gives us == and !=. Semiregular is the concept that express the notion of a type that doesn’t have unusual technical restrictions:

Click here to view code image

template<typename T>
constexpr bool Semiregular()
{
    return Destructible<T>()
         && Default_constructible<T>()
         && Move_constructible<T>()
         && Move_assignable<T>()
         && Copy_constructible<T>()
         && Copy_assignable<T>();
}
A Semiregular can be both moved and copied. That describes most types, but there are examples of types that cannot be copied, such as unique_ptr. However, I don’t know of useful types that can be copied but not moved. Types that can neither be moved nor copied, such as type_info (§22.5), are very rare and tend to reflect system properties.

We can also use constraints checks for functions; for example:

Click here to view code image

template<typename C>
ostream& operator<<(ostream& out, String<C>& s)
{
     static_asser t(Streamable<C>(),"String's character not streamable");
     out << '"'; // double quote character
     for (int i=0; i!=s.size(); ++i)
           cout << s[i];
     out << '"';
}
The concept Streamable needed by String’s output operator << requires its argument C to provide the output operator <<:

Click here to view code image

template<typename T>
constexpr bool Streamable()
{
    return Input_streamable<T>() && Output_streamable<T>();
}
That is, Streamable tests that we can use the standard stream I/O (§4.3, Chapter 38) for a type.

Checking concepts through constraints-check templates has obvious weaknesses:

• Constraints checks are placed in definitions, but they really belong in declarations. That is, a concept is part of the interface to an abstraction, but a constraints check can be used only in its implementation.

• The checking of constraints occurs as part of the instantiation of the constraints-check template. Therefore, the checking may occur later than we would like. In particular, we would have preferred for a constraints check to be guaranteed to be done by the compiler at the point of the first call, but that is impossible without language changes.

• We can forget to insert a constraints check (especially for a function template).

• The compiler does not check that a template implementation uses only the properties specified in its concepts. Thus, a template implementation may pass the constraints check, yet still fail to type check.

• We do not specify semantic properties in a way that a compiler can understand (e.g., we use comments).

Adding constraints checks makes the requirements on template arguments explicit, and if a constraints check is well designed, it leads to more comprehensible error messages. If we forget to insert constraints checks, we are back to the ordinary type checking of the code generated by template instantiation. That can be unfortunate, but it is not disastrous. These constraints checks are a technique for making checking of designs based on concepts more robust, rather than an integral part of the type system.

If we want to, we can place constraints checks almost anywhere. For example, to guarantee that a particular type is checked against a particular concept, we could place constraints checks in a namespace scope (e.g., the global scope). For example:

Click here to view code image

static_assert(Ordered<std::string>,"std::string is not Ordered");     // will succeed
static_assert(Ordered<String<char>>,"String<char> is not Ordered");   // will fail
The first static_assert checks if the standard string is Ordered (it is, because it provides ==, !=, and <). The second checks if our String is Ordered (it is not, because I “forgot” to define <). Using such a global check will perform the constraints check independently of whether we actually use that particular specialization of a template in the program. Depending on our aims, that can be an advantage or a bother. Such a check forces type checking to be done at a specific point in the program; that is usually good for error isolation. Also, such checks can help unit testing. However, for programs using a number of libraries, explicit checks quickly become unmanageable.

Being Regular is an ideal for a type. We can copy objects of regular types, put them into vectors and arrays, compare them, etc. If a type is Ordered, we can also use its objects in sets, sort sequences of such objects, etc. So, we go back and improve our String to make it Ordered. In particular, we add < to provide a lexicographical ordering:

Click here to view code image

template<typename C>
bool operator<(const String<C>& s1, const String<C>& s2)
{
     static_asser t(Ordered<C>(),"String's character type not ordered");
     return std::lexicographical_compare(      // §32.6.5
                     s1.begin(), s1.end(),
                     s2.begin(), s2.end()
               );
}
24.4.1. Axioms
As in mathematics, an axiom is something we can’t prove. It is something we assume to be true. In the context of requirements for template arguments, we use “axiom” in that sense to refer to semantic properties. We use an axiom to state what a class or an algorithm assumes about its set of inputs. An axiom, however expressed, represents an algorithm’s or class’s expectations of (assumptions about) its arguments. We cannot in general test to see whether an axiom holds for values of a type (that is one reason we refer to them as axioms). Furthermore, an axiom is only required to hold for the values actually used by an algorithm. For example, an algorithm can carefully avoid dereferencing null pointers or copying a floating-point NaN. If so, it could have axioms that require pointers to be dereferenceable and floating-point values to be copyable. Alternatively, axioms can be written with the general assumption that singular values (e.g., NaN and nullptr) violate some precondition, so that they need not be considered.

C++ does not (currently) have any way of expressing axioms, but as for concepts, we can make our idea of an axiom a bit more concrete than a comment or some text in a design document.

Consider how we might express some of the key semantic requirements for a type to be regular:

Click here to view code image

template<typename T>
bool Copy_equality(T x)                       // semantics of copy construction
{
     return T{x}==x;      // a copy compares equal to what it is a copy of
}

template<typename T>
bool Copy_assign_equality(T x, T& y)         // semantics of assignment
{
     return (y=x, y==x);   // the result of an assignment compares equal to the source of the assignment
}
In other words, copy operations make copies.

Click here to view code image

template<typename T>
bool Move_effect(T x, T& y)                   // semantics of move y into x
{
     return (x==y ? (x==T{std::move(y)}) : true) && can_destroy(y);
}

template<typename T>
bool Move_assign_effect(T x, T& y, T& z)      // semantics of move assignment y into x
{
return (y==z ? (x=std::move(y), x==z) : true) && can_destroy(y);
}
In other words, a move operation yields a value that compares equal to whatever the source of the move operation compared equal to, and the source of the move can be destroyed.

These axioms are represented as executable code. We might use them for testing, but most importantly, we have to think harder to express them than we would have to simply write a comment. The resulting axioms are more precisely stated than would have been the case in “ordinary English.” Basically, we can express such pseudo axioms using first-order predicate logic.

24.4.2. Multi-argument Concepts
When looking at a single-argument concept and applying it to a type, it looks very much as if we are doing conventional type checking and that the concept is the type of a type. That’s part of the story, but only a part. Often, we find that relationships among argument types are essential for correct specification and use. Consider the standard-library find() algorithm:

Click here to view code image

template<typename Iter, typename Val>
Iter find(Iter b, Iter e, Val x);
The Iter template argument must be an input iterator, and we can (relatively) easily define a constraints-check template for that concept.

So far, so good, but find() depends critically on comparing x to elements of the sequence [b:e). We need to specify that comparison is required; that is, we need to state that Val and and the value type of the input iterator are equality comparable. That requires a two-argument version of Equality_comparable:

Click here to view code image

template<typename T, typename U>
constexpr bool Equality_comparable(T, U)
{

    return Common<T,U>()
         && Totally_ordered<T>()
         && Totally_ordered<U>()
         && Totally_ordered<Common_type<T,U>>()
         && Has_less<T,U>() && Boolean<Less_result<T,U>>()
         && Has_less<U,T>() && Boolean<Less_result<U,T>>()
         && Has_greater<T,U>() && Boolean<Greater_result<T,U>>()
         && Has_greater<U,T>() && Boolean<Greater_result<U,T>>()
         && Has_less_equal<T,U>() && Boolean<Less_equal_result<T,U>>()
         && Has_less_equal<U,T>() && Boolean<Less_equal_result<U,T>>()
         && Has_greater_equal<T,U>() && Boolean<Greater_equal_result<T,U>>()
         && Has_greater_equal<U,T>() && Boolean<Greater_equal_result<U,T>>();
};
This is rather verbose for a simple concept. However, I wanted to be explicit about all of the operators and about the symmetry of their use rather than burying the complexity in a generalization.

Given that, we can define find():

Click here to view code image

template<typename Iter, typename Val>
Iter find(Iter b, Iter e, Val x)
{
       static_assert(Input_iterator<Iter>(),"find() requires an input iterator");
       static_assert(Equality_comparable<Value_type<Iter>,Val>(),
                      "find()'s iterator and value arguments must match");

       while (b!=e) {
            if (*b==x) return b;
            ++b;
       }
       return b;
}
Multi-argument concepts are particularly common and useful when specifying generic algorithms. This is also the area where you find the greatest number of concepts and the greatest need to specify new concepts (as opposed to picking “standard ones” from a catalog of common concepts). The variations among well-defined types appear to be somewhat more limited than the variations among algorithms’ requirements on their arguments.

24.4.3. Value Concepts
Concepts can express arbitrary (syntactic) requirements on a set of template arguments. In particular, a template argument can be an integer value, so concepts can take integer arguments. For example, we can write a constraints check to test that a value template argument is small:

template<int N>
constexpr bool Small_size()
{
    return N<=8;
}
A more realistic example would be a concept for which the numeric argument was just one among others. For example:

Click here to view code image

constexpr int stack_limit = 2048;

template<typename T,int N>
constexpr bool Stackable()    // T is regular and N elements of T can fit on a small stack
{
    return Regular<T>() && sizeof(T)*N<=stack_limit;
}
This implements a notion of “small enough to be stack allocated.” It might be used like this:

Click here to view code image

template<typename T, int N>
struct Buffer {
      //...
};

template<typename T, int N>
void fct()
{
     static_assert(Stackable<T,N>(),"fct() buffer won't fit on stack");
     Buffer<T,N> buf;
      //...
}
Compared to the fundamental concepts for types, value concepts tend to be small and ad hoc.

24.4.4. Constraints Checks
The constraints checks used in this book can be found on the book’s support site. They are not part of a standard, and I hope that in the future they will be replaced by a proper language mechanism. However, they can be useful for thinking about template and type design and reflect the de facto concepts in the standard library. They should go in a separate namespace to avoid interfering with possible future language features and alternative implementations of the idea of concepts. I use namespace Estd, but that may be an alias (§14.4.2). Here are a few constraints checks that you might find useful:

• Input_iterator<X>: X is an iterator that we can use only once to traverse a sequence (forward using ++), reading each element once only.

• Output_iterator<X>: X is an iterator that we can use only once to traverse a sequence (forward using ++), writing each element once only.

• Forward_iterator<X>: X is an iterator that we can use to traverse a sequence (forward using ++). This is what a singly-linked list (e.g., forward_list) naturally supports.

• Bidirectional_iterator<X>: X is an iterator that we can move both forward (using ++) and backward (using ––). This is what a doubly-linked list (e.g., list) naturally supports.

• Random_access_iterator<X>: X is an iterator that we can use to traverse a sequence (forward and backward) and to randomly access elements using subscripting and positioning using += and –=. This is what an array naturally supports.

• Equality_comparable<X,Y>: An X can be compared with a Y using == and !=.

• Totally_ordered<X,Y>: X and Y are Equality_comparable and an X can be compared with a Y using <, <=, > and >=.

• Semiregular<X>: Xs can be copied, default constructed, allocated on the free store, and are free of minor annoying technical restrictions.

• Regular<X>: Xs are Semiregular and can be compared using equality. The standard-library containers require their elements to be regular.

• Ordered<X>: Xs are Regular and Totally_ordered. The standard-library associative containers require their elements to be ordered unless you explicitly provide a comparison operation.

• Assignable<X,Y>: A Y can be assigned to an X using =.

• Predicate<F,X>: An F can be called for an X yielding a bool.

• Streamable<X>: An X can be read and written using iostreams.

• Movable<X>: An X can be moved; that is, it has a move constructor and a move assignment. In addition, an X is addressable and destructible.

• Copyable<X>: An X is Movable and can also be copied.

• Convertible<X,Y>: An X can be implicitly converted to a Y.

• Common<X,Y>: An X and a Y can unambiguously be converted to a common type called Common_type<X,Y>. This is a formalization of the language rule for compatibility of operands to ?: (§11.1.3). For example, Common_type<Base*,Derived*> is Base* and Common_type<int,long> is long.

• Range<X>: An X that can be used by a range-for (§9.5.1), that is, X must provide members, x.begin() and x.end(), or nonmember equivalents, begin(x) and end(x), with the required semantics.

Obviously, these definitions are informal. In most cases, these concepts are based on standard-library type predicates (§35.4.1), and the ISO C++ standard provides formal definitions (e.g., §iso.17.6.3).

24.4.5. Template Definition Checking
A constraints-check template ensures that a type provides the properties required by the concept. If the implementation of a template in fact uses more properties than its concepts guarantee, we may get type errors. For example, the standard-library find() requires a pair of input iterators as arguments, but we might (incautiously) have defined it like this:

Click here to view code image

template<typename Iter, typename Val>
Iter find(Iter b, Iter e, Val x)
{
       static_assert(Input_iterator<Iter>(),"find(): Iter is not a Forward iterator");
       static_assert(Equality_comparable<Value_type<Iter>,Val>),
                      "find(): value type doesn't match iterator");

       while (b!=e) {
            if (*b==x) return b;
            b = b+1;              // note: not ++b
       }
              return b;
}
Now, b+1 is an error unless b is a random-access iterator (and not just a forward iterator as ensured by the constraints check). However, the constraints check does not help us detect that problem. For example:

Click here to view code image

void f(list<int>& lst, vector<string>& vs)
{
     auto p = find(lst.begin(),lst.end(),1209);         // error: list does not provide +
     auto q = find(vs.begin(),vs.end(),"Cambridge");    // OK: vector provides +
      //...
}
The call of find() for the list will fail (because + is not defined for the forward iterator provided by list) and the call for the vector will succeed (because b+1 is fine for vector<string>::iterator).

Constraints checks primarily provide a service to the user of a template: the actual template arguments are checked against the template’s requirements. On the other hand, constraints checks do not help a template writer who would like to be sure that the implementation doesn’t use any properties beyond those specified in the concepts. Ideally, the type system would ensure that, but that requires language features that are still in the future. So, how do we test the implementation of a parameterized class or a generic algorithm?

Concepts provide a strong guideline: the implementation should use no property of an argument that isn’t specified by the concepts, so we should test the implementation with arguments that provide the properties specified by the implementation’s concepts, and only those. Such a type is sometimes called an archetype.

So, for the find() example, we look at Forward_iterator and Equality_comparable or at the standard’s definition of the forward-iterator and equal-comparable concepts (§iso.17.6.3.1, §iso.24.2.5). Then, we decide that we need an Iterator type that provides at least:

• A default constructor

• A copy constructor and a copy assignment

• Operators == and !=

• A prefix operator ++

• A type Value_type<Iterator>

• A prefix operator *

• The ability to assign the result of * to a Value_type<Iterator>

• The ability to assign a Value_type<Iterator> to the result of *

This is slightly simplified from the standard-library forward iterator, but sufficient for find(). Constructing that list by looking at the concepts is easy.

Given this list, we need to find or define a type that provides only the desired features. For a forward iterator, as needed by find(), the standard-library forward_list fits the bill perfectly. This is because “forward iterator” was defined to express the idea of something that allows us to iterate through a singly-linked list. It is not uncommon that a popular type is an archetype for a popular concept. If we decide to use an existing type, we have to be careful, though, not to pick a type that is more flexible than required. For example, the typical mistake when testing algorithms, such as find(), is to use a vector. However, the very generality and flexibility that make vector so popular make it unusable as an archetype for many simple algorithms.

If we can’t find an existing type that fits our needs, we must define one ourselves. That is done by going through the list of requirements and defining suitable members:

Click here to view code image

template<typename Val>
struct Forward {         // for checking find()
     Forward();
     Forward(const Forward&);
     Forward operator=(const Forward&);
     bool operator==(const Forward&);
     bool operator!=(const Forward&);
     void operator++();
     Val& operator*();   // simplified: does not handle a proxy for Val
};

template<typename Val>
using Value_type<Forward<Val>> = Val;       // simplified; see §28.2.4

void f()
{
     Forward<int> p = find(Forward<int>{},Forward<int>{},7);
}
At this level of testing, we need not check that these operations actually implement the right semantics. We just check that the template implementation does not rely on properties that it should not.

Here, I have simplified the testing by not introducing an archetype for the Val argument. Instead, I simply used int. Testing nontrivial conversions between an archetype for Val and an archetype for Iter would be significantly more work and most likely not particularly useful.

Writing a test harness that checks the implementation of find() against std::forward_list or X is not trivial, but it is not among the most difficult tasks facing a designer of generic algorithms. Using a relatively small and well-specified set of concepts makes the task manageable. The tests can and should be completely compile-time.

Note that this simple specification and checking strategy leads to find() requiring its iterator argument to have a Value_type type function (§28.2). That allows pointers to be used as iterators. For many template parameters it is important that built-in types can be used as well as user-defined types (§1.2.2, §25.2.1).

24.5. Advice
[1] A template can pass argument types without loss of information; §24.1.

[2] Templates provide a general mechanism for compile-time programming; §24.1.

[3] Templates provide compile-time “duck typing”; §24.1.

[4] Design generic algorithms by “lifting” from concrete examples; §24.2.

[5] Generalize algorithms by specifying template argument requirements in terms of concepts; §24.3.

[6] Do not give unconventional meaning to conventional notation; §24.3.

[7] Use concepts as a design tool; §24.3.

[8] Aim for “plug compatibility” among algorithms and argument type by using common and regular template argument requirements; §24.3.

[9] Discover a concept by minimizing an algorithm’s requirements on its template arguments and then generalizing for wider use; §24.3.1.

[10] A concept is not just a description of the needs of a particular implementation of an algorithm; §24.3.1.

[11] If possible, choose a concept from a list of well-known concepts; §24.3.1, §24.4.4.

[12] The default concept for a template argument is Regular; §24.3.1.

[13] Not all template argument types are Regular; §24.3.1.

[14] A concept requires a semantic aspect; it is not primarily a syntactic notion; §24.3.1, §24.3.2, §24.4.1.

[15] Make concepts concrete in code; §24.4.

[16] Express concepts as compile-time predicates (constexpr functions) and test them using static_assert() or enable_if<>; §24.4.

[17] Use axioms as a design tool; §24.4.1.

[18] Use axioms as a guide for testing; §24.4.1.

[19] Some concepts involve two or more template arguments; §24.4.2.

[20] Concepts are not just types of types; §24.4.2.

[21] Concepts can involve numeric values; §24.4.3.

[22] Use concepts as a guide for testing template definitions; §24.4.5.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


24. Generic Programming
25. Specialization
26. Instantiation
47h 26m remaining
25. Specialization
It ain’t what you don’t know that gets you into trouble.

It’s what you know for sure that just ain’t so.

– Mark Twain

• Introduction

• Template Parameters and Arguments

Types as Arguments; Values as Arguments; Operations as Arguments; Templates as Arguments; Default Template Arguments

• Specialization

Interface Specialization; The Primary Template; Order of Specialization; Function Template Specialization

• Advice

25.1. Introduction
Over the last two decades, templates have developed from a relatively simple idea to the backbone of most advanced C++ programming. In particular, templates are key to techniques for

• improving type safety (e.g., by eliminating the use of casts; §12.5);

• raising the general level of abstraction of programs (e.g., by using standard containers and algorithms; §4.4, §4.5, §7.4.3, Chapter 31, Chapter 32); and

• providing more flexible, type-safe, and efficient parameterization of types and algorithms (§25.2.3).

These techniques all critically rely on the ability of template code to use template arguments without overhead and in a type-safe manner. Most techniques also rely on the type deduction mechanisms offered by templates (sometimes called compile-time polymorphism; §27.2). These techniques are the backbone of C++ use in performance-critical areas, such as high-performance numerical computing and embedded systems programming. For mature examples, see the standard library (Part IV).

This chapter and the following two present simple examples of the advanced and/or specialized language features supporting techniques aimed at uncompromised flexibility and performance. Many of these techniques are primarily developed for and used by library implementers. Like most programmers, I prefer to forget about the more advanced techniques most of the time. Where I can, I keep my code simple and rely on libraries so that I can benefit from the use of advanced features in the hands of experts in a given application domain.

Templates are introduced in §3.4. This chapter is part of a sequence presenting templates and their uses:

• Chapter 23 gives a more detailed introduction to templates.

• Chapter 24 discusses generic programming, the most common use of templates.

• Chapter 25 (this chapter) shows how to specialize a template with a set of arguments.

• Chapter 26 focuses on template implementation issues related to name binding.

• Chapter 27 discusses the relation between templates and class hierarchies.

• Chapter 28 focuses on templates as a language for generating classes and functions.

• Chapter 29 presents a larger example of template-based programming techniques.

25.2. Template Parameters and Arguments
A template can take parameters:

• Type parameters of “type type”

• Value parameters of built-in types such as ints (§25.2.2) and pointers to functions (§25.2.3)

• Template parameters of “type template” (§25.2.4)

Type parameters are by far the most common, but value parameters are essential for many important techniques (§25.2.2, §28.3).

A template can take a fixed number of parameters or a variable number. The discussion of variadic templates is postponed until §28.6.

Note that it is common to use short names with initial uppercase letters as names of template type arguments, for example, T, C, Cont, and Ptr. This is acceptable because such names tend to be conventional and restricted to a relatively small scope (§6.3.3). However, when using ALL_CAPS, there is always a chance of clashing with macros (§12.6), so don’t use names that are long enough to clash with likely macro names.

25.2.1. Types as Arguments
A template argument is defined to be a type parameter by prefixing it with typename or class. The result of using either is completely equivalent. Every type (built-in or user-defined) is syntactically acceptable to a template declared to take a type parameter. For example:

Click here to view code image

template<typename T>
void f(T);

template<typename T>
class X {
      //...
};
f(1);                      // T deduced to be int
f<double>(1);              // T is double
f<complex<double>>(1);     // T is complex<double>

X<double> x1;              // T is double
X<complex<double>> x2;     // T is complex<double>
A type argument is unconstrained; that is, there is nothing in the interface of a class that constrains it to be a certain kind of type or part of a class hierarchy. The validity of an argument type depends exclusively on its use in the templates, providing a form of duck typing (§24.1). You can implement general constraints as concepts (§24.3).

User-defined and built-in types are handled equivalently when used as template arguments. This is essential for allowing us to define templates that work identically for user-defined and builtin types. For example:

Click here to view code image

vector<double> x1;              // vector of doubles
vector<complex<double>> x2;     // vector of complex<double>
In particular, there is no space or time overhead implied by using either compared to the other:

• Values of built-in types are not “boxed” into special container objects.

• Values of all types are retrieved directly from a vector without use of potentially expensive (e.g., virtual) “get() functions.”

• Values of user-defined types are not implicitly accessed through references.

To be used as a template argument, a type must be in scope and accessible. For example:

Click here to view code image

class X {
     class M { /* ... */ };
      //...
     void mf();
};

void f()
{
     struct S { /* ... */ };
     vector<S> vs;            // OK
     vector<X::M> vm;         // error: X::M is private
      //...
}

void X::mf()
{
     vector<S> vs;      // error: no S in scope
     vector<M> vm;      // OK
      //...
}
25.2.2. Values as Arguments
A template parameter that is not a type or a template is called a value parameter and an argument passed to it a value argument. For example, integer arguments come in handy for supplying sizes and limits:

Click here to view code image

template<typename T, int max>
class Buffer {
     T v[max];
public:
     Buffer() { }
      //...
};

Buffer<char,128> cbuf;
Buffer<int,5000> ibuf;
Buffer<Record,8> rbuf;
Simple and constrained containers such as Buffer can be important where run-time efficiency and compactness are paramount. They avoid the use of free store implied by the use of a more general string or vector while not suffering from the implicit conversions to a pointer like a built-in array (§7.4). The standard-library array (§34.2.1) implements this idea.

An argument for a template value parameter can be (§iso.14.3.2):

• An integral constant expression (§10.4)

• A pointer or a reference to an object or a function with external linkage (§15.2)

• A nonoverloaded pointer to member (§20.6)

• A null pointer (§7.2.2)

A pointer used as a template argument must be of the form &of, where of is the name of an object or a function, or of the form f, where f is the name of a function. A pointer to member must be of the form &X::of, where of is the name of a member. In particular, a string literal is not acceptable as a template argument:

Click here to view code image

template<typename T, char* label>
class X {
      //...
};

X<int,"BMW323Ci"> x1;      // error: string literal as template argument
char lx2[] = "BMW323Ci";
X<int,lx2> x2;             // OK: lx2 has external linkage
This restriction, like the one against floating-point template value arguments, exists to simplify implementation of separately compiled translation units. It is best to think of template value arguments as a mechanism for passing integers and pointers to functions. Resist the temptation to try something more clever. Unfortunately (for no fundamental reason), literal types (§10.4.3) cannot be used as template value parameters. The value template arguments are the mechanism for some more advanced compile-time computation techniques (Chapter 28).

An integer template argument must be a constant. For example:

Click here to view code image

constexpr int max = 200;

void f(int i)
{
     Buffer<int,i> bx;       // error: constant expression expected
     Buffer<int,max> bm;     // OK: constant expression
      //...
}
Conversely, a value template parameter is a constant within the template so that an attempt to change the value of a parameter is an error. For example:

Click here to view code image

template<typename T, int max>
class Buffer {
     T v[max];
public:
     Buffer(int i) { max = i; }   // error: attempt to assign to template value argument
      //...
};
A type template parameter can be used as a type later in a template parameter list. For example:

Click here to view code image

template<typename T, T default_value>
class Vec {
      //...
};

Vec<int,42> c1;
Vec<int*,nullptr> c2;
This becomes particularly useful when combined with a default template argument (§25.2.5); for example:

Click here to view code image

template<typename T, T default_value = T{}>
class Vec {
      //...
};

Vec<int,42> c1;
Vec<int> c11;                // default_value is int{}, that is, 0
Vec<int*,&foo> c2;          // for some global variable "foo"
Vec<int*> c22;             // default_value is string{}; that is, ""
25.2.3. Operations as Arguments
Consider a slightly simplified version of the standard-library map (§31.4.3):

template<typename Key, typename V>
class map {
      //...
};
How do we supply comparison criteria for Keys?

• We can’t hardwire a comparison criterion into the container because the container can’t (in general) impose its needs on the element types. For example, by default, the map uses < for comparison, but not all Keys have a < that we would want to use.

• We can’t hardwire an ordering criterion into the Key type because (in general) there are many different ways of ordering elements based on a key. For example, one of the most common Key types is string and strings can be ordered based on a variety of criteria (e.g., case sensitive and case insensitive).

Consequently, a sorting criterion is not built into the container type or into the element type. In principle, the notion of sorting criteria for a map could be represented as:

[1] A template value argument (e.g., a pointer to a comparison function)

[2] A template type argument to the map template determining the type of a comparison object

At first glance, the first solution (pass a comparison object of a specific type) seems simpler. For example:

Click here to view code image

template<typename Key, typename V, bool(*cmp)(const Key&, const Key&)>
class map {
public:
     map();
      //...
};
This map requires a user to supply the comparison as a function:

Click here to view code image

bool insensitive(const string& x, const string& y)
{
      // compare case insensitive (e.g., "hello" equals "HellO")
}

map<string,int,insensitive> m;          // compare using insensitive()
However, this is not very flexible. In particular, the designer of map will have to decide whether to compare the (unknown) Key type using a pointer to function or a function object of some specific type. Also, because the argument types of the comparison operator must depend on the Key type, it can be hard to provide a default comparison criterion.

Consequently, the second alternative (pass the type of the comparison as a template type parameter) is the more common and the one used in the standard library. For example:

Click here to view code image

template<typename Key, typename V, typename Compare = std::less<Key>>
class map {
public:
     map() { /* ... */ }                      // use the default comparison
     map(Compare c) :cmp{c} { /* ... */ }     // override the default
      //...
     Compare cmp {};                          // default comparison
};
The most common case, comparing using less-than, is the default. If we want a different comparison criterion, we can supply it as a function object (§3.4.3):

Click here to view code image

map<string,int> m1;                               // use the default comparison (less<string>)

map<string,int,std::greater<string>> m2;          // compare using greater<string>()
Function objects can carry state. For example:

Click here to view code image

Complex_compare f3 {"French",3};                  // make a comparison object (§25.2.5)
map<string,int,Complex_compare> m3 {f3};          // compare using f3()
We can also use pointers to functions, including lambdas that can convert to a pointer to function (§11.4.5). For example:

Click here to view code image

using Cmp = bool(*)(const string&,const string&);
map<string,int,Cmp> m4 {insensitive};             // compare using a pointer to function

map<string,int,Cmp> m5 {[](const string& a, const string& b) { return a>b; }};   // compare using a lambda
Passing the comparison operations as a function object has significant benefits compared to passing pointers to functions:

• A simple class member function defined in-class is trivial to inline, whereas inlining a call through a pointer to function requires exceptional attention from a compiler.

• A function object with no data members can be passed with no run-time cost.

• Several operations can be passed as a single object with no additional run-time cost.

The comparison criterion for a map is just an example. However, the technique used to pass it is general and very widely used to parameterize classes and functions with “policies.” Examples include actions for algorithms (§4.5.4, §32.4), allocators for containers (§31.4, §34.4), and deleters for unique_ptr (§34.3.1). We have the same design alternatives when we need to specify arguments for a function template, such as sort(), and the standard library chooses alternative [2] for those cases also (e.g., see §32.4).

If we had only one use of a comparison criterion in our program, it might make sense to use a lambda to express the function object version a bit more tersely:

map<string, int, [](const string& x, const string& y) const { return x<y; }> c3;       // error
Unfortunately, that doesn’t work because there is no conversion of a lambda to a function object type. We could name the lambda and then use that name:

Click here to view code image

auto cmp = [](const string& x, const string& y) const { return x<y; }
map<string,int,decltype(cmp)> c4 {cmp};
I find naming operations useful from a design and maintenance point of view. Also, anything named and declared nonlocally might find other uses.

25.2.4. Templates as Arguments
Sometimes it is useful to pass templates – rather than classes or values – as template arguments. For example:

Click here to view code image

template<typename T, template<typename> class C>
class Xrefd {
     C<T> mems;
     C<T*> refs;
      //...
};

template<typename T>
     using My_vec = vector<T>;        // use default allocator

Xrefd<Entry,My_vec> x1;     // store cross references for Entrys in a vector

template<typename T>
class My_container {
      //...
};

Xrefd<Record,My_container> x2;  // store cross references for Records in a My_container
To declare a template as a template parameter, we must specify its required arguments. For example, we specify that Xrefd’s template parameter C is a template class that takes a single type argument. If we didn’t, we wouldn’t be able to use specializations of C. The point of using a template as a template parameter is usually that we want to instantiate it with a variety of argument types (such as T and T* in the previous example). That is, we want to express the member declarations of a template in terms of another template, but we want that other template to be a parameter so that it can be specified by users.

Only class templates can be template arguments.

The common case in which a template needs only a container or two is often better handled by passing the container types (§31.5.1). For example:

Click here to view code image

template<typename C, typename C2>
class Xrefd2 {
     C mems;
     C2 refs;
      //...
};

Xrefd2<vector<Entry>,set<Entry*>> x;
Here, the value types of C and C2 can be obtained by a simple type function (§28.2) for obtaining the type of elements of a container, for example, Value_type<C>. This is the technique used for the standard-library container adaptors, such as queue (§31.5.2).

25.2.5. Default Template Arguments
Explicitly specifying the comparison criterion for each use of map is tedious – especially as less<Key> is typically the best choice. We can specify less<Key> to be the default type for the Compare template argument, so that only uncommon comparison criteria have to be explicitly specified:

Click here to view code image

template<typename Key, typename V, typename Compare = std::less<Key>>
class map {
public:
     explicit map(const Compare& comp ={});
      //...
};

map<string,int> m1;                // will use less<string> for comparisons
map<string,int,less<string>> m2;   // same type as m1

struct No_case {
      // define operator()() to do case-insensitive string comparison
};

map<string,int,No_case> m3;        // m3 is of a different type from m1 and m2
Note how the default map constructor creates a default comparison object, Compare{}. That’s the common case. If we want a more elaborate construction, we must do so explicitly. For example:

map<string,int,Complex_compare> m {Complex_compare{"French",3}};
The semantic checking of a default argument for a template parameter is done only if that default argument is actually used. In particular, as long as we refrain from using the default template argument less<Key>, we can compare() values of a type X for which less<X> wouldn’t compile. This point is crucial in the design of the standard containers (e.g., std::map), which rely on a template argument to specify default values (§31.4).

Just as for default function arguments (§12.2.5), the default template arguments can be specified and supplied for trailing arguments only:

Click here to view code image

void f1(int x = 0, int y);        // error: default argument not trailing
void f2(int x = 0, int y = 1);    // OK

f2(,2);     // syntax error
f2(2);      // call f2(2,1);

template<typename T1 = int, typename T2>
class X1 {         // error: default argument not trailing
      //...
};

template<typename T1 = int, typename T2 = double>
class X2 {     // OK
      //...
};

X2<,float> v1;  // syntax error
X2<float> v2;   // v2 is an X2<float,double>
Not allowing an “empty” argument to mean “use the default” was a deliberate tradeoff between flexibility and the opportunity for obscure errors.

The technique of supplying a policy through a template argument and then defaulting that argument to supply the most common policy is almost universal in the standard library (e.g., §32.4). Curiously enough, it is not used for basic_string (§23.2, Chapter 36) comparisons. Instead, the standard-library string relies on char_traits (§36.2.2). Similarly, the standard algorithms rely on iterator_traits (§33.1.3) and the standard-library containers rely on allocators (§34.4). The use of traits is presented in §28.2.4.

25.2.5.1. Default Function Template Arguments
Naturally, default template arguments can also be useful for function templates. For example:

Click here to view code image

template<typename Target =string, typename Source =string>
Target to(Source arg)        // convert Source to Target
{
  stringstream interpreter;
  Target result;

  if (!(interpreter << arg)                 // write arg into stream
      || !(interpreter >> result)           // read result from stream
      || !(interpreter >> std::ws).eof())   // stuff left in stream?
      throw runtime_error{"to<>() failed"};

  return result;
}
A function template argument needs to be explicitly mentioned only if it cannot be deduced or if there is no default, so we can write:

Click here to view code image

auto x1 = to<string,double>(1.2);   // very explicit (and verbose)
auto x2 = to<string>(1.2);          // Source is deduced to double
auto x3 = to<>(1.2);                // Target is defaulted to string; Source is deduced to double
auto x4 = to(1.2);                  // the <> is redundant
If all function template arguments are defaulted, the <> can be left out (exactly as in function template specializations; §25.3.4.1).

This implementation of to() is a bit heavyweight for combinations of simple types, such as to<double>(int), but improved implementations can be supplied as specializations (§25.3). Note that to<char>(int) will not work because char and int do not share a string representation. For conversion among scalar numeric types, I tend to prefer narrow_cast<>() (§11.5).

25.3. Specialization
By default, a template gives a single definition to be used for every template argument (or combination of template arguments) that a user can think of. This doesn’t always make sense for someone writing a template. I might want to say, “If the template argument is a pointer, use this implementation; if it is not, use that implementation,” or “Give an error unless the template argument is a pointer derived from class My_base.” Many such design concerns can be addressed by providing alternative definitions of the template and having the compiler choose between them based on the template arguments provided where they are used. Such alternative definitions of a template are called user-defined specializations, or simply user specializations. Consider likely uses of a Vector:

Click here to view code image

template<typename T>
class Vector {  // general vector type
     T* v;
     int sz;
public:
     Vector();
     explicit Vector(int);

     T& elem(int i) { return v[i]; }
     T& operator[](int i);

     void swap(Vector&);
      //...
};

Vector<int> vi;
Vector<Shape*> vps;
Vector<string> vs;
Vector<char*> vpc;
Vector<Node*> vpn;
In such code, most Vectors will be Vectors of some pointer type. There are several reasons for this, but the primary reason is that to preserve run-time polymorphic behavior, we must use pointers (§3.2.2, §20.3.2). That is, anyone who practices object-oriented programming and uses type-safe containers (such as the standard-library containers) will end up with a lot of containers of pointers.

The default behavior of most C++ implementations is to replicate the code for template functions. This is usually good for run-time performance, but unless care is taken, it leads to code bloat in critical cases such as the Vector example.

Fortunately, there is an obvious solution. Containers of pointers can share a single implementation. This can be expressed through specialization. First, we define a version (a specialization) of Vector for pointers to void:

Click here to view code image

template<>
class Vector<void*>{        // complete specialization
     void** p;
      //...
     void*& operator[](int i);
};
This specialization can then be used as the common implementation for all Vectors of pointers. Another use would be to implement unique_ptr<T> based on a single shared implementation class storing a void*.

The template<> prefix says that this is a specialization that can be specified without a template parameter. The template arguments for which the specialization is to be used are specified in <> brackets after the name. That is, the <void*> says that this definition is to be used as the implementation of every Vector for which T is void*.

The Vector<void*> is a complete specialization. That is, there is no template parameter to specify or deduce when we use the specialization; Vector<void*> is used for Vectors declared like this:

Vector<void*> vpv;
To define a specialization that is used for every Vector of pointers and only for Vectors of pointers, we can write:

Click here to view code image

template<typename T>
class Vector<T*> : private Vector<void*> {   // partial specialization
public:
     using Base = Vector<void*>;

     Vector() {}
     explicit Vector(int i) : Base(i) {}

     T*& elem(int i) { return reinterpret_cast<T*&>(Base::elem(i)); }
     T*& operator[](int i) { return reinterpret_cast<T*&>(Base::operator[](i)); }

      //...
};
The specialization pattern <T*> after the name says that this specialization is to be used for every pointer type; that is, this definition is to be used for every Vector with a template argument that can be expressed as T*. For example:

Click here to view code image

Vector<Shape*> vps;    //<T*> is <Shape*> so T is Shape
Vector<int**> vppi;    //<T*> is <int**> so T is int*
A specialization with a pattern containing a template parameter is called a partial specialization in contrast to complete specializations (as in the definition of vector<void*>), where “the pattern” is simply a specific type.

Note that when a partial specialization is used, a template parameter is deduced from the specialization pattern; the template parameter is not simply the actual template argument. In particular, for Vector<Shape*>, T is Shape and not Shape*.

Given this partial specialization of Vector, we have a shared implementation for all Vectors of pointers. The Vector<T*> class is simply an interface to Vector<void*> implemented exclusively through derivation and inline expansion.

It is important that this refinement of the implementation of Vector be achieved without affecting the interface presented to users. Specialization is a way of specifying alternative implementations for different uses of a common interface. Naturally, we could have given the general Vector and the Vector of pointers different names. However, when I tried that, many people who should have known better forgot to use the pointer classes and found their code much larger than expected. In this case, it is much better to hide the crucial implementation details behind a common interface.

This technique proved successful in curbing code bloat in real use. People who do not use a technique like this (in C++ or in other languages with similar facilities for type parameterization) have found that replicated code can cost megabytes of code space even in moderately sized programs. By eliminating the time needed to compile those additional versions of the Vector operations, this technique can also cut compile and link times dramatically. Using a single specialization to implement all lists of pointers is an example of the general technique of minimizing code bloat by maximizing the amount of shared code.

Some compilers are getting smart enough to perform this particular optimization without help from the programmer, but the technique is generally applicable and useful.

Variants of the technique of using a single run-time representation for values of a number of types and relying on the (static) type system to ensure that they are used only according to their declared type has been called type erasure. In the context of C++, it was first documented in the original template paper [Stroustrup,1988].

25.3.1. Interface Specialization
Sometimes, a specialization is not an algorithmic optimization, but a modification of an interface (or even a representation). For example, the standard library complex uses specializations to adjust the set of constructors and the argument types for important operations for important specializations (such as complex<float> and complex<double>). The general (primary) template (§25.3.1.1) looks like this:

Click here to view code image

template<typename T>
class complex {
public:
     complex(const T& re = T{}, const T& im = T{});
     complex(const complex&);                  // copy constructor
     template<typename X>
          complex(const complex<X>&);          // conversion from complex<X> to complex<T>

     complex& operator=(const complex&);
     complex<T>& operator=(const T&);
     complex<T>& operator+=(const T&);
      //...
     template<typename X>
          complex<T>& operator=(const complex<X>&);
     template<typename X>
          complex<T>& operator+=(const complex<X>&);
      //...
};
Note that the scalar assignment operators take reference arguments. That’s not efficient for floats, so complex<float> passes those by value:

Click here to view code image

template<>
class complex<float> {
public:
      //...
     complex<float>& operator= (float);
     complex<float>& operator+=(float);
      //...
     complex<float>& operator=(const complex<float>&);
      //...
};
For complex<double>, that same optimization applies. In addition, conversions from complex<float> and complex<long double> are provided (as described in §23.4.6):

Click here to view code image

template<>
class complex<double> {
public:
     constexpr complex(double re = 0.0, double im = 0.0);
     constexpr complex(const complex<float>&);
     explicit constexpr complex(const complex<long double>&);
      //...
};
Note that these specialized constructors are constexpr, making complex<double> a literal type. We could not do that for the general complex<T>. Also, this definition takes advantage of the knowledge that conversion from complex<float> to complex<double> is safe (it never narrows), so that we can have an implicit constructor from complex<float>. However, the constructor from complex<long double> is explicit to make narrowing less likely.

25.3.1.1. Implementation Specialization
Specialization can be used to provide alternative implementations of a class template for a specific set of template parameters. In that case, a specialization can even provide a representation that differs from that of the general template. For example:

Click here to view code image

template<typename T, int N>
class Matrix;      // N-dimensional Matrix of Ts

template<typename T>
class Matrix<T,0> {     // specialization for N==0
     T val;
      //...
};

template<typename T>
class Matrix<T,1> {     // specialization for N=1
     T* elem;
     int sz;    // number of elements
     // ...
};

template<typename T>
class Matrix<T,2> {     // specialization for N=2
     T* elem;
     int dim1;  // number of rows
     int dim2;  // number of columns
      //...
};
25.3.2. The Primary Template
When we have both a general definition of a template and specializations defining implementations for specific sets of template arguments, we refer to the most general template as the primary template. The primary template defines the interface for all specializations (§iso.14.5.5). That is, the primary template is the one used to determine if a use is valid and takes part in overload resolution. Only after a primary template has been chosen are specializations considered.

The primary template must be declared before any specialization. For example:

Click here to view code image

template<typename T>
class List<T*> {
      //...
};

template<typename T>
class List {          // error: primary template after specialization
      //...
};
The critical information supplied by the primary template is the set of template parameters that the user must supply to use it or any of its specializations. If we have defined a constraints check for a template (§24.4), the primary template is where it belongs because concepts are something a user cares about and must understand to use the template. For example:

Click here to view code image

template<typename T>
class List {
     static_assert(Regular<T>(),"List<T>: T must be Regular");
      //...
};
For technical reasons (because the language doesn’t recognize constraints checks for what they are), a constraints check needs to be replicated in every specialization.

A declaration of the primary template is sufficient to allow the definition of a specialization:

Click here to view code image

template<typename T>
class List;           // not a definition

template<typename T>
class List<T*>{
      //...
};
If used, the primary template must be defined somewhere (§23.7). If the primary template is never instantiated, it need not be defined. This can be used to define a template for which only a fixed set of alternative arguments are accepted. If a user specializes a template, that specialization must be in scope for every use of the template with the type for which it was specialized. For example:

Click here to view code image

template<typename T>
class List {
      //...
};

List<int*> li;

template<typename T>
class List<T*>{       // error: specialization used before defined
      //...
};
Here, List was specialized for int* after List<int*> had been used.

It is essential that every use of a template for a given set of template arguments be implemented by the same specialization. If not, the type system is broken, so that identical uses of a template in different places may yield different results and objects created in different parts of a program may not be compatible. Clearly that would be disastrous, so a programmer must take care that explicit specialization is consistent throughout a program. In principle, implementations are capable of detecting inconsistent specialization, but the standard does not require them to and some don’t.

All specializations of a template must be declared in the same namespace as the primary template. If used, a specialization that is explicitly declared (as opposed to generated from a more general template) must also be explicitly defined somewhere (§23.7). In other words, explicitly specializing a template implies that no (other) definition is generated for that specialization.

25.3.3. Order of Specialization
One specialization is more specialized than another if every argument list that matches its specialization pattern also matches the other, but not vice versa. For example:

Click here to view code image

template<typename T>
     class Vector;            // general; the primary template
template<typename T>
     class Vector<T*>;        // specialized for any pointer
template<>
     class Vector<void*>;     // specialized for void*
Every type can be used as a template argument for the most general Vector, but only pointers can be used for Vector<T*> and only void*s can be used for Vector<void*>.

The most specialized version will be preferred over the others in declarations of objects, pointers, etc. (§25.3).

A specialization pattern can be specified in terms of types composed using the constructs allowed for template parameter deduction (§23.5.2).

25.3.4. Function Template Specialization
Specialization is also useful for template functions (§25.2.5.1). However, we can overload functions, so we see less specialization. Furthermore, C++ supports only complete specialization for functions (§iso.14.7), so we use overloading where we might have tried partial specialization.

25.3.4.1. Specialization and Overloading
Consider the Shell sort from §12.5 and §23.5. Those versions compare elements using < and swap elements using detailed code. A better definition would be:

Click here to view code image

template<typename T>
bool less(T a, T b)
{
     return a<b;
}

template<typename T>
void sort(Vector<T>& v)
{
     const size_t n = v.size();

     for (int gap=n/2; 0<gap; gap/=2)
           for (int i=gap; i!=n; ++i)
                 for (int j=i–gap; 0<=j; j–=gap)
                       if (less(v[j+gap],v[j]))
                             swap(v[j],v[j+gap]);
}
This does not improve the algorithm itself, but it allows improvements to its implementation. We now have less and swap as named entities for which we can provide improved versions. Such names are often referred to as customization points.

As written, sort() will not sort a Vector<char* > correctly because < will compare the two char*s. That is, it will compare the addresses of the first char in each string. Instead, we would like it to compare the characters pointed to. A simple specialization of less() for const char* will take care of that:

Click here to view code image

template<>
bool less<const char*>(const char* a, const char* b)
{
     return strcmp(a,b)<0;
}
As for classes (§25.3), the template<> prefix says that this is a specialization that can be specified without a template parameter. The <const char*> after the template function name means that this specialization is to be used in cases where the template argument is const char*. Because the template argument can be deduced from the function argument list, we need not specify it explicitly. So, we can simplify the definition of the specialization:

Click here to view code image

template<>
bool less<>(const char* a, const char* b)
{
     return strcmp(a,b)<0;
}
Given the template<> prefix, the second empty <> is redundant, so we would typically simply write:

Click here to view code image

template<>
bool less(const char* a, const char* b)
{
     return strcmp(a,b)<0;
}
I prefer this shorter form of declaration. We can go further still. With this last version the distinction between specialization and overloading has become razor thin and largely irrelevant, so we can simply write:

Click here to view code image

bool less(const char* a, const char* b)
{
     return strcmp(a,b)<0;
}
Now that we have “specialized” less() to a version that is semantically correct, we can consider what we might do for swap(). The standard-library swap() is correct for our use and has already been optimized for every type that has efficient move operations. Therefore, when we used swap() instead of the three potentially expensive copy operations, we improved performance for a large number of argument types.

Specialization comes in handy when an irregularity of an argument type causes the general algorithm to give an undesired result (such as less() for C-style strings). These “irregular types” are often the built-in pointer and array types.

25.3.4.2. Specialization That Is Not Overloading
How does a specialization differ from overloading? From a technical point of view, they differ because individual functions take part in overloading whereas only the primary template takes part in specialization (§25.3.1.1). However, I can’t think of an example where that makes a practical difference.

There are a few uses of function specializations. For example, we can select among functions taking no arguments:

Click here to view code image

template<typename T> T max_value();    // no definition

template<> constexpr int max_value<int>() { return INT_MAX; }
template<> constexpr char max_value<char>() { return CHAR_MAX; }
 // ...

template<typename Iter>
Iter my_algo(Iter p)
{
      auto x = max_value<Value_type<Iter>>();    // works for types with specialized max_value()
       //...
}
I used the type function Value_type<> to get the type of the object pointed to by an Iter (§24.4.2).

To get a roughly equivalent effect with overloading, we would have to pass a dummy (unused) argument. For example:

Click here to view code image

int max2(int) { return INT_MAX; }
char max2(char) { return CHAR_MAX; }

template<typename Iter>
Iter my_algo2(Iter p)
{
      auto x = max2(Value_type<Iter>{});      // works for the types for which we overload max2()
       //...
}
25.4. Advice
[1] Use templates to improve type safety; §25.1.

[2] Use templates to raise the level of abstraction of code; §25.1.

[3] Use templates to provide flexible and efficient parameterization of types and algorithms; §25.1.

[4] Remember that value template arguments must be compile-time constants; §25.2.2.

[5] Use function objects as type arguments to parameterize types and algorithms with “policies”; §25.2.3.

[6] Use default template arguments to provide simple notation for simple uses; §25.2.5.

[7] Specialize templates for irregular types (such as arrays); §25.3.

[8] Specialize templates to optimize for important cases; §25.3.

[9] Define the primary template before any specialization; §25.3.1.1.

[10] A specialization must be in scope for every use; §25.3.1.1.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


25. Specialization
26. Instantiation
27. Templates and Hierarchies
47h 26m remaining
26. Instantiation
For every complex problem, there is an answer that is clear, simple, and wrong.

– H. L. Mencken

• Introduction

• Template Instantiation

When Is Instantiation Needed?; Manual Control of Instantiation

• Name Binding

Dependent Names; Point-of-Definition Binding; Point-of-Instantiation Binding; Multiple Instantiation Points; Templates and Namespaces; Overaggressive ADL; Names from Base Classes

• Advice

26.1. Introduction
One of the great strengths of templates is that they are an extremely flexible mechanism for composition of code. To produce impressive code quality, a compiler combines code (information) from

• the template definition and its lexical environment,

• the template arguments and their lexical environment, and

• the environment of the template’s use.

The key to the resulting performance is that the compiler is able to look at code from those contexts simultaneously and weave it together in ways that use all information available. The problem with this is that code in a template definition isn’t as localized as we would prefer (all other things being equal). Sometimes, we can get confused about what a name used in a template definition refers to:

• Is it a local name?

• Is it a name associated with a template argument?

• Is it a name from a base class in a hierarchy?

• Is it a name from a named namespace?

• Is it a global name?

This chapter discusses such questions related to name binding and considers their implications for programming styles.

• Templates were introduced in §3.4.1 and §3.4.2.

• Chapter 23 gives a detailed introduction to templates and the use of template arguments.

• Chapter 24 introduces generic programming and the key notion of concepts.

• Chapter 25 presents details of class templates and function templates and introduces the notion of specialization.

• Chapter 27 discusses the relationship between templates and class hierarchies (supporting generic and object-oriented programming).

• Chapter 28 focuses on templates as a language for generating classes and functions.

• Chapter 29 presents a larger example of how the language facilities and programming techniques can be used in combination.

26.2. Template Instantiation
Given a template definition and a use of that template, it is the implementation’s job to generate correct code. From a class template and a set of template arguments, the compiler needs to generate the definition of a class and the definitions of those of its member functions that were used in the program (and only those; §26.2.1). From a template function and a set of template arguments, a function needs to be generated. This process is commonly called template instantiation.

The generated classes and functions are called specializations. When we need to distinguish between generated specializations and specializations explicitly written by the programmer (§25.3), we refer to generated specializations and explicit specializations, respectively. An explicit specialization is often referred to as a user-defined specialization, or simply a user specialization.

To use templates in nontrivial programs, a programmer must understand the basics of how names used in a template definition are bound to declarations and how source code can be organized (§23.7).

By default, the compiler generates classes and functions from the templates used in accordance with the name-binding rules (§26.3). That is, a programmer need not state explicitly which versions of which templates must be generated. This is important because it is not easy for a programmer to know exactly which versions of a template are needed. Often, templates that the programmer hasn’t even heard of are used in the implementation of libraries, and sometimes templates that the programmer does know of are used with unknown template argument types. For example, the standard-library map (§4.4.3, §31.4.3) is implemented in terms of a red-black tree template with data types and operations unknown to all but the most curious user. In general, the set of generated functions needed can be known only by recursive examination of the templates used in application code libraries. Computers are better suited than humans for doing such analysis.

On the other hand, it is sometimes important for a programmer to be able to state specifically where code should be generated from a template (§26.2.2). By doing so, the programmer gains detailed control over the context of the instantiation.

26.2.1. When Is Instantiation Needed?
It is necessary to generate a specialization of a class template only if the class’s definition is needed (§iso.14.7.1). In particular, to declare a pointer to some class, the actual definition of a class is not needed. For example:

Click here to view code image

class X;
X* p;     // OK: no definition of X needed
X a;      // error: definition of X needed
When defining template classes, this distinction can be crucial. A template class is not instantiated unless its definition is actually needed. For example:

Click here to view code image

template<typename T>
class Link {
     Link* suc;    // OK: no definition of Link needed (yet)
      //...
};

Link<int>* pl;     // no instantiation of Link<int> needed (yet)

Link<int> lnk;     // now we need to instantiate Link<int>
A place where a template is used defines a point of instantiation (§26.3.3).

An implementation instantiates a template function only if that function has been used. By “used” we mean “called or had its address taken.” In particular, instantiation of a class template does not imply the instantiation of all of its member functions. This allows the programmer an important degree of flexibility when defining a template class. Consider:

Click here to view code image

template<typename T>
class List {
      //...
     void sort();
};

class Glob {
      //... no comparison operators ...
};

void f(List<Glob>& lb, List<string>& ls)
{
     ls.sort();
      //... use operations on lb, but not lb.sort() ...
}
Here, List<string>::sort() is instantiated, but List<Glob>::sort() isn’t. This both reduces the amount of code generated and saves us from having to redesign the program. Had List<Glob>::sort() been generated, we would have had to either add the operations needed by List::sort() to Glob, redefine sort() so that it wasn’t a member of List (the better design anyway), or use some other container for Globs.

26.2.2. Manual Control of Instantiation
The language does not require any explicit user action to achieve template instantiation. However, it does provide two mechanisms to help the user take control when needed. The need sometimes arises from a wish to

• optimize the compile-and-link process by eliminating redundant replicated instantiations, or

• know exactly which point of instantiation is used to eliminate surprises from complicated name-binding contexts.

An explicit instantiation request (often simply called an explicit instantiation) is a declaration of a specialization prefixed by the keyword template (not followed by <):

Click here to view code image

template class vector<int>;                    // class
template int& vector<int>::operator[](int);    // member function
template int convert<int,double>(double);      // nonmember function
A template declaration starts with template<, whereas plain template starts an instantiation request. Note that template prefixes a complete declaration; just stating a name is not sufficient:

Click here to view code image

template vector<int>::operator[];   // syntax error
template convert<int,double>;       // syntax error
As in template function calls, the template arguments that can be deduced from the function arguments can be omitted (§23.5.1). For example:

Click here to view code image

template int convert<int,double>(double);    // OK (redundant)
template int convert<int>(double);           // OK
When a class template is explicitly instantiated, every member function is also instantiated.

The link-time and recompilation efficiency impact of instantiation requests can be significant. I have seen examples in which bundling most template instantiations into a single compilation unit cut the compile time from a number of hours to the equivalent number of minutes.

It is an error to have two definitions for the same specialization. It does not matter if such multiple specializations are user-defined (§25.3), implicitly generated (§23.2.2), or explicitly requested. However, a compiler is not required to diagnose multiple instantiations in separate compilation units. This allows a smart implementation to ignore redundant instantiations and thereby avoid problems related to composition of programs from libraries using explicit instantiation. However, implementations are not required to be smart. Users of “less smart” implementations must avoid multiple instantiations. The worst that will happen if they don’t is that their program won’t link; there will be no silent changes of meaning.

To complement explicit instantiation requests, the language provides explicit requests not to instantiate (usually called extern templates). The obvious use is to have one explicit instantiation for a specialization and use extern templates for its use in other translation units. This mirrors the classical use of one definition and many declarations (§15.2.3). For example:

Click here to view code image

#include "MyVector.h"

extern template class MyVector<int>;    // suppresses implicit instantiation
                                        // explicitly instantiate elsewhere
void foo(MyVector<int>& v)
{
      //... use the vector in here ...
}
The “elsewhere” might look something like this:

Click here to view code image

#include "MyVector.h"

template class MyVector<int>;     // instantiate in this translation unit; use this point of instantiation
In addition to generating specializations for all members of a class, the explicit instantiation also determines a single point of instantiation so that other points of instantiation (§26.3.3) can be ignored. One use of this is to place the explicit instantiation in a shared library.

26.3. Name Binding
Define template functions to minimize dependencies on nonlocal information. The reason is that a template will be used to generate functions and classes based on unknown types and in unknown contexts. Every subtle context dependency is likely to surface as a problem for somebody – and that somebody is unlikely to want to know the implementation details of the template. The general rule of avoiding global names as much as possible should be taken especially seriously in template code. Thus, we try to make template definitions as self-contained as possible and to supply much of what would otherwise have been global context in the form of template arguments (e.g., traits; §28.2.4, §33.1.3). Use concepts to document dependencies on template arguments (§24.3).

However, it is not unusual that some nonlocal names must be used to achieve the most elegant formulation of a template. In particular, it is more common to write a set of cooperating template functions than to write just one self-contained function. Sometimes, such functions can be class members, but not always. Sometimes, nonlocal functions are the best choice. Typical examples of that are sort()’s calls to swap() and less() (§25.3.4). The standard-library algorithms are a large-scale example (Chapter 32). When something needs to be nonlocal, prefer a named namespace to the global scope. Doing so preserves some locality.

Operations with conventional names and semantics, such as +, *, [], and sort(), are another source of nonlocal name use in a template definition. Consider:

Click here to view code image

bool tracing;

template<typename T>
T sum(std::vector<T>& v)
{
    T t {};
    if (tracing)
          cerr << "sum(" << &v << ")\n";
    for (int i = 0; i!=v.size(); ++i)
          t = t + v[i];
    return t;
}
 //...

#include<quad.h>

void f(std::vector<Quad>& v)
{
     Quad c = sum(v);
}
The innocent-looking template function sum() depends on several names that are not explicitly specified in its definition, such as tracing, cerr, and the + operator. In this example, + is defined in <quad.h>:

Quad operator+(Quad,Quad);
Importantly, nothing related to Quad is in scope when sum() is defined, and the writer of sum() cannot be assumed to know about class Quad. In particular, the + may be defined later than sum() in the program text, and even later in time.

The process of finding the declaration for each name explicitly or implicitly used in a template is called name binding. The general problem with template name binding is that three contexts are involved in a template instantiation and they cannot be cleanly separated:

[1] The context of the template definition

[2] The context of the argument type declaration

[3] The context of the use of the template

When defining a function template, we want to assure that enough context is available for the template definition to make sense in terms of its actual arguments without picking up “accidental stuff” from the environment of a point of use. To help with this, the language separates names used in a template definition into two categories:

[1] Dependent names: names that depend on a template parameter. Such names are bound at a point of instantiation (§26.3.3). In the sum() example, the definition of + can be found in the instantiation context because it takes operands of the template argument type.

[2] Nondependent names: names that don’t depend on a template parameter. Such names are bound at the point of definition of the template (§26.3.2). In the sum() example, the template vector is defined in the standard header <vector>, and the Boolean tracing is in scope when the definition of sum() is encountered by the compiler.

To be considered, both dependent and independent names must either be in scope at their point of use or be found by argument-dependent lookup (ADL; §14.2.4).

The following subsections go into considerable technical detail about how dependent and non-dependent names in a template definition are bound for a specialization. For complete details, see §iso.14.6.

26.3.1. Dependent Names
The simplest definition of “N depends on a template parameter T” would be “N is a member of T.” Unfortunately, this doesn’t quite suffice; addition of Quads (§26.3) is a counter-example. Consequently, a function call is said to depend on a template argument if and only if one of these conditions holds:

[1] The type of the actual argument depends on a template parameter T according to the type deduction rules (§23.5.2), for example, f(T(1)), f(t), f(g(t)), and f(&t), assuming that t is a T.

[2] The function called has a parameter that depends on T according to the type deduction rules (§23.5.2), for example, f(T), f(list<T>&), and f(const T*).

Basically, the name of a called function is dependent if it is obviously dependent by looking at its arguments or at its formal parameters. For example:

Click here to view code image

template<typename T>
int f(T a)
{
     return g(a);    // OK: a is a dependent name and therefore so is g
}

class Quad { /* ... */ };
int g(Quad);

int z = f(Quad{2});         // f's g is bound to g(Quad)
A call that by coincidence has an argument that matches an actual template parameter type is not dependent. For example:

Click here to view code image

class Quad { /* ... */ };

template<typename T>
int ff(T a)
{
      return gg(Quad{1});     // error: no gg() in scope and gg(Quad{1}) doesn't depend on T
}

int gg(Quad);

int zz = ff(Quad{2});
Had gg(Quad{1}) been considered dependent, its meaning would have been most mysterious to a reader of the template definition. If a programmer wants gg(Quad) to be called, gg(Quad)’s declaration should be placed before the definition of ff() so that gg(Quad) is in scope when ff() is analyzed. This is exactly the same rule as for non-template function definitions (§26.3.2).

By default, a dependent name is assumed to name something that is not a type. So, to use a dependent name as a type, you have to say so, using the keyword typename. For example:

Click here to view code image

template<typename Container>
void fct(Container& c)
{
     Container::value_type v1 = c[7];  // syntax error: value_type is assumed to be a non-type name
     typename Container::value_type v2 = c[9];   // OK: value_type assumed to name a type
     auto v3 = c[11];                            // OK: let the compiler figure it out
      //...
}
We can avoid such awkward use of typename by introducing a type alias (§23.6). For example:

Click here to view code image

template<typename T>
using Value_type<T> = typename T::value_type;

template<typename Container>
void fct2(Container& c)
{
     Value_type<Container> v1 = c[7];  // OK
      //...
}
Naming a member template after a . (dot), –>, or :: requires similar use of the keyword template. For example:

Click here to view code image

class Pool {    // some allocator
public:
     template<typename T> T* get();
     template<typename T> void release(T*);
      //...
};

template<typename Alloc>
void f(Alloc& all)
{
     int* p1 = all.get<int>();               // syntax error: get is assumed to name a non-template
     int* p2 = all.template get<int>();      // OK: get() is assumed to be a template
      //...
}

void user(Pool& pool){{
{
     f(pool);
      //...
}
Compared to the use of typename to explicitly state that a name is assumed to name a type, the use of template to explicitly state that a name is assumed to name a template is rare. Note the difference in the placement of the disambiguating keyword: typename appears before the qualified name and template immediately before the template name.

26.3.2. Point-of-Definition Binding
When the compiler sees a template definition, it determines which names are dependent (§26.3.1). If a name is dependent, looking for its declaration is postponed until instantiation time (§26.3.3).

Names that do not depend on a template argument are treated like names that are not in templates; they must be in scope (§6.3.4) at the point of definition. For example:

Click here to view code image

int x;

template<typename T>
T f(T a)
{
     ++x;        // OK: x is in scope
     ++y;        // error: no y in scope, and y doesn't depend on T
     return a;   // OK: a is dependent
}

int y;

int z = f(2);
If a declaration is found, that declaration is used even if a “better” declaration might be found later. For example:

Click here to view code image

void g(double);
void g2(double);

template<typename T>
int ff(T a)
{
       g2(2);     // call g2(double);
       g3(2);     // error: no g3() in scope
       g(a);      // call g(double); g(int) is not in scope
        //...
}

void g(int);
void g3(int);

int x = ff(5);
Here, ff(5) will call g(double). The definition of g(int) comes too late to be considered – just as if ff() had not been a template or if g had named a variable.

26.3.3. Point-of-Instantiation Binding
The context used to determine the meaning of a dependent name (§26.3.1) is determined by the use of a template with a given set of arguments. This is called a point of instantiation for that specialization (§iso.14.6.4.1). Each use of a template for a given set of template arguments defines a point of instantiation. For a function template, that point is in the nearest global or namespace scope enclosing its use, just after the declaration that contains that use. For example:

Click here to view code image

void g(int);

template<typename T>
void f(T a)
{
     g(a);     // g is bound at a point of instantiation
}
void h(int i)
{
     extern void g(double);
     f(i);
}
 // point of instantiation for f<int>
The point of instantiation for f<int>() is outside h(). This is essential to ensure that the g() called in f() is the global g(int) rather than the local g(double). An unqualified name used in a template definition can never be bound to a local name. Ignoring local names is essential to prevent a lot of nasty macro-like behavior.

To enable recursive calls, the point of instantiation for a function template is after the declaration that instantiates it. For example:

Click here to view code image

void g(int);

template<typename T>
void f(T a)
{
     g(a);                 // g is bound at a point of instantiation
     if (a>1) h(T(a-1));   // h is bound at a point of instantiation
}

enum Count { one=1, two, three };

void h(Count i)
{
     f(i);
}
 // point of declaration for f<int>
Here, having the point of instantiation after the definition of h() is necessary to allow the (indirectly recursive) call h(a–1).

For a template class or a class member, the point of instantiation is just before the declaration containing its use.

Click here to view code image

template<typename T>
class Container {
     vector<T> v;     // elements
public:
     void sort();     // sort elements
      //...
};

 // point of instantiation of Container<int>
void f()
{
     Container<int> c;     // point of use
     c.sort();
}
Had the point of instantiation been after f() the call c.sort() would have failed to find the definition of Container<int>.

Relying on template arguments to make dependencies explicit simplifies our thinking about the template code and even allows us to access local information. For example:

void fff()
{
     struct S { int a,b; };
     vector<S> vs;
      //...
}
Here, S is a local name, but since we use it as an explicit argument, rather than trying to bury its name in the definition of vector, we have no potentially surprising subtleties.

So why don’t we completely avoid nonlocal names in template definitions? That would certainly solve the technical problem with name lookup, but – as for ordinary function and class definitions – we want to be able to use “other functions and types” freely in our code. Turning every dependency into an argument can lead to very messy code. For example:

Click here to view code image

template<typename T>
void print_sorted(vector<T>& v)
{
     sort(v.begin(),v.end());
     for (const auto&T x : v)
           cout << x << '\n';
}

void use(vector<string>& vec)
{
      //...
     print_sorted(vec);   // sort using std::sort, then print using std::cout
}
Here, we are using just two nonlocal names (sort and cout, both from the standard library). To eliminate those we would need to add parameters:

Click here to view code image

template<typename T, typename S>
void print_sorted(vector<T>& v, S sort, ostream& os)
{
     sort(v.begin(),v.end());
     for (const auto T& x : v)
           os << x << '\n';
}

void fct(vector<string>& vec)
{
      //...
     using Iter = decltype(vs.begin());   // vec's iterator type
     print_sorted(some_vec,std::sort<Iter>,std::cout);
}
In this trivial case, there is a lot to be said for removing the dependence on the global name cout. However, in general, as illustrated by sort(), adding parameters can make the code much more verbose without necessarily making it easier to understand.

Also, if the name-binding rules for templates were radically more restrictive than the rules for non-template code, writing template code would be a completely separate skill from writing non-template code. Templates and non-template code would no longer interoperate simply and freely.

26.3.4. Multiple Instantiation Points
A template specialization may be generated

• at any point of instantiation (§26.3.3),

• at any point subsequent to that in a translation unit,

• or in a translation unit specifically created for generating specializations.

This reflects three obvious strategies an implementation can use for generating specializations:

[1] Generate a specialization the first time a call is seen.

[2] At the end of a translation unit, generate all specializations needed for it.

[3] Once every translation unit of a program has been seen, generate all specializations needed for the program.

All three strategies have strengths and weaknesses, and combinations of these strategies are also possible.

So, a template used several times with the same set of template arguments has several points of instantiation. A program is illegal if it is possible to construct two different meanings by choosing different points of instantiation. That is, if the bindings of a dependent or a nondependent name can differ, the program is illegal. For example:

Click here to view code image

void f(int);                            // here, I take care of ints

namespace N {
    class X {};
    char g(X,int);
}

template<typename T>
char ff(T t, double d)
{
      f(d);            // f is bound to f(int)
      return g(t,d);   // g might be bound to g(X,int)
}

auto x1 = ff(N::X{},1.1);          // ff<N::X,double>; may bind g to N::g(X,int), narrowing 1.1 to 1

namespace N {                             // reopen N to take care of doubles
    double g(X,double);
}

auto x2 = ff(N::X,2.2);                   // ff<N::X,double>; binds g to N::g(X,double); the best match
For ff() we have two instantiation points. For the first call, we could generate the specialization at the initialization of x1 and get g(N::X,int) called. Alternatively, we could wait and generate the specialization at the end of the translation unit and get g(N::X,double) called. Consequently, the call ff(N::X{},1.1) is an error.

It is sloppy programming to call an overloaded function between two of its declarations. However, looking at a large program, a programmer would have no reason to suspect a problem. In this particular case, a compiler could catch the ambiguity. However, similar problems can occur in separate translation units, and then detection becomes much harder (for both compilers and programmers). An implementation is not obliged to catch problems of this kind.

To avoid surprising name bindings, try to limit context dependencies in templates.

26.3.5. Templates and Namespaces
When a function is called, its declaration can be found even if it is not in scope, provided it is declared in the same namespace as one of its arguments (§14.2.4). This is important for functions called in template definitions because it is the mechanism by which dependent functions are found during instantiation. The binding of dependent names is done (§iso.14.6.4.2) by looking at

[1] the names in scope at the point where the template is defined, plus

[2] the names in the namespace of an argument of a dependent call (§14.2.4).

For example:

Click here to view code image

namespace N {
    class A { /* ... */ };
    char f(A);
}

char f(int);

template<typename T>
char g(T t)
{
     return f(t);           // choose f() depending on what T is
}

char f(double);

char c1 = g(N::A());        // causes N::f(N::A) to be called
char c2 = g(2);             // causes f(int) to be called
char c3 = g(2.1);           // causes f(int) to be called; f(double) not considered
Here, f(t) is clearly dependent, so we can’t bind f at the point of definition. To generate a specialization for g<N::A>(N::A), the implementation looks in namespace N for functions called f() and finds N::f(N::A).

The f(int) is found because it is in scope at the point of definition of the template. The f(double) is not found because it is not in scope at the point of definition of the template (§iso.14.6.4.1), and argument-dependent lookup (§14.2.4) does not find a global function that takes only arguments of built-in types. I find it easy to forget that.

26.3.6. Overaggressive ADL
Argument-dependent lookup (often referred to as ADL) is very useful to avoid verbosity (§14.2.4). For example:

Click here to view code image

#include <valarray> // Note: No "using namespace std;"

valarray<double> fct(valarray<double> v1, valarray<double> v2, double d)
{
return v1+dv2;           // OK because of ADL
}
Without argument-dependent lookup, the addition operator for valarray, +, would not be found. As it is, the compiler notices that the first argument to + is an valarray defined in std. Therefore, it looks for + in std and finds it (in <valarray>).

However, ADL can be “too aggressive” when combined with unconstrained templates. Consider:

Click here to view code image

#include<vector>
#include<algorithm>
 //...

namespace User {
    class Customer { /* ... */ };
    using Index = std::vector<Customer*>;

    void copy(const Index&, Index&, int deep);    // deep or shallow copy depending on the value of deep

    void algo(Index& x, Index& y)
    {
          //...
         copy(x,y,false); // error
    }
}
It would be a good guess that the author of User meant for User::algo() to call User::copy(). However, that’s not what happens. The compiler notices that Index really is a vector defined in std and looks to see if a relevant function is available in std. In <algorithm>, it finds:

Click here to view code image

template<typename In, typename Out>
Out copy(In,In,Out);
Obviously, this general template is a perfect match for copy(x,y,false). On the other hand, the copy() in User can be called only with a bool-to-int conversion. For this example, as for equivalent examples, the compiler’s resolution is a surprise to most programmers and a source of very obscure bugs. Using ADL to find fully general templates is arguably a language design error. After all, std::copy() requires a pair of iterators (not just two arguments of the same type, such as the two Indexes). The standard says so, but the code does not. Many such problems can be solved by the use of concepts (§24.3, §24.3.2). For example, had the compiler known that std::copy() required two iterators, a nonobscure error would have been the result.

Click here to view code image

template<typename In, typename Out>
Out copy(In p1, In p2, Out q)
{
     static_assert(Input_iterator<In>(), "copy(): In is not an input iterator");
     static_assert(Output_iterator<Out>(), "copy(): Out is not an output iterator");
     static_assert(Assignable<Value_type<Out>,Value_type<In>>(), "copy(): value type mismatch");
      //...
}
Better still, the compiler would have noticed that std::copy() wasn’t even a valid candidate for that call and User::copy() would have been invoked. For example (§28.4):

Click here to view code image

template<typename In, typename Out,
         typename = Enable_if<Input_iterator<In>()
                            && Output_iterator<Out>()
                            && Assignable<Value_type<Out>,Value_type<In>>()>>
Out copy(In p1, In p2, Out q)
{
      //...
}
Unfortunately, many such templates are in libraries that a user cannot modify (e.g., the standard library).

It is a good idea to avoid fully general (completely unconstrained) function templates in headers that also contain type definitions, but that’s hard to avoid. If you need one, protecting it with a constraints check is often worthwhile.

What can a user do if a library has trouble-causing unconstrained templates? Often, we know which namespace our function should come from, so we can be specific about that. For example:

Click here to view code image

void User::algo(Index& x, Index& y)
{
     User::copy(x,y,false);    // OK
      //...
     std::swap(*x[i],*x[j]);   // OK: only std::swap is considered
}
If we don’t want to be specific about which namespace to use, but want to make sure that a particular version of a function is considered by function overloading, we can use a using-declaration (§14.2.2). For example:

Click here to view code image

template<typename Range, typename Op>
void apply(const Range& r, Op f)
{
     using std::begin;
     using std::end;
     for (auto& x : r)
           f(x);
}
Now, the standard begin() and end() are in the overload set used by the range-for to traverse the Range (unless Range has members begin() and end(); §9.5.1).

26.3.7. Names from Base Classes
When a class template has a base class, it can access names from that base. As for other names, there are two distinct possibilities:

• The base class depends on a template argument.

• The base class does not depend on a template argument.

The latter case is simple and treated just like base classes in classes that are not templates. For example:

void g(int);

struct B {
     void g(char);
     void h(char);
};

template<typename T>
class X : public B {
public:
     void h(int);
     void f()
     {
           g(2);      // call B::g(char)
           h(2);      // call X::h(int)
     }
      //...
};
As ever, local names hide other names, so h(2) binds to X::h(int) and B::h(char) is never considered. Similarly, the call g(2) is bound to B::g(char) without any concern for functions declared outside X. That is, the global g() is never considered.

For base classes that depend on a template parameter, we have to be a bit more careful and explicit about what we want. Consider:

void g(int);

struct B {
     void g(char);
     void h(char);
};

template<typename T>
class X : public T {
public:
     void f()
     {
           g(2);      // call ::g(int)
     }
      //...
};

void h(X<B> x)
{
     x.f();
}
Why doesn’t g(2) call B::g(char) (as in the previous example)? Because g(2) isn’t dependent on the template parameter T. It is therefore bound at the point of definition; names from the template argument T (which happens to be used as a base class) are not (yet) known and therefore not considered. If we want to have names from a dependent class considered, we must make the dependency clear. We have three ways of doing that:

• Qualify a name with a dependent type (e.g., T::g).

• Say that the name refers an object of this class (e.g., this–>g).

• Bring the name into scope with a using-declaration (e.g., using T::g).

For example:

Click here to view code image

void g(int);
void g2(int);

struct B {
     using Type = int;
     void g(char);
     void g2(char);
};

template<typename T>
class X : public T {
public:
     typename T::Type m;    // OK
     Type m2;               // error (no Type in scope)

     using T::g2();         // bring T::g2() into scope

     void f()
     {
          this–>g(2);       // call T::g
          g(2);             // call ::g(int); surprise?
          g2(2);            // call T::g2
     }
      //...
};

void h(X<B> x)
{
     x.f();
}
Only at the point of instantiation can we know if the argument used for the parameter T (here B) has the required names.

It is easy to forget to qualify names from a base, and the qualified code often looks a bit verbose and messy. However, the alternative would be that a name in a template class would sometimes bind to a base class member and sometimes to a global entity depending on the template argument. That is not ideal either, and the language rule supports the rule of thumb that a template definition should be as self-contained as possible (§26.3).

Qualifying access to dependent base members of a template can be a nuisance. However, explicit qualifications help maintainers, so the initial author shouldn’t grumble too much about the extra typing. A common occurrence of this problem is when a whole class hierarchy is templatized. For example:

Click here to view code image

template<typename T>
class Matrix_base {     // memory for matrices, operations of all elements
      //...
     int size() const { return sz; }
protected:
     int sz;    // number of elements
     T* elem;   // matrix elements
};

template<typename T, int N>
class Matrix : public Matrix_base<T> {   // N-dimensional matrix
      //...
     T* data()  // return pointer to element storage
     {
          return this–>elem;
     }
};
Here, the this–> qualification is required.

26.4. Advice
[1] Let the compiler/implementation generate specializations as needed; §26.2.1.

[2] Explicitly instantiate if you need exact control of the instantiation environment; §26.2.2.

[3] Explicitly instantiate if you optimize the time needed to generate specializations; §26.2.2.

[4] Avoid subtle context dependencies in a template definition; §26.3.

[5] Names must be in scope when used in a template definition or findable through argument-dependent lookup (ADL); §26.3, §26.3.5.

[6] Keep the binding context unchanged between instantiation points; §26.3.4.

[7] Avoid fully general templates that can be found by ADL; §26.3.6.

[8] Use concepts and/or static_assert to avoid using inappropriate templates; §26.3.6.

[9] Use using-declarations to limit the reach of ADL; §26.3.6.

[10] Qualify names from a template base class with –> or T:: as appropriate; §26.3.7.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


26. Instantiation
27. Templates and Hierarchies
28. Metaprogramming
47h 26m remaining
27. Templates and Hierarchies
Euclid’s and Beethoven’s Fifth; knowing just one of them marks you as semi-educated.

– Stan Kelley-Bootle

• Introduction

• Parameterization and Hierarchy

Generated Types; Template Conversions

• Hierarchies of Class Templates

Templates as Interfaces

• Template Parameters as Base Classes

Composing Data Structures; Linearizing Class Hierarchies

• Advice

27.1. Introduction
Templates and derivation are mechanisms for building new types out of existing ones, for specifying interfaces, and generally for writing useful code that exploits various forms of commonality:

• A template class defines an interface. The template’s own implementation and those of its specializations can be accessed through that interface. The source code implementing the template (in the template definition) is identical for all parameter types. The implementations of different specializations can be very different, but they should all implement the semantics specified for the primary template. A specialization can add functionality to what the primary template offers.

• A base class defines an interface. The class’s own implementation and those of its derived classes can (using virtual functions) be accessed through that interface. The implementations of different derived classes can be very different, but they should all implement the semantics specified for the base class. A derived class can add functionality to what the base class offers.

From a design perspective, the two approaches are close enough to deserve a common name. Since both allow an algorithm to be expressed once and applied to a variety of types, people refer to both as polymorphic (from Greek “many shapes”). To distinguish them, what virtual functions provide is called run-time polymorphism, and what templates offer is called compile-time polymorphism or parametric polymorphism.

The rough duality of the generic and object-oriented approaches can be deceptive. Object-oriented programmers tend to focus on the design of hierarchies of classes (types) with an interface being an individual class (Chapter 21). Generic programmers tend to focus on the design of algorithms with the concepts for template arguments providing an interface that can accommodate many types (Chapter 24). The ideal for a programmer should be mastery of both techniques to the point where either can be used where most appropriate. In many cases, the optimal design contains elements of both. For example vector<Shape*> is a compile-time polymorphic (generic) container holding elements from a run-time polymorphic (object-oriented) hierarchy (§3.2.4).

Generally, good object-oriented programming requires more foresight than good generic programming because all types in a hierarchy must explicitly share an interface defined as a base class. A template will accept any type that meets its concept as an argument, even if there is no explicitly declared commonality among those types. For example accumulate() (§3.4.2, §24.2, §40.6.1) will accept vectors of ints and lists of complex<double> even though there are no declared relationship between the two element types and no declared relationship between the two sequence types.

27.2. Parameterization and Hierarchy
As shown in §4.4.1 and §27.2.2, combinations of templates and class hierarchies are the basis for many useful techniques. So:

• When do we choose to use a class template?

• When do we rely on a class hierarchy?

Consider these questions from a slightly simplified and abstract point of view:

Click here to view code image

template<typename X>
class Ct {         // interface expressed in terms of the parameter
     X mem;
public:
     X f();
     int g();
     void h(X);
};

template<>
class Ct<A> {      // specialization (for A)
     A* mem;       // the representation can differ from that of the primary template
public:
     A f();
     int g();
     void h(A);
     void k(int);    // added functionality
};
     Ct<A> cta;      // specialization for A
     Ct<B> ctb;      // specialization for B
Given that, we can use f(), g(), and h() on the variables cta and ctb, using the implementations of Ct<A> and Ct<B>, respectively. I used an explicit specialization (§23.5.3.4) to show that implementations can vary from what the primary template offers and that it is possible to add functionality. The simpler case – without added functionality – is by far the more common.

The rough equivalent using a hierarchy is:

Click here to view code image

class X {
      //...
};

class Cx {                  // interface expressed in terms of types in scope
     X mem;
public:
     virtual X& f();
     virtual int g();
     virtual void h(X&);
};

class DA : public Cx {      // derived class
public:
     X& f();
     int g();
     void h(X&);
};

class DB : public Cx {     // derived class
     DB* p;                // representation can be more extensive than what the base provides
public:
     X& f();
     int g();
     void h(X&);
     void k(int);          // added functionality
};

Cx& cxa {*new DA};  // cxa is an interface to a DA
Cx& cxb {*new DB};  // cxb is an interface to a DB
Given that, we can use f(), g(), and h() on the variables cxa and cxb, using the implementations of DA and DB, respectively. I use references in the hierarchical version to reflect that we must manipulate derived class objects through pointers or references to preserve run-time polymorphic behavior.

In either case, we manipulate objects that share a common set of operations. From this simplified and abstract point of view we can observe:

• If the types in the interface to the generated or derived classes need to differ, templates have an advantage. To gain access to differing interfaces for derived classes through a base, we must use some form of explicit casting (§22.2).

• If the implementations of generated or derived classes differ only through a parameter or differ only in a few special cases, templates have an advantage. Irregular implementations can be expressed through derived classes or specializations.

• If the actual types of objects used cannot be known at compile time, a class hierarchy is essential.

• If a hierarchical relationship is required between generated or derived types, hierarchies have an advantage. The base class provides a common interface. Conversions among template specializations must be explicitly defined by the programmer (§27.2.2).

• If explicit use of free store (§11.2) is undesirable, templates have an advantage.

• If run-time efficiency is at such a premium that inlining of operations is essential, templates should be used (because effective use of hierarchy requires the use of pointers or references, which inhibit inlining).

Keeping base classes minimal and type-safe can be a struggle. Expressing the interface in terms of existing types that cannot vary for derived classes can be a struggle. Often the result is a compromise that either overconstrains the base class interface (e.g., we pick a class X with a “rich interface” which must be implemented by all derived classes and “for all time”) or underconstrains (e.g., we use void* or a minimal Object*).

The combination of templates and class hierarchies provides design choices and flexibility beyond what either can offer by itself. For example, a pointer to a base class can be used as a template argument to provide run-time polymorphism (§3.2.4), and a template parameter can be used to specify a base class interface to provide type safety (§26.3.7, §27.3.1).

It is not possible to have a virtual function template (§23.4.6.2).

27.2.1. Generated Types
A class template is usefully understood as a specification of how particular types are to be created. In other words, the template implementation is a mechanism that generates types when needed based on a specification. Consequently, a class template is sometimes called a type generator.

As far as the C++ language rules are concerned, there is no relationship between two classes generated from a single class template. For example:

class Shape {
      //...
};

class Circle : public Shape {
{
      //...
};
Given these declarations, people sometimes think that there must be an inheritance relationship between set<Circle> and set<Shape> or at least between set<Circle*> and set<Shape*>. This is a serious logical error based on a flawed argument: “A Circle is a Shape, so a set of Circles is also a set of Shapes; therefore, I should be able to use a set of Circles as a set of Shapes.” The “therefore” part of this argument doesn’t hold. The reason is that a set of Circles guarantees that the members of the set are Circles; a set of Shapes does not provide that guarantee. For example:

Click here to view code image

class Triangle : public Shape {
      //...
};

void f(set<Shape*>& s)
{
      //...
     s.insert(new Triangle{p1,p2,p3});
}

void g(set<Circle*>& s)
{
     f(s);  // error, type mismatch: s is a set<Circle*>, not a set<Shape*>
}
This won’t compile because there is no built-in conversion from set<Circle*>& to set<Shape*>&. Nor should there be. The guarantee that the members of a set<Circle*> are Circles allows us to safely and efficiently apply Circle-specific operations, such as determining the radius, to members of the set. If we allowed a set<Circle*> to be treated as a set<Shape*>, we could no longer maintain that guarantee. For example, f() inserts a Triangle* into its set<Shape*> argument. If the set<Shape*> could have been a set<Circle*>, the fundamental guarantee that a set<Circle*> contains Circle*s only would have been violated.

Logically, we could treat an immutable set<Circle*> as an immutable set<Shape*> because the problem of inserting an inappropriate element into the set cannot occur when we cannot change the set. That is, we could provide a conversion from const set<const Circle*> to const set<const Shape*>. The language doesn’t do so by default, but the designer of set could.

The combination of an array and a base class is particularly nasty because a built-in array does not offer the type safety provided by containers. For example:

Click here to view code image

void maul(Shape* p, int n)          // Danger!
{
     for (int i=0; i!=n; ++i)
           p[i].draw();             // looks innocent; it is not
}

void user()
{
     Circle image[10];              // an image is composed of 10 Circles
      //...
     maul(image,10);                //"maul" 10 Circles
      //...
}
How can we call maul() with image? First, image’s type is converted (decays) from Circle[] to Circle*. Next, Circle* is converted to Shape*. The implicit conversion of an array name to a pointer to the array’s first element is fundamental to C-style programming. Similarly, implicit conversion of a pointer to a derived class to a pointer to its base class is fundamental to object-oriented programming. In combination, they offer ample opportunities for disaster.

In the example above, assume that a Shape is an abstract class with size 4 and that Circle adds a center and a radius. Then sizeof(Circle)>sizeof(Shape) and when we look at the layout of image we find something like this:



When maul() tries to invoke a virtual function on p[1], there is no virtual function pointer where it is expected and the call hopefully fails instantly.

Note that no explicit cast was needed to get this disaster:

• Prefer containers over built-in arrays.

• Consider interfaces such as void f(T* p, int count) highly suspect; when T can be a base class and count is an element count, trouble awaits.

• Consider . (dot) suspect when applied to something that is supposed to be run-time polymorphic unless it is obviously applied to a reference.

27.2.2. Template Conversions
There cannot be any default relationship between classes generated from the same template (§27.2.1). However, for some templates we would like to express such a relationship. For example, when we define a pointer template, we would like to reflect inheritance relationships among the objects pointed to. Member templates (§23.4.6) allow us to specify many such relationships where desired. Consider:

Click here to view code image

template<typename T>
class Ptr {    // pointer to T
     T* p;
public:
     Ptr(T*);
     Ptr(const Ptr&);                       // copy constructor
     template<typename T2>
           explicit operator Ptr<T2>();     // convert Ptr<T> to Ptr<T2>
      //...
};
We would like to define the conversion operators to provide the inheritance relationships we are accustomed to for built-in pointers for these user-defined Ptrs. For example:

Click here to view code image

void f(Ptr<Circle> pc)
{
     Ptr<Shape> ps {pc};       // should work
     Ptr<Circle> pc2 {ps};     // should give error
}
We want to allow the first initialization if and only if Shape really is a direct or indirect public base class of Circle. In general, we need to define the conversion operator so that the Ptr<T> to Ptr<T2> conversion is accepted if and only if a T* can be assigned to a T2*. That can be done like this:

template<typename T>
    template<typename T2>
        Ptr<T>::operator Ptr<T2>()
        {
            return Ptr<T2>{p};
        }
The return-statement will compile if and only if p (which is a T*) can be an argument to the Ptr<T2>(T2*) constructor. Therefore, if T* can be implicitly converted into a T2*, the Ptr<T> to Ptr<T2> conversion will work. For example, we can now write:

Click here to view code image

void f(Ptr<Circle> pc)
{
     Ptr<Shape> ps {pc};      // OK: can convert Circle* to Shape*
     Ptr<Circle> pc2 {ps};    // error: cannot convert Shape* to Circle*
}
Be careful to define logically meaningful conversions only. If in doubt, use a named conversion function, rather than a conversion operator. A named conversion function offers fewer opportunities for ambiguities.

The template parameter lists of a template and one of its template members cannot be combined. For example:

Click here to view code image

template<typename T, typename T2>    // error
Ptr<T>::operator Ptr<T2>()
{
     return Ptr<T2>{p};
}
An alternative solution to this problem uses type traits and enable_if (§28.4).

27.3. Hierarchies of Class Templates
Using object-oriented techniques, a base class is often used to provide a common interface to a set of derived classes. A template can be used to parameterize such an interface, and when that is done it is tempting to parameterize the whole hierarchy of derived classes with the same template parameters. For example, we could parameterize the classical shape example (§3.2.4) with types used to provide an abstraction of the target output “device”:

Click here to view code image

template<typename Color_scheme, typename Canvas>      // questionable example
class Shape {
      //...
};

template<typename Color_scheme, typename Canvas>
class Circle : public Shape {
      //...
};
template<typename Color_scheme, typename Canvas>
class Triangle : public Shape {
      //...
};

void user()
{
     auto p = new Triangle<RGB,Bitmapped>{{0,0},{0,60},{30,sqr t(60*60–30 *30)}};
      //...
}
Something along this line is often the first idea (after seeing something like vector<T>) that a programmer used to object-oriented programming considers. However, caution is recommended when mixing object-oriented and generic techniques.

As written, this parameterized shape hierarchy is too verbose for real use. That could be addressed using default template arguments (§25.2.5). However, the verbosity is not the main problem. If only one combination of Color_scheme and Canvas is used in a program, the amount of code generated is almost exactly the same as would have been generated for the unparameterized equivalent. The “almost” comes because the compiler will suppress code generation for the definitions of unused non-virtual member functions of a class template. However, if N combinations of Color_scheme and Canvas are used in a program, the code for every virtual function will be replicated N times. Because a graphics hierarchy is likely to have many derived classes, many member functions, and many complicated functions, the result is likely to be massive code bloat. In particular, the compiler cannot know whether a virtual function is used or not, so it must generate code for all such functions and for all functions called by such functions. Parameterizing a huge class hierarchy with many virtual member functions is typically a poor idea.

For this shape example, the Color_scheme and Canvas parameters are unlikely to affect the interface much: most member functions will not have them as part of their function type. These parameters are an “implementation detail” that escaped into the interface – with likely serious performance implications. It is not really the whole hierarchy that needs those parameters; it is a few configuration functions and (most likely) a few lower-level drawing/rendering functions. It is generally not a good idea to “overparameterize” (§23.4.6.3): try to avoid parameters that affect only a few members. If only a few member functions are affected by a parameter, try to make those function templates with that parameter. For example:

Click here to view code image

class Shape {
     template<typename Color_scheme, typename Canvas>
         void configure(const Color_scheme&, const Canvas&);
      //...
};
How to share the configuration information among different classes and different objects is a separate issue. Clearly, we cannot simply store a Color_scheme and Canvas in the Shape without parameterizing Shape itself with Color_scheme and Canvas. One solution would be for configure() to “translate” the information in Color_scheme and Canvas into a standard set of configuration parameters (e.g., a set of integers). Another solution is to give a Shape a Configuration* member, where Configuration is a base class providing a general interface to configuration information.

27.3.1. Templates as Interfaces
A template class can be used to provide a flexible and type-safe interface to a common implementation. The vector from §25.3 is a good example of this:

template<typename T>
class Vector<T*>
     : private Vector<void*>
{
      //...
};
In general, this technique can be used to provide type-safe interfaces and for localizing casts to implementations, rather than forcing users to write them.

27.4. Template Parameters as Base Classes
In classical object-oriented programming using class hierarchies, we place information that can be different for different classes in derived classes and access it through virtual functions in a base class (§3.2.4, §21.2.1). That way, we can write common code without worrying about variations in the implementations. However, this technique does not allow us to vary the types used in the interface (§27.2). Also, those virtual function calls can be expensive compared to a simple operation from an inlined function. To compensate, we might pass the specialized information and operations to the base class as template arguments. In fact, a template argument can be used as a base class.

The general problem addressed by the following two subsections is “How can we combine separately specified information into a single compact object with a well-specified interface?” This is a fundamental question and the solutions are of general importance.

27.4.1. Composing Data Structures
Consider writing a balanced binary tree library. Since we are providing a library to be used by many different users, we can’t build the type of the user’s (application’s) data into our tree nodes. We have many alternatives:

• We could put the user’s data in a derived class and access it using virtual functions. But the virtual function calls (or equivalently, run-time resolved and checked solutions) are relatively expensive, and our interface to the user’s data is not expressed in terms of the user’s type, so we still need to use casts to access it.

• We could put a void* in our nodes and let the user use that to refer to data allocated outside our nodes. But that could double the number of allocations, add many (potentially expensive) pointer dereferences, and add the space overhead of a pointer in each node. We would also need to use a cast to access our user data using its correct type. That cast can’t be type checked.

• We could put a Data* into our nodes, where Data is a “universal base class” for our data structures. That would solve the type-checking problem, but that combines the cost and inconvenience of the previous two approaches.

There are more alternatives, but consider:

Click here to view code image

template<typename N>
struct Node_base {      // doesn't know about Val (the user data)
     N* left_child;
     N* right_child;

     Node_base();

     void add_left(N* p)
     {
          if (left_child==nullptr)
                left_child = p;
          else
                 //...
     }
      //...
};

template<typename Val>
struct Node : Node_base<Node<Val>> {      // use derived class as part of its own base
     Val v;
     Node(Val vv);
      //...
};
Here, we pass the derived class Node<Val> as a template argument to its own base (Node_base). That allows Node_base to use Node<Val> in its interfaces without even knowing its real name!

Note that the layout of a Node is compact. For example, a Node<double> will look roughly equivalent to this:

struct Node_double {
     Node_double* left_child;
     Node_double* right_child;
     double val;
};
Unfortunately, with this design, a user has to be aware of Node_base’s operations and the structure of the resulting tree. For example:

Click here to view code image

using My_node = Node<double>;

void user(const vector<double>& v)
{
     My_node root;
     int i = 0;

     for (auto x : v) {
           auto p = new My_node{x};
           if (i++%2)                 // choose where to insert
                 root.add_left(p);
           else
                 root.add_right(p);
     }
}
However, it is not easy for a user to keep the structure of a tree reasonable. Typically, we would like to let the tree take care of that by implementing a tree-balancing algorithm. However, to balance a tree so that you can search it efficiently, the balancer needs to know the user’s values.

How do we add a balancer to our design? We could hardwire the balancing strategy into Node_base and let Node_base “peek” at the user data. For example, a balanced tree implementation, such as the standard-library map, (by default) requires that a value type provides a less-than operation. That way, the Node_base operations can simply use <:

Click here to view code image

template<typename N>
struct Node_base {
     static_assert(Totally_ordered<N>(), "Node_base: N must have a <");

     N* left_child;
     N* right_child;
     Balancing_info bal;

     Node_base();

     void insert(N& n)
     {
           if (n<left_child)
                  //... do something ...
           else
                  //... do something else ...
     }
      //...
};
This works nicely. In fact, the more information about nodes we build into the Node_base, the simpler the implementation becomes. In particular, we could parameterize the Node_base with a value type rather than a node type (as is done for std::map), and we would have the tree in a single compact package. However, doing so doesn’t address the fundamental question we are trying to address here: how to combine information from several separately specified sources. Writing everything in one place dodges that problem.

So let us assume that the user will want to manipulate Nodes (e.g., move a node from one tree to another), so that we can’t simply store user data into an anonymous node. Let us further assume that we would like to be able to use a variety of balancing algorithms, so that we need to make the balancer an argument. These assumptions force us to face the fundamental question. The simplest solution is to let Node combine the value type with a balancer type. However, Node doesn’t need to use the balancer, so it just passes it on to Node_base:

Click here to view code image

template<typename Val, typename Balance>
struct Search_node : public Node_base<Search_node<Val, Balance>, Balance>
{
     Val val;      // user data
     Search_node(Val v): val(v) {}
};
Balance is mentioned twice here because it is part of the node type and because Node_base needs to make an object of type Balance:

Click here to view code image

template<typename N, typename Balance>
struct Node_base : Balance {
     N* left_child;
     N* right_child;

     Node_base();

     void insert(N& n)
     {
          if (this–>compare(n,left_child))      // use compare() from Balance
                 //... do something ...
          else
                 //... do something else ...
     }
      //...
};
I could have used Balance to define a member, rather than using it as a base. However, some important balancers require no per-node data, so by making Balance a base, I benefit from the empty-base optimization. The language guarantees that if a base class has no non-static data members, no memory will be allocated for it in an object of derived class (§iso.1.8). Also, this design is with minor stylistic differences that of a real binary tree framework [Austern,2003]. We might use these classes like this:

Click here to view code image

struct Red_black_balance {
      // data and operations needed to implement red-black trees
};

template<typename T>
using Rb_node = Search_node<T,Red_black_balance>;   // type alias for red-black trees

Rbnode<double> my_root;       // a red-black tree of doubles

using My_node = Rb_node<double>;

void user(const vector<double>& v)
{
     my_for (auto x : v)
           root.insert(*new My_node{x});
}
The layout of a node is compact, and we can easily inline all performance-critical functions. What we achieved by the slightly elaborate set of definitions was type safety and ease of composition. This elaboration delivers a performance advantage compared to every approach that introduces a void* into the data structure or function interfaces. Such a use of void* disables valuable type-based optimization techniques. Choosing a low-level (C-style) programming technique in the key parts of a balanced binary tree implementation implies a significant run-time cost.

We passed the balancer as a separate template argument:

Click here to view code image

template<typename N, typename Balance>
struct Node_base : Balance {
          //...
};

template<typename Val, typename Balance>
struct Search_node
     : public Node_base<Search_node<Val, Balance>, Balance>
{
      //...
};
Some find this clear, explicit, and general; others find it verbose and confusing. The alternative is to make the balancer an implicit argument in the form of an associated type (a member type of Search_node):

Click here to view code image

template<typename N>
struct Node_base : N::balance_type {    // use N's balance_type
          //...
};

template<typename Val, typename Balance>
struct Search_node
     : public Node_base<Search_node<Val,Balance>>
{
     using balance_type = Balance;
      //...
};
This technique is heavily used in the standard library to minimize explicit template arguments.

The technique of deriving from a base class is very old. It was mentioned in the ARM (1989) and is sometimes referred to as the Barton-Nackman trick after an early use in mathematical software [Barton,1994]. Jim Coplien called it the curiously recurring template pattern (CRTP) [Coplien,1995].

27.4.2. Linearizing Class Hierarchies
The Search_node example from §27.4.1 uses its template to compress its representation and to avoid using void*. The techniques are general and very useful. In particular, many programs that deal with trees rely on it for type safety and performance. For example, the “Internal Program Representation” (IPR) [DosReis,2011] is a general and systematic representation of C++ code as typed abstract syntax trees. It uses template parameters as base classes extensively, both as an implementation aid (implementation inheritance) and to provide abstract interfaces in the classical object-oriented way (interface inheritance). The design addresses a difficult set of criteria, including compactness of nodes (there can be many millions of nodes), optimized memory management, access speed (don’t introduce unnecessary indirections or nodes), type safety, polymorphic interfaces, and generality.

The users see a hierarchy of abstract classes providing perfect encapsulation and clean functional interfaces representing the semantics of a program. For example, a variable is a declaration, which is a statement, which is an expression, which is a node:

Var –> Decl –> Stmt –> Expr –> Node
Clearly, some generalization has been done in the design of the IPR because in ISO C++ statements cannot be used as expressions.

In addition, there is a parallel hierarchy of concrete classes providing compact and efficient implementations of the classes in the interface hierarchy:

impl::Var –> impl::Decl –> impl::Stmt –> impl::Expr –> impl::Node
In all, there are about 80 leaf classes (such as Var, If_stmt, and Multiply) and about 20 generalizations (such as Decl, Unary, and impl::Stmt).

The first attempt of a design was a classical multiple-inheritance “diamond” hierarchy (using solid arrows to represent interface inheritance and dashed arrows for implementation inheritance):



That worked but led to excessive memory overhead: the nodes were too large because of data needed to navigate the virtual bases. In addition, programs were seriously slowed down by the many indirections to access the many virtual bases in each object (§21.3.5).

The solution was to linearize the dual hierarchy so that no virtual bases were used:



For the full set of classes the chain of derivation becomes:

Click here to view code image

impl::Var –>
     impl::Decl<ipl::Var> –>
          ipl::Stmt<impl::Var> –>
               ipl::Expr<impl::Var> –>
                    ipl::Node<impl::Var> –>
                         ipr::Var –>
                              ipr::Decl –>
                                   ipr::Stmt –>
                                        ipr::Expr –>
                                             ipr::Node
This is represented as a compact object with no internal “management data” except the single vptr (§3.2.3, §20.3.2).

I will show how that is done. The interface hierarchy, defined in namespace ipr is described first. Starting from the bottom, a Node holds data used to optimize traversal and Node type identification (the code_category) and to ease storage of IPR graphs in files (the node_id). These are fairly typical “implementation details” hidden from the users. What a user will know is that every node in an IPR graph has a unique base of type Node and that this can be used to implement operations using the visitor pattern [Gamma,1994] (§22.3):

Click here to view code image

struct ipr::Node {
     const int node_id;
     const Category_code category;

     virtual void accept(Visitor&) const = 0;    // hook for visitor classes
protected:
     Node(Category_code);
};
Node is meant to be used as a base class only, so its constructor is protected. It also has a pure virtual function, so it cannot be instantiated except as a base class.

An expression (Expr) is a Node that has a type:

Click here to view code image

struct ipr::Expr : Node {
     virtual const Type& type() const = 0;
protected:
     Expr(Category_code c) : Node(c) { }
};
Obviously, this is quite a generalization of C++ because it implies that even statements and types have types: it is an aim of the IPR to represent all of C++ without implementing all of C++’s irregularities and limitations.

A statement (Stmt) is an Expr that has a source file location and can be annotated with various information:

Click here to view code image

struct ipr::Stmt : Expr {
     virtual const Unit_location& unit_location() const = 0;      // line in file
     virtual const Source_location& source_location() const = 0;  // file

     virtual const Sequence<Annotation>& annotation() const = 0;
protected:
     Stmt(Category_code c) : Expr(c) { }
};
A declaration (Decl) is a Stmt that introduces a name:

Click here to view code image

struct ipr::Decl : Stmt {
     enum Specifier { /* storage class, virtual, access control, etc. */ };

     virtual Specifier specifiers() const = 0;
     virtual const Linkage& lang_linkage() const = 0;

     virtual const Name& name() const = 0;

     virtual const Region& home_region() const = 0;
     virtual const Region& lexical_region() const = 0;

     virtual bool has_initializer() const = 0;
     virtual const Expr& initializer() const = 0;

      //...
protected:
     Decl(Category_code c) : Stmt(c) { }
};
As you might expect, Decl is one of the central notions when it comes to representing C++ code. This is where you find scope information, storage classes, access specifiers, initializers, etc.

Finally, we can define a class to represent a variable (Var) as a leaf class (most derived class) of our interface hierarchy:

Click here to view code image

struct ipr::Var : Category<var_cat, Decl> {
};
Basically, Category is a notational aid with the effect of deriving Var from Decl and giving the Category_code used to optimize Node type identification:

Click here to view code image

template<Category_code Cat, typename T = Expr>
struct ipr::Category : T {
protected:
     Category() : T(Cat) { }
};
Every data member is a Var. That includes global, namespace, local, and class static variables and constants.

Compared to representations you find in compilers, this interface is tiny. Except for some data for optimizations in Node, this is just a set of classes with pure virtual functions. Note that it is a single hierarchy with no virtual base classes. It is a straightforward object-oriented design. However, implementing this simply, efficiently, and maintainably is not easy, and IPR’s solution is certainly not what an experienced object-oriented designer would first think of.

For each IPR interface class (in ipr), there is a corresponding implementation class (in impl). For example:

Click here to view code image

template<typename T>
struct impl::Node : T {
     using Interface = T;  // make the template argument type available to users
     void accept(ipr::Visitor& v) const override { v.visit(*this); }
};
The “trick” is to establish the correspondence between the ipr nodes and the impl nodes. In particular, the impl nodes must provide the necessary data members and override the abstract virtual functions in the ipr nodes. For impl::Node, we can see that if T is an ipr::Node or any class derived from ipr::Node, then the accept() function is properly overridden.

Now, we can proceed to provide implementation classes for the rest of the ipr interface classes:

Click here to view code image

template<typename Interface>
struct impl::Expr : impl::Node<Interface> {
     const ipr::Type* constraint;        // constraint is the type of the expression

     Expr() : constraint(0) { }

     const ipr::Type& type() const override { return *util::check(constraint); }
};
If the Interface argument is an ipr::Expr or any class derived from ipr::Expr, then impl::Expr is an implementation for ipr::Expr. We can make sure of that. Since ipr::Expr is derived from ipr::Node, this implies that impl::Node gets the ipr::Node base class that it needs.

In other words, we have managed to provide implementations for two (different) interface classes. We can proceed in this manner:

Click here to view code image

template<typename S>
struct impl::Stmt : S {
     ipr::Unit_location unit_locus;               // logical position in translation unit
     ipr::Source_location src_locus;               // source file, line, and column
     ref_sequence<ipr::Annotation> notes;

     const ipr::Unit_location& unit_location() const override { return unit_locus; }
     const ipr::Source_location& source_location() const override { return src_locus; }
     const ipr::Sequence<ipr::Annotation>& annotation() const override { return notes; }
};
That is, impl:Stmt provides the three data items needed to implement ipr::Stmt’s interface and overrides ipr::Stmt’s three virtual functions to do so.

Basically, all impl classes follow Stmt’s pattern:

Click here to view code image

template<typename D>
struct impl::Decl : impl::Stmt<impl::Expr<D>> {     // uses the implementations of Stmt and Expr
     basic_decl_data<D> decl_data;
     ipr::Named_map* pat;
     val_sequence<ipr::Substitution> args;

     Decl() : decl_data(0), pat(0) { }

     const ipr::Sequence<ipr::Substitution>& substitutions() const { return args; }
     const ipr::Named_map& generating_map() const override { return *util::check(pat); }
     const ipr::Linkage& lang_linkage() const override;
     const ipr::Region& home_region() const override;
};
Finally, we can define the leaf class impl::Var:

Click here to view code image

struct Var : impl::Decl<ipr::Var> {
     const ipr::Expr* init;
     const ipr::Region* lexreg;

     Var();

     bool has_initializer() const override;
     const ipr::Expr& initializer() const override;
     const ipr::Region& lexical_region() const override;
};
Note that Var is not a template; it is a user-level abstraction in our application. The implementation of Var is an example of generic programming, but its use is classical object-oriented programming.

The combination of inheritance and parameterization is powerful. This expressive power can lead to confusion for beginners and occasionally even for experienced programmers when faced with a new application area. However, the benefits of the combination are concrete: type safety, performance, and minimal source code size. The extensibility offered by class hierarchies and virtual functions is not compromised.

27.5. Advice
[1] When having to express a general idea in code, consider whether to represent it as a template or as a class hierachy; §27.1.

[2] A template usually provides common code for a variety of arguments; §27.1.

[3] An abstract class can completely hide implementation details from users; §27.1.

[4] Irregular implementations are usually best represented as derived classes; §27.2.

[5] If explicit use of free store is undesirable, templates have an advantage over class hierarchies; §27.2.

[6] Templates have an advantage over abstract classes where inlining is important; §27.2.

[7] Template interfaces are easily expressed in terms of template argument types; §27.2.

[8] If run-time resolution is needed, class hierarchies are necessary; §27.2.

[9] The combination of templates and class hierarchies is often superior to either without the other; §27.2.

[10] Think of templates as type generators (and function generators); §27.2.1.

[11] There is no default relation between two classes generated from the same template; §27.2.1.

[12] Do not mix class hierarchies and arrays; §27.2.1.

[13] Do not naively templatize large class hierarchies; §27.3.

[14] A template can be used to provide a type-safe interface to a single (weakly typed) implementation; §27.3.1.

[15] Templates can be used to compose type-safe and compact data structures; §27.4.1.

[16] Templates can be used to linearize a class hierarchy (minimizing space and access time); §27.4.2.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


27. Templates and Hierarchies
28. Metaprogramming
29. A Matrix Design
47h 26m remaining
28. Metaprogramming
Trips to fairly unknown regions should be made twice; once to make mistakes and once to correct them.

– John Steinbeck

• Introduction

• Type Functions

Type Aliases; Type Predicates; Selecting a Function; Traits

• Control Structures

Selection; Iteration and Recursion; When to Use Metaprogramming

• Conditional Definition: Enable_if

Use of Enable_if; Implementing Enable_if; Enable_if and Concepts; More Enable_if Examples

• A Compile-Time List: Tuple

A Simple Output Function; Element Access; make_tuple

• Variadic Templates

A Type-Safe printf(); Technical Details; Forwarding; The Standard-Library tuple

• SI Units Example

Units; Quantitys; Unit Literals; Utility Functions

• Advice

28.1. Introduction
Programming that manipulates program entities, such as classes and functions, is commonly called metaprogramming. I find it useful to think of templates as generators: they are used to make classes and functions. This leads to the notion of template programming as an exercise in writing programs that compute at compile time and generate programs. Variations of this idea have been called two-level programming, multilevel programming, generative programming, and – more commonly – template metaprogramming.

There are two main reasons for using metaprogramming techniques:

• Improved type safety: We can compute the exact types needed for a data structure or algorithm so that we don’t need to directly manipulate low-level data structures (e.g., we can eliminate many uses of explicit type conversion).

• Improved run-time performance: We can compute values at compile time and select functions to be called at run time. That way, we don’t need to do those computations at run time (e.g., we can resolve many examples of polymorphic behavior to direct function calls). In particular, by taking advantage of the type system, we can dramatically improve the opportunities for inlining. Also, by using compact data structures (possibly generated; §27.4.2, §28.5), we make better use of memory with positive effects on both the amount of data we can handle and the execution speed.

Templates were designed to be very general and able to generate optimal code [Stroustrup,1994]. They provide arithmetic, selection, and recursion. In fact, they constitute a complete compile-time functional programming language [Veldhuizen,2003]. That is, templates and their template instantiation mechanism are Turing complete. One demonstration of this was that Eisenecker and Czarnecki wrote a Lisp interpreter in only a few pages using templates [Czarnecki,2000]. The C++ compile-time mechanisms provide a pure functional programming language: You can create values of various types, but there are no variables, assignments, increment operators, etc. The Turing completeness implies the possibility of infinite compilations, but that’s easily taken care of by translation limits (§iso.B). For example, an infinite recursion will be caught by running out of some compile-time resource, such as the number of recursive constexpr calls, the number of nested classes, or the number of recursively nested template instantiations.

Where should we draw the line between generic programming and template metaprogramming? The extreme positions are:

• It is all template metaprogramming: after all, any use of compile-time parameterization implies instantiation that generates “ordinary code.”

• It is all generic programming: after all, we are just defining and using generic types and algorithms.

Both of these positions are useless because they basically define generic programming and template metaprogramming as synonyms. I think there is a useful distinction to be made. A distinction helps us decide between alternative approaches to problems and to focus on what is important for a given problem. When I write a generic type or algorithm, I don’t feel that I am writing a compile-time program. I am not using my programming skills for the compile-time part of my program. Instead, I am focusing on defining requirements on arguments (§24.3). Generic programming is primarily a design philosophy – a programming paradigm, if you must (§1.2.1).

In contrast, metaprogramming is programming. The emphasis is on computation, often involving selection and some form of iteration. Metaprogramming is primarily a set of implementation techniques. I can think of four levels of implementation complexity:

[1] No computation (just pass type and value arguments)

[2] Simple computation (on types or values) not using compile-time tests or iteration, for example, && of Booleans (§24.4) or addition of units (§28.7.1)

[3] Computation using explicit compile-time tests, for example, a compile-time if (§28.3).

[4] Computation using compile-time iteration (in the form of recursion; §28.3.2).

The ordering indicates the level of complexity, with implications for the difficulty of the task, the difficulty of debugging, and the likelihood of error.

So, metaprogramming is a combination of “meta” and programming: a metaprogram is a compile-time computation yielding types or functions to be used at run time. Note that I don’t say “template metaprogramming” because the computation may be done using constexpr functions. Note also that you can rely on other people’s metaprogramming without actually doing metaprogramming yourself: calling a constexpr function hiding a metaprogram (§28.2.2) or extracting the type from a template type function (§28.2.4) is not in itself metaprogramming; it just uses a metaprogram.

Generic programming usually falls into the first, “no computation” category, but it is quite possible to support generic programming using metaprogramming techniques. When doing so, we have to be careful that our interface specifications are precisely defined and correctly implemented. Once we use (meta)programming as part of an interface, the possibility of programming errors creeps in. Without programming, the meaning is directly defined by the language rules.

Generic programming focuses on interface specification, whereas metaprogramming is programming, usually with types as the values.

Overenthusiastic use of metaprogramming can lead to debugging problems and excessive compile times that render some uses unrealistic. As ever, we have to apply common sense. There are many simple uses of metaprogramming that lead to better code (better type safety, lower memory footprint, and lower run time) without exceptional compile-time overhead. Many standard-library components, such as function (§33.5.3), thread (§5.3.1, §42.2.2), and tuple (§34.2.4.2), are examples of relatively simple application of metaprogramming techniques.

This chapter explores the basic metaprogramming techniques and presents the basic building blocks of metaprograms. Chapter 29 offers a more extensive example.

28.2. Type Functions
A type function is a function that either takes at least one type argument or produces at least one type as a result. For example, sizeof(T) is a built-in type function that given a type argument T returns the size of an object (measured in chars; §6.2.8).

Type functions don’t have to look like conventional functions. In fact, most don’t. For example, the standard library’s is_polymorphic<T> takes its argument as a template argument and returns its result as a member called value:

if (is_polymorphic<int>::value) cout << "Big surprise!";
The value member of is_polymorphic is either true or false. Similarly, the standard-library convention is that a type function that returns a type does so by a member called type. For example:

Click here to view code image

enum class Axis : char { x, y, z };
enum Flags { off, x=1, y=x<<1, z=x<<2, t=x<<3 };

typename std::underlying_type<Axis>::type v1;    // v1 is a char
typename std::underlying_type<Flags>::type v2;    // v2 is probably an int (§8.4.2)
A type function can take more than one argument and return several result values. For example:

template<typename T, int N>
struct Array_type {
     using type = T;
     static const int dim = N;
      //...
};
This Array_type is not a standard-library function or even a particularly useful function. I just used it as an excuse to show how to write a simple multi-argument, multi-return-value type function. It can be used like this:

Click here to view code image

using Array = Array_type<int,3>;

Array::type x;                  // x is an int
constexpr int s = Array::dim;   // s is 3
Type functions are compile-time functions. That is, they can only take arguments (types and values) that are known at compile time and produce results (types and values) that can be used at compile time.

Most type functions take at least one type argument, but there are useful ones that don’t. For example, here is a type function that returns an integer type of the appropriate number of bytes:

Click here to view code image

template<int N>
struct Integer {
     using Error = void;
     using type = Select<N,Error,signed char,short,Error,int,Error,Error,Error,long>;
};

typename Integer<4>::type i4 = 8;   //4-byte integer
typename Integer<1>::type i1 = 9;   //1-byte integer
Select is defined and explained in §28.3.1.3. It is of course possible to write templates that take values only and produce values only. I don’t consider those type functions. Also, constexpr functions (§12.1.6) are usually a better way of expressing compile-time computations on values. I can compute a square root at compile time using templates, but why would I want to when I can express the algorithm more cleanly using constexpr functions (§2.2.3, §10.4, §28.3.2)?

So, C++ type functions are mostly templates. They can perform very general computations using types and values. They are the backbone of metaprogramming. For example, we might want to allocate an object on the stack provided that it is small and on the free store otherwise:

Click here to view code image

constexpr int on_stack_max = sizeof(std::string);  // max size of object we want on the stack

template<typename T>
struct Obj_holder {
     using type = typename std::conditional<(sizeof(T)<=on_stack_max),
                                            Scoped<T>,          // first alternative
                                            On_heap<T>          // second alternative
                                       >::type;
};
The standard-library template conditional is a compile-time selector between two alternatives. If its first argument evaluates to true, the result (presented as the member type) is the second argument; otherwise, the result is the third argument. §28.3.1.1 shows how conditional is implemented. In this case, Obj_holder<X>’s type is defined to be Scoped<X> if an object of X is small and On_heap<X> if it is large. Obj_holder can be used like this:

Click here to view code image

void f()
{
     typename Obj_holder<double>::type v1;                    // the double goes on the stack
     typename Obj_holder<array<double,200>>::type v2;         // the array goes on the free store
      //...
     *v1 = 7.7;     // Scoped provides pointer-like access (v1 holds a double)
     (*v2)[77] = 9.9;  // On_heap provides pointer-like access (v2 holds an array))
}
The Obj_holder example is not hypothetical. For example, the C++ standard contains the following comment in its definition of the function type (§33.5.3) for holding function-like entities: “Implementations are encouraged to avoid the use of dynamically allocated memory for small callable objects, for example, where f’s target is an object holding only a pointer or reference to an object and a member function pointer” (§iso.20.8.11.2.1). It would be hard to follow that advice without something like Obj_holder.

The implementations of Scoped and On_heap do not involve any metaprogramming:

Click here to view code image

template<typename T>
struct On_heap {
     On_heap() :p(new T) {}     // allocate
     ~On_heap() { delete p; }   // deallocate

     T& operator*() { return *p; }
     T* operator–>() { return p; }

     On_heap(const On_heap&) = delete;         // prevent copying
     On_heap& operator=(const On_heap&) = delete;
private:
     T* p;     // pointer to object on the free store
};

template<typename T>
struct Scoped {
     Scoped() {}

     T& operator*() { return x; }
     T* operator–>() { return &x; }

     Scoped(const Scoped&) = delete;           // prevent copying
     Scoped& operator=(const Scoped&) = delete;
private:
     T x;      // the object
};
On_heap and Scoped provide good examples of how generic programming and template metaprogramming require us to devise uniform interfaces to different implementations of a general idea (here, the idea of allocation of an object).

Both On_heap and Scoped can be used as members as well as local variables. On_heap always places its object on the free store, whereas Scoped contains its object.

§28.6 shows how we can implement versions of On_heap and Scoped for types that take constructor arguments (by using variadic templates and forwarding).

28.2.1. Type Aliases
Note how the implementation details of Obj_holder (as for Integer) shine through when we use typename and ::type to extract the member type. This is a consequence of the way the language is specified and used, this is the way template metaprogramming code has been written for the last 15 years, and this is the way it appears in the C++11 standard. I consider it insufferable. It reminds me of the bad old days in C, where every occurrence of a user-defined type had to be prefixed with the struct keyword. By introducing a template alias (§23.6), we can hide the ::type implementation details and make a type function look much more like a function returning a type (or like a type). For example:

Click here to view code image

template<typename T>
using Holder = typename Obj_holder<T>::type;

void f2()
{
     Holder<double> v1;
          // the double goes on the stack
     Holder<array<double,200>> v2;        // the array goes on the free store
     //...
     *v1 = 7.7;      // Scoped provides pointer-like access (v1 holds a double)
     (*v2)[77] = 9.9;   // On_heap provides pointer-like access (v2 holds an array))
}
Except when explaining an implementation or what the standard specifically offers, I use such type aliases systematically. When the standard provides a type function (called something like “type property predicate” or “composite type category predicate”), such as conditional, I define a corresponding type alias (§35.4.1):

Click here to view code image

template<bool C, typename T, typename F>
using Conditional = typename std::conditional<C,T,F>::type;
Please note that these aliases are unfortunately not part of the standard.

28.2.1.1. When Not to Use an Alias
There is one case in which it is significant to use ::type directly, rather than an alias. If only one of the alternatives is supposed to be a valid type, we should not use an alias. Consider first a simple analogy:

if (p) {
       p–>f(7);
        //...
}
It is important that we don’t enter the block if p is the nullptr. We are using the test to see if p is valid. Similarly, we might want to test to see if a type is valid. For example:

conditional<
  is_integral<T>::value,
  make_unsigned<T>::value
  Error
>::type
Here, we test if T is an integral type (using the std::is_integral type predicate) and make the unsigned variant of that type if it is (using the std::make_unsigned type function). If that succeeds, we have an unsigned type; otherwise, we will have to deal with the Error indicator.

Had we written Make_unsigned<T> meaning

typename make_unsigned<T>::type
and tried to use it for a nonintegral type, say std::string, we would have tried to make a nonexistent type (make_unsigned<std::string>::type). The result would have been a compile-time error.

In the rare cases where we can’t use aliases consistently to hide ::type, we can fall back on the more explicit, implementation-oriented ::type style. Alternatively, we can introduce a Delay type function to delay evaluation of a type function until its use:

Conditional<
  is_integral<T>::value,
  Delay<Make_unsigned,T>,
  Error
>
The implementation of a perfect Delay function is nontrivial, but for many uses this will do:

Click here to view code image

template<template<typename...> class F, typename... Args>
using Delay = F<Args...>;
This uses a template template argument (§25.2.4) and variadic templates (§28.6).

Independently of which solution we choose to avoid the undesired instantiation, this is the kind of expert territory that I enter only with some trepidation.

28.2.2. Type Predicates
A predicate is a function that returns a Boolean value. If you want to write functions that take arguments that are types, it seems obvious that you’ll like to ask questions about the arguments’ types. For example: Is this a signed type? Is this type polymorphic (i.e., does it have at least one virtual function)? Is this type derived from that type?

The answers to many such questions are known to the compiler and exposed to the programmer through a set of standard-library type predicates (§35.4.1). For example:

Click here to view code image

template<typename T>
void copy(T* p, const T* q, int n)
{
     if (std::is_pod<T>::value)
           memcpy(p,q,n*sizeof(T));              // use optimized memory copy
     else
         for (int i=0; i!=n; ++i)
               p[i] = q[i];            // copy individual values
}
Here, we try to optimize the copy by using the (supposedly optimal) standard-library function memcpy() when we can treat the objects as “plain old data” (POD; §8.2.6). If not, we copy the objects one by one (potentially) using their copy constructor. We determine whether the template argument type is a POD by the standard-library type predicate is_pod. The result is presented by the member value. This standard-library convention is similar to the way type functions present their result as a member type.

The std::is_pod predicate is one of the many provided by the standard library (§35.4.1). Since the rules for being a POD are tricky, is_pod is most likely a compiler intrinsic rather than implemented in the library as C++ code.

Like the ::type convention, the value ::value causes verbosity and is a departure from conventional notation that lets implementation details shine through: a function returning a bool should be called using ():

template<typename T>
void copy(T* p, const T* q, int n)
{
     if (is_pod<T>())
      //...
}
Fortunately, the standard supports that for all standard-library type predicates. Unfortunately, for language-technical reasons, this resolution is not available in the context of a template argument. For example:

Click here to view code image

template<typename T>
void do_something()
{
     Conditional<(is_pod<T>()),On_heap<T>,Scoped<T>> x;   // error: is_pod<T>() is a type
      //..
}
In particular, is_pod<T> is interpreted as the type of a function taking no argument and returning an is_pod<T> (§iso.14.3[2]).

My solution is to add functions to provide the conventional notation in all contexts:

template<typename T>
constexpr bool Is_pod()
{
    return std::is_pod<T>::value;
}
I capitalize the names of these type functions to avoid confusion with the standard-library versions. In addition, I keep them in a separate namespace (Estd).

We can define our own type predicates. For example:

template<typename T>
constexpr bool Is_big()
{
    return 100<sizeof(T);
}
We could use this (rather crude) notion of “big” like this:

Click here to view code image

template<typename T>
using Obj_holder = Conditional<(Is_big<T>()), On_heap<T>> Scoped<T>>;
It is rarely necessary to define predicates that directly reflect basic properties of types because the standard library provides many of those. Examples are is_integral, is_pointer, is_empty, is_polymorphic, and is_move_assignable (§35.4.1). When we have to define such predicates, we have rather powerful techniques available. For example, we can define a type function to determine whether a class has a member of a given name and of an appropriate type (§28.4.4).

Naturally, type predicates with more than one argument can also be useful. In particular, this is how we represent relations between two types, such as is_same, is_base_of, and is_convertible. These are also from the standard library.

I use Is_* constexpr functions to support the usual () calling syntax for all of these is_* functions.

28.2.3. Selecting a Function
A function object is an object of some type, so the techniques for selecting types and values can be used to select a function. For example:

Click here to view code image

struct X {  // write X
     void operator()(int x) { cout <<"X" << x << "!\n"; }
      //...
};

struct Y {  // write Y
     void operator()(int y) { cout <<"Y" << y << "!\n"; }
      //...
};

void f()
{
     Conditional<(sizeof(int)>4),X,Y>{}(7);    // make an X or a Y and call it

     using Z = Conditional<(Is_polymorphic<X>()),X,Y>;
     Z zz;      // make an X or a Y
     zz(7);     // call an X or a Y
}
As shown, a selected function object type can be used immediately or “remembered” for later use.

Classes with member functions computing some value are the most general and flexible mechanism for computation in template metaprogramming.

Conditional is a mechanism for compile-time programming. In particular, this means that the condition must be a constant expression. Note the parentheses around sizeof(int)>4; without those, we would have gotten a syntax error because the compiler would have interpreted the > as the end of the template argument list. For that reason (and others), I prefer to use < (less than) rather than > (greater than). Also, I sometimes use parentheses around conditions for readability.

28.2.4. Traits
The standard library relies heavily on traits. A trait is used to associate properties with a type. For example, the properties of an iterator are defined by its iterator_traits (§33.1.3):

Click here to view code image

template<typename Iterator>
struct iterator_traits {
     using difference_type = typename Iterator::difference_type;
     using value_type = typename Iterator::value_type;
     using pointer = typename Iterator::pointer;
     using reference = typename Iterator::reference;
     using iterator_category = typename Iterator::iterator_category;
};
You can see a trait as a type function with many results or as a bundle of type functions.

The standard library provides allocator_traits (§34.4.2), char_traits (§36.2.2), iterator_traits (§33.1.3), regex_traits (§37.5), pointer_traits (§34.4.3). In addition, it provides time_traits (§35.2.4) and type_traits (§35.4.1), which confusingly are simple type functions.

Given iterator_traits for a pointer, we can talk about the value_type and the difference_type of a pointer even though pointers don’t have members:

Click here to view code image

template<typename Iter>
Iter search(Iter p, Iter q, typename iterator_traits<Iter>::value_type val)
{
      typename iterator_traits<Iter>::difference_type m = q–p;
       //...
}
This is a most useful and powerful technique, but:

• It is verbose.

• It often bundles otherwise weakly related type functions.

• It exposes implementation details to users.

Also, people sometimes throw in type aliases “just in case,” leading to unneccesary complexity. Consequently, I prefer to use simple type functions:

Click here to view code image

template<typename T>
    using Value_type = typename std::iterator_traits<T>::value_type;

template<typename T>
    using Difference_type = typename std::iterator_traits<T>::difference_type;

template<typename T>
    using Iterator_category= typename std::iterator_traits<T>::iterator_category;
The example cleans up nicely:

Click here to view code image

template<typename Iter>
Iter search(Iter p, Iter q, Value_type<Iter> val)
{
      Difference_type<Iter> m = q–p;
       //...
}
I suspect that traits are currently overused. Consider how to write the previous example without any mention of traits or other type functions:

Click here to view code image

template<typename Iter, typename Val>
Iter search(Iter p, Iter q, Val val)
{
      auto x = *p;                                 // if we don't need to name *p's type
      auto m = q–p;                                // if we don't need to name q-p's type

      using value_type = decltype(*p);             // if we want to name *p's type
      using difference_type = decltype(q–p);       // if we want to name q-p's type

      //...
}
Of course, decltype() is a type function, so all I did was to eliminate user-defined and standard-library type functions. Also, auto and decltype are new in C++11, so older code could not have been written this way.

We need a trait (or equivalent, such as decltype()) to associate a type with another type, such as a value_type with a T*. For that, a trait (or an equivalent) is indispensable for non-intrusively adding type names needed for generic programming or metaprogramming. When a trait is used simply to provide a name for something that already has a perfectly good name, such as pointer for value_type* and reference for value_type&, the utility is less clear and the potential for confusion greater. Don’t blindly define traits for everything “just in case.”

28.3. Control Structures
To do general computation at compile time, we need selection and recursion.

28.3.1. Selection
In addition to what is trivially done using ordinary constant expressions (§10.4), I use:

• Conditional: a way of choosing between two types (an alias for std::conditional)

• Select: a way of choosing among several types (defined in §28.3.1.3)

These type functions return types. If you want to choose among values, ?: is sufficient; Conditional and Select are for selecting types. They are not simply compile-time equivalents to if and switch even though they can appear to be when they are used to choose among function objects (§3.4.3, §19.2.2).

28.3.1.1. Selecting between Two Types
It is surprisingly simple to implement Conditional, as used in §28.2. The conditional template is part of the standard library (in <type_traits>), so we don’t have to implement it, but it illustrates an important technique:

Click here to view code image

template<bool C, typename T, typename F>   // general template
struct conditional {
     using type = T;
};

template<typename T, typename F>          // specialization for false
struct conditional<false,T,F> {
     using type = F;
};
The primary template (§25.3.1.1) simply defines its type to be T (the first template parameter after the condition). If the condition is not true, the specialization for false is chosen and type is defined to be F. For example:

typename conditional<(std::is_polymorphic<T>::value),X,Y>::type z;
Obviously, the syntax leaves a bit to be desired (§28.2.2), but the underlying logic is beautiful.

Specialization is used to separate the general case from one or more specialized ones (§25.3). In this example, the primary template takes care of exactly half of the functionality, but that fraction can vary from nothing (every nonerroneous case is handled by a specialization; §25.3.1.1) to all but a single terminating case (§28.5). This form of selection is completely compile-time and doesn’t cost a byte or a cycle at run time.

To improve the syntax, I introduce a type alias:

Click here to view code image

template<bool B, typename T, typename F>
using Conditional = typename std::conditional<B,T,F>::type;
Given that, we can write:

Conditional<(Is_polymorphic<T>()),X,Y> z;
I consider that a significant improvement.

28.3.1.2. Compile Time vs. Run Time
Looking at something like

Conditional<(std::is_polymorphic<T>::value),X,Y> z;
for the first time, it is not uncommon for people to think, “Why don’t we just write a normal if?” Consider having to choose between two alternatives, Square and Cube:

Click here to view code image

struct Square {
     constexpr int operator()(int i) { return i*i; }
};

struct Cube {
     constexpr int operator()(int i) { return i*i*i; }
};
We might try the familiar if-statement:

Click here to view code image

if (My_cond<T>())
      using Type = Square;    // error: declaration as if-statement branch
else
      using Type = Cube;      // error: declaration as if-statement branch

Type x;   // error: Type is not in scope
A declaration cannot be the only statement of a branch of an if-statement (§6.3.4, §9.4.1), so this will not work even though My_cond<T>() is computed at compile time. Thus, an ordinary if-statement is useful for ordinary expressions, but not for type selection.

Let us try an example that doesn’t involve defining a variable:

Conditional<(My_cond<T>()),Square,Cube>{}(99);  // invoke Square{}(99) or Cube{}(99)
That is, select a type, construct a default object of that type, and call it. That works. Using “conventional control structures,” this would become:

((My_cond<T>())?Square:Cube){}(99);
This example doesn’t work because Square and Cube are types, rather than values of types that are compatible in a conditional expression (§11.1.3). We could try

(My_cond<T>()?Square{}:Cube{})(99);    // error: incompatible arguments for ?:
Unfortunately, this version suffers from the problem that Square{} and Cube{} are not of compatible types acceptable as alternatives in a ?: expression. The restriction to compatible types is often unacceptable in metaprogramming because we need to choose between types that are not explicitly related.

Finally, this works:

My_cond<T>()?Square{}(99):Cube{}(99);
Furthermore, it is not significantly more readable than

Conditional<(My_cond<T>()),Square,Cube>{}(99);
28.3.1.3. Selecting among Several Types
Selecting among N alternatives is very similar to choosing between two. Here is a type function returning its Nth argument type:

Click here to view code image

class Nil {};

template<int I, typename T1 =Nil, typename T2 =Nil, typename T3 =Nil, typename T4 =Nil>
struct select;

template<int I, typename T1 =Nil, typename T2 =Nil, typename T3 =Nil, typename T4 =Nil>
using Select = typename select<I,T1,T2,T3,T4>::type;

 // Specializations for 0-3:

template<typename T1, typename T2, typename T3, typename T4>
struct select<0,T1,T2,T3,T4> { using type = T1; };  // specialize for N==0

template<typename T1, typename T2, typename T3, typename T4>
struct select<1,T1,T2,T3,T4> { using type = T2; };  // specialize for N==1

template<typename T1, typename T2, typename T3, typename T4>
struct select<2,T1,T2,T3,T4> { using type = T3; };  // specialize for N==2

template<typename T1, typename T2, typename T3, typename T4>
struct select<3,T1,T2,T3,T4> { using type = T4; };  // specialize for N==3
The general version of select should never be used, so I didn’t define it. I chose zero-based numbering to match the rest of C++. This technique is perfectly general: such specializations can present any aspect of the template arguments. We don’t really want to pick a maximum number of alternatives (here, four), but that problem can be addressed using variadic templates (§28.6). The result of picking a nonexisting alternative is to use the primary (general) template. For example:

Select<5,int,double,char> x;
In this case, that would lead to an immediate compile-time error as the general Select isn’t defined.

A realistic use would be to select the type for a function returning the Nth element of a tuple:

Click here to view code image

template<int N, typename T1, typename T2, typename T3, typename T4>
Select<N,T1,T2,T3,T4>& get(Tuple<T1,T2,T3,T4>& t);    // see §28.5.2

auto x = get<2>(t);  // assume that t is a Tuple
Here, the type of x will be whatever T3 is for the Tuple called t. Indexing into tuples is zero-based.

Using variadic templates (§28.6), we can provide a far simpler and more general select:

Click here to view code image

template<unsigned N, typename... Cases>    // general case; never instantiated
struct select;

template<unsigned N, typename T, typename... Cases>
struct select<N,T,Cases...> :select<N–1,Cases...> {
};

template<typename T, typename... Cases>    // final case: N==0
struct select<0,T,Cases...> {
   using type = T;
};

template<unsigned N, typename... Cases>
using Select = typename select<N,Cases...>::type;
28.3.2. Iteration and Recursion
The basic techniques for calculating a value at compile time can be illustrated by a factorial function template:

template<int N>
constexpr int fac()
{
    return N*fac<N–1>();
}

template<>
constexpr int fac<1>()
{
    return 1;
}

constexpr int x5 = fac<5>();
The factorial is implemented using recursion, rather than using a loop. Since we don’t have variables at compile time (§10.4), that makes sense. In general, if we want to iterate over a set of values at compile time, we use recursion.

Note the absence of a condition: there is no N==1 or N<2 test. Instead, the recursion is terminated when the call of fac() selects the specialization for N==1. In template metaprogramming (as in functional programming), the idiomatic way of working your way through a sequence of values is to recurse until you reach a terminating specialization.

In this case, we could also do the computation in the more conventional way:

constexpr int fac(int i)
{
    return (i<2)?1:i*fac(i–1);
}

constexpr int x6 = fac(6);
I find this clearer than the function template expression of the idea, but tastes vary and there are algorithms that are best expressed by separating the terminating case from the general case. The non-template version is marginally easier for a compiler to handle. The run-time performance will, of course, be identical.

The constexpr version can be used for both compile-time and run-time evaluation. The template (metaprogramming) version is for compile-time use only.

28.3.2.1. Recursion Using Classes
Iteration involving more complicated state or more elaborate parameterization can be handled using classes. For example, the factorial program becomes:

Click here to view code image

template<int N>
struct Fac {
     static const int value = N*Fac<N–1>::value;
};

template<>
struct Fac<1> {
     static const int value = 1;
};

constexpr int x7 = Fac<7>::value;
For a more realistic example, see §28.5.2.

28.3.3. When to Use Metaprogramming
Using the control structures described here, you can compute absolutely everything at compile time (translation limits permitting). The question remains: Why would you want to? We should use these techniques if and when they yield cleaner, better-performing, and easier-to-maintain code than alternative techniques. The most obvious constraint on metaprogramming is that code depending on complicated uses of templates can be hard to read and very hard to debug. Nontrivial uses of templates can also impact compile times. If you have a hard time understanding what is going on in code requiring complicated patterns of instantiation, so might the compiler. Worse still, so may the programmer who gets to maintain your code.

Template metaprogramming attracts clever people:

• Partly, that’s because metaprogramming allows us to express things that simply can’t be done at the same level of type safety and run-time performance. When the improvements are significant and the code maintainable, these are good – sometimes even compelling – reasons.

• Partly, that’s because metaprogramming allows us to show off our cleverness. Obviously, that is to be avoided.

How would you know that you have gone too far with metaprogramming? One warning sign that I use is an urge to use macros (§12.6) to hide “details” that have become too ugly to deal with directly. Consider:

#define IF(c,x,y) typename std::conditional<(c),x,y>::type
Is this going too far? It allows us to write

IF(cond,Cube,Square) z;
rather than

typename std::conditional<(cond),Cube,Square>::type z;
I have biased the question by using the very short name IF and the long form std::conditional.

Similarly, a more complex condition would almost equalize the number of characters used. The fundamental difference is that I have to write typename and ::type to use the standard’s terminology. That exposes the template implementation technique. I would like to hide that, and the macro does. However, if many people need to collaborate and programs get large, a bit of verbosity is preferable to a divergence of notations.

Another serious argument against the IF macro is that its name is misleading: conditional is not a “drop-in replacement” for a conventional if. That ::type represents a significant difference: conditional selects between types; it does not directly alter control flow. Sometimes it is used to select a function and thus represent a branch in a computation; sometimes it is not. The IF macro hides an essential aspect of its function. Similar objections can be leveled at many other “sensible” macros: they are named for some programmer’s particular idea of their use, rather than reflecting fundamental functionality.

In this case, the problems of verbosity, of the implementation details leaking out, and of poor naming are easily handled by a type alias (Conditional; §28.2.1). In general, look hard for ways to clean up the syntax presented to users without inventing a private language. Prefer systematic techniques, such as specialization and the use of aliases, to macro hackery. Prefer constexpr functions to templates for compile-time computation, and hide template metaprogramming implementation details in constexpr functions whenever feasible (§28.2.2).

Alternatively, we can look at the fundamental complexity of what we are trying to do:

[1] Does it require explicit tests?

[2] Does it require recursion?

[3] Can we write concepts (§24.3) for our template arguments?

If the answer to question [1] or [2] is “yes” or the answer to question [3] is “no,” we should consider whether there may be maintenance problems. Maybe some form of encapsulation is possible? Remember that complexities of a template implementation become visible to users (“leak out”) whenever an instantiation fails. Also, many programmers do look into header files where every detail of a metaprogram is immediately exposed.

28.4. Conditional Definition: Enable_if
When we write a template, we sometimes want to provide an operation for some template arguments, but not for others. For example:

Click here to view code image

template<typename T>
class Smart_pointer {
      //...
     T& operator*();      // return reference to whole object
     T* operator–>();     // select a member (for classes only)
      //...
};
If T is a class, we should provide operator–>(), but if T is a built-in type, we simply cannot do so (with the usual semantics). Therefore, we want a language mechanism for saying, “If this type has this property, define the following.” We might try the obvious:

Click here to view code image

template<typename T>
class Smart_pointer {
      //...
     T& operator*();                       // return reference to whole object
     if (Is_class<U>()) U* operator–>();   // syntax error
      //...
};
However, that does not work. C++ does not provide an if that can select among definitions based on a general condition. But, as with Conditional and Select (§28.3.1), there is a way. We can write a somewhat curious type function to make the definition of operator–>() conditional. The standard library (in <type_traits>) provides enable_if for that. The Smart_pointer example becomes:

Click here to view code image

template<typename T>
class Smart_pointer {
      //...
     T& operator*();                              // return reference to whole object
     template<typename U = T>                     // weird wor karound to enable SFINAE
     Enable_if<Is_class<T>(),T>* operator–>();    // select a member (for classes only)
      //...
};
As usual, I have used type aliases and constexpr functions to simplify the notation:

Click here to view code image

template<bool B, typename T=void>
using Enable_if = typename std::enable_if<B,T>::type;

template<typename T> constexpr bool Is_class()
{
    return std::is_class<T>::value;
}
If Enable_if’s condition evaluates to true, its result is its second argument (here, T). If Enable_if’s condition evaluates to false, the whole function declaration of which it is part is completely ignored. In this case, if T is a class, we get a definition of operator–>() returning a T*, and if it is not, we don’t declare anything.

Given the definition of Smart_pointer using Enable_if, we get:

Click here to view code image

void f(Smart_pointer<double> p, Smart_pointer<complex<double>> q)
{
    auto d0 = *p;             // OK
    auto c0 = *q;             // OK
    auto d1 = q–>real();      // OK
    auto d2 = p–>real();      // error: p doesn't point to a class object
     //...
}
You may consider Smart_pointer and operator–>() exotic, but providing (defining) operations conditionally is very common. The standard library provides many examples of conditional definition, such as Alloc::size_type (§34.4.2) and pair being movable if both of their elements are (§34.2.4.1). The language itself defines –> only for pointers to class objects (§8.2).

In this case, the elaboration of the declaration of operator–>() with Enable_if simply changes the kind of error we get from examples, such as p–>real():

• If we unconditionally declare operator–>(), we get a “–> used on a non-class pointer” error at instantiation time for the definition of Smart_pointer<double>::operator–>().

• If we conditionally declare operator–>() using Enable_if, if we use –> on a Smart_ptr<double>, we get a “Smart_ptr<double>::operator–>() not defined” error at the point of use of Smart_ptr<double>::operator–>().

In either case, we do not get an error unless we use –> on a Smart_ptr<T> where T is not a class.

We have moved the error detection and reporting from the implementation of Smart_pointer<T>::operator–>() to its declaration. Depending on the compiler and especially on how deep in a nest of template instantiations the error happens, this can make a significant difference. In general, it is preferable to specify templates precisely so as to detect errors early rather than relying on bad instantiations being caught. In this sense, we can see Enable_if as a variant of the idea of a concept (§24.3): it allows a more precise specification of the requirements of a template.

28.4.1. Use of Enable_if
For many uses, the functionality of enable_if is pretty ideal. However, the notation we have to use is often awkward. Consider:

Enable_if<Is_class<T>(),T> *operator–>();
The implementation shows through rather dramatically. However, what is actually expressed is pretty close to the minimal ideal:

declare_if (Is_class<T>()) T* operator–>();    // not C++
However, C++ does not have a declare_if construct for selecting declarations.

Using Enable_if to decorate the return type places it up front where you can see it and where it logically belongs, because it affects the whole declaration (not just the return type). However, some declarations do not have a return type. Consider two of vector’s constructors:

Click here to view code image

template<typename T>
class vector {
public:
     vector(size_t n, const T& val);  // n elements of type T with value val

     template<typename Iter>
         vector(Iter b, Iter e);  // initialize from [b:e)
      //...
};
This looks innocent enough, but the constructor taking a number of elements wreaks its usual havoc. Consider:

vector<int> v(10,20);
Is that 10 elements with the value 20 or an attempt to initialize from [10:20]? The standard requires the former, but the code above would naively pick the latter because an int-to-size_t conversion is required for the first constructor whereas the pair of ints is a perfect match for the template constructor. The problem is that I “forgot” to tell the compiler that the Iter type should be an iterator. However, that can be done:

Click here to view code image

template<typename T>
class vector<T> {
public:
     vector(size_t n, const T& val);    // n elements of type T with value val

     template<typename Iter, typename =Enable_if<Input_iterator<Iter>(),>>
         vector(Iter b, Iter e);       // initialize from [b:e)
      //...
};
That (unused) default template argument will be instantiated because we certainly can’t deduce that unused template parameter. This implies that the declaration of vector(Iter,Iter) will fail unless Iter is an Input_iterator (§24.4.4).

I introduced the Enable_if as a default template argument because that is the most general solution. It can be used for templates without arguments and/or without return types. However, in this case, we could alternatively apply it to the constructor argument type:

Click here to view code image

template<typename T>
class vector<T> {
public:
     vector(size_t n, const T& val);      // n elements of type T with value val

     template<typename Iter>
         vector(Enable_if<Input_iterator<Iter>(),Iter> b, Iter e);        // initialize from [b:e)
      //...
};
The Enable_if techniques work for template functions (including member functions of class templates and specializations) only. The implementation and use of Enable_if rely on a detail in the rules for overloading function templates (§23.5.3.2). Consequently, it cannot be used to control declarations of classes, variables, or non-template functions. For example:

Click here to view code image

Enable_if<(version2_2_3<config),My_struct>* make_default()  // error: not a template
{
     return new My_struct{};
}

template<typename T>
void f(const T& x)
{
     Enable_if<!(20<sizeof(T)),T> tmp = x;             // error: tmp is not a function
     Enable_if<(20<sizeof(T)),T&> tmp = *new T{x};   // error: tmp is not a function
      //...
}
For tmp, using obj_holder (§28.2) would almost certainly be cleaner anyway: if you had managed to construct that free-store object, how would you delete it?

28.4.2. Implementing Enable_if
The implementation of Enable_if is almost trivial:

Click here to view code image

template<bool B, typename T = void>
struct std::enable_if {
     typedef T type;
};

template<typename T>
struct std::enable_if<false, T> {};      // no ::type if B==false

template<bool B, typename T = void>
using Enable_if = typename std::enable_if<B,T>::type;
Note that we can leave out the type argument and get void by default.

For a language-technical explanation of how these simple declarations become useful as a fundamental construct see §23.5.3.2.

28.4.3. Enable_if and Concepts
We can use Enable_if for a wide variety of predicates, including many tests of type properties (§28.3.1.1). Concepts are among the most general and useful predicates we have. Ideally, we would like to overload based on concepts, but lacking language support for concepts, the best we can do is to use Enable_if to select based on constraints. For example:

Click here to view code image

template<typename T>
Enable_if<Ordered<T>()> fct(T*,T*) { /* optimized implementation */ }

template<typename T>
Enable_if<!Ordered<T>()> fct(T*,T*) { /* nonoptimized implementation */ }
Note that Enable_if defaults to void, so fct() is a void function. I’m not sure that using that default increases readability, but we can use fct() like this:

Click here to view code image

void f(vector<int>& vi, vector<complex<int>>& vc)
{
     if (vi.size()==0 || vc.size()==0) throw runtime_error("bad fct arg");
     fct(&vi.front(),&vi.back());             // call optimized
     fct(&vc.front(),&vc.back());             // call nonoptimized
}
These calls are resolved as described because we can use < for an int but not for a complex<int>. Enable_if resolves to void if we don’t provide a type argument.

28.4.4. More Enable_if Examples
When using Enable_if, sooner or later we want to ask if a class has a member with a specific name and an appropriate type. For many of the standard operations, such as constructors and assignments, the standard library provides a type property predicate, such as is_copy_assignable and is_default_constructible (§35.4.1). However, we can build our own predicates. Consider the question “Can we call f(x) if x is of type X?” Defining has_f to answer that question gives an opportunity to demonstrate some of the techniques used and some of the scaffolding/boilerplate code provided internally in many template metaprogramming libraries (including parts of the standard library). First, define the usual class plus specialization to represent an alternative:

Click here to view code image

struct substitution_failure { };  // represent a failure to declare something

template<typename T>
struct substitution_succeeded : std::true_type
{ };

template<>
struct substitution_succeeded<substitution_failure> : std::false_type
{ };
Here, substitution_failure is used to represent a substitution failure (§23.5.3.2). We derive from std::true_type unless the argument type is substitution_failure. Obviously, std::true_type and std::false_type are types that represent the values true and false, respectively:

std::true_type::value == true
std::false_type::value == false
We use substitution_succeeded to define the type functions we really want. For example, we might be looking for a function f that we can call as f(x). For that, we can define has_f:

Click here to view code image

template<typename T>
struct has_f
   : substitution_succeeded<typename get_f_result<T>::type>
{};
So, if get_f_result<T> yields a proper type (presumably the return type of a call of f), has_f::value is true_type::value, which is true. If get_f_result<T> doesn’t compile, it returns substitution_failure and has_f::value is false.

So far, so good, but how do we get get_f_result<T> to be substitution_failure if somehow f(x) doesn’t compile for a value x of type X? The definition that achieves that looks innocent enough:

Click here to view code image

template<typename T>
struct get_f_result {
private:
     template<typename X>
         static auto check(X const& x) –> decltype(f(x));    // can call f(x)
     static substitution_failure check(...);                 // cannot call f(x)
public:
     using type = decltype(check(std::declval<T>()));
};
We simply declare a function check so that check(x) has the same return type as f(x). Obviously, that won’t compile unless we can call f(x). So, that declaration of check fails if we can’t call f(x). In that case, because substitution failure is not an error (SFINAE; §23.5.3.2), we get the second definition of check(), which has substitution_failure as its return type. And, yes, this elaborate piece of trickery fails if our function f was declared to return a substitution_failure.

Note that decltype() does not evaluate its operand.

We managed to turn what looked like a type error into the value false. It would have been simpler if the language had provided a primitive (built-in) operation for doing that conversion; for example:

is_valid(f(x));    // can f(x) be compiled?
However, a language cannot provide everything as a language primitive. Given the scaffolding code, we just have to provide conventional syntax:

template<typename T>
constexpr bool Has_f()
{
    return has_f<T>::value;
}
Now, we can write:

Click here to view code image

template<typename T>
class X {
      //...
     template<typename U = T<
     Enable_if<Has_f<U>()> use_f(const U& t)
     {
           //...
          f(t);
           //...
     }
      //...
};
X<T> has a member use_f() if and only if f(t) can be called for a T value t.

Note that we cannot simply write:

if (Has_f<decltype(t)>()) f(t);
The call f(t) will be type checked (and fail type checking) even if Has_f<decltype(t)>() returns false.

Given the technique used to define Has_f, we can define Has_foo for any operation or member foo we can think of. The scaffolding is 14 lines of code for each foo. This can get repetitive but is not difficult.

This implies that Enable_if<> allows us to choose among overloaded templates based on just about any logical criteria for argument types. For example, we can define a Has_not_equals() type function to check if != is available and use it like this:

Click here to view code image

template<typename Iter, typename Val>
Enable_if<Has_not_equals<Iter>(),Iter> find(Iter first, Iter last, Val v)
{
     while (first!=last && !(*first==v))
           ++first;
     return first;
}
template<typename Iter, typename Val>
Enable_if<!Has_not_equals<Iter>(),Iter> find(Iter first, Iter last, Val v)
{
     while (!(first==last) && !(*first==v))
           ++first;
     return first;
}
Such ad hoc overloading easily gets messy and unmanageable. For example, try adding versions that use != for the value comparison (that is, *first!=v, rather than !(*first==v)), when possible. Consequently, I recommend relying on the more structured standard overloading rules (§12.3.1) and specialization rules (§25.3) when there is a choice. For example:

Click here to view code image

template<typename T>
auto operator!=(const T& a, const T& b) –> decltype(!(a==b))
{
     return !(a==b);
}
The rules ensure that if a specific != has already been defined for a type T (as a template or as a non-template function), this definition will not be instantiated. I use decltype() partly to show how in general to derive the return type from a previously defined operator, and partly to handle the rare cases where != returns something different from bool.

Similarly, we can conditionally define >, <=, >=, etc., given a <.

28.5. A Compile-Time List: Tuple
Here, I’ll demonstrate the basic template metaprogramming techniques in a single simple, but realistic, example. I will define a Tuple with an associated access operation and an output operation. Tuples defined like this have been used industrially for more than a decade. The more elegant and more general std::tuple is presented in §28.6.4 and §34.2.4.2.

The idea is to allow code like this:

Tuple<double, int, char> x {1.1, 42, 'a'};
cout << x << "\n";
cout << get<1>(x) << "\n";
The resulting output is:

{ 1.1, 42, 'a'}
42
The definition of Tuple is fundamentally simple:

Click here to view code image

template<typename T1=Nil, typename T2=Nil, typename T3=Nil, typename T4=Nil>
struct Tuple : Tuple<T2, T3, T4> {  // layout: {T2,T3,T4} before T1
     T1 x;

     using Base = Tuple<T2, T3, T4>;
     Base* base() { return static_cast<Base*>(this); }
     const Base* base() const { return static_cast<const Base*>(this); }

     Tuple(const T1& t1, const T2& t2, const T3& t3, const T4& t4) :Base{t2,t3,t4}, x{t1} { }
};
So, a Tuple of four elements (often referred to as a 4-tuple) is a Tuple of three elements (a 3-tuple) followed by a fourth element.

We construct a Tuple of four elements with a constructor that takes four values (potentially of four different types). It uses its last three elements (its tail) to initialize its base 3-tuple and the first (its head) to initialize its member x.

Manipulation of the tail of a Tuple – that is of the base class of the Tuple – is important and common in the implementation of the Tuple. Consequently, I provided an alias Base and a pair of member functions base() to simplify manipulation of the base/tail.

Obviously, this definition handles only tuples that really have four elements. Furthermore, it leaves much of the work to the 3-tuple. Tuples with fewer than four elements are defined as specializations:

Click here to view code image

template<>
struct Tuple<> { Tuple() {} };            //0-tuple

template<typename T1>
struct Tuple<T1> : Tuple<> {              //1-tuple
     T1 x;

     using Base = Tuple<>;
     Base* base() { return static_cast<Base*>(this); }
     const Base* base() const { return static_cast<const Base*>(this); }

     Tuple(const T1& t1) :Base{}, x{t1} { }
};

template<typename T1, typename T2>
struct Tuple<T1, T2> : Tuple<T2> {       //2-tuple, layout: T2 before T1
     T1 x;

     using Base = Tuple<T2>;
     Base* base() { return static_cast<Base*>(this); }
     const Base* base() const { return static_cast<const Base*>(this); }

     Tuple(const T1& t1, const T2& t2) :Base{t2}, x{t1} { }
};

template<typename T1, typename T2, typename T3>
struct Tuple<T1, T2, T3> : Tuple<T2, T3> {      //3-tuple, layout: {T2,T3} before T1
     T1 x;
     using Base = Tuple<T2, T3>;
     Base* base() { return static_cast<Base*>(this); }
     const Base* base() const { return static_cast<const Base* >(this); }

     Tuple(const T1& t1, const T2& t2, const T3& t3) :Base{t2, t3}, x{t1} { }
};
These declarations are rather repetitive and follow the simple pattern of the first Tuple (the 4-tuple). That definition of a 4-tuple, Tuple, is the primary template and provides the interface to Tuples of all sizes (0, 1, 2, 3, and 4). That is why I had to provide those Nil default template arguments. In fact, they will never be used. Specialization will choose one of the simpler Tuples rather than use Nil.

The way I defined Tuple as a “stack” of derived classes is fairly conventional (e.g., std::tuple is defined similarly; §28.6.4). It has the curious effect that the first element of a Tuple will (given the usual implementation techniques) get the highest address and that the last element will have the same address as the whole Tuple. For example:

Tuple<double,string,int,char>{3.14,"Bob",127,'c'}
can be graphically represented like this:


This opens some interesting optimization possibilities. Consider:

class FO { /* function object with no data members */ };

typedef Tuple<int*, int*> T0;
typedef Tuple<int*,FO> T1;
typedef Tuple<int*, FO, FO> T2;
On my implementation, I got sizeof(T0)==8, sizeof(T1)==4, and sizeof(T2)==4 as the compiler optimizes away the empty base classes. This is called the empty-base optimization and is guaranteed by the language (§27.4.1).

28.5.1. A Simple Output Function
The definition of Tuple has a nice regular, recursive structure that we can use to define a function for displaying the list of elements. For example:

Click here to view code image

template<typename T1, typename T2, typename T3, typename T4>
void print_elements(ostream& os, const Tuple<T1,T2,T3,T4>& t)
{
     os << t.x << ", ";             // t's x
     print_elements(os,*t.base());
}

template<typename T1, typename T2, typename T3>
void print_elements(ostream& os, const Tuple<T1,T2,T3>& t)
{
     os << t.x << ", ";
     print_elements(os,*t.base());
}

template<typename T1, typename T2>
void print_elements(ostream& os, const Tuple<T1,T2>& t)
{
     os << t.x << ", ";
     print_elements(os,*t.base());
}

template<typename T1>
void print_elements(ostream& os, const Tuple<T1>& t)
{
     os << t.x;
}

template<>
void print_elements(ostream& os, const Tuple<>& t)
{
     os << " ";
}
The similarity of the print_elements() for the 4-tuple, 3-tuple, and 2-tuple hints at a better solution (§28.6.4), but for now I’ll just use these print_elements() to define a << for Tuples:

Click here to view code image

template<typename T1, typename T2, typename T3, typename T4>
ostream& operator<<(ostream& os, const Tuple<T1,T2,T3,T4>& t)
{
     os << "{ ";
     print_elements(os,t);
     os << " }";
     return os;
}
We can now write:

Click here to view code image

Tuple<double, int, char> x {1.1, 42, 'a'};
cout << x << "\n";

cout << Tuple<double,int,int,int>{1.2,3,5,7} << "\n";
cout << Tuple<double,int,int>{1.2,3,5} << "\n";
cout << Tuple<double,int>{1.2,3} << "\n";
cout << Tuple<double>{1.2} << "\n";
cout << Tuple<>{} << "\n";
Unsurprisingly, the output is:

{ 1.1, 42, a }
{ 1.2,3,5,7 }
{ 1.2,3,5 }
{ 1.2,3 }
{ 1.2 }
{ }
28.5.2. Element Access
As defined, Tuple has a variable number of elements of potentially differing types. We would like to access those elements efficiently and without the possibility of type system violations (i.e., without using casts). We can imagine a variety of schemes, such as naming the elements, numbering the elements, and accessing elements by recursing though the elements until we reach a desired element. The last alternative is what we will use to implement the most common access strategy: index the elements. In particular, I want to implement a way to subscript a tuple. Unfortunately, I am unable to implement an appropriate operator[], so I use a function template get():

Click here to view code image

Tuple<double, int, char> x {1.1, 42, 'a'};

cout << "{ "
     << get<0>(x) << ", "
     << get<1>(x) << ", "
     << get<2>(x) << " }\n";   // write { 1.1, 42, a }

auto xx = get<0>(x);  // xx is a double
The idea is to index the elements, starting from 0, in such a way that the element selection is done at compile time and we preserve all type information.

The get() function constructs an object of type getNth<T,int>. The job of getNth<X,N> is to return a reference to the Nth element, which is assumed to have type X. Given such a helper, we can define get():

Click here to view code image

template<int N, typename T1, typename T2, typename T3, typename T4>
Select<N, T1, T2, T3, T4>& get(Tuple<T1, T2, T3, T4>& t)
{
     return getNth<Select<N, T1, T2, T3, T4>,N>::get(t);
}
The definition of getNth is a variant of the usual recursion from N down to the specialization for 0:

Click here to view code image

template<typename Ret, int N>
struct getNth {          // getNth() remembers the type (Ret) of the Nth element
     template<typename T>
     static Ret& get(T& t)      // get the value element N from t's Base
     {
          return getNth<Ret,N–1>::get(*t.base());
     }
};
template<typename Ret>
struct getNth<Ret,0> {
     template<typename T>
     static Ret& get(T& t)
     {
          return t.x;
     }
};
Basically, getNth is a special-purpose for-loop, implemented by recursing N–1 times. The member functions are static because we don’t really want any objects of class getNth. That class is only used as a place to hold Ret and N in a way that allows the compiler to use them.

This is quite a bit of scaffolding to index into a Tuple, but at least the resulting code is type-safe and efficient. By “efficient,” I mean that given a reasonably good compiler (as is common), there is no run-time overhead for accessing a Tuple member.

Why must we write get<2>(x) rather than just x[2]? We could try:

template<typename T>
constexpr auto operator[](T t,int N)
{
     return get<N>(t);
}
Unfortunately, this does not work:

• operator[]() must be a member, but we could handle that by defining it within Tuple.

• Inside operator[](), the argument N is not known to be a constant expression.

• I “forgot” that only lambdas can deduce their result type from their return-statement (§11.4.4), but that could be handled by adding a –>decltype(get<N>(t)).

To get that, we need some language lawyering and for now, we have to make do with get<2>(x).

28.5.2.1. const Tuples
As defined, get() works for non-const Tuple elements and can be used on the left-hand side of assignments. For example:

Tuple<double, int, char> x {1.1, 42, 'a'};

get<2>(x) = 'b';     // OK
However, it can’t be used for consts:

Click here to view code image

const Tuple<double, int, char> xx {1.1, 42, 'a'};

get<2>(xx) = 'b';         // error: xx is const
char cc = get<2>(xx);     // error: xx is const (surprise?)
The problem is that get() takes its argument by non-const reference. But xx is a const, so it is not an acceptable argument.

Naturally, we also want to be able to have const Tuples. For example:

Click here to view code image

const Tuple<double, int, char> xx {1.1, 422, 'a'};
char cc = get<2>(xx);                // OK: reading from const
cout << "xx: " << xx << "\n";
get<2>(xx) = 'x';                    // error: xx is const
To handle const Tuples, we have to add const versions of get() and getNth’s get(). For example:

Click here to view code image

template<typename Ret, int N>
struct getNth {         // getNth() remembers the type (Ret) of the Nth element
     template<typename T>
     static Ret& get(T& t)    // get the value element N from t's Base
     {
            return getNth<Ret,N–1>::get(*t.base());
     }

     template<typename T>
     static const Ret& get(const T& t)       // get the value element N from t's Base
     {
            return getNth<Ret,N–1>::get(*t.base());
     }
};

template<typename Ret>
struct getNth<Ret,0> {
     template<typename T> static Ret& get(T& t) { return t.x; }
     template<typename T> static const Ret& get(const T& t) { return t.x; }
};

template<int N, typename T1, typename T2, typename T3, typename T4>
Select<N, T1, T2, T3, T4>& get(Tuple<T1, T2, T3, T4>& t)
{
     return getNth<Select<N, T1, T2, T3, T4>,N>::get(t);
}

template<int N, typename T1, typename T2, typename T3, typename T4>
const Select<N, T1, T2, T3, T4>& get(const Tuple<T1, T2, T3, T4>& t)
{
     return getNth<Select<N, T1, T2, T3, T4>,N>::get(t);
}
Now, we can handle both const and non-const arguments.

28.5.3. make_tuple
A class template cannot deduce its template arguments, but a function template can deduce them from its function arguments. This implies that we can make a Tuple type implicit in code by having a function construct it for us:

Click here to view code image

template<typename T1, typename T2, typename T3, typename T4>
Tuple<T1, T2, T3, T4> make_tuple(const T1& t1, const T2& t2, const T3& t3, const T4& t4)
{
     return Tuple<T1, T2, T3, T4>{t1, t2, t3,t4};
}

 //... and the other four make_tuples ...
Given make_tuple(), we can write:

auto xxx = make_tuple(1.2,3,'x',1223);
cout << "xxx: " << xxx << "\n";
Other useful functions, such as head() and tail(), are easily implemented. The standard-library tuple provides a few such utility functions (§28.6.4).

28.6. Variadic Templates
Having to deal with an unknown number of elements is a common problem. For example, an error-reporting function may take between zero and ten arguments, a matrix may have between one and ten dimensions, and a tuple can have zero to ten elements. Note that in the first and the last example, the elements may not necessarily be of the same type. In most cases, we would prefer not to deal with each case separately. Ideally, a single piece of code should handle the cases for one element, two elements, three elements, etc. Also, I pulled the number ten out of a hat: ideally, there should be no fixed upper limit on the number of elements.

Over the years, many solutions have been found. For example, default arguments (§12.2.5) can be used to allow a single function to accept a variable number of arguments, and function overloading (§12.3) can be used to provide a function for each number of arguments. Passing a single list of elements (§11.3) can be an alternative to having a variable number of arguments as long as the elements are all of the same type. However, to elegantly handle the case of an unknown number of arguments of unknown (and possibly differing) types, some additional language support is needed. That language feature is called a variadic template.

28.6.1. A Type-Safe printf()
Consider the archetypical example of a function needing an unknown number of arguments of a variety of types: printf(). As provided by the C and C++ standard libraries, printf() is flexible and performs nicely (§43.3). However, it is not extensible to user-defined types and not type-safe, and it is a popular target for hackers.

The first argument to printf() is a C-style string interpreted as a “format string.” Additional arguments are used as required by the format string. Format specifiers, such as %g for floating-point and %s for zero-terminated arrays of characters, control the interpretation of the additional arguments. For example:

Click here to view code image

printf("The value of %s is %g\n","x",3.14);
string name = "target";
printf("The value of %s is %P\n",name,Point{34,200});

printf("The value of %s is %g\n",7);
The first call of printf() works as intended, but the second call has two problems: the format specification %s refers to C-style strings, and printf() will not interpret the std::string argument correctly. Furthermore, there is no %P format and in general no direct way of printing values of user-defined types, such as Point. In the third call of printf(), I provided an int as the argument for %s and I “forgot” to provide an argument for %g. In general, a compiler is not able to compare the number and types of arguments required by the format string with the number and types of arguments provided by the programmer. The output of that last call (if any) would not be pretty.

Using variadic templates, we can implement an extensible and type-safe variant of printf(). As is common for compile-time programming, the implementation has two parts:

[1] Handle the case where there is just one argument (the format string).

[2] Handle the case where there is at least one “additional” argument that, suitably formatted, needs to output at an appropriate point indicated by the format string.

The simplest case is the one with only one argument, the format string:

Click here to view code image

void printf(const char* s)
{
     if (s==nullptr) return;

     while (*s) {
          if (*s=='%' && *++s!='%')  // make sure no more arguments are expected
                                     //%% represents plain % in a format string
                throw runtime_error("invalid format: missing arguments");
          std::cout << *s++;
     }
}
That prints out the format string. If a format specifier is found, this printf() throws an exception because there is no argument to be formatted. A format specifier is defined to be a % not followed by another % (%% is printf()’s notation for a % that does not start a type specifier). Note that *++s does not overflow even if a % is the last character in a string. In that case, *++s refers to the terminating zero.

That done, we must handle printf() with more arguments. Here is where a template, and in particular a variadic template, comes into play:

Click here to view code image

template<typename T, typename... Args>       // variadic template argument list: one or more arguments
void printf(const char* s, T value, Args... args)     // function argument list: two or more arguments

{
     while (s && * s) {
          if (*s=='%' &&*++s!='%') {            // a format specifier (ignore which one it is)
                std::cout << value;             // use first non-format argument
                return printf(++s, args...);    // do a recursive call with the tail of the argument list
          }
          std::cout << *s++;
     }
     throw std::runtime_error("extra arguments provided to printf");
}
This printf() finds and prints the first non-format argument, “peels off” that argument, and then calls itself recursively. When there are no more non-format arguments, it calls the first (simpler) printf(). Ordinary characters (i.e., not % formal specifiers) are simply printed.

The overloading of << replaces the use of the (possibly erroneous) “hint” in the format specifier. If an argument has a type for which << is defined, that argument is printed; otherwise, that call does not type check and the program will never run. A formatting character after a % is not used. I can imagine type-safe uses for such characters, but the purpose of this example is not to design the perfect printf() but to explain variadic templates.

The Args... defines what is called a parameter pack. A parameter pack is a sequence of (type/value) pairs from which you can “peel off” arguments starting with the first. When printf() is called with two or more arguments

void printf(const char* s, T value, Args... args);
is chosen, with the first argument as s, the second as value, and the rest (if any) bundled into the parameter pack args for later use. In the call printf(++s,args...) the parameter pack args is expanded so that the first element of args is selected as value and args is one element shorter than in the previous call. This carries on until args is empty, so that we call:

void printf(const char*);
If we really wanted to, we could check printf() format directives, such as %s. For example:

Click here to view code image

template<typename T, typename... Args>        // variadic template argument list: one or more arguments
void printf(const char* s, T value, Args... args)   // function argument list: two or more arguments
{
     while (s && *s) {
          if (*s=='%') {   // a format specifier or %%
                switch (*++s) {
                case '%':      // not format specifier
                      break;
                case 's':
                      if (!Is_C_style_string<T>() && !Is_string<T>())
                             throw runtime_error("Bad printf() format");
                      break;
                case 'd':
                      if (!Is_integral<T>()) throw runtime_error("Bad printf() format");
                      break;
                case 'g':
                      if (!Is_floating_point<T>()) throw runtime_error("Bad printf() format");
                      break;
                }
                std::cout << value;               // use first non-format argument
                return printf(++s, args...);      // do a recursive call with the tail of the argument list
          }
          std::cout <<*s++;

     }
     throw std::runtime_error("extra arguments provided to printf");
}
The standard library provides std::is_integral and std::is_floating_point, but you’d have to craft Is_C_style_string yourself.

28.6.2. Technical Details
If you are familiar with functional programming, you should find the printf() example (§28.6) an unusual notation for a pretty standard technique. If not, here are minimal technical examples that might help. First, we can declare and use a simple variadic template function:

Click here to view code image

template<typename... Types>
void f(Types... args);    // variadic template function
That is, f() is a function that can be called with an arbitrary number of arguments of arbitrary types:

Click here to view code image

f();                   // OK: args contains no arguments
f(1);                  // OK: args contains one argument: int
f(2, 1.0);             // OK: args contains two arguments: int and double
f(2, 1.0, "Hello");    // OK: args contains three arguments: int, double, and const char*
A variadic template is defined with the ... notation:

Click here to view code image

template<typename... Types>
void f(Types... args);   // variadic template function
The typename... in the declaration of Types specifies that Types is a template parameter pack. The ... in the type of args specifies that args is a function parameter pack. The type of each args function argument is the corresponding Types template argument. We can use class... with the same meaning as typename.... The ellipsis (...) is a separate lexical token, so you can place whitespace before or after it. An ellipsis can appear in many different places in the grammar, but it always means “zero or more occurrences of something.” Think of a parameter pack as a sequence of values for which the compiler has remembered the types. For example, we could graphically represent a parameter pack for {'c',127,string{"Bob"},3.14}:


This is typically called a tuple. The memory layout is not specified by the C++ standard. For example, it might be the reverse of what is shown here (last element at the lowest memory address; §28.5). However, it is a dense, not a linked, representation. To get to a value, we need to start from the beginning and work our way through to what we want. The implementation of Tuple demonstrates that technique (§28.5). We can find the type of the first element and access it using that, then we can (recursively) proceed to the next argument. If we want to, we can give the appearance of indexed access using something like get<N> for Tuple (and for std::tuple; §28.6.4), but unfortunately there is no direct language support for that.

If you have a parameter pack, you can expand it into its sequence of elements by placing a ... after it. For example:

Click here to view code image

template<typename T, typename... Args>
void printf(const char* s, T value, Args... args)
{
      //...
     return printf(++s, args...);     // do a recursive call with the elements of args as arguments
      //...
}
Expansion of a parameter pack into its elements is not restricted to function calls. For example:

Click here to view code image

template<typename... Bases>
class X : public Bases... {
public:
     X(const Bases&... b) : Bases(b)... { }
};

X<> x0;
X<Bx> x1(1);
X<Bx,By> x2(2,3);
X<Bx,By,Bz> x3(2,3,4);
Here, Bases... says that X has zero or more bases. When it comes to initializing an X, the constructor requires zero or more values of types specified in the Bases variadic template argument. One by one those values are passed to the corresponding base initializer.

We can use the ellipsis to mean “zero or more elements of something” in most places where a list of elements is required (§iso.14.5.3), such as in:

• A template argument list

• A function argument list

• An initializer list

• A base specifier list

• A base or member initializer list

• A sizeof... expression

A sizeof... expression is used to obtain the number of elements in a parameter pack. For example, we can define a constructor for a tuple given a pair provided the number of tuple elements is two:

Click here to view code image

template<typename... Types>
class tuple {
      //...
     template<typename T, typename U, typename = Enable_if<sizeof...(Types)==2>
         tuple(const pair<T,U>&);
};
28.6.3. Forwarding
One of the major uses of variadic templates is forwarding from one function to another. Consider how to write a function that takes as arguments something to be called and a possibly empty list of arguments to give to the “something” as arguments:

template<typename F, typename... T>
void call(F&& f, T&&... t)
{
     f(forward<T>(t)...);
}
That is pretty simple and not a hypothetical example. The standard-library thread has constructors using this technique (§5.3.1, §42.2.2). I use pass-by-rvalue-reference of a deduced template argument type to be able to correctly distinguish between rvalues and lvalues (§23.5.2.1) and std::forward() to take advantage of that (§35.5.1). The ... in T&&... is read as “accept zero or more && arguments, each of the type of the corresponding T.” The ... in forward<T>(t)... is read “forward the zero or more arguments from t.”

I used a template argument for the type of the “something” to be called, so that call() can accept functions, pointers to functions, function objects, and lambdas.

We can test call():

Click here to view code image

void g0()
{
     cout << "g0()\n";
}

template<typename T>
void g1(const T& t)
{
     cout << "g1(): " << t << '\n';
}

void g1d(double t)
{
     cout << "g1d(): " << t << '\n';
}

template<typename T, typename T2>
void g2(const T& t, T2&& t2)
{
     cout << "g2(): " << t << ' ' << t2 << '\n';
}

void test()
{
     call(g0);
     call(g1);                            // error: too few arguments
     call(g1<int>,1);
     call(g1<const char*>,"hello");
     call(g1<double>,1.2);
     call(g1d,1.2);
     call(g1d,"No way!");                 // error: wrong argument type for g1d()
     call(g1d,1.2,"I can't count");       // error: too many arguments for g1d()
     call(g2<double,string>,1,"world!");

     int i = 99;                          // testing with lvalues
     const char* p = "Trying";
     call(g2<double,string>,i,p);

     call([](){ cout <<"l1()\n"; });
     call([](int i){ cout <<"l0(): " << i << "\n";},17);
     call([i](){ cout <<"l1(): " << i << "\n"; });
}
I have to be specific about which specialization of a template function to pass because call() cannot deduce which one to use from the types of the other arguments.

28.6.4. The Standard-Library tuple
The Tuple in §28.5 has an obvious weakness: it can handle at most four elements. This section presents the standard-library tuple (from <tuple>; §34.2.4.2) and explains the techniques used to implement it. The key difference between std::tuple and Tuple is that the former uses variadic templates to remove the limitation on the number of elements. Here are the key definitions:

Click here to view code image

template<typename... Values> class tuple;        // Primary template

template<> class tuple<> { };                    // 0-tuple specialization

template<typename Head, typename... Tail>
class tuple<Head, Tail...>
     : private tuple<Tail...> { // here is the recursion
/*
     Basically, a tuple stores its head (its first (type,value) pair)
     and derives from the tuple of its tail (the rest of the (type/value) pairs).
     Note that the type is encoded in the type, not stored as data
*/
     typedef tuple<Tail...> inherited;
public:
     constexpr tuple() { }      // default: the empty tuple

     tuple(Add_lvalue_reference<Head> h, Add_lvalue_reference<Tail>... t) // from separate arguments
          : m_head(h), inherited(t...) { }

     template<typename... VValues>                             // from another tuple
     tuple(const tuple<VValues...>& other)
          : m_head(other.head()), inherited(other.tail()) { }

     template<typename... VValues>
     tuple(const tuple<VValues...>& other)
          : m_head(other.head()), inherited(other.tail()) { }
     template<typename... VValues>
     tuple& operator=(const tuple<VValues...>& other)  // assignment
     {
          m_head = other.head();
          tail() = other.tail();
          return *this;
     }
      //...

protected:
     Head m_head;
private:
     Add_lvalue_reference<Head> head() { return m_head; }
     Add_lvalue_reference<const Head> head() const { return m_head; }

     inherited& tail() { return *this; }
     const inherited& tail() const { return *this; }
};
There is no guarantee that std::tuple is implemented as hinted here. In fact, several popular implementations derive from a helper class (also a variadic class template), so as to get the element layout in memory to be the same as a struct with the same member types.

The “add reference” type functions add a reference to a type if it isn’t a reference already. They are used to avoid copying by ensuring call-by-const-reference (§35.4.2).

Curiously, std::tuple does not provide head() and tail() functions, so I made them private. In fact, tuple does not provide any member functions for accessing an element. If you want to access an element of a tuple, you must (directly or indirectly) call a function that splits it into a value and .... If I want head() and tail() for the standard-library tuple, I can write them:

Click here to view code image

template<typename Head, typename... Tail>
Head& head(tuple<Head,Tail...>& t)
{
     return std::get<0>(t);    // get first element of t (§34.2.4.2)
}

template<typename Head, typename... Tail>
tuple<Tail&...> tail(tuple<Head, Tail...>& t)
{
   return /* details */;
}
The “details” of the definition of tail() are ugly and complicated. If the designers of tuple had meant for us to use tail() on a tuple, they would have provided it as a member.

Given tuple, we can make tuples and copy and manipulate them:

Click here to view code image

tuple<string,vector<int>,double> tt("hello",{1,2,3,4},1.2);
string h = head(tt);                             //"hello"
tuple<vector<int>,double> t2 = tail(tt);         //{{1,2,3,4},1.2};
It can get tedious to mention all of those types. Instead, we can deduce them from argument types, for example, using the standard-library make_tuple():

Click here to view code image

template<typename... Types>
tuple<Types...> make_tuple(Types&&... t)     // simplified (§iso.20.4.2.4)
{
     return tuple<Types...>(t...);
}
string s = "Hello";
vector<int> v = {1,22,3,4,5};
auto x = make_tuple(s,v,1.2);
The standard-library tuple has many more members than listed in the implementation above (hence the // ...). In addition, the standard provides several helper functions. For example, get() is provided for element access (like get() from §28.5.2), so we can write:

Click here to view code image

auto t = make_tuple("Hello tuple", 43, 3.15);
double d = get<2>(t);          // d becomes 3.15
So std::get() provides compile-time zero-based subscripting of std::tuples.

Every member of std::tuple is useful to someone and most are useful to many, but none adds to our understanding of variadic templates, so I do not go into details. There are constructors and assignments from the same type (copy and move), from other tuple types (copy and move), and from pairs (copy and move). The operations taking a std::pair argument use sizeof... (§28.6.2) to ensure that their target tuples have exactly two elements. There are (nine) constructors and assignments taking allocators (§34.4) and a swap() (§35.5.2).

Unfortunately, the standard library does not offer << or >> for tuple. Worse, writing a << for std::tuple is amazingly complicated because there is no simple and general way of iterating through the elements of a standard-library tuple. First we need a helper; it is a struct with two print() functions. One print() recurses through a list printing elements, and the other stops the recursion when there are no more elements to print:

Click here to view code image

template<size_t N>  // print element N and following elements
struct print_tuple {
     template<typename... T>
     static typename enable_if<(N<sizeof...(T))>::type
     print(ostream& os, const tuple<T...>& t) // nonempty tuple
     {
          os << ", " << get<N>(t);       // print an element
          print_tuple<N+1>::print(os,t);      // print the rest of the elements
     }

     template<typename... T>
     static typename enable_if<!(N<sizeof...(T))>::type                 // empty tuple
     print(ostream&, const tuple<T...>&)
     {
     }
};
The pattern is that of a recursive function with a terminating overload (like printf() from §28.6.1).

However, note how it wastefully lets get<N>() count from 0 to N.

We can now write a << for tuple:

Click here to view code image

std::ostream& operator << (ostream& os, const tuple<>&)   // the empty tuple
{
  return os << "{}";
}

template<typename T0, typename... T>
ostream& operator<<(ostream& os, const tuple<T0, T...>& t)  // a nonempty tuple
{
  os << '{' << std::get<0>(t);  // print first element
  print_tuple<1>::print(os,t);  // print the rest of the elements
  return os << '}';
}
We can now print a tuple:

Click here to view code image

void user()
{
     cout << make_tuple() << '\n';
     cout << make_tuple("One meatball!") << '\n';
     cout << make_tuple(1,1.2,"Tail!") << '\n';
}
28.7. SI Units Example
Using constexpr and templates, we can compute just about anything at compile time. Providing input for such computations can be tricky, but we can always #include data into the program text. However, I prefer simpler examples that in my opinion stand a better chance when it comes to maintenance. Here, I will show an example that provides a reasonable tradeoff between implementation complexity and utility. The compilation overhead is minimal and there is no run-time overhead. The example is to provide a small library for computations using units, such as meters, kilograms, and seconds. These MKS units are a subset of the international standard (SI) units used universally in science. The example is chosen to show how the simplest metaprogramming techniques can be used in combination with other language features and techniques.

We want to attach units to our values, so as to avoid meaningless computations. For example:

Click here to view code image

auto distance = 10.9_m;        //10.9 meters
auto time = 20.5_s;            //20.5 seconds
auto speed = distance/time;  // 0.53 m/s (meters per second)

if (speed == 0.53)             // error: 0.53 is dimensionless
 //...
if (speed == distance)       // error: can't compare m to m/s
 //...
if (speed == 10.9_m/20.5_s)      // OK: the units match
 //...
Quantity<MpS2> acceleration = distance/square(time);  // MpS2 means m/(s*s)

cout << "speed==" << speed << " acceleration==" << acceleration << "\n";
Units provide a type system for physical values. As shown, we can use auto to hide types when we want to (§2.2.2), user-defined literals to introduce typed values (§19.2.6), and a type Quantity for use when we want to be explicit about Units. A Quantity is a numeric value with a Unit.

28.7.1. Units
First, I will define Unit:

template<int M, int K, int S>
struct Unit {
     enum { m=M, kg=K, s=S };
};
A Unit has components representing the three units of measurement that we are interested in:

• Meters for length

• Kilograms for mass

• Seconds for time

Note that the unit values are encoded in the type. A Unit is meant for compile-time use.

We can provide more conventional notation for the most common units:

Click here to view code image

using M = Unit<1,0,0>;       // meters
using Kg = Unit<0,1,0>;      // kilograms
using S = Unit<0,0,1>;       // seconds
using MpS = Unit<1,0,–1>;    // meters per second (m/s)
using MpS2 = Unit<1,0,–2>;   // meters per square second (m/(s*s))
Negative unit values indicate division by a quantity with that unit. This three-value representation of a unit is very flexible. We can represent the proper unit of any computation involving distance, mass, and time. I doubt we will find much use for Quantity<123,–15,1024>, that is, 123 distances multiplied, divided by 15 masses multiplied, and then multiplied by 1024 time measurements multiplied – but it is nice to know that the system is general. Unit<0,0,0> indicates a dimensionless entity, a value without a unit.

When we multiply two quantities, their units are added. Thus, addition of Units is useful:

Click here to view code image

template<typename U1, typename U2>
struct Uplus {
     using type = Unit<U1::m+U2::m, U1::kg+U2::kg, U1::s+U2::s>;
};

template<typename U1, typename U2>
using Unit_plus = typename Uplus<U1,U2>::type;
Similarly, when we divide two quantities, their units are subtracted:

Click here to view code image

template<typename U1, typename U2>
struct Uminus {
     using type = Unit<U1::m–U2::m, U1::kg–U2::kg, U1::s–U2::s>;
};

template<typename U1, typename U2>
using Unit_minus = typename Uminus<U1,U2>::type;
Unit_plus and Unit_minus are simple type functions (§28.2) on Units.

28.7.2. Quantitys
A Quantity is a value with an associated Unit:

Click here to view code image

template<typename U>
struct Quantity {
     double val;
     explicit constexpr Quantity(double d) : val{d} {}
};
A further refinement would have made the type used to represent the value a template parameter, possibly defaulted to double. We can define Quantitys with a variety of units:

Click here to view code image

Quantity<M> x {10.5};       // x is 10.5 meters
Quantity<S> y {20.5};       // y is 20.5 seconds
I made the Quantity constructor explicit to make it less likely to get implicit conversions from dimensionless entities, such as plain C++ floating-point literals:

Click here to view code image

Quantity<MpS> s = 0.53;    // error: attempt to convert an int to meters/second

Quantity<M> comp(Quantity<M>);
 //...
Quantity<M> n = comp(10.9);      // error: comp() requires a distance
Now we can start thinking about computations. What do we do to physical measurements? I’m not going to review a whole physics textbook, but certainly we need addition, subtraction, multiplication, and division. You can only add and subtract values with the same units:

Click here to view code image

template<typename U>
Quantity<U> operator+(Quantity<U> x, Quantity<U> y)  // same dimension
{
     return Quantity<U>{x.val+y.val};
}

template<typename U>
Quantity<U> operator–(Quantity<U> x, Quantity<U> y)  // same dimension
{
     return Quantity<U>{x.val–y.val};
}
Quantity’s constructor is explicit, so we have to convert the resulting double value back to Quantity.

Multiplication of Quantitys require addition of their Units. Similarly, division of Quantitys subtraction of their Units. For example:

Click here to view code image

template<typename U1, typename U2>
Quantity<Unit_plus<U1,U2>> operator *(Quantity<U1> x, Quantity<U2> y)
{
     return Quantity<Unit_plus<U1,U2>>{x.val *y.val};
}

template<typename U1, typename U2>
Quantity<Unit_minus<U1,U2>> operator/(Quantity<U1> x, Quantity<U2> y)
{
     return Quantity<Unit_minus<U1,U2>>{x.val/y.val};
}
Given these arithmetic operations, we can express most computations. However, we find that real-world computations contain a fair number of scaling operations, that is, multiplications and divisions by dimensionless values. We could use Quantity<Unit<0,0,0>> but that gets tedious:

Click here to view code image

Quantity<MpS> speed {0.53};
auto double_speed = Quantity<Unit<0,0,0>>{2} *speed;
To eliminate that verbosity, we can either provide an implicit conversion from double to Quantity<Unit<0,0,0>> or add a couple of variants to the arithmetic operations. I chose the latter:

Click here to view code image

template<typename U>
Quantity<U> operator *(Quantity<U> x, double y)
{
    return Quantity<U>{x.val *y};
}

template<typename U>
Quantity<U> operator *(double x, Quantity<U> y)
{
    return Quantity<U>{x *y.val};
}
We can now write:

Click here to view code image

Quantity<MpS> speed {0.53};
auto double_speed = 2*speed;
The main reason I do not define an implicit conversion from double to Quantity<Unit<0,0,0>> is that we do not want that conversion for addition or subtraction:

Quantity<MpS> speed {0.53};
auto increased_speed = 2.3+speed;      // error: can't add a dimensionless scalar to a speed
It is nice to have the detailed requirement for the code precisely dictated by the application domain.

28.7.3. Unit Literals
Thanks to the type aliases for the most common units, we can now write:

Click here to view code image

auto distance = Quantity<M>{10.9};  //10.9 meters
auto time = Quantity<S>{20.5};      //20.5 seconds
auto speed = distance/time;       //0.53 m/s (meters per second)
That’s not bad, but it is still verbose compared to code that conventionally simply leaves the units in the heads of the programmers:

Click here to view code image

auto distance = 10.9;         //10.9 meters
double time = 20.5;             //205 seconds
auto speed = distance/time;   //0.53 m/s (meters per second)
We needed the .0 or the explicit double to ensure that the type is double (and get the correct result for the division).

The code generated for the two examples should be identical, and we can do better still notationally. We can introduce user-defined literals (UDLs; §19.2.6) for the Quantity types:

Click here to view code image

constexpr Quantity<M> operator"" _m(long double d) { return Quantity<M>{d}; }
constexpr Quantity<Kg> operator"" _kg(long double d) { return Quantity<Kg>{d}; }
constexpr Quantity<S> operator"" _s(long double d) { return Quantity<S>{d}; }
That gives us the literals from our original example:

Click here to view code image

auto distance = 10.9_m;        //10.9 meters
auto time = 20.5_s;            //20.5 seconds
auto speed = distance/time;  //0.53 m/s (meters per second)

if (speed == 0.53)             // error: 0.53 is dimensionless
 //...
if (speed == distance)       // error: can't compare m to m/s
 //...
if (speed == 10.9_m/20.5_s)      // OK: the units match
I defined * and / for combinations of Quantitys and dimensionless values, so we can scale the units using multiplication or division. However, we could also provide more of the conventional units as user-defined literals:

Click here to view code image

constexpr Quantity<M> operator"" _km(long double d) { return Quantity<M>{1e3*d; }
constexpr Quantity<Kg> operator"" _g(long double d) { return Quantity<Kg>{d/1e3}; }
constexpr Quantity<Kg> operator"" _mg(long double d) { return Quantity<Kg>{d/1e6; }        // milligram
constexpr Quantity<S> operator"" _ms(long double d) { return Quantity<S>{d/1e3}; }             // milliseconds
constexpr Quantity<S> operator"" _us(long double d) { return Quantity<S>{d/1e6}; }             // microseconds
constexpr Quantity<S> operator"" _ns(long double d) { return Quantity<s>{d/1e9}; }       // nanoseconds
 //...
Obviously, this could really get out of control through overuse of nonstandard suffixes (e.g., us is suspect even though it is widely used because u looks a bit like a Greek µ).

I could have provided the various magnitudes as more types (as is done for std::ratio; §35.3) but thought it simpler to keep the Unit types simple and focused on doing their primary task well.

I use long double arguments because that is required for floating-point literal operators (§19.2.6). Unfortunately, defining a UDL for long doubles will give us only a suffix for floatingpoint literals. To get a suffix for an integer literal, say 20s as well as for 20.0s, we also have to define a literal operator for the suffix for unsigned long long.

28.7.4. Utility Functions
To finish the job (as defined by the initial example), we need the utility function square(), the equality operator, and the output operator. Defining square() is trivial:

Click here to view code image

template<typename U>
constexpr Quantity<Unit_plus<U,U>> square(Quantity<U> x)
{
    return Quantity<Unit_plus<U,U>>(x.val*x.val);
}
That basically shows how to write arbitrary computational functions. I could have constructed the Unit right there in the return value definition, but using the existing type function was easier. Alternatively, we could easily have defined a type function Unit_double.

The == looks more or less like all ==s. It is defined for values of the same Units only:

Click here to view code image

template<typename U>
bool operator==(Quantity<U> x, Quantity<U> y)
{
     return x.val==y.val;
}

template<typename U>
bool operator!=(Quantity<U> x, Quantity<U> y)
{
     return x.val!=y.val;
}
Note that I pass Quantitys by value. At run time, they are represented as doubles.

The output functions just do conventional character manipulation:

Click here to view code image

string suffix(int u, const char* x)   // helper function
{
     string suf;
     if (u) {
            suf += x;
            if (1<u) suf += '0'+u;

            if (u<0) {
                  suf += '–';
                  suf += '0'–u;
            }
     }
     return suf;
}
template<typename U>
ostream& operator<<(ostream& os, Quantity<U> v)
{
     return os << v.val << suffix(U::m,"m") << suffix(U::kg,"kg") << suffix(U::s,"s");
}
Finally, we can write:

Click here to view code image

auto distance = 10.9_m;        //10.9 meters
auto time = 20.5_s;            //20.5 seconds
auto speed = distance/time;  //0.53 m/s (meters per second)

if (speed == 0.53)             // error: 0.53 is dimensionless
 //...
if (speed == distance)       // error: can't compare m to m/s
 //...
if (speed == 10.9_m/20.5_s)      // OK: the units match
 //...

Quantity<MpS2> acceleration = distance/square(time);  // MpS2 means m/(s*s)

cout << "speed==" << speed << " acceleration==" << acceleration << "\n";
Such code will, given a reasonable compiler, generate exactly the same code as would have been generated using doubles directly. However, it is “type checked” (at compile time) according to the rules for physical units. It is an example of how we can add a whole new set of application-specific types with their own checking rules to a C++ program.

28.8. Advice
[1] Use metaprogramming to improve type safety; §28.1.

[2] Use metaprogramming to improve performance by moving computation to compile time; §28.1.

[3] Avoid using metaprogramming to an extent where it significantly slows down compilation; §28.1.

[4] Think in terms of compile-time evaluation and type functions; §28.2.

[5] Use template aliases as the interfaces to type functions returning types; §28.2.1.

[6] Use constexpr functions as the interfaces to type functions returning (non-type) values; §28.2.2.

[7] Use traits to nonintrusively associate properties with types; §28.2.4.

[8] Use Conditional to choose between two types; §28.3.1.1.

[9] Use Select to choose among several alternative types; §28.3.1.3.

[10] Use recursion to express compile-time iteration; §28.3.2.

[11] Use metaprogramming for tasks that cannot be done well at run time; §28.3.3.

[12] Use Enable_if to selectively declare function templates; §28.4.

[13] Concepts are among the most useful predicates to use with Enable_if; §28.4.3.

[14] Use variadic templates when you need a function that takes a variable number of arguments of a variety of types; §28.6.

[15] Don’t use variadic templates for homogeneous argument lists (prefer initializer lists for that); §28.6.

[16] Use variadic templates and std::move() where forwarding is needed; §28.6.3.

[17] Use simple metaprogramming to implement efficient and elegant unit systems (for fine-grained type checking); §28.7.

[18] Use user-defined literals to simplify the use of units; §28.7.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


28. Metaprogramming
29. A Matrix Design
Part IV: The Standard Library
47h 26m remaining
29. A Matrix Design
Never express yourself more clearly than you are able to think.

– Niels Bohr

• Introduction

Basic Matrix Uses; Matrix Requirements

• A Matrix Template

Construction and Assignment; Subscripting and Slicing

• Matrix Arithmetic Operations

Scalar Operations; Addition; Multiplication

• Matrix Implementation

slice; Matrix Slices; Matrix_ref; Matrix List Initialization; Matrix Access; Zero-Dimensional Matrix

• Solving Linear Equations

Classical Gaussian Elimination; Pivoting; Testing; Advice

29.1. Introduction
A language feature in isolation is boring and useless. This chapter demonstrates how features can be used in combination to address a challenging design task: a general N-dimensional matrix.

I have never seen a perfect matrix class. In fact, given the wide variety of uses of matrices, it is doubtful whether one could exist. Here, I present the programming and design techniques needed to write a simple N-dimensional dense matrix. If nothing else, this Matrix is far easier to use, and just as compact and fast, as anything a programmer would have time to write using vectors or builtin arrays directly. The design and programming techniques used for Matrix are widely applicable.

29.1.1. Basic Matrix Uses
Matrix<T,N> is an N-dimensional matrix of some value type T. It can be used like this:

Click here to view code image

Matrix<double,0> m0{1};          // zero dimensions: a scalar
Matrix<double,1> m1{1,2,3,4};    // one dimension: a vector (4 elements)
Matrix<double,2> m2{             // two dimensions (3*4 elements)
     {00,01,02,03},    //row 0
     {10,11,12,13},    //row 1
     {20,21,22,23}     //row 2
};
Matrix<double,3> m3(4,7,9);     // three dimensions (4*7*9 elements), all 0-initialized
Matrix<complex<double>,17> m17; //17 dimensions (no elements so far)
The element type must be something we can store. We do not require every property that we have for a floating-point number from every element type. For example:

Click here to view code image

Matrix<double,2> md;          // OK
Matrix<string,2> ms;          // OK: just don't try arithmetic operations

Matrix<Matrix<int,2>,2> mm {  //3-by-2 matrix of 2-by-2 matrices
                              // a matrix is a plausible "number"
     {  // row 0
            {{1, 2}, {3, 4}},  // col 0
            {{4, 5}, {6, 7}},  // col 1
     },
     {  // row 1
            {{8, 9}, {0, 1}},  // col 0
            {{2, 3}, {4, 5}},  // col 1
     },
     {  // row 2
            {{1, 2}, {3, 4}},  // col 0
            {{4, 5}, {6, 7}},  // col 1
     }
};
Matrix arithmetic doesn’t have exactly the same mathematical properties as integer or floating-point arithmetic (e.g., matrix multiplication is not commutative), so we must be careful how we use such a matrix.

As for vector, we use () to specify sizes and {} to specify element values (§17.3.2.1, §17.3.4.1). The number of rows must match the specified number of dimensions and the number of elements in each dimension (each column) must match. For example:

Click here to view code image

Matrix<char,2> mc1(2,3,4);     // error: too many dimension sizes
Matrix<char,2> mc2 {
     {'1','2','3'}             // error: initializer missing for second dimension
};
Matrix<char,2> mc2 {
     {'1','2','3'},
     {'4','5'}                 // error: element missing for third column
};
Matrix<T,N> has its number of dimensions (its order) specified as a template argument (here, N). Each dimension has a number of elements (its extent()) deduced from the initializer list or specified as a Matrix constructor argument using the () notation. The total number of elements is referred to as its size(). For example:

Click here to view code image

Matrix<double,1> m1(100);        // one dimension: a vector (100 elements)
Matrix<double,2> m2(50,6000);    // two dimensions: 50*6000 elements

auto d1 = m1.order;            //1
auto d2 = m2.order;            //2

auto e1 = m1.extent(0);          //100
auto e2 = m1.extent(1);          // error: m1 is one-dimensional

auto e3 = m2.extent(0);          //50
auto e2 = m2.extent(1);          //6000

auto s1 = m1.size();             //100
auto s2 = m2.size();             //50*6000
We can access Matrix elements by several forms of subscripting. For example:

Click here to view code image

Matrix<double,2> m {              // two dimensions (4*3 elements)
     {00,01,02,03},  // row 0
     {10,11,12,13},  // row 1
     {20,21,22,23}   // row 2
};

double d1 = m(1,2);               // d==12
double d2 = m[1][2];              // d==12
Matrix<double,1> m1 = m[1];       // row 1: {10,11,12,13}
double d3 = m1[2];                // d==12
We can define an output function for use in debugging like this:

Click here to view code image

template<typename M>
     Enable_if<Matrix_type<M>(),ostream&>
operator<<(ostream& os, const M& m)
{
    os << '{';
    for (size_t i = 0; i!=rows(m); ++i){
          os << m[i];
          if (i+1!=rows(m)) os << ',';
    }
    return os << '}';
}
Here, Matrix_type is a concept (§24.3). Enable_if is an alias for enable_if’s type (§28.4), so this operator<<() returns an ostream&.

Given that, cout<<m prints: {{0,1,2,3},{10,11,12,13},{20,21,22,23}}.

29.1.2. Matrix Requirements
Before proceeding with an implementation, consider what properties we might like to have:

• N dimensions, where N is a parameter that can vary from 0 to many, without specialized code for every dimension.

• N-dimensional storage is useful in general, so the element type can be anything we can store (like a vector element).

• The mathematical operations should apply to any type that can reasonably be described as a number, including a Matrix.

• Fortran-style subscripting using one index per dimension, for example, m(1,2,3) for a 3-D Matrix, yielding an element.

• C-style subscripting, for example, m[7], yielding a row (a row is an N–1-D sub-Matrix of an N-D Matrix).

• Subscripting should be potentially fast and potentially range checked.

• Move assignment and move constructor to ensure efficient passing of Matrix results and to eliminate expensive temporaries.

• Some mathematical matrix operations, such as + and *=.

• A way to read, write, and pass around references to submatrices, Matrix_refs, for use for both reading and writing elements.

• The absence of resource leaks in the form of the basic guarantee (§13.2).

• Fused critical operations, for example, m*v+v2 as a single function call.

This is a relatively long and ambitious list, but it does not add up to “everything for everybody.” For example, I did not list:

• Many more mathematical matrix operations

• Specialized matrices (e.g., diagonal and triangular matrices)

• Sparse Matrix support

• Support for parallel execution of Matrix operations

However valuable those properties are, they go beyond what is needed to present basic programming techniques.

To provide this, I use a combination of several language features and programming techniques:

• Classes (of course)

• Parameterization with numbers and types

• Move constructors and assignments (to minimize copying)

• RAII (relying on constructors and destructors)

• Variadic templates (for specifying extents and for indexing)

• Initializer lists

• Operator overloading (to get conventional notation)

• Function objects (to carry information about subscripting)

• Some simple template metaprogramming (e.g., for checking initializer lists and for distinguishing reading and writing for Matrix_refs)

• Implementation inheritance for minimizing code replication.

Obviously, a Matrix like this could be a built-in type (as it is in many languages), but the point here is exactly that in C++ it is not built in. Instead, facilities are provided for users to make their own.

29.2. A Matrix Template
To give an overview, here is the declaration of Matrix with its most interesting operations:

Click here to view code image

template<typename T, size_t N>
class Matrix {
public:
     static constexpr size_t order = N;// number of dimensions
     using value_type = T;
     using iterator = typename std::vector<T>::iterator;
     using const_iterator = typename std::vector<T>::const_iterator;

     Matrix() = default;
     Matrix(Matrix&&) = default;                                    // move
     Matrix& operator=(Matrix&&) = default;
     Matrix(const Matrix&) = default;                               // copy
     Matrix& operator=(const Matrix&) = default;
     ~Matrix() = default;

     template<typename U>
         Matrix(const Matrix_ref<U,N>&);                            // construct from Matrix_ref
     template<typename U>
         Matrix& operator=(const Matrix_ref<U,N>&);                 // assign from Matrix_ref

     template<typename...Exts>                                      // specify the extents
         explicit Matrix(Exts... exts);

     Matrix(Matrix_initializer<T,N>);                               // initialize from list
     Matrix& operator=(Matrix_initializer<T,N>);                    // assign from list

     template<typename U>
         Matrix(initializer_list<U>) =delete;                       // don't use {} except for elements
     template<typename U>
         Matrix& operator=(initializer_list<U>) = delete;

     static constexpr size_t order() { return N; }                  // number of dimensions
     size_t extent(size_t n) const { return desc.extents[n]; }      //#elements in the nth dimension
     size_t size() const { return elems.size(); }                   // total number of elements
     const Matrix_slice<N>& descriptor() const { return desc; }     // the slice defining subscripting

     T* data() { return elems.data(); }                             //"flat" element access
     const T* data() const { return elems.data(); }

      //...

private:
     Matrix_slice<N> desc;          // slice defining extents in the N dimensions
     vector<T> elems;               // the elements
};
Using a vector<T> to hold the elements relieves us from concerns of memory management and exception safety. A Matrix_slice holds the sizes necessary to access the elements as an N-dimensional matrix (§29.4.2). Think of it as a gslice (§40.5.6) specialized for our Matrix.

A Matrix_ref (§29.4.3) behaves just like a Matrix except that it refers to a Matrix, rather than owning its own elements. Think of it as a reference to a sub-Matrix

A Matrix_initializer<T,N> is a suitably nested initializer list for a Matrix<T,N> (§29.4.4).

29.2.1. Construction and Assignment
The default copy and move operations have just the right semantics: memberwise copy or move of the desc (slice descriptor defining subscripting) and the elements. Note that for management of the storage for elements, Matrix gets all the benefits from vector. Similarly, the default constructor and destructor have just the right semantics.

The constructor that takes extents (numbers of elements in dimensions) is a fairly trivial example of a variadic template (§28.6):

Click here to view code image

template<typename T, size_t N>
    template<typename... Exts>
    Matrix<T,N>::Matrix(Exts... exts)
         :desc{exts...},      // copy extents
          elems(desc.size)    // allocate desc.size elements and default initialize them
    {}
The constructor that takes an initializer list requires a bit of work:

Click here to view code image

template<typename T, size_t N>
Matrix<T, N>::Matrix(Matrix_initializer<T,N> init)
{
     desc.extents = Matrix_impl::derive_extents(init);     // deduce extents from initializer list (§29.4.4)
     Matrix_impl::compute_strides(desc);                 // compute strides and size (§29.4.4)
     elems.reserve(desc.size);                           // make room for slices
     Matrix_impl::insert_flat(init,elems);               // initialize from initializer list (§29.4.4)
     assert(elems.size() == desc.size);
}
The Matrix_initializer is a suitably nested initializer_list (§29.4.4). The extents are deduced by the derive_extents() and the size is computed by compute_strides(). Then, the elements are stored in elems by inser t_flat() from the Matrix_impl namespace.

To ensure that {} initialization is only used for lists of elements, I =deleted the simple initializer_list constructor. This is to enforce the use of () initialization for extents. For example:

Click here to view code image

enum class Piece { none, cross, naught };

Matrix<Piece,2> board1 {
     {Piece::none, Piece::none, Piece::none},
     {Piece::none, Piece::none, Piece::none},
     {Piece::none, Piece::none, Piece::cross}
};
Matrix<Piece,2> board2(3,3);   // OK
Matrix<Piece,2> board3 {3,3};  // error: constructor from initializer_list<int> deleted
Without that =delete, that last definition would have been accepted.

Finally, we have to be able to construct from a Matrix_ref, that is, from a reference to a Matrix or a part of a Matrix (a submatrix):

Click here to view code image

template<typename T, size_t N>
    template<typename U>
    Matrix<T,N>::Matrix(const Matrix_ref<U,N>& x)
         :desc{x.desc}, elems{x.begin(),x.end()}  // copy desc and elements
    {
         static_assert(Convertible<U,T>(),"Matrix constructor: incompatible element types");
    }
The use of a template allows us to construct from a Matrix with a compatible element type.

As usual, the assignments resemble the constructors. For example:

Click here to view code image

template<typename T, size_t N>
    template<typename U>
    Matrix<T,N>& Matrix<T,N>::operator=(const Matrix_ref<U,N>& x)
    {
         static_assert(Convertible<U,T>(),"Matrix =: incompatible element types");

         desc = x.desc;
         elems.assign(x.begin(),x.end());
         return *this;
    }
That is, we copy the members of Matrix.

29.2.2. Subscripting and Slicing
A Matrix can be accessed through subscripting (to elements or rows), through rows and columns, or through slices (parts of rows or columns).

Matrix<T,N> Access

m.row(i)

Row i of m; a Matrix_ref<T,N-1>

m.column(i)

Column i of m; a Matrix_ref<T,N-1>

m[i]

C-style subscripting: m.row(i)

m(i,j)

Fortran-style element access: m[i][j]; a T&;

the number of subscripts must be N

m(slice(i,n),slice(j))

Submatrix access with slicing: a Matrix_ref<T,N>;

slice(i,n) is elements [i:i+n) of the subscript’s dimension;

slice(j) is elements [i:max) of the subscript’s dimension;

max is the dimension’s extent; the number of subscripts must be N

These are all member functions:

Click here to view code image

template<typename T, size_t N>
class Matrix {
public:
      //...

     template<typename ... Args>                                // m(i,j,k) subscripting with integers
         Enable_if<Matrix_impl::Requesting_element<Args...>(), T&>
         operator()(Args... args);
     template<typename ... Args>
         Enable_if<Matrix_impl::Requesting_element<Args...>(), const T&>
         operator()(Args... args) const;
     template<typename ... Args>                                // m(s1,s2,s3) subscripting with slices
         Enable_if<Matrix_impl::Requesting_slice<Args...>(), Matrix_ref<T, N>>
         operator()(const Args&... args);
     template<typename ... Args>
         Enable_if<Matrix_impl::Requesting_slice<Args...>(), Matrix_ref<const T,N>>
         operator()(const Args&... args) const;

     Matrix_ref<T,N–1> operator[](size_t i) { return row(i); }  // m[i] row access
     Matrix_ref<const T,N–1> operator[](size_t i) const { return row(i); }

     Matrix_ref<T,N–1> row(size_t n);                           // row access
     Matrix_ref<const T,N–1> row(size_t n) const;

     Matrix_ref<T,N–1> col(size_t n);                           // column access
     Matrix_ref<const T,N–1> col(size_t n) const;

      //...
};
C-style subscripting is done by m[i] selecting and returning the ith row:

Click here to view code image

template<typename T, size_t N>
Matrix_ref<T,N–1> Matrix<T,N>::operator[](size_t n)
{
   return row(n);   //§29.4.5
}
Think of a Matrix_ref (§29.4.3) as a reference to a sub-Matrix.

Matrix_ref<T,0> is specialized so that it refers to a single element (§29.4.6).

Fortran-style subscripting is done by listing an index for each dimension, for example, m(i,j,k), yielding a scalar:

Click here to view code image

Matrix<int,2> m {
     {01,02,03},
     {11,12,13}
};

m(1,2) = 99;          // overwrite the element in row 1 column 2; that is 13
auto d1 = m(1);       // error: too few subscripts
auto d2 = m(1,2,3);   // error: too many subscripts
In addition to subscripting with integers, we can subscript with slices. A slice describes a subset of the elements of a dimension (§40.5.4). In particular, slice{i,n} refers to elements [i:i+n) of the dimension to which it applies. For example:

Matrix<int,2> m2 {
     {01,02,03},
     {11,12,13},
     {21,22,23}
};

auto m22 = m2(slice{1,2},slice{0,3});
Now m22 is a Matrix<int,2> with the value

{
    {11,12,13},
    {21,22,23}
}
The first (row) subscript slice{1,2} selects the last two rows, and the second (column) subscript slice{0,3} selects all elements in the columns.

The return type for a () with slice subscripts is a Matrix_ref, so we can use it as the target of an assignment. For example:

m2(slice{1,2},slice{0,3}) = {
     {111,112,113},
     {121,122,123}
};
Now m2 has the value

{
     {01,02,03},
     {111,112,113},
     {121,122,123}
}
Selecting all elements from a point onward is so common that there is a shorthand: slice{i} means slice{i,max} where max is larger than the largest subscript in the dimension. So, we can simplify m2(slice{1,2},slice{0,3}) to the equivalent m2(slice{1,2},slice{0}).

The other simple common case is to select all elements of a single row or column, so a plain integer subscript i among a set of slice subscripts is interpreted as slice{i,1}. For example:

Click here to view code image

Matrix<int,2> m3 {
     {01,02,03},
     {11,12,13},
     {21,22,23}
};

auto m31 = m3(slice{1,2},1);        // m31 becomes {{12},{22}}
auto m32 = m3(slice{1,2},0);        // m32 becomes {{11},{21}}
auto x = m3(1,2);                   // x == 13
The notion of slicing subscripts is supported in essentially all languages used for numeric programming, so hopefully it is not too unfamiliar.

The implementations of row(), column(), and operator()() are presented in §29.4.5. The implementations of const versions of these functions are basically the same as those of their non-const versions. The key difference is that const versions return results with const elements.

29.3. Matrix Arithmetic Operations
So, we can create Matrixes, copy them, access their elements and rows. However, what we often want is to have mathematical operations that save us from expressing our algorithms in terms of accesses to individual elements (scalars). For example:

Click here to view code image

Matrix<int,2> mi {{1,2,3}, {4,5,6 }};        //2-by-3
Matrix<int,2> m2 {mi};                       // copy
mi*=2;                                       // scale: {{2,4,6},{8,10,12}}
Matrix<int,2> m3 = mi+m2;                    // add: {{3,6,9},{12,15,18}}
Matrix<int,2> m4 {{1,2}, {3,4}, {5,6}};      //3-by-2
Matrix<int,2> m5 = mi*m4;                     // multiply: {{44,56},{98,128}}
The mathematical operations are defined like this:

Click here to view code image

template<typename T, size_t N>
class Matrix {
     //...

    template<typename F>
        Matrix& apply(F f);                  // f(x) for every element x

    template<typename M, typename F>      // f(x,mx) for corresponding elements *this and m
        Enable_if<Matrix_type<M>(),Matrix> apply(const M& m, F f);

    Matrix& operator=(const T& value);       // assignment with scalar

    Matrix& operator+=(const T& value);      // scalar addition
    Matrix& operator-=(const T& value);      // scalar subtraction
    Matrix& operator*=(const T& value);      // scalar multiplication
    Matrix& operator/=(const T& value);      // scalar division
    Matrix& operator%=(const T& value);      // scalar modulo

    template<typename M>                     // matrix addition
        Enable_if<Matrix_type<M>(),Matrix&> operator+=(const M& x);
    template<typename M>                     // matrix subtraction
        Enable_if<Matrix_type<M>(),Matrix&> operator-=(const M& x);

     //...
};

 // Binary +, -, * are provided as nonmember functions
An operations taking a matrix arguments are provided only if the argument is of Matrix_type.

29.3.1. Scalar Operations
A scalar arithmetic operation simply applies its operation and right-hand operand to each element. For example:

Click here to view code image

template<typename T, size_t N>
Matrix<T,N>& Matrix<T,N>::operator+=(const T& val)
{
     return apply([&](T& a) { a+=val; } );  // using a lambda (§11.4)
}
This apply() applies a function (or a function object) to each element of its Matrix:

Click here to view code image

template<typename T, size_t N>
    template<typename F>
    Matrix<T,N>& Matrix<T,N>::apply(F f)
    {
         for (auto& x : elems) f(x);     // this loop uses stride iterators
         return *this;
    }
As usual, returning *this enables chaining. For example:

m.apply([](double& x){a=abs(x);}).apply([](double& x){a=sqrt(x);});     // m[i] = sqrt(abs(m[i])) for all i
As usual (§3.2.1.1, §18.3), we can define the “plain operators,” such as +, outside the class using the assignment operators, such as +=. For example:

Click here to view code image

template<typename T, size_t N>
Matrix<T,N> operator+(const Matrix<T,N>& m, const T& val)
{
     Matrix<T,N> res = m;
     res+=val;
     return res;
}
Without the move constructor, this return type would be a bad performance bug.

29.3.2. Addition
Addition of two Matrixes is very similar to the scalar versions:

Click here to view code image

template<typename T, size_t N>
    template<typename M>
    Enable_if<Matrix_type<M>(),Matrix<T,N>&> Matrix<T,N>::operator+=(const M& m)
    {
         static_assert(m.order==N,"+=: mismatched Matrix dimensions");
         assert(same_extents(desc,m.descriptor()));       // make sure sizes match

         return apply(m, [](T& a,const Value_type<M>&b) { a+=b; });
    }
Matrix::apply(m,f) is the two-argument version of Matrix::apply(f). It applies its f to its two Matrixes (m and *this):

Click here to view code image

template<typename T, size_t N>
    template<typename M, typename F>
    Enable_if<Matrix_type<M>(),Matrix<T,N>&> Matrix<T,N>::apply(M& m, F f)
    {
        assert(same_extents(desc,m.descriptor()));             // make sure sizes match
        for (auto i = begin(), j = m.begin(); i!=end();++i,++j)
              f(*i,*j);
        return *this;
    }
Now operator+() is easily defined:

Click here to view code image

template<typename T, size_t N>
Matrix<T,N> operator+(const Matrix<T,N>& a, const Matrix<T,N>& b)
{
     Matrix<T,N> res = a;
     res+=b;
     return res;
}
This defines + for two Matrixes of the same type yielding a result of that type. We could generalize:

Click here to view code image

template<typename T, typename T2, size_t N,
    typename RT = Matrix<Common_type<Value_type<T>,Value_type<T2>>,N>>
Matrix<RT,N> operator+(const Matrix<T,N>& a, const Matrix<T2,N>& b)
{
     Matrix<RT,N> res = a;
     res+=b;
     return res;
}
If, as is common, T and T2 are the same type, Common_type is that type. The Common_type type function is derived from std::common_type (§35.4.2). For built-in types it, like ?:, gives a type that best preserves values of arithmetic operations. If Common_type is not defined for a pair of types we want to use in combination, we can define it. For example:

Click here to view code image

template<>
struct common_type<Quad,long double> {
     using type = Quad;
};
Now Common_type<Quad,long double> is Quad.

We also need operations involving Matrix_refs (§29.4.3). For example:

Click here to view code image

template<typename T, size_t N>
Matrix<T,N> operator+(const Matrix_ref<T,N>& x, const T& n)
{
     Matrix<T,N> res = x;
     res+=n;
     return res;
}
Such operations look exactly like their Matrix equivalents. There is no difference between Matrix and Matrix_ref element access: the difference between Matrix and Matrix_ref is in the initialization and ownership of elements.

Subtraction, multiplication, etc., by scalars and the handling of Matrix_refs are just repetition of the techniques used for addition.

29.3.3. Multiplication
Matrix multiplication is not as simple as addition: the product of an N-by-M matrix and a M-by-P matrix is an N-by-P matrix. For M==1 we get that the product of two vectors is a matrix, and from P==1 we get that the product of a matrix and a vector is a vector. We can generalize matrix multiplication into higher dimensions, but to do that we have to introduce tensors [Kolecki,2002], and I don’t want to divert this discussion of programming techniques and how to use language features into a physics and engineering math lesson. So, I’ll stick to one and two dimensions.

Treating one Matrix<T,1> as an N-by-1 matrix and another as a 1-by-M matrix, we get:

Click here to view code image

template<typename T>
Matrix<T,2> operator*(const Matrix<T,1>& u, const Matrix<T,1>& v)
{
     const size_t n = u.extent(0);
     const size_t m = v.extent(0);
     Matrix<T,2> res(n,m);                  // an n-by-m matrix
     for (size_t i = 0; i!=n; ++i)
           for (size_t j = 0; j!=m; ++j)
                 res(i,j) = u[i]*v[j];
     return res;
}
This is the simplest case: matrix element res(i,j) is u[i]*v[j]. I have not tried to generalize to handle the cases where the element types of the vectors are different. If necessary, the techniques discussed for addition can be used.

Note that I’m writing to each element of res twice: once to initialize to T{} and once to assign u[i]*v[j]. This roughly doubles the cost of the multiplication. If that bothers you, write a multiplication without that overhead and see if the difference matters in your program.

Next, we can multiply an N-by-M matrix with a vector seen as an M-by-1 matrix. The result is an N-by-1 matrix:

Click here to view code image

template<typename T>
Matrix<T,1> operator*(const Matrix<T,2>& m, const Matrix<T,1>& v)
{
     assert(m.extent(1)==v.extent(0));
     const size_t nr = m.extent(0);
     const size_t nc = m.extent(1);
     Matrix<T,1> res(n);
     for (size_t i = 0; i!=nr; ++i)
           for (size_t j = 0; j!=nc; ++j)
                 res(i) += m(i,j)*v(j);
     return res;
}
Note that the declaration of res initializes its elements to T{}, which is zero for numeric types, so that the += starts out from zero.

The N-by-M matrix times M-by-P matrix is handled similarly:

Click here to view code image

template<typename T>
Matrix<T,2> operator*(const Matrix<T,2>& m1, const Matrix<T,2>& m2)
{
     const size_t nr = m1.extent(0);
     const size_t nc = m1.extent(1);
     assert(nc==m2.extent(0));       // columns must match rows

     const size_t p = m2.extent(1);
     Matrix<T,2> res(nr,p);
     for (size_t i = 0; i!=nr; ++i)
           for (size_t j = 0; j!=p; ++j)
                 for (size_t k = 0; k!=nc; ++k)
                       res(i,j) += m1(i,k)*m2(k,j);
    return res;
}
There are numerous ways of optimizing this important operation.

That innermost loop could be more elegantly expressed as:

res(i,j) = dot_product(m1[i],m2.column(j))
Here, dot_product() is simply an interface to the standard-library inner_product() (§40.6.2):

Click here to view code image

template<typename T>
T dot_product(const Matrix_ref<T,1>& a, const Matrix_ref<T,1>& b)
{
     return inner_product(a.begin(),a.end(),b.begin(),0.0);
}
29.4. Matrix Implementation
So far, I have delayed the presentation of the most complicated (and for some programmers the most interesting) “mechanical” parts of the Matrix implementation. For example: What is a Matrix_ref? What is a Matrix_slice? How do you initialize a Matrix from a nest of initializer_lists and make sure the dimensions are reasonable? How do we ensure that we don’t instantiate a Matrix with an unsuitable element type?

The easiest way to present this code is to place all of Matrix in a header file. In that case, add inline to the definition of every nonmember function.

The definitions of functions that are not members of Matrix, Matrix_ref, Matrix_slice, or part of the general interface are placed in namespace Matrix_impl.

29.4.1. slice()
A simple slice as used for slice subscripting describes a mapping from an integer (subscript) to an element location (index) in terms of three values:

Click here to view code image

struct slice {
     slice() :start(-1), length(-1), stride(1) { }
     explicit slice(size_t s) :start(s), length(-1), stride(1) { }
     slice(size_t s, size_t l, size_t n = 1) :start(s), length(l), stride(n) { }

     size_t operator()(size_t i) const { return start+i*stride; }

     static slice all;

     size_t start;         // first index
     size_t length;        // number of indices included (can be used for range checking)
     size_t stride;        // distance between elements in sequence
};
There is a standard-library version of slice; see §40.5.4 for a more thorough discussion. This version provides notational convenience (e.g., the default values provided by the constructors).

29.4.2. Matrix Slices
A Matrix_slice is the part of the Matrix implementation that maps a set of subscripts to the location of an element. It uses the idea of generalized slices (§40.5.6):

Click here to view code image

template<size_t N>
struct Matrix_slice {
     Matrix_slice() = default;                               // an empty matrix: no elements

     Matrix_slice(siz e_t offset, initializer_list<siz e_t> exts);  // star ting offset and extents
     Matrix_slice(siz e_t offset, initializer_list<siz e_t> exts, initializer_list<siz e_t> strs); // and strides

     template<typename...Dims>                               // N extents
         Matrix_slice(Dims... dims);

     template<typename... Dims,
              typename = Enable_if<All(Convertible<Dims,size_t>()...)>>
         size_t operator()(Dims... dims) const;              // calculate index from a set of subscripts

     size_t size;                   // total number of elements
     size_t start;                  // starting offset
     array<size_t,N> extents;       // number of elements in each dimension
     array<size_t,N> strides;       // offsets between elements in each dimension
};
In other words, a Matrix_slice describes what is considered rows and columns in a region of memory. In the usual C/C++ row-major layout of a matrix, the elements of rows are contiguous, and the elements of a column are separated by a fixed number of elements (a stride). A Matrix_slice is a function object, and its operator()() does a stride calculation (§40.5.6):

Click here to view code image

template<size_t N>
    template<typename... Dims>
    size_t Matrix_slice<N>::operator()(Dims... dims) const
    {

        static_asser t(sizeof...(Dims)==N, "Matrix_slice<N>::operator(): dimension mismatch");

        size_t args[N] { size_t(dims)... };     // Copy arguments into an array

        return start+inner_product(args,args+N,strides.begin(),siz e_t{0});
    }
Subscripting must be efficient. This is a simplified algorithm that needs to be optimized. If nothing else, specialization can be used to eliminate the simplifying copy of subscripts out of the variadic template’s parameter pack. For example:

Click here to view code image

template<>
struct Matrix_slice<1> {

     //...

    size_t operator()(size_t i) const
    {
         return i;
    }
}

template<>
struct Matrix_slice<2> {

     //...

    size_t operator()(size_t i, size_t j) const
    {
         return start+i.strides[0]+j;
    }
}
The Matrix_slice is fundamental for defining the shape of a Matrix (its extents) and for implementing N-dimensional subscripting. However, it is also useful for defining submatrices.

29.4.3. Matrix_ref
A Matrix_ref is basically a clone of the Matrix class used to represent sub-Matrixes. However, a Matrix_ref does not own its elements. It is constructed from a Matrix_slice and a pointer to elements:

Click here to view code image

template<typename T, size_t N>
class Matrix_ref {
public:
     Matrix_ref(const Matrix_slice<N>& s, T* p) :desc{s}, ptr{p} {}
      //... mostly like Matrix ...
private:
     Matrix_slice<N> desc;    // the shape of the matrix
     T* ptr;                  // the first element in the matrix
};
A Matrix_ref simply points to the elements of “its” Matrix. Obviously, a Matrix_ref should not outlive its Matrix. For example:

Click here to view code image

Matrix_ref<double,1> user()
{
     Matrix<double,2> m = {{1,2}, {3,4}, {5,6}};
     return m.row(1);
}

auto mr = user();    // trouble
The great similarity between Matrix and Matrix_ref leads to duplication. If that becomes a bother, we can derive both from a common base:

Click here to view code image

template<typename T, size_t N>
class Matrix_base {
      //... common stuff ...
};

template<typename T, size_t N>
class Matrix : public Matrix_base<T,N> {
      //... special to Matrix ...
private:
     Matrix_slice<N> desc;      // the shape of the matrix
     vector<T> elements;
};

template<typename T, size_t N>
class Matrix_ref : public Matrix_base<T,N> {
      //... special to Matrix_ref ...
private:
     Matrix_slice<N> desc;     // the shape of the matrix
     T* ptr;
};
29.4.4. Matrix List Initialization
The Matrix constructor that constructs from an initializer_list takes as its argument type the alias Matrix_initializer:

Click here to view code image

template<typename T, size_t N>
using Matrix_initializer = typename Matrix_impl::Matrix_init<T, N>::type;
Matrix_init describes the structure of a nested initializer_list.

Matrix_init<T,N> simply has Matrix_init<T,N–1> as its member type:

Click here to view code image

template<typename T, size_t N>
struct Matrix_init {
     using type = initializer_list<typename Matrix_init<T,N–1>::type>;
};
The N==1 is special. That is where we get to the (most deeply nested) initializer_list<T>:

template<typename T>
struct Matrix_init<T,1> {
     using type = initializer_list<T>;
};
To avoid surprises, we define N=0 to be an error:

Click here to view code image

template<typename T>
struct Matrix_init<T,0>;   // undefined on purpose
To complete the Matrix constructor that takes a Matrix_initializer (_???_), we need three operations, two of which recurse down a tree of initializ er_lists for a Matrix<T,N>:

• derive_extents() determines the shape of the Matrix:

• Checks that the tree really is N deep

• Checks that each row (sub-initializ e_list) has the same number of elements

• Sets the extent of each row

• compute_strides() computes the strides needed for subscript calculations and the number of elements, given the extents.

• insert_flat() copies the elements of the tree of initializer_list<T>s into the elems of a Matrix.

The derived_extents() called from a Matrix constructor to initialize its desc looks like this:

Click here to view code image

template <std::size_t N, typename List>
std::array<std::siz e_t,N> derive_extents(const List& list)
{
     array<siz e_t,N> a;
     auto f = a.begin();
     add_extents<N>(f,list);   // add sizes (extents) to a
     return a;
}
You give it an initializer_list and it returns an array of extents.

The recursion is done from N to the final 1 where the initializer_list is an initializer_list<T>:

Click here to view code image

template<size_t N, typename I, typename List>
Enable_if<(N>1),void> add_extents(I& first, const List& list)
{
     assert(check_non_jagged<N>(list));
     *first++ = list.size(); // store this size (extent)
     add_extents<N-1>(first,*list.begin());
}

template <std::size_t N, typename I, typename List>
Enable_if<(N==1),void> add_extents(I& first, const List& list)
{
     *first++ = list.size();    
}
The check_non_jagged() function checks that all rows have the same number of elements:

Click here to view code image

template <size_t N, typename List>
bool check_non_jagged(const List& list)
{
     auto i = list.begin();
     for (auto j = i+1; j!=list.end(); ++j)
           if (derive_extents<N.1>(.i) != derive_extents<N.1>(.j))
                 return false;
     return true;
}
Given the extents, e.g., as computed by derive_extents(), we can compute the number of elements and the strides for a Matrix:

Click here to view code image

template<int N>
void compute_strides(Matrix_slice<N>& ms)
{
     siz e_t st = 1;                   // last stride is 1
     for (int i=N.1; i>=0; ..i) {      // for each dimension, compute the stride
       ms.strides[i] = st;
       st .= ms.extents[i];
     }
     ms.siz e = st;
}
We need inser t_flat() to take a possibly nested initializer list and present its elements to Matrix<T> as a vector<T>. It takes the initializ er_list given to a Matrix as the Matrix_initializ er and provides the elements as the target:</T<

Click here to view code image

template<typename T, typename Vec>
void insert_flat(initializer_list<T> list, Vec& vec)
{
     add_list(list.begin(),list.end(),vec);
}
Unfortunately, we can’t rely on the elements being allocated contiguously in memory, so we need to build the vector through a set of recursive calls. If we have a list of initializer_lists, we recurse through each:

Click here to view code image

template<typename T, typename Vec>  // nested initializer_lists
void add_list(const initializer_list<T>* first, const initializer_list<T>* last, Vec& vec)
{
     for (;first!=last;++first)
           add_list(first->begin(),first->end(),vec);
}
When we reach a list with non-initializer_list elements, we insert those elements into our vector:

Click here to view code image

template<typename T, typename Vec>
void add_list(const T*first, const T *last, Vec& vec)
{
     vec.insert(vec.end(),first,last);
}
I use vec.insert(vec.end(),first,last) because there is no push_back() that takes a sequence argument.

29.4.5. Matrix Access
A Matrix provides access by row, column, slice (§29.4.1), and element (§29.4.3). A row() or column() operation returns a Matrix_ref<T,N–1>, the () subscript operation with integers returns a T&, and the () subscript operation with slices returns a Matrix<T,N>.

The row of a Matrix<T,N> is a Matrix_ref<T,N–1> as long as 1<N:

Click here to view code image

template<typename T, size_t N>
Matrix_ref<T,N-1> Matrix<T,N>::row(size_t n)
{
     assert(n<rows());
     Matrix_slice<N-1> row;
     Matrix_impl::slice_dim<0>(n,desc,row);
     return {row,data()};
}
We need specializations for N==1 and N==0:

template<typename T>
T& Matrix<T,1>::row(size_t i)
{
     return &elems[i];
}

template<typename T>
T& Matrix<T,0>::row(size_t n) = delete;
Selecting a column() is essentially the same as selecting a row(). The difference is simply in the construction of the Matrix_slice:

Click here to view code image

template<typename T, size_t N>
Matrix_ref<T,N-1> Matrix<T,N>::column(size_t n)
{
     assert(n<cols());
     Matrix_slice<N-1> col;
     Matrix_impl::slice_dim<1>(n,desc,col);
     return {col,data()};
}
Requesting_element() and Requesting_slice() are concepts for a set of integers used for subscripting with a set of integers and subscripting by a slice, respectively (§29.4.5). They check that a sequence of access-function arguments are of suitable types for use as subscripts.

Subscripting with integers is defined like this:

Click here to view code image

template<typename T, size_t N>         // subscripting with integers
     template<typename... Args>
     Enable_if<Matrix_impl::Requesting_element<Args...>(),T&>
     Matrix<T,N>::operator()(Args... args)
     {
          assert(Matrix_impl::check_bounds(desc, args...));
          return *(data() + desc(args...));
}
The check_bounds() predicate checks that the number of subscripts equals the number of dimensions and that the subscripts are within bounds:

Click here to view code image

template<size_t N, typename... Dims>
bool check_bounds(const Matrix_slice<N>& slice, Dims... dims)
{
     size_t indexes[N] {size_t(dims)...};
     return equal(indexes, indexes+N, slice.extents.begin(), less<size_t> {});
}
The actual location of the element in the Matrix is calculated by invoking the Matrix’s Matrix_slice’s generalized slice calculation presented as a function object: desc(args...). Add that to the start of the data (data()) and we have our location:

return *(data() + desc(args...));
This leaves the most mysterious part of the declaration for last. The specification of operator()()’s return type looks like this:

Enable_if<Matrix_impl::Requesting_element<Args...>(),T&>
So the return type is T& provided that

Matrix_impl::Requesting_element<Args...>()
is true (§28.4). This predicate simply checks that every subscript can be converted to the required size_t by using a concept version of the standard-library predicate is_convertible (§35.4.1):

Click here to view code image

template<typename ... Args>
constexpr bool Requesting_element()
{
     return All(Convertible<Args,size_t>()...);
}
All() simply applies its predicate to every element of a variadic template:

constexpr bool All() { return true; }

template<typename ... Args>
constexpr bool All(bool b, Args... args)
{
     return b && All(args...);
}
The reason for using a predicate (Requesting_element) and the Enable_if() is to choose between the element and the slice subscript operators. The predicate used by the slice subscript operator looks like this:

Click here to view code image

template<typename... Args>
constexpr bool Requesting_slice()
{
     return All((Convertible<Args,size_t>() || Same<Args,slice>())...)
                && Some(Same<Args,slice>()...);
}
That is, if there is at least one slice argument and if all arguments are either convertible to slice or size_t, we have something that can be used to describe a Matrix<T,N>:

Click here to view code image

template<typename T, size_t N>    // subscripting with slices
    template<typename... Args>
        Enable_if<Matrix_impl::Requesting_slice<Args...>(), Matrix_ref<T,N>>
    Matrix<T,N>::operator()(const Args&... args)
    {
         Matrix_slice<N> d;
         d.start = Matrix_impl::do_slice(desc,d,args...);
         return {d,data()};
    }
The slices represented as extents and strides in a Matrix_slice and used for slice subscripting are computed like this:

Click here to view code image

template<size_t N, typename T, typename... Args>
size_t do_slice(const Matrix_slice<N>& os, Matrix_slice<N>& ns, const T& s, const Args&... args)
{
     size_t m = do_slice_dim<sizeof...(Args)+1>(os,ns,s);
     size_t n = do_slice(os,ns,args...);
     return m+n;
}
As usual, the recursion is terminated by a simple function:

Click here to view code image

template<size_t N>
size_t do_slice(const Matrix_slice<N>& os, Matrix_slice<N>& ns)
{
     return 0;
}
The do_slice_dim() is a tricky bit of computation (to get the slice values right) but illustrates no new programming techniques.

29.4.6. Zero-Dimensional Matrix
The Matrix code contains a lot of occurrences of N–1 where N is the number of dimensions. Thus, N==0 could easily become a nasty special case (for the programming as well as for the mathematics). Here, we solve the problem by defining a specialization:

Click here to view code image

template<typename T>
class Matrix<T,0> {
public:
     static constexpr size_t order = 0;
     using value_type = T;

     Matrix(const T& x) : elem(x) { }
     Matrix& operator=(const T& value) { elem = value; return *this; }

     T& operator()() { return elem; }
     const T& operator()() const { return elem; }

     operator T&() { return elem; }
     operator const T&() { return elem; }
private:
     T elem;
};
Matrix<T,0> is not really a matrix. It stores a single element of type T and can only be converted to a reference to that type.

29.5. Solving Linear Equations
The code for a numerical computation makes sense if you understand the problem being solved and the math used to express the solution and tends to appear to be utter nonsense if you don’t. The example used here should be rather trivial if you have learned basic linear algebra; if not, just see it as an example of transcribing a textbook solution into code with minimal rewording.

The example here is chosen to demonstrate a reasonably realistic and important use of Matrixes. We will solve a set (any set) of linear equations of this form:

a1,1 x1 + ... + a1,n xn = b1

...

an,1 x1 + ... + an,n xn = bn

Here, the xs designate the n unknowns; as and bs are given constants. For simplicity, we assume that the unknowns and the constants are floating-point values. The goal is to find values for the unknowns that simultaneously satisfy the n equations. These equations can compactly be expressed in terms of a matrix and two vectors:

Ax =b
Here, A is the square n-by-n matrix defined by the coefficients:

A
∼
=
∼
[
�
1
,
1
...
�
1
,
�
...
...
...
�
�
,
1
...
�
�
,
�
]
The vectors x and b are the vectors of unknowns and constants, respectively:

x
∼
=
∼
[
�
1
...
�
�
]
∼
,
∼
and
∼
boldb
=
[
�
1
...
�
�
]
This system may have zero, one, or an infinite number of solutions, depending on the coefficients of the matrix A and the vector b. There are various methods for solving linear systems. We use a classic scheme, called Gaussian elimination [Freeman,1992], [Stewart,1998], [Wood,1999]. First, we transform A and b so that A is an upper-triangular matrix. By “upper-triangular,” we mean all the coefficients below the diagonal of A are zero. In other words, the system looks like this:

[
�
1
,
1
...
�
1
,
�
0
...
...
0
0
�
�
,
�
]
∼
[
�
1
...
�
�
]
∼
=
∼
[
�
1
...
�
�
]
This is easily done. A zero for position a(i,j) is obtained by multiplying the equation for row i by a constant so that a(i,j) equals another element in column j, say a(k,j). That done, we just subtract the two equations, and a(i,j)==0 and the other values in row i change appropriately.

If we can get all the diagonal coefficients to be nonzero, then the system has a unique solution, which can be found by “back substitution.” The last equation is easily solved:

an,n xn = bn

Obviously, x[n] is b[n]/a(n,n). That done, eliminate row n from the system and proceed to find the value of x[n–1], and so on, until the value for x[1] is computed. For each n, we divide by a(n,n) so the diagonal values must be nonzero. If that does not hold, the back substitution method fails, meaning that the system has zero or an infinite number of solutions.

29.5.1. Classical Gaussian Elimination
Now let us look at the C++ code to express this. First, we’ll simplify our notation by conventionally naming the two Matrix types that we are going to use:

using Mat2d = Matrix<double,2>;
using Vec = Matrix<double,1>;
Next, we will express our desired computation:

Click here to view code image

Vec classical_gaussian_elimination(Mat2d A, Vec b)
{
     classical_elimination(A, b);
     return back_substitution(A, b);
}
That is, we make copies of our inputs A and b (using call-by-value), call a function to solve the system, and then calculate the result to return by back substitution. The point is that our breakdown of the problem and our notation for the solution are right out of the textbook. To complete our solution, we have to implement classical_elimination() and back_substitution(). Again, the solution is in the textbook:

Click here to view code image

void classical_elimination(Mat2d& A, Vec& b)
{
     const size_t n = A.dim1();

      // traverse from 1st column to the next-to-last, filling zeros into all elements under the diagonal:
     for (size_t j = 0; j!=n-1; ++j) {
           const double pivot = A(j, j);
           if (pivot==0) throw Elim_failure(j);
            // fill zeros into each element under the diagonal of the ith row:
           for (size_t i = j+1; i!=n; ++i) {
                 const double mult = A(i,j) / pivot;
                 A[i](slice(j)) = scale_and_add(A[j](slice(j)), -mult,A[i](slice(j)));
                 b(i) -= mult*b(j);  // make the corresponding change to b
           }
     }
}
The pivot is the element that lies on the diagonal of the row we are currently dealing with. It must be nonzero because we need to divide by it; if it is zero, we give up by throwing an exception:

Click here to view code image

Vec back_substitution(const Mat2d& A, const Vec& b)
{
     const size_t n = A.dim1();
     Vec x(n);

     for (size_t i = n-1; i>=0; --i) {
           double s = b(i)-dot_product(A[i](slice(i+1)),x(slice(i+1)));
           if (double m = A(i,i))
                 x(i) = s/m;
           else
                 throw Back_subst_failure(i);
     }
     return x;
}
29.5.2 Pivoting
We can avoid the divide-by-zero problem and also achieve a more robust solution by sorting the rows to get zeros and small values away from the diagonal. By “more robust” we mean less sensitive to rounding errors. However, the values change as we go along placing zeros under the diagonal, so we have to also reorder to get small values away from the diagonal (that is, we can’t just reorder the matrix and then use the classical algorithm):

Click here to view code image

void elim_with_partial_pivot(Mat2d& A, Vec& b)
{
     const size_t n = A.dim1();

     for (size_t j = 0; j!=n; ++j) {
           size_t pivot_row = j;
      // look for a suitable pivot:
            for (size_t k = j+1; k!=n; ++k)
                  if (abs(A(k,j)) > abs(A(pivot_row,j)))
                        pivot_row = k;

             // swap the rows if we found a better pivot:
            if (pivot_row!=j) {
                   A.swap_rows(j,pivot_row);
                   std::swap(b(j),b(pivot_row));
            }

             // elimination:
            for (size_t i = j+1; i!=n; ++i) {
                  const double pivot = A(j,j);
                  if (pivot==0) error("can't solve: pivot==0");
                  const double mult = A(i,j)/pivot;
                  A[i](slice(j)) = scale_and_add(A[j].slice(j), –mult, A[i].slice(j));
                  b(i) –= mult*b(j);
            }
      }
}
We use swap_rows() and scale_and_multiply() to make the code more conventional and to save us from writing an explicit loop.

29.5.3. Testing
Obviously, we have to test our code. Fortunately, there is a simple way to do that:

Click here to view code image

void solve_random_system(size_t n)
{
     Mat2d A = random_matrix(n);  // generate random Mat2d
     Vec b = random_vector(n);    // generate random Vec

     cout << "A = " << A << '\n';
     cout << "b = " << b << endl;

     try {
          Vec x = classical_gaussian_elimination(A, b);
          cout << "classical elim solution is x = " << x << '\n';
               Vec v = A * x;
          cout << " A * x = " <<v<< endl;
     }
     catch(const exception& e) {
          cerr << e.what() << '\n';
     }
}
We can get to the catch-clause in three ways:

• A bug in the code (but, being optimists, we don’t think there are any)

• An input that trips up classical_elimination() (using elim_with_partial_pivot() would minimize the chances of that)

• Rounding errors

However, our test is not as realistic as we’d like because genuinely random matrices are unlikely to cause problems for classical_elimination().

To verify our solution, we print out A*x, which had better equal b (or close enough for our purpose, given rounding errors). The likelihood of rounding errors is the reason we didn’t just do:

if (A*x!=b) error("substitution failed");
Because floating-point numbers are just approximations to real numbers, we have to accept approximately correct answers. In general, using == and != on the result of a floating-point computation is best avoided: floating-point is inherently an approximation. Had I felt the need for a machine check, I would have defined an equal() function with a notion of which error ranges to consider acceptable and then written:

if (!equal(A*x,b)) error("substitution failed");
The random_matrix() and random_vector() are simple uses of random numbers and are left as simple exercises for the reader.

29.5.4. Fused Operations
In addition to providing efficient primitive operations, a general matrix class must handle three related problems to satisfy performance-conscious users:

[1] The number of temporaries must be minimized.

[2] Copying of matrices must be minimized.

[3] Multiple loops over the same data in composite operations must be minimized.

Consider U=M*V+W, where U, V, and W are vectors (Matrix<T,1>) and M is a Matrix<T,2>. A naive implementation introduces temporary vectors for M*V and M*V+W and copies the results of M*V and M*V+W. A smart implementation calls a function mul_add_and_assign(&U,&M,&V,&W) that introduces no temporaries, copies no vectors, and touches each element of the matrices the minimum number of times.

The move constructor helps: the temporary used for M*V is used for (M*V)+W. If we had written

Matrix<double,1> U=M*V+W;
we would have eliminated all element copies: the elements allocated in the local variable in M*V are the ones ending up in U.

That leaves the problem of merging the loops: loop fusion. This degree of optimization is rarely necessary for more than a few kinds of expressions, so a simple solution to efficiency problems is to provide functions such as mul_add_and_assign() and let the user call those where it matters. However, it is possible to design a Matrix so that such optimizations are applied automatically for expressions of the right form. That is, we can treat U=M*V+W as a use of a single operator with four operands. The basic technique was demonstrated for ostream manipulators (§38.4.5.2). In general, it can be used to make a combination of n binary operators act like an (n+1)-ary operator. Handling U=M*V+W requires the introduction of two auxiliary classes. However, the technique can result in impressive speedups (say, 30 times) on some systems by enabling more powerful optimization techniques. First, for simplicity, let us restrict ourselves to two-dimensional matrices of double-precision floating-point numbers:

using Mat2d = Matrix<double,2>;
using Vec = Matrix<double,1>;
We define the result of multiplying a Mat2d by a Vec:

Click here to view code image

struct MVmul {
     const Mat2d& m;
     const Vec& v;

     MVmul(const Mat2d& mm, const Vec &vv) :m{mm}, v{vv} { }

     operator Vec();// evaluate and return result
};

inline MVmul operator*(const Mat2d& mm, const Vec& vv)
{
     return MVmul(mm,vv);
}
This “multiplication” should replace the one from §29.3 and does nothing except store references to its operands; the evaluation of M*V is deferred. The object produced by * is closely related to what is called a closure in many technical communities. Similarly, we can deal with what happens if we add a Vec:

Click here to view code image

struct MVmulVadd {
     const Mat2d& m;
     const Vec& v;
     const Vec& v2;

     MVmulVadd(const MVmul& mv, const Vec& vv) :m(mv.m), v(mv.v), v2(vv) { }

     operator Vec(); // evaluate and return result
};

inline MVmulVadd operator+(const MVmul& mv, const Vec& vv)
{
     return MVmulVadd(mv,vv);
}
This defers the evaluation of M*V+W. We now have to ensure that it all gets evaluated using a good algorithm when it is assigned to a Vec:

Click here to view code image

template<>
class Matrix<double,1> {      // specialization (just for this example)
      //...

public:
     Matrix(const MVmulVadd& m)                    // initialize by result of m
     {
           // allocate elements, etc.
          mul_add_and_assign(this,&m.m,&m.v,&m.v2);
     }

     Matrix& operator=(const MVmulVadd& m)         // assign the result of m to *this
     {
         mul_add_and_assign(this,&m.m,&m.v,&m.v2);
         return *this;
     }
      //...
};
Now U=M*V+W is automatically expanded to

U.operator=(MVmulVadd(MVmul(M,V),W))
which because of inlining resolves to the desired simple call

mul_add_and_assign(&U,&M,&V,&W)
Clearly, this eliminates the copying and the temporaries. In addition, we might write mul_add_and_assign() in an optimized fashion. However, if we just wrote it in a fairly simple and unoptimized fashion, it would still be in a form that offered great opportunities to an optimizer.

The importance of this technique is that most really time-critical vector and matrix computations are done using a few relatively simple syntactic forms. Typically, there is no real gain in optimizing expressions of half a dozen operators. For that we typically want to write a function anyway.

This technique is based on the idea of using compile-time analysis and closure objects to transfer evaluation of a subexpression into an object representing a composite operation. It can be applied to a variety of problems with the common attribute that several pieces of information need to be gathered into one function before evaluation can take place. I refer to the objects generated to defer evaluation as composition closure objects, or simply compositors.

If this composition technique is used to delay execution of all operations, it is referred to as expression templates [Vandevoorde,2002] [Veldhuizen,1995]. Expression templates systematically use function objects to represent expressions as abstract syntax trees (ASTs).

29.6. Advice
[1] List basic use cases; §29.1.1.

[2] Always provide input and output operations to simplify simple testing (e.g., unit testing); §29.1.1.

[3] Carefully list the properties a program, class, or library ideally should have; §29.1.2.

[4] List the properties of a program, class, or library that are considered beyond the scope of the project; §29.1.2.

[5] When designing a container template, carefully consider the requirements on the element type; §29.1.2.

[6] Consider how the design might accommodate run-time checking (e.g., for debugging); §29.1.2.

[7] If possible, design a class to mimic existing professional notation and semantics; §29.1.2.

[8] Make sure that the design does not leak resources (e.g., have a unique owner for each resource and use RAII); §29.2.

[9] Consider how a class can be constructed and copied; §29.1.1.

[10] Provide complete, flexible, efficient, and semantically meaningful access to elements; §29.2.2, §29.3.

[11] Place implementation details in their own _impl namespace; §29.4.

[12] Provide common operations that do not require direct access to the representation as helper functions; §29.3.2, §29.3.3.

[13] For fast access, keep data compact and use accessor objects to provide necessary nontrivial access operations; §29.4.1,§29.4.2, §29.4.3.

[14] The structure of data can often be expressed as nested initializer lists; §29.4.4.

[15] When dealing with numbers, aways consider “end cases,” such as zero and “many”; §29.4.6.

[16] In addition to unit testing and testing that the code meets its requirements, test the design through examples of real use; §29.5.

[17] Consider how the design might accommodate unusually stringent performance requirements; §29.5.4


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


29. A Matrix Design
Part IV: The Standard Library
30. Standard-Library Overview
47h 26m remaining
Part IV: The Standard Library
This part describes the C++ standard library. The aim is to provide an understanding of how to use the library, to demonstrate generally useful design and programming techniques, and to show how to extend the library in the ways in which it was intended to be extended.

Chapters

30 Standard-Library Overview

31 STL Containers

32 STL Algorithms

33 STL Iterators

34 Memory and Resources

35 Utilities

36 Strings

37 Regular Expressions

38 I/O Streams

39 Locales

40 Numerics

41 Concurrency

42 Threads and Tasks

43 The C Standard Library

44 Compatibility

“... I am just now beginning to discover the difficulty of expressing one’s ideas on paper. As long as it consists solely of description it is pretty easy; but where reasoning comes into play, to make a proper connection, a clearness & a moderate fluency, is to me, as I have said, a difficulty of which I had no idea ...”

– Charles Darwin


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


Part IV: The Standard Library
30. Standard-Library Overview
31. STL Containers
47h 26m remaining
30. Standard-Library Overview
Many secrets of art and nature are thought by the unlearned to be magical.

– Roger Bacon

• Introduction

Standard-Library Facilities; Design Constraints; Description Style

• Headers

• Language Support

initializer_list Support; Range-for Support

• Error Handling

Exceptions; Assertions; system_error

• Advice

30.1. Introduction
The standard library is the set of components specified by the ISO C++ standard and shipped with identical behavior (modulo performance) by every C++ implementation. For portability and long-term maintainability, I strongly recommend using the standard library whenever feasible. Maybe you can design and implement a better alternative for your application, but:

• How easy will it be for some future maintainer to learn that alternative design?

• How likely is the alternative to be available on a yet unknown platform ten years from now?

• How likely is the alternative to be useful for future applications?

• How likely is it that your alternative will be interoperable with code written using the standard library?

• How likely is it that you can spend as much effort optimizing and testing your alternative as was done for the standard library?

And, of course, if you use an alternative, you (or your organization) will be responsible for the maintenance and evolution of the alternative “forever.” In general: try not to reinvent the wheel.

The standard library is rather large: its specification in the ISO C++ standard is 785 dense pages. And that is without describing the ISO C standard library, which is a part of the C++ standard library (another 139 pages). To compare, the C++ language specification is 398 pages. Here, I summarize, relying heavily on tables, and give a few examples. Details can be found elsewhere, including online copies of the standard, complete online documentation of implementations, and (if you like to read code) open source implementations. Rely on the references to the standard for complete details.

The standard-library chapters are not intended to be read in their order of presentation. Each chapter and typically each major subsection can be read in isolation. Rely on cross-references and the index if you encounter something unknown.

30.1.1. Standard-Library Facilities
What ought to be in the standard C++ library? One ideal is for a programmer to be able to find every interesting, significant, and reasonably general class, function, template, etc., in a library. However, the question here is not “What ought to be in some library?” but “What ought to be in the standard library?” “Everything!” is a reasonable first approximation to an answer to the former question but not to the latter. A standard library is something that every implementer must supply so that every programmer can rely on it.

The C++ standard library provides:

• Support for language features, such as memory management (§11.2), the range-for statement (§9.5.1), and run-time type information (§22.2)

• Information about implementation-defined aspects of the language, such as the largest finite float value (§40.2)

• Primitive operations that cannot be easily or efficiently implemented in the language itself, such as is_polymorphic, is_scalar, and is_nothrow_constructible (§35.4.1)

• Facilities for low-level (“lock-free”) concurrent programming (§41.3)

• Support for thread-based concurrency (§5.3, §42.2)

• Minimal support for task-based concurrency, such as future and async() (§42.4)

• Functions that most programmers cannot easily implement optimally and portably, such as uninitialized_fill() (§32.5) and memmove() (§43.5)

• Minimal support for (optional) reclamation of unused memory (garbage collection), such as declare_reachable() (§34.5)

• Nonprimitive foundational facilities that a programmer can rely on for portability, such as lists (§31.4), maps (§31.4.3), sort() (§32.6), and I/O streams (Chapter 38)

• Frameworks for extending the facilities it provides, such as conventions and support facilities that allow a user to provide I/O of a user-defined type in the style of I/O for built-in types (Chapter 38) and the STL (Chapter 31)

A few facilities are provided by the standard library simply because it is conventional and useful to do so. Examples are the standard mathematical functions, such as sqrt() (§40.3), random number generators (§40.7), complex arithmetic (§40.4), and regular expressions (Chapter 37).

The standard library aims to be the common foundation for other libraries. In particular, combinations of its facilities allow the standard library to play three supporting roles:

• A foundation for portability

• A set of compact and efficient components that can be used as the foundation for performance-sensitive libraries and applications

• A set of components enabling intra-library communications

The design of the library is primarily determined by these three roles. These roles are closely related. For example, portability is commonly an important design criterion for a specialized library, and common container types such as lists and maps are essential for convenient communication between separately developed libraries.

The last role is especially important from a design perspective because it helps limit the scope of the standard library and places constraints on its facilities. For example, string and list facilities are provided in the standard library. If they were not, separately developed libraries could communicate only by using built-in types. However, advanced linear algebra and graphics facilities are not provided. Such facilities are obviously widely useful, but they are rarely directly involved in communication between separately developed libraries.

Unless a facility is somehow needed to support these roles, it can be left to some library outside the standard. For good and bad, leaving something out of the standard library opens the opportunity for different libraries to offer competing realizations of an idea. Once a library proves itself widely useful in a variety of computing environments and application domains, it becomes a candidate for the standard library. The regular expression library (Chapter 37) is an example of this.

A reduced standard library is available for freestanding implementations, that is, implementations running with minimal or no operating system support (§6.1.1).

30.1.2. Design Constraints
The roles of a standard library impose several constraints on its design. The facilities offered by the C++ standard library are designed to be:

• Valuable and affordable to essentially every student and professional programmer, including the builders of other libraries.

• Used directly or indirectly by every programmer for everything within the library’s scope.

• Efficient enough to provide genuine alternatives to hand-coded functions, classes, and templates in the implementation of further libraries.

• Either policy free or with an option to supply policies as arguments.

• Primitive in the mathematical sense. That is, a component that serves two weakly related roles will almost certainly suffer overhead compared to individual components designed to perform only a single role.

• Convenient, efficient, and reasonably safe for common uses.

• Complete in what they do. The standard library may leave major functions to other libraries, but if it takes on a task, it must provide enough functionality so that individual users or implementers need not replace it to get the basic job done.

• Easy to use with built-in types and operations.

• Type safe by default, and therefore in principle checkable at run time.

• Supportive of commonly accepted programming styles.

• Extensible to deal with user-defined types in ways similar to the way built-in types and standard-library types are handled.

For example, building the comparison criteria into a sort function is unacceptable because the same data can be sorted according to different criteria. This is why the C standard-library qsort() takes a comparison function as an argument rather than relying on something fixed, say, the < operator (§12.5). On the other hand, the overhead imposed by a function call for each comparison compromises qsort() as a building block for further library building. For almost every data type, it is easy to do a comparison without imposing the overhead of a function call.

Is that overhead serious? In most cases, probably not. However, the function call overhead can dominate the execution time for some algorithms and cause users to seek alternatives. The technique described in §25.2.3 of supplying comparison criteria through a template argument solves that problem for sort() and many other standard-library algorithms. The sort example illustrates the tension between efficiency and generality. It is also an example of how such tensions can be resolved. A standard library is not merely required to perform its tasks. It must also perform them so efficiently that users are not tempted to supply their own alternatives to what the standard offers. Otherwise, implementers of more advanced features are forced to bypass the standard library in order to remain competitive. This would add a burden to the library developer and seriously complicate the lives of users wanting to stay platform-independent or to use several separately developed libraries.

The requirements of “primitiveness” and “convenience of common uses” can conflict. The former requirement precludes exclusively optimizing the standard library for common cases. However, components serving common, but nonprimitive, needs can be included in the standard library in addition to the primitive facilities, rather than as replacements. The cult of orthogonality must not prevent us from making life convenient for the novice and the casual user. Nor should it cause us to leave the default behavior of a component obscure or dangerous.

30.1.3. Description Style
A full description of even a simple standard-library operation, such as a constructor or an algorithm, can take pages. Consequently, I use an extremely abbreviated style of presentation. Sets of related operations are typically presented in tables:

Some Operations

p=op(b,e,x)

op does something to the range [b:e) and x, returning p

foo(x)

foo does something to x but returns no result

bar(b,e ,x)

Does x have something to do with [b:e)?

I try to be mnemonic when choosing identifiers, so b and e will be iterators specifying a range, p a pointer or an iterator, and x some value, all depending on context. In this notation, only the commentary distinguishes no result from a Boolean result, so you can confuse those if you try hard enough. For an operation returning a Boolean, the explanation usually ends with a question mark. Where an algorithm follows the usual pattern of returning the end of an input sequence to indicate “failure,” “not found,” etc. (§4.5.1, §33.1.1), I do not mention that explicitly.

Usually, such an abbreviated description is accompanied with a reference to the ISO C++ standard, some further explanation, and examples.

30.2. Headers
The facilities of the standard library are defined in the std namespace and presented as a set of headers. The headers identify the major parts of the library. Thus, listing them gives an overview of the library.

The rest of this subsection is a list of headers grouped by function, accompanied by brief explanations and annotated by references to where they are discussed. The grouping is chosen to match the organization of the standard.

A standard header with a name starting with the letter c is equivalent to a header in the C standard library. For every header <X.h> defining part of the C standard library in the global namespace and also in namespace std, there is a header <cX> defining the same names. Ideally, the names from a <cX> header do not pollute the global namespace (§15.2.4), but unfortunately (due to complexities of maintaining multilanguage, multi-operating-system environments) most do.

Containers

<vector>

One-dimensional resizable array

§31.4.2

<deque>

Double-ended queue

§31.4.2

<forward_list>

Singly-linked list

§31.4.2

<list>

Doubly-linked list

§31.4.2

<map>

Associative array

§31.4.3

<set>

Set

§31.4.3

<unordered_map>

Hashed associative array

§31.4.3.2

<unordered_set>

Hashed set

§31.4.3.2

<queue>

Queue

§31.5.2

<stack>

Stack

§31.5.1

<array>

One-dimensional fixed-size array

§34.2.1

<bitset>

Array of bool

§34.2.2

The associative containers multimap and multiset can be found in <map> and <set>, respectively. The priority_queue (§31.5.3) is declared in <queue>.

General Utilities

<utility>

Operators and pairs

§35.5, §34.2.4.1

<tuple>

Tuples

§34.2.4.2

<type_traits>

Type traits

§35.4.1

<typeindex>

Use a type_info as a key or a hash code

§35.5.4

<functional>

Function objects

§33.4

<memory>

Resource management pointers

§34.3

<scoped_allocator>

Scoped allocators

§34.4.4

<ratio>

Compile-time rational arithmetic

§35.3

<chrono>

Time utilities

§35.2

<ctime>

C-style date and time

§43.6

<iterator>

Iterators and iterator support

§33.1

Iterators provide the mechanism to make standard algorithms generic (§3.4.2, §33.1.4).

Algorithms

<algorithm>

General algorithms

§32.2

<cstdlib>

bsearch(), qsort()

§43.7

A typical general algorithm can be applied to any sequence (§3.4.2, §32.2) of any type of element. The C standard library functions bsearch() and qsort() apply to built-in arrays with elements of types without user-defined copy constructors and destructors only (§12.5).

Diagnostics

<exception>

Exception class

§30.4.1.1

<stdexcept>

Standard exceptions

§30.4.1.1

<cassert>

Assert macro

§30.4.2

<cerrno>

C-style error handling

§13.1.2

<system_error>

System error support

§30.4.3

Assertions using exceptions are described in §13.4.

Strings and Characters

<string>

String of T

Chapter 36

<cctype>

Character classification

§36.2.1

<cwctype>

Wide-character classification

§36.2.1

<cstring>

C-style string functions

§43.4

<cwchar>

C-style wide-character string functions

§36.2.1

<cstdlib>

C-style allocation functions

§43.5

<cuchar>

C-style multibyte characters

 

<regex>

Regular expression matching

Chapter 37

The <cstring> header declares the strlen(), strcpy(), etc., family of functions. The <cstdlib> declares atof() and atoi() which convert C-style strings to numeric values.

Input/Output

<iosfwd>

Forward declarations of I/O facilities

§38.1

<iostream>

Standard iostream objects and operations

§38.1

<ios>

iostream bases

§38.4.4

<streambuf>

Stream buffers

§38.6

<istream>

Input stream template

§38.4.1

<ostream>

Output stream template

§38.4.2

<iomanip>

Manipulators

§38.4.5.2

<sstream>

Streams to/from strings

§38.2.2

<fstream>

Streams to/from files

§38.2.1

<cstdio>

printf() family of I/O

§43.3

<cwchar>

printf()-style I/O of wide characters

§43.3

Manipulators are objects used to manipulate the state of a stream (§38.4.5.2).

Localization

<locale>

Represent cultural differences

Chapter 39

<clocale>

Represent cultural differences C-style

 

<codecvt>

Code conversion facets

§39.4.6

A locale localizes differences such as the output format for dates, the symbol used to represent currency, and string collation criteria that vary among different natural languages and cultures.

Language Support

<limits>

Numeric limits

§40.2

<climits>

C-style numeric scalar-limit macros

§40.2

<cfloat>

C-style numeric floating-point limit macros

§40.2

<cstdint>

Standard integer type names

§43.7

<new>

Dynamic memory management

§11.2.3

<typeinfo>

Run-time type identification support

§22.5

<exception>

Exception-handling support

§30.4.1.1

<initializer_list>

initializer_list

§30.3.1

<cstddef>

C library language support

§10.3.1

<cstdarg>

Variable-length function argument lists

§12.2.4

<csetjmp>

C-style stack unwinding

 

<cstdlib>

Program termination

§15.4.3

<ctime>

System clock

§43.6

<csignal>

C-style signal handling

 

The <cstddef> header defines the type of values returned by sizeof(), size_t, the type of the result of pointer subtraction and of array subscripts, ptrdiff_t (§10.3.1), and the infamous NULL macro (§7.2.2).

C-style stack unwinding (using setjmp and longjmp from <csetjmp>) is incompatible with the use of destructors and with exception handling (Chapter 13, §30.4) and is best avoided. C-style stack unwinding and signals are not discussed in this book.

Numerics

<complex>

Complex numbers and operations

§40.4

<valarray>

Numeric vectors and operations

§40.5

<numeric>

Generalized numeric operations

§40.6

<cmath>

Standard mathematical functions

§40.3

<cstdlib>

C-style random numbers

§40.7

<random>

Random number generators

§40.7

For historical reasons, abs() and div() are found in <cstdlib> rather than in <cmath> with the rest of the mathematical functions (§40.3).

Concurrency

<atomic>

Atomic types and operations

§41.3

<condition_variable>

Waiting for an action

§42.3.4

<future>

Asynchronous task

§42.4.4

<mutex>

Mutual exclusion classes

§42.3.1

<thread>

Threads

§42.2

C provides standard-library facilities of varying relevance to C++ programmers. The C++ standard library provides access to all such facilities:

C Compatibility

<cinttypes>

Aliases for common integer types

§43.7

<cstdbool>

C bool

 

<ccomplex>

<complex>

 

<cfenv>

Floating-point environment

 

<cstdalign>

C alignment

 

<ctgmath>

C ‘‘type generic math’’: <complex> and <cmath>

 

The <cstdbool> header will not define macros bool, true, or false. The <cstdalign> header will not define a macro alignas. The .h equivalents to <cstdbool>, <ccomplex>, <calign>, and <ctgmath> approximate C++ facilities for C. Avoid them if you can.

The <cfenv> header provides types (such as fenv_t and fexcept_t), floating-point status flags, and control modes describing an implementation’s floating-point environment.

A user or a library implementer is not allowed to add or subtract declarations from the standard headers. Nor is it acceptable to try to change the contents of a header by defining macros to change the meaning of declarations in a header (§15.2.3). Any program or implementation that plays such games does not conform to the standard, and programs that rely on such tricks are not portable. Even if they work today, the next release of any part of an implementation may break them. Avoid such trickery.

For a standard-library facility to be used, its header must be included. Writing out the relevant declarations yourself is not a standards-conforming alternative. The reason is that some implementations optimize compilation based on standard header inclusion, and others provide optimized implementations of standard-library facilities triggered by the headers. In general, implementers use standard headers in ways programmers cannot predict and shouldn’t have to know about.

A programmer can, however, specialize utility templates, such as swap() (§35.5.2), for non-standard-library, user-defined types.

30.3. Language Support
A small but essential part of the standard library is language support, that is, facilities that must be present for a program to run because language features depend on them.

Library Supported Language Features

<new>

new and delete

§11.2

<typeinfo>

typeid() and type_info

§22.5

<iterator>

Range-for

§30.3.2

<initializer_list>

initializer_list

§30.3.1

30.3.1. initializer_list Support
A {}-list is converted into an object of type std::initializer_list<X> according to the rules described in §11.3. In <initializer_list>, we find initializer_list:

Click here to view code image

template<typename T>
class initializer_list {  //§iso.18.9
public:
     using value_type = T;
     using reference = const T&;        // note const: initializer_list elements are immutable
     using const_reference = const T&;
     using size_type = size_t;
     using iterator = const T*;
     using const_iterator = const T*;

     initializer_list() noexcept;

     size_t size() const noexcept;      // number of elements
     const T* begin() const noexcept;   // first element
     const T* end() const noexcept;     // one-past-last element
};

template<typename T>
     const T* begin(initializer_list<T> lst) noexcept { return lst.begin(); }
template<typename T>
     const T* end(initializer_list<T> lst) noexcept { return lst.end(); }
Unfortunately, initializer_list does not offer a subscript operator. If you want to use [] rather than *, subscript a pointer:

Click here to view code image

void f(initializer_list<int> lst)
{
     for(int i=0; i<lst.size(); ++i)
           cout << lst[i] << '\n';    // error

     const int* p = lst.begin();
     for(int i=0; i<lst.size(); ++i)
           cout << p[i] << '\n';      // OK
}
Naturally, an initializer_list can also be used by a range-for. For example:

void f2(initializer_list<int> lst)
{
     for (auto x : lst)
           cout << x << '\n';
}
30.3.2. Range-for Support
A range-for statement is mapped to a for-statement using an iterator as described in §9.5.1.

In <iterator>, the standard library provides std::begin() and std::end() functions for built-in arrays and for every type that provides member begin() and end(); see §33.3.

All standard-library containers (e.g., vector and unordered_map) and strings support iteration using range-for; container adaptors (such as stack and priority_queue) do not. The container headers, such as <vector>, include <initializer_list>, so the user rarely has to do so directly.

30.4. Error Handling
The standard library consists of components developed over a period of almost 40 years. Thus, their style and approaches to error handling are not consistent:

• C-style libraries consist of functions, many of which set errno to indicate that an error happened; see §13.1.2 and §40.3.

• Many algorithms operating on a sequence of elements return an iterator to the one-past-the-last element to indicate “not found” or “failure”; see §33.1.1.

• The I/O streams library relies on a state in each stream to reflect errors and may (if the user requests it) throw exceptions to indicate errors; see §38.3.

• Some standard-library components, such as vector, string, and bitset, throw exceptions to indicate errors.

The standard library is designed so that all facilities obey “the basic guarantee” (§13.2); that is, even if an exception is thrown, no resource (such as memory) is leaked and no invariant for a standard-library class is broken.

30.4.1. Exceptions
Some standard-library facilities report errors by throwing exceptions:

Standard-Library Exceptions (continues)

bitset

Throws invalid_argument, out_of_range, overflow_error

iostream

Throws ios_base::failure if exceptions are enabled

regex

Throws regex_error

string

Throws length_error, out_of_range

vector

Throws length_error, out_of_range

Any container with at()

Throws out_of_range

new T

Throws bad_alloc or bad_array_new_length if not enough memory for a T

dynamic_cast<T>(r)

Throws bad_cast if it cannot convert the reference r to a T

typeid()

Throws bad_typeid if it cannot deliver a type_info

thread

Throws system_error

call_once()

Throws system_error

mutex

Throws system_error

unique_lock

Throws system_error

condition_variable

Throws system_error

async()

Throws system_error

packaged_task

Throws bad_alloc, future_error

future and promise

Throws future_error

These exceptions may be encountered in any code that directly or indirectly uses these facilities. In addition, any operation that manipulates an object that may throw an exception must be assumed to throw (that exception) unless care has been taken to avoid that. For example, a packaged_task will throw an exception if the function it is required to execute throws.

Unless you know that no facility is used in a way that could throw an exception, it is a good idea to always catch one of the root classes of the standard-library exception hierarchy (such as exception) as well as any exception (...) somewhere (§13.5.2.3), for example, in main().

30.4.1.1. The Standard exception Hierarchy
Do not throw built-in types, such as int and C-style strings. Instead, throw objects of types specifically defined to be used as exceptions.

This hierarchy of standard exception classes provides a classification of exceptions:



This hierarchy attempts to provide a framework for exceptions beyond the ones defined by the standard library. Logic errors are errors that in principle could be caught either before the program starts executing or by tests of arguments to functions and constructors. Run-time errors are all other errors. The system_error is described in §30.4.3.3.

The standard-library exception hierarchy is rooted in class exception:

Click here to view code image

class exception {
public:
     exception();
     exception(const exception&);
     exception& operator=(const exception&);
     virtual ~exception();
     virtual const char* what() const;
};
The what() function can be used to obtain a string that is supposed to indicate something about the error that caused the exception.

A programmer can define an exception by deriving from a standard-library exception like this:

Click here to view code image

struct My_error : runtime_error {
     My_error(int x) :runtime_error{"My_error"}, interesting_value{x} { }
     int interesting_value;
};
Not all exceptions are part of the standard-library exception hierarchy. However, all exceptions thrown by the standard library are from the exception hierarchy.

Unless you know that no facility is used in a way that could throw an exception, it is a good idea to somewhere catch all exceptions. For example:

Click here to view code image

int main()
try {
      //...
}
catch (My_error& me) {           // a My_error happened
      // we can use me.interesting_value and me.what()
}
catch (runtime_error& re) {      // a runtine_error happened
      // we can use re.what()
}
catch (exception& e) {           // some standard-library exception happened
      // we can use e.what()
}
catch (...) {                    // Some unmentioned exception happened
      // we can do local cleanup
}
As for function arguments, we use references to avoid slicing (§17.5.1.4).

30.4.1.2. Exception Propagation
In <exception>, the standard library provides facilities for making propagation of exceptions accessible to programmers:

Exception Propagation (§iso.18.8.5)

exception_ptr

Unspecified type used to point to exceptions

ep=current_exception()

ep is an exception_ptr to the current exception, or to

no exception if there is no currently active exception; noexcept

rethrow_exception(ep)

Re-throw the exception pointed to by ep;

ep’s contained pointer must not be nullptr; noreturn (§12.1.7)

ep=make_exception_ptr(e)

ep is an exception_ptr to exception e; noexcept

An exception_ptr can point to any exception, not just exceptions from the exception hierarchy. Think of exception_ptr as a smart pointer (like shared_ptr) that keeps its exception alive for as long as an exception_ptr points to it. That way, we can pass an exception_pointer to an exception out of a function that caught it and re-throw elsewhere. In particular, an exception_ptr can be used to implement a re-throw of an exception in a different thread from the one in which the exception was caught. This is what promise and future (§42.4) rely on. Use of rethrow_exception() on an exception_ptr (from different threads) does not introduce a data race.

The make_exception_ptr() could be implemented as:

Click here to view code image

template<typename E>
exception_ptr make_exception_ptr(E e) noexcept
try {
     throw e;
}
catch(...) {
     return current_exception();
}
A nested_exception is class that stores an exception_ptr obtained from a call of current_exception():

nested_exception (§iso.18.8.6)

nested_exception ne {};

Default constructor: ne holds an exception_ptr

to the current_exception(); noexcept

nested_exception ne {ne2};

Copy constructor: both ne and ne2 hold

an exception_ptr to the stored exception

ne2=ne

Copy assignment: both ne and ne2 hold an exception_ptr

to the stored exception

ne.-nested_exception()

Destructor; virtual

ne.rethrow_nested()

Rethrow ne’s stored exception;

terminate() if no exception is stored in ne; noreturn

ep=ne.nested_ptr()

ep is an exception_ptr pointing to ne’s stored exception; noexcept

throw_with_nested(e)

Throw an exception of type derived from nested_exception

and e’s type; e must not be derived from nested_exception; noreturn

rethrow_if_nested(e)

dynamic_cast<const nested_exception&>(e).rethrow_nested();

e’s type must be derived from nested_exception

The intended use of nested_exception is as a base class for a class used by an exception handler to pass some information about the local context of an error together with an exception_ptr to the exception that caused it to be called. For example:

Click here to view code image

struct My_error : runtime_error {
     My_error(const string&);
      //...
};

void my_code()
{
     try {
           //...
     }
     catch (...) {
          My_error err {"something went wrong in my_code()"};
           //...
          throw_with_nested(err);
     }
}
Now My_error information is passed along (rethrown) together with a nested_exception holding an exception_ptr to the exception caught.

Further up the call chain, we might want to look at the nested exception:

Click here to view code image

void user()
{
     try {
          my_code();
     }
     catch(My_error& err) {

      //... clear up My_error problems ...

          try {
              rethrow_if_nested(err);    // re-throw the nested exception, if any
          }
          catch (Some_error& err2) {
                //... clear up Some_error problems ...
          }
     }
}
This assumes that we know that Some_error might be nested with My_error.

An exception cannot propagate out of a noexcept function (§13.5.1.1).

30.4.1.3. terminate()
In <exception>, the standard library provides facilities for dealing with unexpected exceptions:

terminate (§iso.18.8.3, §iso.18.8.4)

h=get_terminate()

h is the current terminate handler; noexcept

h2=set_terminate(h)

h becomes the current terminate handler;

 

h2 is the previous terminate handler; noexcept

terminate()

Terminate the program; noreturn; noexcept

uncaught_exception()

Has an exception been thrown on the current thread and not yet been caught? noexcept

Avoid using these functions, except very occasionally set_terminate() and terminate(). A call of terminate() terminates a program by calling a terminate handler set by a call of set_terminate(). The – almost always correct – default is to immediately terminate the program. For fundamental operating system reasons, it is implementation-defined whether destructors for local objects are invoked when terminate() is called. If terminate() is invoked as the result of a noexcept violation, the system is allowed (important) optimizations that imply that the stack may even be partially unwound (§iso.15.5.1).

It is sometimes claimed that uncaught_exception() can be useful for writing destructors that behave differently depending on whether a function is exited normally or by an exception. However, uncaught_exception() is also true during stack unwinding (§13.5.1) after the initial exception has been caught. I consider uncaught_exception() too subtle for practical use.

30.4.2. Assertions
The standard provides:

Assertions (§iso.7)

static_assert(e,s)

Evaluate e at compile time; give s as a compiler error message if !e

assert(e)

If the macro NDEBUG is not defined, evaluate e at run time

and if !e, write a message to cerr and abort();if NDEBUG is defined, do nothing

For example:

Click here to view code image

template<typename T>
void draw_all(vector<T*>& v)
{
     static_assert(Is_base_of<Shape,T>(),"non-Shape type for draw_all()");

     for (auto p : v) {
          assert(p!=nullptr);
           //...
     }
}
The assert() is a macro found in <cassert>. The error message produced by assert() is implementation-defined but should contain the source file name (__FILE__), and the source line number (__LINE__) containing the assert().

Asserts are (as they should be) used more frequently in production code than in small illustrative textbook examples.

The name of the function (__func__) may also be included in the message. It can be a serious mistake to assume that the assert() is evaluated when it is not. For example, given a usual compiler setup, assert(p!=nullptr) will catch an error during debugging, but not in the final shipped product.

For a way to manage assertions, see §13.4.

30.4.3. system_error
In <system_error>, the standard library provides a framework for reporting errors from the operating system and lower-level system components. For example, we may write a function to check a file name and then open a file like this:

Click here to view code image

ofstream& open_file(const string& path)
{
     auto dn = split_into_directory_and_name(path);           // split into {path,name}

     error_code err {does_directory_exist(dn.first)};         // ask "the system" about the path
     if (err) {  // err!=0 means error

           //... see if anything can be done ...

          if (cannot_handle_err)
                throw system_error(err);
     }

      //...
     return ofstream{path};     // retuen by move
}
Assuming that “the system” doesn’t know about C++ exceptions, we have no choice about whether to deal with error codes or not; the only questions are “where?” and “how?” In <system_error>, the standard library provides facilities for classifying error codes, for mapping system-specific error codes into more portable ones, and for mapping error codes into exceptions:

System Error Types

error_code

Holds a value identifying an error and the category of that error; system-specific (§30.4.3.1)

error_category

A base class for types used to identify the source and encoding of a particular kind (category) of error code (§30.4.3.2)

system_error

A runtime_error exception containing an error_code (§30.4.3.3)

error_condition

Holds a value identifying an error and the category of that error; potentially portable (§30.4.3.4)

errc

enum class with enumerators for error codes from <cerrno> (§40.3); basically POSIX error codes

future_errc

enum class with enumerators for error codes from <future> (§42.4.4)

io_errc

enum class with enumerators for error codes from <ios> (§38.4.4)

30.4.3.1. Error Codes
When an error “bubbles up” from a lower level as an error code, we must handle the error it represents or turn it into an exception. But first we must classify it: different systems use different error codes for the same problem, and different systems simply have different kinds of errors.

error_code (§iso.19.5.2)

error_code ec {};

Default constructor: ec={0,generic_category}; noexcept

error_code ec {n,cat};

ec={n,cat}; cat is an error_category

and n is an int representing an error in cat; noexcept

error_code ec {n};

ec={n,generic_category};

n represents an error; n is a value of type EE for which is_error_code_enum<EE>::value==true; noexcept

ec.assign(n,cat)

ec={n,cat}; cat is an error_category;

and n is an int representing an error in cat; noexcept

ec=n

ec={n,generic_category}: ec=make_error_code(n);

n represets an error; n is a value of type EE for which is_error_code_enum<EE>::value==true; noexcept

ec.clear()

ec={0,generic_category()}; noexcept

n=ec.value()

n is ec’s stored value; noexcept

cat=ec.category()

cat is a reference to ec’s stored category; noexcept

s=ec.message()

s is a string representing ec potentially used as

an error message: ec.category().message(ec.value())

bool b {ec};

Convert ec to bool; b is true if ec represents

an error; that is, b==false means ‘‘no error’’; explicit

ec==ec2

Either or both of ec and ec2 can be an error_code;

to compare equal ec and ec2 must have equivalent

category()s and equivalent value()s; if ec and ec2 are

of the same type, equivalence is defined by ==;

if not, equivalence is defined by category().equivalent().

ec!=ec2

!(ec==ec2)

ec<ec2

An order ec.category()<ec2.category()

|| (ec.category()==ec2.category() && ec.value()

e=ec.default_error_condition()

e is a reference to an error_condition: e=ec.category().default_error_condition(ec.value())

os<<ec

Write ec.name() ‘:’ ec.value() to the ostream os

ec=make_error_code(e)

e is an errc;

ec=error_code(static_cast<int>(e),generic_category())

For a type representing the simple idea of an error code, error_code provides a lot of members. It is basically a simple map from an integer to a pointer to an error_category:

Click here to view code image

class error_code {
public:
      // representation: {value,category} of type {int,const error_category*}
};
An error_category is an interface to an object of a class derived from error_category. Therefore, an error_category is passed by reference and stored as a pointer. Each separate error_category is represented by a unique object.

Consider again the open_file() example:

Click here to view code image

ofstream& open_file(const string& path)
{
     auto dn = split_into_directory_and_name(path);           // split into {path,name}

     if (error_code err {does_directory_exist(dn.first)}) {   // ask "the system" about the path
          if (err==errc::permission_denied) {
                 //...
          }
          else if (err==errc::not_a_directory) {
                 //...
          }
          throw system_error(err);  // can't do anything locally
     }

      //...
     return ofstream{path};     // retur n by move
}
The errc error codes are described in §30.4.3.6. Note that I used an if-then-else chain rather than the more obvious switch-statement. The reason is that == is defined in terms of equivalence, taking both the error category() and the error value() into account. Also, == is capable of handling the enumerators from errc and other standard-library enumerations.

The operations on error_codes are system-specific. In some cases, error_codes can be mapped into error_conditions (§30.4.3.4) using the mechanisms described in §30.4.3.5. An error_condition is extracted from an error_code using default_error_condition(). An error_condition typically contains less information than an error_code, so it is usually a good idea to keep the error_code available and only extract its error_condition when needed.

Manipulating error_codes does not change the value of errno (§13.1.2, §40.3). The standard library leaves the error states provided by other libraries unchanged.

30.4.3.2. Error Categories
An error_category represents a classification of errors. Specific errors are represented by a class derived from class error_category:

Click here to view code image

class error_category {
public:
      //... interface to specific categories derived from error_category ...
};
error_category (§iso.19.5.1.1)

cat.-error_category()

Destructor; virtual; noexcept

s=cat.name()

s is the name of cat; s is a C-style string;

virtual; noexcept

ec=cat.default_error_condition(n)

ec is the error_condition for n in cat; virtual; noexcept

cat.equivalent(n,ec)

Is ec.category()==cat and ec.value()==n?

ec is an error_condition; virtual; noexcept

cat.equivalent(ec,n)

Is ec.category()==cat and ec.value()==n?

ec is an error_code; virtual; noexcept

s=cat.message(n)

s is a string describing the error n in cat; virtual

cat==cat2

Is cat the same category as cat2? noexcept

cat!=cat2

!(cat==cat2) ; noexcept

cat<cat2

Is cat<cat2 in an order based on error_category

addresses: std::less<const error_category*>()(cat, cat2)?

noexcept

Because error_category is designed to be used as a base class, no copy or move operations are provided. Access an error_category through pointers or references.

There are four named standard-library categories:

Standard-library Error Categories (§iso.19.5.1.1)

ec=generic_category()

ec.name()=="generic"; ec is a reference to an error_category

ec=system_category()

ec.name()=="system" ec is a reference to an error_category;

represents system errors: if ec corresponds to a POSIX

error then ec.value() equals that error’s errno

ec=future_category()

ec.name()=="future"; ec is a reference to an error_category;

represents errors from <future>

ec=iostream_category()

ec.name()=="iostream"; ec is a reference to an error_category;

represents errors from the iostream library

These categories are necessary because a simple integer error code can have different meanings in different contexts (categorys). For example, 1 means "operation not permitted" (EPERM) in POSIX, is a generic code (state) for all errors as an iostream error, and means "future already retrieved" (future_already_retrieved) as a future error. (in at least one implementation). The values of these enumerations are implementation defined.

30.4.3.3. Exception system_error
A system_error is used to report errors that originate in the parts of the standard library that deal with the operating system. It passes along an error_code and optionally an error-message string:

Click here to view code image

class system_error : public runtime_error {
public:
      //...
};
Exception Class system_error (§iso.19.5.6)

system_error se {ec,s};

se holds {ec,s}; ec is an error_code; s is a string

or a C-style string intended as part of an error message

system_error se {ec};

se holds {ec}; ec is an error_code

system_error se {n,cat,s};

se holds {error_code{n,cat},s}; cat is an error_category

and n is an int representing an error in cat;

s is a string or a C-style string intended as part of

an error message

system_error se {n,cat};

se holds error_code{n,cat}; cat is an error_category

and n is an int representing an error in cat

ec=se.code()

ec is a reference to se’s error_code; noexcept

p=se.what()

p is a C-style string version of se’s error string; noexcept

Code catching a system_error has its error_code available. For example:

Click here to view code image

try {
      // something
}
catch (system_error& err) {
     cout << "caught system_error " << err.what() <<'\n';      // error message

     auto ec = err.code();
     cout << "category: " << ec.category().what() <<'\n';
     cout << "value: " << ec.value() <<'\n';
     cout << "message: " << ec.message() <<'\n';
}
Naturally, system_errors can be used by code that is not part of the standard library. A system-specific error_code is passed, rather than a potentially portable error_condition (§30.4.3.4). To get an error_condition from an error_code use default_error_condition() (§30.4.3.1).

30.4.3.4. Potentially Portable Error Conditions
Potentially portable error codes (error_conditions) are represented almost identically to the system-specific error_codes:

Click here to view code image

class error_condition {    // potentially portable (§iso.19.5.3)
public:
      // like error_code but
      // no output operator (<<) and
      // no default_error_condition()
};
The general idea is that each system has a set of specific ("native") codes that are mapped into the potentially portable ones for the convenience of programmers of programs (often libraries) that need to work on multiple platforms.

30.4.3.5. Mapping Error Codes
Making an error_category with a set of error_codes and at least one error_condition starts with defining an enumeration with the desired error_code values. For example:

enum class future_errc {
    broken_promise = 1,
    future_already_retrieved,
    promise_already_satisfied,
    no_state
};
The meaning of these values is completely category-specific. The integer values of these enumerators are implementation-defined.

The future error category is part of the standard, so you can find it in your standard library. The details are likely to differ from what I describe.

Next, we need to define a suitable category for our error codes:

Click here to view code image

class future_cat : public error_category {      // to be returned from future_category()
public:
     const char* name() const noexcept override { return "future"; }

     string message(int ec) const override;
};

const error_category& future_category() noexcept
{
     static future_cat obj;
     return obj;
}
The mapping from integer values to error message() strings is a bit tedious. We have to invent a set of messages that are likely to be meaningful to a programmer. Here, I’m not trying to be clever:

Click here to view code image

string future_cat::message(int ec) const
{
     switch (static_cast<future_errc>(ec)) {
     default:                                return "bad future_cat code";
     case future_errc::broken_promise: return:            return "future_error: broken promise";
     future_errc::future_already_retrieved:  return "future_error: future already retrieved";
     future_errc::promise_already_satisfied: return "future_error: promise already satisfied";
     future_errc::no_state:                  return "future_error: no state";
     }
}
We can now make an error_code out of a future_errc:

Click here to view code image

error_code make_error_code(future_errc e) noexcept
{
     return error_code{int(e),future_category()};
}
For the error_code constructor and assignment that take a single error value, it is required that the argument be of the appropriate type for the error_category. For example, an argument intended to become the value() of an error_code of future_category() must be a future_errc. In particular, we can’t just use any int. For example:

Click here to view code image

error_code ec1 {7};                              // error
error_code ec2 {future_errc::no_state};          // OK

ec1 = 9;                                         // error
ec2 = future_errc::promise_already_satisfied;    // OK
ec2 = errc::broken_pipe;                         // error: wrong error category
To help the implementer of error_code, we specialize the trait is_error_code_enum for our enumeration:

Click here to view code image

template<>
struct is_error_code_enum<future_errc> : public true_type { };
The standard already provides the general template:

template<typename>
struct is_error_code_enum : public false_type { };
This states that anything we don’t deem an error code value isn’t. For error_condition to work for our category, we must repeat what we did for error_code. For example:

Click here to view code image

error_condition make_error_condition(future_errc e) noexcept;

template<>
struct is_error_condition_enum<future_errc> : public true_type { };
For a more interesting design, we could use a separate enum for the error_condition and have make_error_condition() implement a mapping from future_errc to that.

30.4.3.6. errc Error Codes
Standard error_codes for the system_category() are defined by enum class errc with values equivalent to the POSIX-derived contents of <cerrno>:

enum class errc Enumerators (§iso.19.5) (continues)

address_family_not_supported

EAFNOSUPPORT

address_in_use

EADDRINUSE

address_not_available

EADDRNOTAVAIL

already_connected

EISCONN

argument_list_too_long

E2BIG

argument_out_of_domain

EDOM

bad_address

EFAULT

bad_file_descriptor

EBADF

bad_message

EBADMSG

broken_pipe

EPIPE

connection_aborted

ECONNABORTED

connection_already_in_progress

EALREADY

connection_refused

ECONNREFUSED

connection_reset

ECONNRESET

cross_device_link

EXDEV

destination_address_required

EDESTADDRREQ

device_or_resource_busy

EBUSY

directory_not_empty

ENOTEMPTY

executable_format_error

ENOEXEC

file_exists

EEXIST

file_too_large

EFBIG

filename_too_long

ENAMETOOLONG

function_not_supported

ENOSYS

host_unreachable

EHOSTUNREACH

identifier_removed

EIDRM

illegal_byte_sequence

EILSEQ

inappropriate_io_control_operation

ENOTTY

interrupted

EINTR

invalidargument

EINVAL

invalid_seek

ESPIPE

io_error

EIO

is_a_directory

EISDIR

message_size

EMSGSIZE

network_down

ENETDOWN

network_reset

ENETRESET

network_unreachable

ENETUNREACH

no_buffer_space

ENOBUFS

no_child_process

ECHILD

no_link

ENOLINK

no_lock_available

ENOLCK

no_message

ENOMSG

no_message_available

ENODATA

no_protocol_option

ENOPROTOOPT

no_space_on_device

ENOSPC

no_stream_resources

ENOSR

no_such_device

ENODEV

no_such_device_or_address

ENXIO

no_such_file_or_directory

ENOENT

no_such_process

ESRCH

not_a_directory

ENOTDIR

not_a_socket

ENOTSOCK

not_a_stream

ENOSTR

not_connected

ENOTCONN

not_enough_memory

ENOMEM

not_supported

ENOTSUP

operation_canceled

ECANCELED

operation_in_progress

EINPROGRESS

operation_not_permitted

EPERM

operation_not_supported

EOPNOTSUPP

operation_would_block

EWOULDBLOCK

owner_dead

EOWNERDEAD

permission_denied

EACCES

protocol_error

EPROTO

protocol_not_supported

EPROTONOSUPPORT

read_only_file_system

EROFS

resource_deadlock_would_occur

EDEADLK

resource_unavailable_try_again

EAGAIN

result_out_of_range

ERANGE

state_not_recoverable

ENOTRECOVERABLE

stream_timeout

ETIME

text_file_busy

ETXTBSY

timed_out

ETIMEDOUT

too_many_files_open

EMFILE

too_many_files_open_in_system

ENFILE

too_many_links

EMLINK

too_many_symbolic_link_levels

ELOOP

value_too_large

EOVERFLOW

wrong_protocol_type

EPROTOTYPE

These codes are valid for the "system" category: system_category(). For systems supporting POSIX-like facilities, they are also valid for the "generic" category: generic_category().

The POSIX macros are integers whereas the errc enumerators are of type errc. For example:

Click here to view code image

void problem(errc e)
{
     if (e==EPIPE) {                 // error: no conversion of errc to int
           //...
     }

     if (e==broken_pipe) {           // error: broken_pipe not in scope
           //...
     }

     if (e==errc::broken_pipe) {     // OK
           //...
     }
}
30.4.3.7. future_errc Error Codes
Standard error_codes for the future_category() are defined by enum class future_errc:

enum class future_errc Enumerators (§iso.30.6.1)

broken_promise

1

future_already_retrieved

2

promise_already_satisfied

3

no_state

4

These codes are valid for the "future" category: future_categor y(). The numeric values of these error codes are implementation defined, so use the enumerator names consistently.

30.4.3.8. io_errc Error Codes
Standard error_codes for the iostream_category() are defined by enum class io_errc:

enum class io_errc Enumerator (§iso.27.5.1)

stream

1

This code is valid for the "iostream" category: iostream_category().

30.5. Advice
[1] Use standard-library facilities to maintain portability; §30.1, §30.1.1.

[2] Use standard-library facilities to minimize maintenance costs; §30.1.

[3] Use standard-library facilities as a base for more extensive and more specialized libraries; §30.1.1.

[4] Use standard-library facilities as a model for flexible, widely usable software; §30.1.1.

[5] The standard-library facilities are defined in namespace std and found in standard-library headers; §30.2.

[6] A C standard-library header X.h is presented as a C++ standard-library header in <cX>; §30.2.

[7] Do not try to use a standard-library facility without #includeing its header; §30.2.

[8] To use a range-for on a built-in array, #include<iterator>; §30.3.2.

[9] Prefer exception-based error handling over return-code-based error handling; §30.4.

[10] Always catch exception& (for standard-library and language support exceptions) and ... (for unexpected exceptions); §30.4.1.

[11] The standard-library exception hierarchy can be (but does not have to be) used for a user’s own exceptions; §30.4.1.1.

[12] Call terminate() in case of serious trouble; §30.4.1.3.

[13] Use static_assert() and assert() extensively; §30.4.2.

[14] Do not assume that assert() is always evaluated; §30.4.2.

[15] If you can’t use exceptions, consider <system_error>; §30.4.3.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


30. Standard-Library Overview
31. STL Containers
32. STL Algorithms
47h 26m remaining
31. STL Containers
It was new. It was singular. It was simple. It must succeed!

– H. Nelson

• Introduction

• Container Overview

Container Representation; Element Requirements

• Operations Overview

Member Types; Constructors, Destructor, and Assignments; Size and Capacity; Iterators; Element Access; Stack Operations; List Operations; Other Operations

• Containers

vector; Lists; Associative Containers

• Container Adaptors

stack; queue; priority_queue

• Advice

31.1. Introduction
The STL consists of the iterator, container, algorithm, and function object parts of the standard library. The rest of the STL is presented in Chapter 32 and Chapter 33.

31.2. Container Overview
A container holds a sequence of objects. This section summarizes the types of containers and briefly outlines their properties. Operations on containers are summarized in §31.3.

Containers can be categorized like this:

• Sequence containers provide access to (half-open) sequences of elements.

• Associative containers provide associative lookup based on a key.

In addition, the standard library provides types of objects that hold elements while not offering all of the facilities of sequence containers or associative containers:

• Container adaptors provide specialized access to underlying containers.

• Almost containers are sequences of elements that provide most, but not all, of the facilities of a container.

The STL containers (the sequence and associative containers) are all resource handles with copy and move operations (§3.3.1). All operations on containers provide the basic guarantee (§13.2) to ensure that they interact properly with exception-based error handling.

Sequence Containers (§iso.23.3)

vector<T,A>

A contiguously allocated sequence of Ts;

the default choice of container

list<T,A>

A doubly-linked list of T; use when you need to insert and

delete elements without moving existing elements

forward_list<T,A>

A singly-linked list of T; ideal for empty and very short sequences

deque<T,A>

A double-ended queue of T; a cross between a vector and a list;

slower than one or the other for most uses

The A template argument is the allocator that the container uses to acquire and release memory (§13.6.1, §34.4). For example:

Click here to view code image

template<typename T, typename A = allocator<T>>
class vector {
     //...
};
A is defaulted to std::allocator<T> (§34.4.1) which uses operator new() and operator delete() when it needs to acquire or release memory for its elements.

These containers are defined in <vector>, <list> <forward_list>, and <deque>. The sequence containers are contiguously allocated (e.g., vector) or linked lists (e.g., forward_list) of elements of their value_type (T in the notation used above). A deque (pronounced “deck”) is a mixture of linked-list and contiguous allocation.

Unless you have a solid reason not to, use a vector. Note that vector provides operations for inserting and erasing (removing) elements, allowing a vector to grow and shrink as needed. For sequences of small elements, a vector can be an excellent representation for a data structure requiring list operations.

When inserting and erasing elements of a vector, elements may be moved. In contrast, elements of a list or an associative container do not move when new elements are inserted or other elements are erased.

A forward_list (a singly-linked list) is basically a list optimized for empty and very short lists. An empty forward_list takes up only one word. There are surprisingly many uses for lists where most are empty (and the rest are very short).

Ordered Associative Containers (§iso.23.4.2)

C is the type of the comparison; A is the allocator type

map<K,V,C,A>

An ordered map from K to V; a sequence of (K,V) pairs

multimap<K,V,C,A>

An ordered map from K to V; duplicate keys allowed

set<K,C,A>

An ordered set of K

multiset<K,C,A>

An ordered set of K; duplicate keys allowed

These containers are usually implemented as balanced binary trees (usually red-black trees).

The default ordering criterion for a key, K, is std::less<K> (§33.4).

As for sequence containers, the A template argument is the allocator that the container uses to acquire and release memory (§13.6.1, §34.4). The A template argument is defaulted to std::allocator<std::pair<const K,T>> (§31.4.3) for maps and std::allocator<K> for sets.

Unordered Associative Containers (§iso.23.5.2)

H is the hash function type; E is the equality test; A is the allocator type

unordered_map<K,V,H,E,A>

An unordered map from K to V

unordered_multimap<K,V,H,E,A>

An unordered map from K to V; duplicate keys allowed

unordered_set<K,H,E,A>

An unordered set of K

unordered_multiset<K,H,E,A>

An unordered set of K; duplicate keys allowed

These containers are implemented as hash tables with linked overflow. The default hash function type, H, for a type K is std::hash<K> (§31.4.3.2). The default for the equality function type, E, for a type K is std::equal_to<K> (§33.4); the equality function is used to decide whether two objects with the same hash code are equal.

The associative containers are linked structures (trees) with nodes of their value_type (in the notation used above, pair<const K,V> for maps and K for sets). The sequence of a set, map, or multiset multimap is ordered by its key value (K). An unordered container need not have an ordering relation for its elements (e.g., <) and uses a hash function instead (§31.2.2.1). The sequence of an unordered container does not have a guaranteed order. A multimap differs from a map in that a key value may occur many times.

Container adaptors are containers providing specialized interfaces to other containers:

Container Adaptors (§iso.23.6)

C is the container type

priority_queue<T,C,Cmp>

Priority queue of Ts; Cmp is the priority function type

queue<T,C>

Queue of Ts with push() and pop()

stack<T,C>

Stack of Ts with push() and pop()

The default for a priority_queue’s priority function, Cmp, is std::less<T>. The default for the container type, C, is std::deque<T> for queue and std::vector<T> for stack and std::vector<T> priority_queue. See §31.5.

Some data types provide much of what is required of a standard container, but not all. We sometimes refer to those as “almost containers.” The most interesting of those are:

‘‘Almost Containers’’

T[N]

A fixed-size built-in array: N contiguous elements of type T;

no size() or other member functions

array<T,N>

A fixed-size array of N contiguous elements of type T;

like the built-in array, but with most problems solved

basic_string<C,Tr,A>

A contiguously allocated sequence of characters of type C

with text manipulation operations, e.g., concatenation (+ and +=);

basic_string is typically optimized not to require free store for

short strings (§19.3.3)

string

basic_string<char>

u16string

basic_string<char16_t>

u32string

basic_string<char32_t>

wstring

basic_string<wchar_t>

valarray<T>

A numerical vector with vector operations, but with restrictions

to encourage high-performance implementations;

use only if you do a lot of vector arithmetic

bitset<N>

A set of N bits with set operations, such as & and |

vector<bool>

A specialization of vector<T> with compactly stored bits

For basic_string, A is the allocator (§34.4) and Tr is the character traits (§36.2.2).

Prefer a container, such as vector, string, or array, over a built-in array when you have a choice. The implicit array-to-pointer conversion and the need to remember the size for a built-in array are major sources of errors (e.g., see §27.2.1).

Prefer the standard strings to other strings and to C-style strings. The pointer semantics of C-style strings imply an awkward notation and extra work for the programmer, and they are a major source of errors (such as memory leaks) (§36.3.1).

31.2.1. Container Representation
The standard doesn’t prescribe a particular representation for a standard container. Instead, the standard specifies the container interfaces and some complexity requirements. Implementers will choose appropriate and often cleverly optimized implementations to meet the general requirements and common uses. In addition to what is needed to manipulate elements, such a “handle” will hold an allocator (§34.4).

For a vector, the element data structure is most likely an array:


The vector will hold a pointer to an array of elements, the number of elements, and the capacity (the number of allocated, currently unused slots) or equivalent (§13.6).

A list is most likely represented by a sequence of links pointing to the elements and the number of elements:



A forward_list is most likely represented by a sequence of links pointing to the elements:



A map is most likely implemented as a (balanced) tree of nodes pointing to (key,value) pairs:



An unordered_map is most likely implemented as a hash table:



A string might be implemented as outlined in §19.3 and §23.2; that is, for short strings the characters are stored in the string handle itself, and for longer strings the elements are stored contiguously on the free-store (like vector elements). Like vector, a string can grow into “free space” allocated to avoid repeated reallocations:


Like a built-in array (§7.3), an array is simply a sequence of elements, with no handle:


This implies that a local array does not use any free store (unless it is allocated there) and that an array member of a class does not imply any free store operations.

31.2.2. Element Requirements
To be an element of a container, an object must be of a type that allows the container implementation to copy or move it, and to swap elements. If a container copies an element using a copy constructor or copy assignment, the result of the copy must be an equivalent object. This roughly means that any test for equality that you can devise on the value of the objects must deem the copy equal to the original. In other words, copying an element must work much like an ordinary copy of an int. Similarly, a move constructor and a move assignment must have the conventional definitions and move semantics (§17.5.1). In addition, it must be possible to swap() elements with the usual semantics. If a type has copy or move, the standard-library swap() will work.

The details of the element requirements are scattered over the standard and quite hard to read (§iso.23.2.3, §iso.23.2.1, §iso.17.6.3.2), but basically a container can hold elements of a type that has conventional copy or move operations. Many basic algorithms, such as copy(), find(), and sort() will work as long as the requirements for being a container element are met as well as the algorithm’s specific requirements (such as elements being ordered; §31.2.2.1).

Some violations of the rules for standard containers can be detected by a compiler, but others cannot and might then cause unexpected behavior. For example, an assignment operation that throws an exception might leave a partially copied element behind. That would be bad design (§13.6.1) and would violate the rules of the standard by not providing the basic guarantee (§13.2). An element in an invalid state could cause serious trouble later.

When copying objects is not reasonable, an alternative is to put pointers to objects into containers instead of the objects themselves. The most obvious example is polymorphic types (§3.2.2, §20.3.2). For example, we use vector<unique_ptr<Shape>> or vector<Shape*> rather than vector<Shape> to preserve polymorphic behavior.

31.2.2.1. Comparisons
Associative containers require that their elements can be ordered. So do many operations that can be applied to containers (e.g., sort() and merge()). By default, the < operator is used to define the order. If < is not suitable, the programmer must provide an alternative (§31.4.3, §33.4). The ordering criterion must define a strict weak ordering. Informally, this means that both less-than and equality (if defined) must be transitive. That is, for an ordering criterion cmp (think of it as “less than”) we require:

[1] Irreflexivity: cmp(x,x) is false.

[2] Antisymmetry: cmp(x,y) implies !cmp(y,x).

[3] Transitivity: If cmp(x,y) and cmp(y,z), then cmp(x,z).

[4] Transitivity of equivalence: Define equiv(x,y) to be !(cmp(x,y)||cmp(y,x)). If equiv(x,y) and equiv(y,z), then equiv(x,z).

The last rule is the one that allows us to define equality (x==y) as !(cmp(x,y)||cmp(y,x)) if we need ==.

Standard-library operations that require a comparison come in two versions. For example:

Click here to view code image

template<typename Ran>
    void sort(Ran first, Ran last);           // use < for comparison
template<typename Ran, typename Cmp>
    void sort(Ran first, Ran last, Cmp cmp);  // use cmp
The first version uses < and the second uses a user-supplied comparison cmp. For example, we might decide to sort fruit using a comparison that isn’t case sensitive. We do that by defining a function object (§3.4.3, §19.2.2) that does the comparison when invoked for a pair of strings:

Click here to view code image

class Nocase {       // case-insensitive string compare
public:
     bool operator()(const string&, const string&) const;
};

bool Nocase::operator()(const string& x, const string& y) const
     // return true if x is lexicographically less than y, not taking case into account
{
    auto p = x.begin();
    auto q = y.begin();

    while (p!=x.end() && q!=y.end() && toupper(*p)==toupper(*q)) {
         ++p;
         ++q;
    }
    if (p == x.end()) return q != y.end();
    if (q == y.end()) return false;
    return toupper(*p) < toupper(*q);
}
We can call sort() using that comparison criterion. Consider:

fruit:
      apple pear Apple Pear lemon
Sorting using sort(fruit.begin(),fruit.end(),Nocase()) would yield something like

Click here to view code image

fruit:
      Apple apple lemon Pear pear
Assuming a character set in which uppercase letters precede lowercase letters, plain sort(fruit.begin(),fruit.end()) would give:

Click here to view code image

fruit:
      Apple Pear apple lemon pear
Beware that < on C-style strings (i.e., const char*s) compares pointer values (§7.4). Thus, associative containers will not work as most people would expect them to if C-style strings are used as keys. To make them work properly, a less-than operation that compares based on lexicographical order must be used. For example:

Click here to view code image

struct Cstring_less {
     bool operator()(const char* p, const char* q) const { return strcmp(p,q)<0; }
};

map<char*,int,Cstring_less> m;           // map that uses strcmp() to compare const char* keys
31.2.2.2. Other Relational Operators
By default, containers and algorithms use < when they need to do a less-than comparison. When the default isn’t right, a programmer can supply a comparison criterion. However, no mechanism is provided for also passing an equality test. Instead, when a programmer supplies a comparison cmp, equality is tested using two comparisons. For example:

Click here to view code image

if (x == y)                    // not done where the user supplied a comparison

if (!cmp(x,y) && !cmp(y,x))    // done where the user supplied a comparison cmp
This saves the user from having to provide an equality operation for every type used as the value type for an associative container or by an algorithm using a comparison. It may look expensive, but the library doesn’t check for equality very often, in about 50% of the cases only a single call of cmp() is needed, and often the compiler can optimize away the double check.

Using an equivalence relationship defined by less-than (by default <) rather than equality (by default ==) also has practical uses. For example, associative containers (§31.4.3) compare keys using an equivalence test !(cmp(x,y)||cmp(y,x)). This implies that equivalent keys need not be equal. For example, a multimap (§31.4.3) that uses case-insensitive comparison as its comparison criterion will consider the strings Last, last, lAst, laSt, and lasT equivalent, even though == for strings deems them different. This allows us to ignore differences we consider insignificant when sorting.

If equals (by default ==) always gives the same result as the equivalence test !(cmp(x,y)||cmp(y,x)) (by default cmp() is <), we say that we have a total order.

Given < and ==, we can easily construct the rest of the usual comparisons. The standard library defines them in the namespace std::rel_ops and presents them in <utility> (§35.5.3).

31.3. Operations Overview
The operations and types provided by the standard containers can be summarized like this:



An arrow indicates that a set of operations is provided for a container; it is not an inheritance operation. A question mark (?) indicates a simplification: I have included operations that are provided for only some of the containers. In particular:

• A multi* associative container or a set does not provide [] or at().

• A forward_list does not provide insert(), erase(), or emplace(); instead, it provides the *_after operations.

• A forward_list does not provide back(), push_back(), pop_back(), or emplace_back().

• A forward_list does not provide reverse_iterator, const_reverse_iterator, rbegin(), rend(), crbegin(), crend(), or size().

• A unordered_* associative container does not provide <, <=, >, or >=.

The [] and at() operations are replicated simply to reduce the number of arrows.

The bucket interface is described in §31.4.3.2.

Where meaningful, an access operation exists in two versions: one for const and one for non-const objects.

The standard-library operations have complexity guarantees:

Standard Container Operation Complexity

 

[]

List

Front

Back

Iterators

 

§31.2.2

§31.3.7

§31.4.2

§31.3.6

§33.1.2

vector

const

O(n)+

 

const+

Ran

list

 

const

const

const

Bi

forward_list

 

const

const

 

For

deque

const

O(n)

const

const

Ran

stack

 

 

 

const

 

queue

 

 

const

const

 

priority_queue

 

 

O(log(n))

O(log(n))

 

map

O(log(n))

O(log(n))+

 

 

Bi

multimap

 

O(log(n))+

 

 

Bi

set

 

O(log(n))+

 

 

Bi

multiset

 

O(log(n))+

 

 

Bi

unordered_map

const+

const+

 

 

For

unordered_multimap

 

const+

 

 

For

unordered_set

 

const+

 

 

For

unordered_multiset

 

const+

 

 

For

string

const

O(n)+

O(n)+

const+

Ran

array

const

 

 

 

Ran

built-in array

const

 

 

 

Ran

valarray

const

 

 

 

Ran

bitset

const

 

 

 

 

“Front” operations refer to insertion and deletion before the first element. Similarly, “Back” operations refer to insertion and deletion after the last element, and “List” operations refer to insertion and deletion not necessarily at the ends of a container.

In the Iterators column, “Ran” means “random-access iterator,” “For” means “forward iterator,” and “Bi” means “bidirectional iterator” (§33.1.4).

Other entries are measures of the efficiency of the operations. A const entry means the operation takes an amount of time that does not depend on the number of elements in the container; another conventional notation for constant time is O(1). O(n) means the operation takes time proportional to the number of elements involved. A + suffix indicates that occasionally a significant extra cost is incurred. For example, inserting an element into a list has a fixed cost (so it is listed as const), whereas the same operation on a vector involves moving the elements following the insertion point (so it is listed as O(n)). Occasionally, all elements of a vector must be relocated (so I added a +). The “big O” notation is conventional. I added the + for the benefit of programmers who care about predictability in addition to average performance. A conventional term for O(n)+ is amortized linear time.

Naturally, if a constant is large, it can dwarf a small cost proportional to the number of elements. However, for large data structures const tends to mean “cheap,” O(n) to mean “expensive,” and O(log(n)) to mean “fairly cheap.” For even moderately large values of n, O(log(n)), where log is the binary logarithm, is far closer to constant time than to O(n). For example:

Logarithm Examples

n

16

128

1,024

16,384

1,048,576

log(n)

4

7

10

14

20

n*n

256

802,816

1,048,576

268,435,456

1.1e+12

People who care about cost must take a closer look. In particular, they must understand what elements are counted to get the n. However, the message is clear: don’t mess with quadratic algorithms for larger values of n.

The measures of complexity and cost are upper bounds. The measures exist to give users some guidance as to what they can expect from implementations. Naturally, implementers will try to do better in important cases.

Note that the “Big O” complexity measures are asymptotic; that is, it could require a lot of elements before complexity differences matter. Other factors, such as the cost of an individual operation on an element, may dominate. For example, traversing a vector and a list both have complexity O(n). However, given modern machine architectures, getting to the next element through a link (in a list) can be very much more expensive than getting to the next element of a vector (where the elements are contiguous). Similarly, a linear algorithm may take significantly more or significantly less than ten times as long for ten times as many elements because of the details of memory and processor architecture. Don’t just trust your intuition about cost and your complexity measures; measure. Fortunately, the container interfaces are so similar that comparisons are easy to code.

The size() operation is constant time for all operations. Note that forward_list does not have size(), so if you want to know the number of elements, you must count them yourself (at the cost of O(n)). A forward_list is optimized for space and does not store its size or a pointer to its last element.

The string estimates are for longer strings. The “short string optimization” (§19.3.3) makes all operations on short strings (e.g., less than 14 characters) roughly constant time.

The entries for stack and queue reflect the cost for the default implementation using a deque as the underlying container (§31.5.1, §31.5.2).

31.3.1. Member Types
A container defines a set of member types:

Member types (§iso.23.2, §iso.23.3.6.1)

value_type

Type of element

allocator_type

Type of memory manager

size_type

Unsigned type of container subscripts, element counts, etc.

difference_type

Signed type of difference between iterators

iterator

Behaves like value_type*

const_iterator

Behaves like const value_type*

reverse_iterator

Behaves like value_type*

const_reverse_iterator

Behaves like const value_type*

reference

value_type&

const_reference

const value_type&

pointer

Behaves like value_type*

const_pointer

Behaves like const value_type*

key_type

Type of key; associative containers only

mapped_type

Type of mapped value; associative containers only

key_compare

Type of comparison criterion; ordered containers only

hasher

Type of hash function; unordered containers only

key_equal

Type of equivalence function; unordered containers only

local_iterator

Type of bucket iterator; unordered containers only

const_local_iterator

Type of bucket iterator; unordered containers only

Every container and “almost container” provides most of these member types. However, they don’t provide types that are not meaningful. For example, array does not have an allocator_type and vector does not have a key_type.

31.3.2. Constructors, Destructor, and Assignments
Containers provide a variety of constructors and assignment operations. For a container called C (e.g., vector<double> or map<string,int>) we have:

Constructors, Destructor, and Assignment (continues)

C is a container; by default, a C uses the default allocator C::allocator_type{}

C c {};

Default constructor: c is an empty container

C c {a};

Default construct c; use allocator a

C c(n);

c initialized with n elements with the value value_type{};

not for associative containers

C c(n,x);

Initialize c with n copies of x; not for associative containers

C c(n,x,a);

Initialize c with n copies of x; use allocator a;

not for associative containers

Constructors, Destructor, and Assignment (continued)

C is a container; by default, a C uses the default allocator C::allocator_type{}

C c {elem};

Initialize c from elem;

if C has an initializer-list constructor, prefer that;

otherwise, use another constructor

C c {c2};

Copy constructor: copy c2’s elements and allocator into c

C c {move(c2)};

Move constructor: move c2’s elements and allocator into c

C c {{elem},a};

Initialize c from the initializer_list {elem}; use allocator a

C c {b,e};

Initialize c with elements from [b:e)

C c {b,e,a};

Initialize c with elements from [b:e); use allocator a

c.-C()

Destructor: destroy c’s elements and release all resources

c2=c

Copy assignment: copy c’s elements into c2

c2=move(c)

Move assignment: move c’s elements into c2

c={elem}

Assign to c from initializer_list {elem}

c.assign(n,x)

Assign n copies of x; not for associative containers

c.assign(b,e)

Assign to c from [b:e)

c.assign({elem})

Assign to c from initializer_list {elem}

Additional constructors for associative containers are described in §31.4.3.

Note that an assignment does not copy or move allocators. A target container gets a new set of elements but retains its old container, which it uses to allocate space for the new elements (if any). Allocators are described in §34.4.

Remember that a constructor or an element copy may throw an exception to indicate that it cannot perform its tasks.

The potential ambiguities for initializers are discussed in §11.3.3 and §17.3.4.1. For example:

Click here to view code image

void use()
{
     vector<int> vi {1,3,5,7,9};     // vector initialized by five ints
     vector<string> vs(7);           // vector initialized by seven empty strings

     vector<int> vi2;
     vi2 = {2,4,6,8};                // assign sequence of four ints to vi2
     vi2.assign(&vi[1],&vi[4]);      // assign the sequence 3,5,7 to vi2

     vector<string> vs2;
     vs2 = {"The Eagle", "The Bird and Baby"};            // assign two strings to vs2
     vs2.assign("The Bear", "The Bull and Vet");          // run-time error
}
The error in the assignment to vs2 is that a pair of pointers are passed (not an initializer_list) and the two pointers do not point into the same array. Use () for size initializers and {} for every other kind of iterator.

Containers are often large, so we almost always pass them by reference. However, because they are resource handles (§31.2.1), we can return them (implicitly using move) efficiently. Similarly, we can move them as arguments when we don’t want aliasing. For example:

Click here to view code image

void task(vector<int>&& v);

vector<int> user(vector<int>& large)
{
    vector<int> res;
     //...
    task(move(large));   // transfer ownership of data to task()
     //...
    return res;
}
31.3.3. Size and Capacity
The size is the number of elements in the container; the capacity is the number of elements that a container can hold before allocating more memory:

Size and Capacity

x=c.size()

x is the number of elements of c

c.empty()

Is c empty?

x=c.max_size()

x is the largest possible number of elements of c

x=c.capacity()

x is the space allocated for c; vector and string only

c.reserve(n)

Reserve space for n elements for c; vector and string only

c.resize(n)

Change size of c to n;

use the default element value for added elements;

sequence containers only (and string)

c.resize(n,v)

Change size of c to n; use v for added elements;

sequence containers only (and string)

c.shrink_to_fit()

Make c.capacity() equal to c.size(); vector, deque, and string only

c.clear()

Erase all elements of c

When changing the size or the capacity, the elements may be moved to new storage locations. That implies that iterators (and pointers and references) to elements may become invalid (i.e., point to the old element locations). For an example, see §31.4.1.1.

An iterator to an element of an associative container (e.g., a map) is only invalidated if the element to which it points is removed from the container (erase()d; §31.3.7). In contrast, an iterator to an element of a sequence container (e.g., a vector) is invalidated if the elements are relocated (e.g., by a resize(), reserve(), or push_back()) or if the element to which it points is moved within the container (e.g., by an erase() or insert() of an element with a lower index).

It is tempting to assume that reserve() improves performance, but the standard growth strategies for vector (§31.4.1.1) are so effective that performance is rarely a good reason to use reserve(). Instead, see reserve() as a way of increasing the predictability of performance and for avoiding invalidation of iterators at inconvenient points of a program.

31.3.4. Iterators
A container can be viewed as a sequence either in the order defined by the containers iterator or in the reverse order. For an associative container, the order is based on the container’s comparison criterion (by default <):

Iterators

p=c.begin()

p points to the first element of c

p=c.end()

p points to the one-past-last element of c

cp=c.cbegin()

p points to the constant first element of c

p=c.cend()

p points to the constant one-past-last element of c

p=c.rbegin()

p points to the first element of reverse sequence of c

p=c.rend()

p points to the one-past-last element of reverse sequence of c

p=c.crbegin()

p points to the constant first element of reverse sequence of c

p=c.crend()

p points to the constant one-past-last element of reverse sequence of c

The most common form of iteration over elements is to traverse a container from its beginning to its end. The simplest way of doing that is by a range-for (§9.5.1) which implicitly uses begin() and end(). For example:

Click here to view code image

for (auto& x : v)           // implicit use of v.begin() and v.end()
      cout << x << '\n';
When we need to know the position of an element in a container or if we need to refer to more than one element at a time, we use iterators directly. In such cases, auto is useful to minimize source code size and eliminate opportunities for typos. For example, assuming a random-access iterator:

Click here to view code image

for (auto p = v.begin(); p!=v.end(); ++p) {
      if (p!=v.begin() && *(p–1)==*p)
            cout << "duplicate " << *p << '\n';
}
When we don’t need to modify elements, cbegin() and cend() are appropriate. That is, I should have written:

Click here to view code image

for (auto p = v.cbegin(); p!=v.cend(); ++p) {           // use const iterators
      if (p!=v.cbegin() && *(p–1)==*p)
            cout << "duplicate " << *p << '\n';
}
For most containers and most implementations, using begin() and end() repeatedly is not a performance problem, so I did not bother to complicate the code like this:

Click here to view code image

auto beg = v.cbegin();
auto end = v.cend();

for (auto p = beg; p!=end; ++p) {
      if (p!=beg && *(p–1)==*p)
            cout << "duplicate " << *p << '\n';
}
31.3.5. Element Access
Some elements can be accessed directly:

Element Access

c.front()

Reference to first element of c; not for associative containers

c.back()

Reference to last element of c; not for forward_list or associative containers

c[i]

Reference to the ith element of c; unchecked access;

not for lists or associative containers

c.at(i)

Reference to the ith element of c; throw an out_of_range if i is out of range;

not for lists or associative containers

c[k]

Reference to the element with key k of c; insert (k,mapped_type{}) if not found;

for map and unordered_map only

c.at(k)

Reference to the element with key k of c; throw an out_of_range if k is not found;

for map and unordered_map only

Some implementations – especially debug versions – always do range checking, but you cannot portably rely on that for correctness or on the absence of checking for performance. Where such issues are important, examine your implementations.

The associative containers map and unordered_map have [] and at() that take arguments of the key type, rather than positions (§31.4.3).

31.3.6. Stack Operations
The standard vector, deque, and list (but not forward_list or the associative containers) provide efficient operations at the end (back) of their sequence of elements:

Stack Operations

c.pushback(x)

Add x to c (using copy or move) after the last element

c.pop_back()

Remove the last element from c

c.emplace_back(args)

Add an object constructed from args to c after the last element

A c.push_back(x) moves or copies x into c, increasing c’s size by one. If we run out of memory or x’s copy constructor throws an exception, c.push_back(x) fails. A failed push_back() has no effect on the container: the strong guarantee is offered (§13.2).

Note that pop_back() does not return a value. Had it done so, a copy constructor throwing an exception could seriously complicate the implementation.

In addition, list and deque provide the equivalent operations on the start (front) of their sequences (§31.4.2). So does forward_list.

The push_back() is a perennial favorite for growing a container without preallocation or chance of overflow, but emplace_back() can be used similarly. For example:

Click here to view code image

vector<complex<double>> vc;
for (double re,im; cin>>re>>im; )    // read two doubles
      vc.emplace_back(re,im);        // add complex<double>{re,im} at the end
31.3.7 List Operations
Containers provide list operations:

List Operations

For list operations on associative container, see §31.4.3.1

q=c.insert(p,x)

Add x before p; use copy or move

q=c.insert(p,n,x)

Add n copies of x before p

q=c.insert(p,first,last)

Add elements from [first:last) before p

q=c.insert(p,{elem})

Add elements from initializer_list {elem} before p

q=c.emplace(p,args)

Add element constructed from args before p

q=c.erase(p)

Remove element at p from c

q=c.erase(first,last)

Erase [first:last) of c

c.clear()

Erase all elements of c

For insert() functions, the result, q, points to the last element inserted. For erase() functions, q points to the element that followed the last element erased.

For containers with contiguous allocation, such as vector and deque, inserting and erasing an element can cause elements to be moved. An iterator pointing to a moved element becomes invalid. An element is moved if its position is after the insertion/deletion point or if all elements are moved because the new size exceeds the previous capacity. For example:

Click here to view code image

vector<int> v {4,3,5,1};
auto p = v.begin()+2;         // points to v[2], that is, the 5
v.push_back(6);               // p becomes invalid; v == {4,3,5,1,6}
p = v.begin()+2;              // points to v[2], that is, the 5
auto p2 = v.begin()+4;        // p2 points to v[4], that is, the 6
v.erase(v.begin()+3);         // v == {4,3,5,6}; p is still valid; p2 is invalid
Any operation that adds an element to a vector may cause every element to be reallocated (§13.6.4).

The emplace() operation is used when it is notationally awkward or potentially inefficient to first create an object and then copy (or move) it into a container. For example:

Click here to view code image

void user(list<pair<string,double>>& lst)
{

     auto p = lst.begin();
     while (p!=lst.end()& & p–>first!="Denmark")               // find an insertion point
            ++p; */ ;
     p=lst.emplace(p,"England",7.5);                          // nice and terse
     p=lst.insert(p,make_pair("France",9.8));                 // helper function
     p=lst.insert(p,pair<string,double>>{"Greece",3.14});     // verbose
}
The forward_list does not provide operations, such as insert(), that operate before an element identified by an iterator. Such an operation could not be implemented because there is no general way of finding the previous element in a forward_list given only an iterator. Instead, forward_iterator provides operations, such as insert_after(), that operate after an element identified by an iterator. emplace_hint() to provide a hint rather than “plain” emplace().

31.3.8 Other Operations
Containers can be compared and swapped:

Comparisons and Swap

c1==c2

Do all corresponding elements of c1 and c2 compare equal?

c1!=c2

!(c1==c2)

c1<c2

Is c1 lexicographically before c2?

c1<=c2

!(c2<c1)

c1>c2

c2<c1

c1>=c2

!(c1<c2)

c1.swap(c2)

Exchanges values of c1 and c2; noexcept

swap(c1,c2)

c1.swap(c2)

When comparing containers with an operator (e.g., <=), the elements are compared using the equivalent element operator generated from == or < (e.g., a>b is done using !(b<a)).

The swap() operations exchange both elements and allocators.

31.4. Containers
This section goes into more detail about:

• vector, the default container (§31.4.1)

• The linked lists: list and forward_list (§31.4.2)

• The associative containers, such as map and unordered_map (§31.4.3)

31.4.1. vector
The STL vector is the default container. Use it unless you have a good reason not to. If your suggested alternative is a list or a built-in array, think twice.

§31.3 describes the operations on vector and implicitly contrasts them with what is provided for other containers. However, given the importance of vector, this section takes a second look with more emphasis on how the operations are provided.

The vector’s template argument and member types are defined like this:

Click here to view code image

template<typename T, typename Allocator = allocator<T>>
class vector {
public:
     using reference = value_type&;
     using const_reference = const value_type&;
     using iterator = /* implementation-defined */;
     using const_iterator = /* implementation-defined */;
     using size_type = /* implementation-defined */;
     using difference_type = /* implementation-defined */;
     using value_type = T;
     using allocator_type = Allocator;
     using pointer = typename allocator_traits<Allocator>::pointer;
     using const_pointer = typename allocator_traits<Allocator>::const_pointer;
     using reverse_iterator = std::reverse_iterator<iterator>;
     using const_reverse_iterator = std::reverse_iterator<const_iterator>;

      //...
};
31.4.1.1. vector and Growth
Consider the layout of a vector object (as described in §13.6):



The use of both a size (number of elements) and a capacity (the number of available slots for elements without reallocation) makes growth through push_back() reasonably efficient: there is not an allocation operation each time we add an element, but only every time we exceed capacity (§13.6). The standard does not specify by how much capacity is increased when it is exceeded, but adding half the size is common. I used to be careful about using reserve() when I was reading into a vector. I was surprised to find that for essentially all of my uses, calling reserve() did not measurably affect performance. The default growth strategy worked just as well as my estimates, so I stopped trying to improve performance using reserve(). Instead, I use it to increase predictability of reallocation delays and to prevent invalidation of pointers and iterators.

The notion of capacity allows for iterators into a vector to be valid unless a reallocation actually happens. Consider reading letters into a buffer and keeping track of word boundaries:

Click here to view code image

vector<char> chars;            // input "buffer" for characters
constexpr int max = 20000;
chars.reserve(max);
vector<char*> words;           // pointers to start of words

bool in_word = false;
for (char c; cin.get(c);) {
      if (isalpha(c)) {
             if (!in_word) {           // found beginning of word
                    in_word = true;
                    chars.push_back(0);    // end of previous word
                    chars.push_back(c);
                    words.push_back(&chars.back());
             }
             else
                    chars.push_back(c);
      }
      else
             in_word = false;
}
if (in_word)
      chars.push_back(0);       // ter minate last word

if (max<chars.size()) {   // oops: chars grew beyond capacity; the words are invalid
       //...
}
Had I not used reserve() here, the pointers in words would have been invalidated if chars.push_back() caused a relocation. By “invalidated,” I mean that any use of those pointers would be undefined behavior. They may – or may not – point to an element, but almost certainly not to the elements they pointed to before the relocation.

I considered using chars.shrink_to_fit() to free surplus allocation, but shrink_to_fit() may also relocate and invalidate pointers so that should be postponed until after the last use of words.

The ability to grow a vector using push_back() and related operations implies that low-level C-style use of malloc() and realloc() (§43.5) is as unnecessary as it is tedious and error-prone.

31.4.1.2 vector and Nesting
A vector (and similar contiguously allocated data structures) has three major advantages compared to other data structures:

• The elements of a vector are compactly stored: there is no per-element memory overhead. The amount of memory consumed by a vec of type vector<X> is roughly size of (vector<X>)+vec.size()*size of (X). The size of (vector<X>) is about 12 bytes, which is insignificant for larger vectors.

• Traversal of a vector is very fast. To get to the next element, the code does not have to indirect through a pointer, and modern machines are optimized for consecutive access through a vector-like structure. This makes linear scans of vector elements, as in find() and copy(), close to optimal.

• vector supports simple and efficient random access. This is what makes many algorithms on vectors, such as sort() and binary_search(), efficient.

It is easy to underestimate these benefits. For example, a doubly-linked list, such as list, usually incurs a four-words-per-element memory overhead (two links plus a free-store allocation header), and traversing it can easily be an order of magnitude more expensive than traversing a vector containing equivalent data. The effect can be so spectacular and surprising that I suggest you test it yourself [Stroustrup,2012a].

The benefits of compactness and efficiency of access can be unintentionally compromised. Consider how to represent a two-dimensional matrix. There are two obvious alternatives:

• A vector of vectors: vector<vector<double>> accessed by C-style double subscripting: m[i][j]

• A specific matrix type, Matrix<2,double> (Chapter 29), that stores elements contiguously (e.g., in a vector<double>) and computes locations in that vector from a pair of indices: m(i,j)

The memory layout for a 3-by-4 vector<vector<double>> looks like this:


The memory layout for Matrix<2,double> looks like this:


To construct the vector<vector<double>>, we need four constructor calls with four free-store allocation operations. To access an element, we need to do a double indirection.

To construct the Matrix<2,double>, we need one constructor call with one free-store allocation. To access an element, we need a single indirection.

Once we reach an element of a row, we don’t need a further indirection to access its successor, so access to the vector<vector<double>> is not always twice as costly as access to Matrix<2,double>. However, for algorithms that require high performance, the allocation, deallocation, and access costs implied by the linked structure of vector<vector<double>> could be a problem.

The vector<vector<double>> solution implies the possiblity of the rows having different sizes. There are cases where that is an advantage, but more often it is simply an opportunity for errors and a burden for testing.

The problems and overhead get worse when we need higher dimensions: compare the number of added indirections and allocations for a vector<vector<vector<double>>> and a Matrix<3,double>.

In summary, I note that the importance of compactness of data structures is often underestimated or compromised. The advantages are logical as well as performance related. Combine this with a tendency to overuse pointers and new and we have a widespread problem. For example, consider the development complexities, run-time costs, memory costs, and opportunities for errors in an implementation of a two-dimensional structure when the rows are implemented as independent objects on the free store: vector<vector<double>*>.

31.4.1.3. vector and Arrays
A vector is a resource handle. This is what allows it to be resized and enables efficient move semantics. However, that occasionally puts it at a disadvantage compared to data structures (such as built-in arrays and array) that do not rely on storing elements separately from a handle. Keeping a sequence of elements on the stack or in another object can give a performance advantage, just as it can be a disadvantage.

A vector deals with properly initialized objects. This is what allows us to use them simply and rely on proper destruction of elements. However, that occasionally puts it at a disadvantage compared to data structures (such as built-in arrays and array) that allow uninitialized elements.

As an example, we need not initialize array elements before reading into them:

void read()
{
     array<int,MAX> a;
     for (auto& x : a)
           cin.get(x);
}
For vector, we might use emplace_back() to achieve a similar effect (without having to specify a MAX).

31.4.1.4. vector and string
A vector<char> is a resizable, contiguous sequence of chars, and so is a string. So how do we choose between the two?

A vector is a general mechanism for storing values. It makes no assumptions about the relationships among the values stored in it. To a vector<char>, the string Hello, World! is just a sequence of 13 elements of type char. Sorting them into !,HWdellloor (preceded by a space) makes sense. In contrast, a string is intended to hold character sequences. The relationships among the characters are assumed to be important. So, for example, we rarely sort the characters in a string because that destroys meaning. Some string operations reflect that (e.g., c_str(), >>, and find() “know” that C-style strings are zero-terminated). The implementations of string reflect assumptions about the way we use strings. For example, the short-string optimization (§19.3.3) would be a pure pessimization if it wasn’t for the fact that we use many short strings, so that minimizing free-store use becomes worthwhile.

Should there be a “short-vector optimization”? I suspect not, but it would require a massive empirical study to be sure.

31.4.2. Lists
The STL provides two linked-list types:

• list: a doubly-linked list

• forward_list: a singly-linked list

A list is a sequence optimized for insertion and deletion of elements. When you insert into a list or delete an element from a list, the locations of other elements of the list are not affected. In particular, iterators referring to other elements are not affected.

Compared to vector, subscripting could be painfully slow, so subscripting is not provided for lists. If necessary, use advance() and similar operations to navigate lists (§33.1.4). A list can be traversed using iterators: list provides bidirectional iterators (§33.1.2) and forward_list provides forward iterators (hence the name of that type of list).

By default, list elements are individually allocated in memory and include predecessor and successor pointers (§11.2.2). Compared to a vector, a list uses more memory per element (usually at least four words more per element), and traversals (iteration) are significantly slower because they involve indirection through pointers rather than simple consecutive access.

A forward_list is a singly-linked list. Think of it as a data structure optimized for empty or very short lists that you typically traverse starting from the beginning. For compactness, forward_list doesn’t even provide a size(); an empty forward_list takes up just one word of memory. If you need to know the number of elements of a forward_list, just count them. If there are enough elements to make counting them expensive, maybe you should use a different container.

With the exception of subscripting, capacity management, and size() for forward_list, the STL lists provide the member types and operations offered by vector (§31.4). In addition, list and forward_list provide specific list member functions:

Operations for Both list<T> and forward_list<T> (§iso.23.3.4.5, §iso.23.3.5.4)

lst.push_front(x)

Add x to lst (using copy or move) before the first element

lst.pop_front()

Remove the first element from lst

lst.emplace_front(args)

Add T{args} to lst before the first element

lst.remove(v)

Remove all elements of lst with value v

lst.remove_if(f)

Remove all elements of lst for which f(x)==true

lst.unique()

Remove adjacent duplicate elements of lst

lst.unique(f)

Remove adjacent duplicate elements of lst using f for equality

lst.merge(lst2)

Merge the ordered lists lst and lst2 using < as the order;

lst2 is merged into lst and emptied in the process

lst.merge(lst2,f)

Merge the ordered lists lst and lst2 using f as the order;

lst2 is merged into lst and emptied in the process

lst.sort()

Sort lst using < as the order

lst.sort(f)

Sort lst using f as the order

lst.reverse()

Reverse the order of the elements of lst; noexcept

As opposed to the general remove() and unique() algorithms (§32.5), the member algorithms really do affect the size of a list. For example:

Click here to view code image

void use()
{
     list<int> lst {2,3,2,3,5};
     lst.remove(3);                    // lst is now {2,2,5}
     lst.unique();                     // lst is now {2,5}
     cout << lst.size() << '\n';       // writes 2
}
The merge() algorithm is stable; that is, equivalent elements keep their relative order.

Operations for list<T> (§iso.23.3.5.5)

p points to an element of lst or lst.end()

lst.splice(p,lst2)

Insert the elements of lst2 before p; lst2 becomes empty

lst.splice(p,lst2,p2)

Insert the element pointed to by p2 in lst2 before p;

the element pointed to by p2 is removed from lst2

lst.splice(p,lst2,b,e)

Insert the elements [b:e) from lst2 before p;

 

the elements [b:e) are removed from lst2

A splice() operation does not copy element values and does not invalidate iterators to elements. For example:

Click here to view code image

list<int> lst1 {1,2,3};
list<int> lst2 {5,6,7};

auto p = lst1.begin();
++p;                      // p points to 2

auto q = lst2.begin();
++q;                      // q points to 6

lst1.splice(p,lst2);      // lst1 is now {1,5,6,7,2,3}; lst2 is now {}
                          // p still points to 2 and q still points to 6
A forward_list cannot access the element before one pointed to by an iterator (it does not have a predecessor link), so its emplace(), insert(), erase(), and splice() operations operate on the position after an iterator:

Operations for forward_list<T> (§iso.23.3.4.6)

p2=lst.emplace_after(p,args)

Emplace element constructed from args after p;

p2 points to the new element

p2=lst.insert_after(p,x)

Insert x after p; p2 points to the new element

p2=lst.insert_after(p,n,x)

Insert n copies of x after p;

p2 points to the last new element

p2=lst.insert_after(p,b,e)

Insert [b:e) after p; p2 points to the last new element

p2=lst.insert_after(p,{elem})

Insert {elem} after p;

p2 points to the last new element; elem is an initializer_list

p2=lst.erase_after(p)

Erase the element after p;

p2 points to the element after p or lst.end()

p2=lst.erase_after(b,e)

Erase [b:e); p2=e

lst.splice_after(p,lst2)

Splice in lst2 after p

lst.splice_after(p,lst2,p2)

Splice in p2 after p; remove p2 from lst2

lst.splice_after(p,lst2,b,e)

Splice in [b:e) after p; remove [b:e) from lst2

These list operations are all stable; that is, they preserve the relative order of elements that have equivalent values.

31.4.3. Associative Containers
Associative containers provide lookup based on keys. They come in two variants:

• Ordered associative containers do lookup based on an ordering criterion, by default < (less than). They are implemented as balanced binary trees, usually red-black trees.

• Unordered associative containers do lookup based on a hash function. They are implemented as hash tables with linked overflow.

Both come as

• maps: sequences of {key,value} pairs

• sets: maps without values (or you could say that the key is also the value)

Finally, maps and sets, whether ordered or unordered, come in two variants:

• “Plain” sets or maps with a unique entry for each key

• “Multi” sets or maps for which multiple entries can exist for each key

The name of an associate container indicates its place in this 3-dimensional space: {set|map, plain|unordered, plain|multi}. “Plain” is never spelled out, so the associative containers are:

Associative Containers (§iso.23.4.1, §iso.23.5.1)

set

multiset

unordered_set

unordered_multiset

map

multimap

unordered_map

unordered_multimap

Their template arguments are described in §31.4.

Internally, a map and an unordered_map are very different. See §31.2.1 for graphical representations. In particular, map uses its comparison criterion (typically <) on a key to search through a balanced tree (an O(log(n)) operation), whereas unordered_map applies a hash function on a key to find a slot in a hash table (an O(1) operation for a good hash function).

31.4.3.1. Ordered Associative Containers
Here are the template arguments and member types for map:

Click here to view code image

template<typename Key,
    typename T,
    typename Compare = less<Key>,
    typename Allocator = allocator<pair<const Key, T>>>
class map {
public:
    using key_type = Key;
    using mapped_type = T;
    using value_type = pair<const Key, T>;
    using key_compare = Compare;
    using allocator_type = Allocator;
    using reference = value_type&;
    using const_reference = const value_type&;
    using iterator = /* implementation-defined */ ;
    using const_iterator = /* implementation-defined */ ;
    using size_type = /* implementation-defined */ ;
    using difference_type = /* implementation-defined */ ;
    using pointer = typename allocator_traits<Allocator>::pointer;
    using const_pointer = typename allocator_traits<Allocator>::const_pointer;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    class value_compare { /* operator()(k1,k2) does a key_compare()(k1,k2) */ };
     //...
};
In addition to the constructors mentioned in §31.3.2, the associative containers have constructors allowing a programmer to supply a comparator:

map<K,T,C,A> Constructors (§iso.23.4.4.2)

map m {cmp,a};

Construct m to use comparator cmp and allocator a; explicit

map m {cmp};

map m {cmp, A{}}; explicit

map m {};

map m {C{}}; explicit

map m {b,e,cmp,a};

Construct m to use comparator cmp and allocator a;

 

initialize with the elements from [b:e)

map m {b,e,cmp};

map m {b,e,cmp, A{}};

map m {b,e};

map m {b,e,C{}};

map m {m2};

Copy and move constructors

map m {a};

Construct default map; use allocator a; explicit

map m {m2,a};

Copy or move construct m from m2; use allocator a

map m {{elem},cmp,a};

Construct m to use comparator cmp and allocator a;

initialize with the elements from initializer_list {elem}

map m {{elem},cmp};

map m {{elem},cmp,A{}};

map m {{elem}};

map m {{elem},C{}};

For example:

Click here to view code image

map<string,pair<Coordinate,Coordinate>> locations
    {
         {"Copenhagen",{"55:40N","12:34E"}},
         {"Rome",{"41:54N","12:30E"}},
         {"New York",{"40:40N","73:56W"}}
    };
The associative containers offer a variety of insertion and lookup operations:

Associative Container Operations (§iso.23.4.4.1)

v=c[k]

v is a reference to the element with key k;

if k is not found, {k,mapped_type{}} is inserted into c;

only for map and unordered_map

v=c.at(k)

v is a reference to the element with key k;

if k is not found, an out_of_range is thrown;

only for map and unordered_map

Associative Container Operations (continued) (§iso.23.4.4.1)

See also §31.3.7

p=c.find(k)

p points to the first element with key k or c.end()

p=c.lower_bound(k)

p points to the first element with key >=k or c.end();

ordered containers only

p=c.upper_bound(k)

p points to the first element with key >k or c.end();

ordered containers only

pair(p1,p2)=c.equal_range(k)

p1=c.lower_bound(k); p2=c.upper_bound(k)

r=c.insert(x)

x is a value_type or something that can be copied

into a value_type (e.g., a two-element tuple); for r see below

c.insert(b,e)

c.insert(*p) for every p in [b:e)

c.insert({args})

Insert each element of the initializer_list args;

an element is of type pair<key_type,mapped_type>

r=c.emplace(args)

p insert an object of c’s value_type constructed

from args into c; for r see below

p=c.emplace_hint(h,args)

p points to an object of c’s value_type constructed

from args and inserted into c;

 

h is an iterator into c, possibly used as a hint of

where to start to search for a place for the new entry

n=c.erase(k)

Erase all elements with key k;

n is the number of elements removed

r=c.key_comp()

r is a copy of the key comparison object;

ordered containers only

r=c.value_comp()

r is a copy of the value comparison object;

ordered containers only

n=c.count(k)

n is the number of elements with key k

Operations specific to unordered containers are presented in §31.4.3.5.

If a key, k, is not found by a subscript operation, m[k], a default value is inserted. For example:

Click here to view code image

map<string,string> dictionary;

dictionary["sea"]="large body of water";     // insert or assign to element

cout << dictionary["seal"]; <<'\n';                  // read value
If seal is not in the dictionary, nothing is printed: the empty string was entered as the value for seal and returned as the result of the lookup.

If that is not the desired behavior, we can use find() and insert() directly:

Click here to view code image

auto q = dictionary.find("seal");         // lookup; don't insert

if (q==dictionary.end()) {
      cout << "entry not found\n";
      dictionary.insert(make_pair("seal","eats fish"));
}
else
      cout << q->second;
In fact, [] is little more than a convenient notation for insert(). The result of m[k] is equivalent to the result of (*(m.insert(make_pair(k,V{})).first)).second, where V is the mapped type.

The insert(make_pair()) notation is rather verbose. Instead, we could use emplace():

dictionary.emplace("sea cow","extinct");
Depending on the quality of the optimizer, this may also be more efficient.

If you try to insert a value into a map and there already is an element with its key, the map is unchanged. If you want to have more than one value for a single key, use a multimap.

The first iterator of the pair (§34.2.4.1) returned by equal_range() is lower_bound() and the second upper_bound(). You can print the value of all elements with the key "apple" in a multimap<string,int> like this:

Click here to view code image

multimap<string,int> mm {{"apple",2}, { "pear",2}, {"apple",7}, {"orange",2}, {"apple",9}};

const string k {"apple"};
auto pp = mm.equal_range(k);
if (pp.first==pp.second)
      cout << "no element with value '" << k << "'\n";
else {
      cout << "elements with value '" << k << "':\n";
      for (auto p=pp.first; p!=pp.second; ++p)
            cout << p–>second << ' ';
}
This prints 2 7 9.

I could equivalently have written:

Click here to view code image

auto pp = make_pair(mm.lower_bound(),m.upper_bound());
 //...
However, that would imply an extra traversal of the map. The equal_range(), lower_bound(), and upper_bound() are also provided for sorted sequences (§32.6).

I tend to think of a set as a map with no separate value_type. For a set, the value_type is also the key_type. Consider:

struct Record {
     string label;
     int value;
};
To have a set<Record>, we need to provide a comparison function. For example:

Click here to view code image

bool operator<(const Record& a, const Record& b)
{
     return a.label<b.label;
}
Given that, we can write:

Click here to view code image

set<Record> mr {{"duck",10}, {"pork",12}};

void read_test()
{
     for (auto& r : mr) {
          cout << '{' << r.label << ':' << r.value << '}';
     }
     cout << \'n';
}
The key of an element in an associative container is immutable (§iso.23.2.4). Therefore, we cannot change the values of a set. We cannot even change a member of an element that takes no part in the comparison. For example:

Click here to view code image

void modify_test()
{
     for (auto& r : mr)
          ++r.value;      // error: set elements are immutable
}
If you need to modify an element, use a map. Don’t try to modify a key: if you were to succeed, the underlying mechanism for finding elements would break.

31.4.3.2. Unordered Associative Containers
The unordered associative containers (unordered_map, unordered_set, unordered_multimap, unordered_multiset) are hash tables. For simple uses, there are few differences from (ordered) containers because the associative containers share most operations (§31.4.3.1). For example:

Click here to view code image

unordered_map<string,int> score1 {
    {"andy", 7}, {"al",9}, {"bill",–3}, {"barbara",12}
};

map<string,int> score2 {
    {"andy", 7}, {"al",9}, {"bill",–3}, {"barbara",12}
};

template<typename X, typename Y>
ostream& operator<<(ostream& os, const pair<X,Y>& p)
{
    return os << '{' << p.first << ',' << p.second << '}';
}
void user()
{
    cout <<"unordered: ";
    for (const auto& x : score1)
          cout << x << ", ";

    cout << "\nordered: ";
    for (const auto& x : score2)
          cout << x << ", ";
    cout << '\n';
}
The visible difference is that iteration through a map is ordered and for an unordered_map it is not:

Click here to view code image

unordered: {andy,7}, {al,9}, {bill,–3}, {barbara,12},
ordered: {al,9}, {andy, 7}, {barbara,12}, {bill,–3},
Iteration over an unordered_map depends on the order of insertion, the hash function, and the load factor. In particular, there is no guarantee that elements are printed in the order of their insertion.

31.4.3.3. Constructing unordered_maps
The unordered_map has a lot of template arguments and member type aliases to match:

Click here to view code image

template<typename Key,
         typename T,
         typename Hash = hash<Key>,
         typename Pred = std::equal_to<Key>,
         typename Allocator = std::allocator<std::pair<const Key, T>>>
class unordered_map {
public:
     using key_type = Key;
     using value_type = std::pair<const Key, T>;
     using mapped_type = T;
     using hasher = Hash;
     using key_equal = Pred;
     using allocator_type = Allocator;
     using pointer = typename allocator_traits<Allocator>::pointer;
     using const_pointer= typename allocator_traits<Allocator>::const_pointer;
     using reference = value_type&;
     using const_reference = const value_type&
     using size_type = /* implementation-defined */;
     using difference_type = /* implementation-defined */;
     using iterator = /* implementation-defined */;
     using const_iterator = /* implementation-defined */;
     using local_iterator = /* implementation-defined */;
     using const_local_iterator = /* implementation-defined */;

      //...
};
By default, an unordered_map<X> uses hash<X> for hashing and equal_to<X> to compare keys.

The default equal_to<X> (§33.4) simply compares X values using ==.

The general (primary) template hash doesn’t have a definition. It is up to users of a type X to define hash<X> if needed. For common types, such as string, standard hash specializations are provided, so the user need not provide them:

Types with hash<T> (§iso.20.8.12) Supplied by the Standard Library

string

u16string

u32string

wstring

bool

characters

integers

floating-point types

pointers

type_index

thread::id

error_code

bitset<N>

unique_ptr<T,D>

shared_ptr<T>

 

Note the absence of a specialization for C-style strings; hashing a pointer (even a const char.) hashes the address.

A hash function (e.g., a specialization of hash for a type T or a pointer to function) must be callable with an argument of type T and return a size_t (§iso.17.6.3.4). Two calls of a hash function for the same value must give the same result, and ideally such results are uniformly distributed over the set of size_t values so as to minimize the chances that h(x)==h(y) if x!=y.

There is a potentially bewildering set of combinations of template argument types, constructors, and defaults for an unordered container. Fortunately, there is a pattern:

unordered_map<K,T,H,E,A> Constructors (§iso.23.5.4)

unordered_map m {n,hf,eql,a};

Construct m with n buckets,

the hash function hf, the equality function eql,

and the allocator a; explicit

unordered_map m {n,hf,eql};

unordered_map m{n,hf,eql,allocator_type{}}; explicit

unordered_map m {n,hf};

unordered_map m {n,hf,key_eql{}}; explicit

unordered_map m {n};

unordered_map m {n,hasher{}}; explicit

unordered_map m {};

unordered_map m {N}; the bucket count N

is implementation-defined; explicit

Here, n is an element count for an otherwise empty unordered_map.

unordered_map<K,T,H,E,A> Constructors (§iso.23.5.4)

unordered_map m {b,e,n,hf,eql,a};

Construct m with n buckets

from the elemsof [b:e),

using hash function hf, the equality function eql,

and the allocator a;

unordered_map m {b,e,n,hf,eql};

unordered_map m {b,e,n,hf,eql,allocator_type{}};

unordered_map m {b,e,n,hf};

unordered_map m {b,e,n,hf,key_equal{}};

unordered_map m {b,e,n};

unordered_map m {b,e,n,hasher{}};

unordered_map m {b,e};

unordered_map m {b,e,N};

the bucket count N is implementation-defined

Here, we get the initial elements from a sequence [b:e). The number of elements will be then number of elements in [b:e), distance(b,e).

unordered_map<K,T,H,E,A> Constructors (§iso.23.5.4)

unordered_map m {{elem},n,hf,eql,a};

Construct m from the elemsofan initializer_list,

using n buckets,

the hash function hf, the equality function eql,

and the allocator a

unordered_map m {{elem},n,hf,eql};

unordered_map m {{elem},n,hf,eql,allocator_type{}};

unordered_map m {{elem},n,hf};

unordered_map m {{elem},n,hf,key_equal{}};

unordered_map m {{elem},n};

unordered_map m {{elem},n,hasher{}};

unordered_map m {{elem}};

unordered_map m {{elem},N};

the bucket count N is implementation-defined

Here, we get the initial elements from a sequence from a {}-delimited initializer list of elements. The number of elements in the unordered_map will be the number of elements in the initializer list.

Finally, unordered_map has copy and move constructors, and also equivalent constructors that supply allocators:

unordered_map<K,T,H,E,A> Constructors (§iso.23.5.4)

unordered_map m {m2};

Copy and move constructors: construct m from m2

unordered_map m {a};

Default construct m and give it allocator a; explicit

unordered_map m {m2,a};

Construct m from m2 and give it allocator a

Be careful when constructing an unordered_map with one or two arguments. There are many possible combinations of types, and mistakes can lead to strange error messages. For example:

Click here to view code image

map<string,int> m {My_comparator};              // OK
unordered_map<string,int> um {My_hasher};       // error
A single constructor argument must be another unordered_map (for a copy or move constructor), a bucket count, or an allocator. Try something like:

unordered_map<string,int> um {100,My_hasher};   // OK
31.4.3.4. Hash and Equality Functions
Naturally, a user can define a hash function. In fact, there are several ways to do that. Different techniques serve different needs. Here, I present several versions, starting with the most explicit and ending with the simplest. Consider a simple Record type:

struct Record {
     string name;
     int val;
};
I can define Record hash and equality operations like this:

Click here to view code image

struct Nocase_hash {
     int d = 1;     // shift code d number of bits in each iteration
     size_t operator()(const Record& r) const
     {
          size_t h = 0;
          for (auto x : r.name) {
                h <<= d;
                h ^= toupper(x);
          }


          return h;
     }
};

struct Nocase_equal {
     bool operator()(const Record& r,const Record& r2) const
     {
          if (r.name.size()!=r2.name.size()) return false;
          for (int i = 0; i<r.name.size(); ++i)
                if (toupper(r.name[i])!=toupper(r2.name[i]))
                      return false;
          return true;
     }
};
Given that, I can define and use an unordered_set of Records:

Click here to view code image

unordered_set<Record,Nocase_hash,Nocase_equal> m {
    { {"andy", 7}, {"al",9}, {"bill",–3}, {"barbara",12} },
    20, /. bucket count ./
    Nocase_hash{2},
    Nocase_equal{}
};

for (auto r : m)
      cout << "{" << r.name << ',' << r.val << "}\n";
If, as is most common, I wanted to use the default values for my hash and equality functions, I could do that by simply not mentioning them as constructor arguments. By default, the unordered_set uses the default versions:

Click here to view code image

unordered_set<Record,Nocase_hash,Nocase_equal> m {
    {"andy", 7}, {"al",9}, {"bill",–3}, {"barbara",12}
     // use bucket count 4, Nocase_hash{}, and Nocase_equal{}
};
Often, the easiest way of writing a hash function is to use the standard-library hash functions provided as specializations of hash (§31.4.3.2). For example:

Click here to view code image

size_t hf(const Record& r) { return hash<string>()(r.name)^hash<int>()(r.val); };

bool eq (const Record& r, const Record& r2) { return r.name==r2.name && r.val==r2.val; };
Combining hash values using exclusive OR (^) preserves their distributions over the set of values of type size_t (§3.4.5, §10.3.1).

Given this hash function and equality function, we can define an unordered_set:

Click here to view code image

unordered_set<Record,decltype(&hf),decltype(&eq)> m {
    { {"andy", 7}, {"al",9}, {"bill",–3}, {"barbara",12} },
    20, /. bucket count ./
    hf,
    eq
};

for (auto r : m)
      cout << "{" << r.name << ',' << r.val << "}\n";
I used decltype to avoid having to explicitly repeat the types of hf and eq.

If we don’t have an initializer list handy, we can give an initial size instead:

unordered_set<Record,decltype(&hf),decltype(&eq)> m {10,hf,eq};
That also makes it a bit easier to focus on the hash and equality operations.

If we wanted to avoid separating the definitions of hf and eq from their point of use, we could try lambdas:

Click here to view code image

unordered_set<Record,                                   // value type
        function<size_t(const Record&)>,                // hash type
        function<bool(const Record&,const Record&)>     // equal type
    > m {     10,
          [](const Record& r) { return hash<string>{}(r.name)^hash<int>{}(r.val); },
          [](const Record& r, const Record& r2) { return r.name==r2.name && r.val==r2.val; }
    };
The point about using (named or unnamed) lambdas instead of functions is that they can be defined locally in a function, next to their use.

However, here, function may incur overhead that I would prefer to avoid if the unordered_set was heavily used. Also, I consider that version messy and prefer to name the lambdas:

Click here to view code image

auto hf = [](const Record& r) { return hash<string>()(r.name)^hash<int>()(r.val); };
auto eq = [](const Record& r, const Record& r2) { return r.name==r2.name && r.val==r2.val; };

unordered_set<Record,decltype(hf),decltype(eq)> m {10,hf,eq};
Finally, we may prefer to define the meaning of hash and equality once for all unordered containers of Record by specializing the standard-library hash and equal_to templates used by unordered_map:

Click here to view code image

namespace std {
   template<>
   struct hash<Record>{
        size_t operator()(const Record &r) const
        {
             return hash<string>{}(r.name)^hash<int>{}(r.val);
        }
   };
   template<>
   struct equal_to<Record> {
        bool operator()(const Record& r, const Record& r2) const
        {
             return r.name==r2.name && r.val==r2.val;
        }
   };
}
unordered_set<Record> m1;
unordered_set<Record> m2;
The default hash and hashes obtained from it by using exclusive-or are often pretty good. Don’t rush to use homemade hash functions without experimentation.

31.4.3.5. Load and Buckets
Significant parts of the implementation of an unordered container are made visible to the programmer. Keys with the same hash value are said to be “in the same bucket” (see §31.2.1). A programmer can examine and set the size of the hash table (known as “the number of buckets”):

Hash Policy (§iso.23.2.5)

h=c.hash_function()

h is c’s hash function

eq=c.key_eq()

eq is c’s equality test

d=c.load_factor()

d is the number of elements divided by the number of buckets: double(c.size())/c.bucket_count(); noexcept

d=c.max_load_factor()

d is the maximum load factor for c; noexcept

c.max_load_factor(d)

Set c’s maximum load factor to d;if c’s load factor gets

close to its maximum load factor, c will resize the hash table

(increase the number of buckets)

c.rehash(n)

Make c’s bucket count >= n

c.reserve(n)

Make room for n entries (taking the load factor into account): c.rehash(ceil(n/c.max_load_factor()))

The load factor of an unordered associative container is simply the fraction of the capacity that has been used. For example, if the bucket_count() is 100 elements and the size() is 30, the load_factor() is 0.3.

Note that setting the max_load_factor, calling rehash(), or calling reser ve() can be very expensive operations (worst case O(n.n)) because they can . and in realistic scenarios typically do . cause rehashing of all elements. These functions are used to ensure that rehashing takes place at relatively convenient times in a program’s execution. For example:

Click here to view code image

unordered_set<Record,[](const Record& r) { return hash(r.name); }> people;// ...
 //...
constexpr int expected = 1000000;     // expected maximum number of elements
people.max_load_factor(0.7);          // at most 70% full
people.reserve(expected);             //about 1,430,000 buckets
You need to experiment to find a suitable load factor for a given set of elements and a particular hash function, but 70% (0.7) is often a good choice.

Bucket Interface (§iso.23.2.5)

n=c.bucket_count()

n is the number of buckets in c (the size of the hash table); noexcept

n=c.max_bucket_count()

n is the largest possible number of elements in a bucket; noexcept

m=c.bucket_size(n)

m is the number of elements in the nth bucket

i=c.bucket(k)

An element with key k would be in the ith bucket

p=c.begin(n)

p points to the first element in bucket n

p =c.end(n)

p points to the one-past-the-last element in bucket n

p=c.cbegin(n)

p points to the first element in bucket n;

p is a const iterator

p =c.cend(n)

p points to the one-past-the-last element in bucket n;

p is a const iterator

Use of an n for which c.max_bucket_count()<=n as an index into a bucket is undefined (and probably disastrous).

One use for the bucket interface is to allow experimentation with hash functions: a poor hash function will lead to large bucket_siz e()s for some key values. That is, it will lead to many keys being mapped to the same hash value.

31.5. Container Adaptors
A container adaptor provides a different (typically restricted) interface to a container. Container adaptors are intended to be used only through their specialized interfaces. In particular, the STL container adaptors do not offer direct access to their underlying container. They do not offer iterators or subscripting.

The techniques used to create a container adaptor from a container are generally useful for nonintrusively adapting the interface of a class to the needs of its users.

31.5.1. stack
The stack container adaptor is defined in <stack>. It can be described by a partial implementation:

Click here to view code image

template<typename T, typename C = deque<T>>
class stack {      //§iso.23.6.5.2
public:
     using value_type = typename C::value_type;
     using reference = typename C::reference;
     using const_reference = typename C::const_reference;
     using size_type = typename C::size_type;
     using container_type = C;
public:
     explicit stack(const C&);  // copy from container
     explicit stack(C&& = C{});      // move from container

      // default copy, move, assignment, destructor

     template<typename A>
         explicit stack(const A& a);              // default container, allocator a
     template<typename A>
         stack(const C& c, const A& a);           // elements from c, allocator a
     template<typename A>
         stack(C&&, const A&);
     template<typename A>
         stack(const stack&, const A&);
     template<typename A>
         stack(stack&&, const A&);

     bool empty() const { return c.empty(); }
     size_type size() const { return c.size(); }
     reference top() { return c.back(); }
     const_reference top() const { return c.back(); }
     void push(const value_type& x) { c.push_back(x); }
     void push(value_type&& x) { c.push_back(std::move(x)); }
     void pop() { c.pop_back(); }      // pop the last element

     template<typename ... Args>
     void emplace(Args&&... args)
     {
          c.emplace_back(std::forward<Args>(args)...);
     }

     void swap(stack& s) noexcept(noexcept(swap(c, s.c)))
     {
          using std::swap;   // be sure to use the standard swap()
          swap(c,s.c);
     }
protected:
     C c;
};
That is, a stack is an interface to a container of the type passed to it as a template argument. A stack eliminates the non-stack operations on its container from the interface, and provides the conventional names: top(), push(), and pop().

In addition, stack provides the usual comparison operators (==, <, etc.) and a nonmember swap().

By default, a stack makes a deque to hold its elements, but any sequence that provides back(), push_back(), and pop_back() can be used. For example:

Click here to view code image

stack<char> s1;                 // uses a deque<char> to store elements
stack<int,vector<int>> s2;      // uses a vector<int> to store elements
Often, vector is faster than deque and uses less memory.

Elements are added to a stack using push_back() on the underlying container. Consequently, a stack cannot “overflow” as long as there is memory available on the machine for the container to acquire. On the other hand, a stack can underflow:

Click here to view code image

void f()
{
     stack<int> s;
     s.push(2);
     if (s.empty()) {          // underflow is preventable
            // don't pop
     }
     else {                    // but not impossible
          s.pop();      // fine: s.size() becomes 0
          s.pop();      // undefined effect, probably bad
     }
}
We do not pop() an element to use it. Instead, the top() is accessed and then pop()ed when it is no longer needed. This is not too inconvenient, can be more efficient when a pop() is not necessary, and greatly simplifies the implementation of exception guarantees. For example:

Click here to view code image

void f(stack<char>& s)
{
     if (s.top()=='c') s.pop();    // optionally remove optional initial 'c'
      //...
}
By default, a stack relies on the allocator from its underlying container. If that’s not enough, there are a handful of constructors for supplying another.

31.5.2. queue
Defined in <queue>, a queue is an interface to a container that allows the insertion of elements at the back() and the extraction of elements at the front():

Click here to view code image

template<typename T, typename C = deque<T> >
class queue {     //§iso.23.6.3.1
      //... like stack, but no top()...
     void pop() { c.pop_front(); }    // pop the first element
};
Queues seem to pop up somewhere in every system. One might define a server for a simple message-based system like this:

Click here to view code image

void server(queue<Message>& q, mutex& m)
{
     while (!q.empty()) {
          Message mess;
          {   lock_guard<mutex> lck(m);    // lock while extracting message
              if (q.empty()) return;             // somebody else got the message
              mess = q.front();
              q.pop();
          }
           // serve request
     }
}
31.5.3. priority_queue
A priority_queue is a queue in which each element is given a priority that controls the order in which the elements get to be the top(). The declaration of priority_queue is much like the declaration of queue with additions to deal with a comparison object and a couple of constructors initializing from a sequence:

Click here to view code image

template<typename T, typename C = vector<T>, typename Cmp = less<typename C::value_type>>
class priority_queue {      //§iso.23.6.4
protected:
     C c;
     Cmp comp;
public:
     priority_queue(const Cmp& x, const C&);
     explicit priority_queue(const Cmp& x = Cmp{}, C&& = C{});
     template<typename In>
         priority_queue(In b, In e, const Cmp& x, const C& c);    // insert [b:e) into c
      //...
};
The declaration of priority_queue is found in <queue>.

By default, the priority_queue simply compares elements using the < operator, and top() returns the largest element:

Click here to view code image

struct Message {
     int priority;
     bool operator<(const Message& x) const { return priority < x.priority; }
      //...
};

void server(priority_queue<Message>& q, mutex& m)
{
     while (!q.empty()) {
          Message mess;
          {   lock_guard<mutex> lck(m);    // hold lock while extracting message
              if (q.empty()) return;       // somebody else got the message
              mess = q.top();
              q.pop();
          }
           // serve highest priority request
     }
}
This differs from the queue version (§31.5.2) in that Messages with higher priority will get served first. The order in which elements with equal priority come to the head of the queue is not defined. Two elements are considered of equal priority if neither has higher priority than the other (§31.2.2.1).

Keeping elements in order isn’t free, but it needn’t be expensive either. One useful way of implementing a priority_queue is to use a tree structure to keep track of the relative positions of elements. This gives an O(log(n)) cost of both push() and pop(). A priority_queue is almost certainly implemented using a heap (§32.6.4).

31.6. Advice
[1] An STL container defines a sequence; §31.2.

[2] Use vector as your default container; §31.2, §31.4.

[3] Insertion operators, such as insert() and push_back() are often more efficient on a vector than on a list; §31.2, §31.4.1.1.

[4] Use forward_list for sequences that are usually empty; §31.2, §31.4.2.

[5] When it comes to performance, don’t trust your intuition: measure; §31.3.

[6] Don’t blindly trust asymptotic complexity measures; some sequences are short and the cost of individual operations can vary dramatically; §31.3.

[7] STL containers are resource handles; §31.2.1.

[8] A map is usually implemented as a red-black tree; §31.2.1, §31.4.3.

[9] An unordered_map is a hash table; §31.2.1, §31.4.3.2.

[10] To be an element type for a STL container, a type must provide copy or move operations; §31.2.2.

[11] Use containers of pointers or smart pointers when you need to preserve polymorphic behavior; §31.2.2.

[12] Comparison operations should implement a strict weak order; §31.2.2.1.

[13] Pass a container by reference and return a container by value; §31.3.2.

[14] For a container, use the ()-initializer syntax for sizes and the {}-initializer syntax for lists of elements; §31.3.2.

[15] For simple traversals of a container, use a range-for loop or a begin/end pair of iterators; §31.3.4.

[16] Use const iterators where you don’t need to modify the elements of a container; §31.3.4.

[17] Use auto to avoid verbosity and typos when you use iterators; §31.3.4.

[18] Use reserve() to avoid invalidating pointers and iterators to elements; §31.3.3, §31.4.1.

[19] Don’t assume performance benefits from reserve() without measurement; §31.3.3.

[20] Use push_back() or resize() on a container rather than realloc() on an array; §31.3.3, §31.4.1.1.

[21] Don’t use iterators into a resized vector or deque; §31.3.3.

[22] When necessary, use reserve() to make performance predictable; §31.3.3.

[23] Do not assume that [] range checks; §31.2.2.

[24] Use at() when you need guaranteed range checks; §31.2.2.

[25] Use emplace() for notational convenience; §31.3.7.

[26] Prefer compact and contiguous data structures; §31.4.1.2.

[27] Use emplace() to avoid having to pre-initialize elements; §31.4.1.3.

[28] A list is relatively expensive to traverse; §31.4.2.

[29] A list usually has a four-word-per-element memory overhead; §31.4.2.

[30] The sequence of an ordered container is defined by its comparison object (by default <); §31.4.3.1.

[31] The sequence of an unordered container (a hashed container) is not predictably ordered; §31.4.3.2.

[32] Use unordered containers if you need fast lookup for large amounts of data; §31.3.

[33] Use unordered containers for element types with no natural order (e.g., no reasonable <); §31.4.3.

[34] Use ordered associative containers (e.g., map and set) if you need to iterate over their elements in order; §31.4.3.2.

[35] Experiment to check that you have an acceptable hash function; §31.4.3.4.

[36] Hash functions obtained by combining standard hash functions for elements using exclusive or are often good; §31.4.3.4.

[37] 0.7 is often a reasonable load factor; §31.4.3.5.

[38] You can provide alternative interfaces for containers; §31.5.

[39] The STL adaptors do not offer direct access to their underlying containers; §31.5.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


31. STL Containers
32. STL Algorithms
33. STL Iterators
47h 26m remaining
32. STL Algorithms
Form is liberating.

– Engineer’s proverb

• Introduction

• Algorithms

Sequences; Policy Arguments; Complexity

• Nonmodifying Sequence Algorithms

for_each(); Sequence Predicates; count(); find(); equal() and mismatch(); search()

• Modifying Sequence Algorithms

copy(); unique(); remove(), reverse(), and replace(); rotate(), random_shuffle(), and partition(); Permutations; fill(); swap()

• Sorting and Searching

Binary Search; merge(); Set Algorithms; Heaps; lexcographical_compare()

• Min and Max

• Advice

32.1. Introduction
This chapter presents the STL algorithms. The STL consists of the iterator, container, algorithm, and function object parts of the standard library. The rest of the STL is presented in Chapter 31 and Chapter 33.

32.2. Algorithms
There are about 80 standard algorithms defined in <algorithm>. They operate on sequences defined by a pair of iterators (for inputs) or a single iterator (for outputs). When copying, comparing, etc., two sequences, the first is represented by a pair of iterators, [b:e), but the second by just a single iterator, b2, which is considered the start of a sequence holding sufficient elements for the algorithm, for example, as many elements as the first sequence: [b2:b2+(e–b)). Some algorithms, such as sort(), require random-access iterators, whereas many, such as find(), only read their elements in order so that they can make do with a forward iterator. Many algorithms follow the usual convention of returning the end of a sequence to represent “not found” (§4.5). I don’t mention that for each algorithm.

Algorithms, both the standard-library algorithms and the users’ own ones, are important:

• Each names a specific operation, documents an interface, and specifies semantics.

• Each can be widely used and known by many programmers.

For correctness, maintainability, and performance, these can be immense advantages compared to “random code” with less well-specified functions and dependencies. If you find yourself writing a piece of code with several loops, local variables that don’t seem to relate to each other, or complicated control structures, consider if the code could be simplified by making a part into a function/algorithm with a descriptive name, a well-defined purpose, a well-defined interface, and well-defined dependencies.

Numerical algorithms in the style of the STL algorithms are presented in §40.6.

32.2.1. Sequences
The ideal for a standard-library algorithm is to provide the most general and flexible interface to something that can be implemented optimally. The iterator-based interfaces are a good, but not perfect, approximation to that ideal (§33.1.1). For example, an iterator-based interface does not directly represent the notion of a sequence, leading to the possibility of confusion and difficulties in detecting some range errors:

Click here to view code image

void user(vector<int>& v1, vector<int>& v2)
{
     copy(v1.begin(),v1.end(),v2.begin());    // may overflow v2
     sort(v1.begin(),v2.end());                    // oops!
}
Many such problems can be alleviated by providing container versions of the standard-library algorithms. For example:

Click here to view code image

template<typename Cont>
void sort(Cont& c)
{
     static_assert(Range<Cont>(), "sort(): Cont argument not a Range");
     static_assert(Sortable<Iterator<Cont>>(), "sort(): Cont argument not Sortable");

     std::sort(begin(c),end(c));
}

template<typename Cont1, typename Cont2>
void copy(const Cont1& source, Cont2& target)
{
     static_assert(Range<Cont1>(), "copy(): Cont1 argument not a Range");
     static_assert(Range<Cont2>(), "copy(): Cont2 argument not a Range");
     if (target.size()<source.size()) throw out_of_range{"copy target too small"};

     std::copy(source.begin(),source.end(),target.begin());
}
This would simplify the definition of user(), make the second error impossible to express, and catch the first at run time:

Click here to view code image

void user(vector<int>& v1, vector<int>& v2)
{
     copy(v1,v2);   // overflows will be caught
     sort(v1);
}
However, the container versions are also less general than the versions that use iterators directly. In particular, you cannot use the container sort() to sort half a container, and you cannot use the container copy() to write to an output stream.

A complementary approach is to define a “range” or “sequence” abstraction that allows us to define sequences when needed. I use the concept Range to denote anything with begin() and end() iterators (§24.4.4). That is, there is no Range class holding data – exactly as there is no Iterator class or Container class in the STL. So, in the “container sort()” and “container copy()” examples, I called the template argument Cont (for “container”), but they will accept any sequence with a begin() and an end() that meets the rest of the requirements for the algorithm.

The standard-library algorithms mostly return iterators. In particular, they do not return containers of results (except in a few rare examples, a pair). One reason for that is that when the STL was designed, there was no direct support for move semantics. So, there was no obvious and efficient way to return a lot of data from an algorithm. Some programmers used explicit indirection (e.g., a pointer, reference, or iterator) or some clever trickery. Today, we can do better:

Click here to view code image

template<typename Cont, typename Pred>
vector<Value_type<Cont>*>
find_all(Cont& c, Pred p)
{
     static_assert(Range<Cont>(), "find_all(): Cont argument not a Range");
     static_assert(Predicate<Pred>(), "find_all(): Pred argument not a Predicate");

     vector<Value_type<Cont>*> res;
     for (auto& x : c)
           if (p(x)) res.push_back(&x);
     return res;
}
In C++98, this find_all() would have been a bad performance bug whenever the number of matches was large. If the choice of standard-library algorithms seems restrictive or insufficient, extension with new versions of STL algorithms or new algorithms is often a viable and superior alternative to just writing “random code” to work around the problem.

Note that whatever an STL algorithm returns, it cannot be an argument container. The arguments to STL algorithms are iterators (Chapter 33), and an algorithm has no knowledge of the data structure those iterators point into. Iterators exist primarily to isolate algorithms from the data structure on which they operate, and vice versa.

32.3. Policy Arguments
Most standard-library algorithms come in two versions:

• A “plain” version that performs its action using conventional operations, such as < and ==

• A version that takes key operations as arguments

For example:

Click here to view code image

template<typename Iter>
void sort(Iter first, Iter last)
{
      //... sort using e1<e2 ...
}

template<typename Iter, typename Pred>
void sort(Iter first, Iter last, Pred pred)
{
      //... sort using pred(e1,e2) ...
}
This greatly increases the flexibility of the standard library and its range of uses.

The usual two versions of an algorithm can be implemented as two (overloaded) function templates or as a single function template with a default argument. For example:

Click here to view code image

template<typename Ran, typename Pred = less<Value_type<Ran>>>   // use a default template argument
sort(Ran first, Ran last, Pred pred ={})
{
      //... use pred(x,y) ...
}
The difference between having two functions and having one with a default argument can be observed by someone taking pointers to functions. However, thinking of many of the variants of the standard algorithms as simply “the version with the default predicate” roughly halves the number of template functions you need to remember.

In some cases, an argument could be interpreted as either a predicate or a value. For example:

Click here to view code image

bool pred(int);

auto p = find(b,e,pred);   // find the element pred or apply the predicate pred()? (the latter)
In general, a compiler cannot disambiguate such examples, and programmers would get confused even in the cases where the compiler could disambiguate.

To simplify the task for the programmer, the _if suffix is often used to indicate that an algorithm takes a predicate. The reason to distinguish by using two names is to minimize ambiguities and confusion. Consider:

Click here to view code image

using Predicate = bool(*)(int);

void f(vector<Predicate>& v1, vector<int>& v2)
{
     auto p1 = find(v1.begin(),v1.end(),pred);        // find element with the value pred
     auto p2 = find_if(v2.begin(),v2.end(),pred);     // count elements for which pred() returns true
}
Some operations passed as arguments to an algorithm modify the element to which they are applied (e.g., some operations passed to for_each(); §32.4.1), but most are predicates (e.g., a comparison object for sort()). Unless otherwise stated, assume that a policy argument passed to an algorithm should not modify an element. In particular, do not try to modify elements through predicates:

Click here to view code image

int n_even(vector<int>& v)                         // don't do this
      // count the number of even values in v
{
     return count_if(v.begin(),v.end(),[](int& x) {++x; return x&1; });
}
Modifying an element through a predicate obscures what is being done. If you are really sneaky, you could even modify the sequence (e.g., by inserting or removing an element using the name of a container being iterated over), so that the iteration would fail (probably in obscure ways). To avoid accidents, you may pass arguments to predicates by const reference.

Similarly, a predicate should not carry state that changes the meaning of its operation. The implementation of an algorithm may copy a predicate, and we rarely want repeated uses of a predicate on the same value to give different results. Some function objects passed to algorithms, such as random number generators, do carry mutable state. Unless you are really sure that an algorithm doesn’t copy, keep a function object argument’s mutable state in another object and access it through a pointer or a reference.

The == and < operations on pointer elements are rarely appropriate for an STL algorithm: they compare machine addresses rather than the values pointed to. In particular, do not sort or search containers of C-style strings using the default == and < (§32.6).

32.3.1. Complexity
As for containers (§31.3), the complexity of algorithms is specified by the standard. Most algorithms are linear, O(n), for some n, which is usually the length of an input sequence.

Algorithm Complexity (§iso.25)

O(1)

swap(), iter_swap()

O(log(n))

lower_bound(), upper_bound(), equal_range(), binary_search(), push_heap(), pop_heap(), partition_point()

O(n*log(n))

inplace_merge() (worst case), stable_partition() (worst case),

sort(), stable_sort(), partial_sort(), partial_sort_copy(), sort_heap()

O(n*n)

find_end(), find_first_of(), search(), is_permutation() (worst case)

O(n)

All the rest

As ever, these are asymptotic complexities, and you have to know what n measures to have an idea of the implications. For example, if n<3, a quadratic algorithm may be the best choice. The cost of each iteration can vary dramatically. For example, traversing a list can be much slower than traversing a vector, even though the complexity in both cases is linear (O(n)). Complexity measures are not a substitute for common sense and actual time measurements; they are one tool among many to ensure quality code.

32.4. Nonmodifying Sequence Algorithms
A nonmodifying algorithm just reads the values of elements of its input sequences; it does not rearrange the sequence and does not change the values of the elements. Typically, user-supplied operations to an algorithm don’t change the values of elements either; they tend to be predicates (which may not modify their arguments).

32.4.1. for_each()
The simplest algorithm is for_each(), which just applies an operation to each element of a sequence:

for_each (§iso.25.2.4)

f=for_each(b,e,f)

Do f(x) for each x in [b:e); return f

When possible, prefer a more specific algorithm.

The operation passed to for_each() may modify elements. For example:

Click here to view code image

void increment_all(vector<int>& v)  // increment each element of v
{
     for_each(v.begin(),v.end(), [](int& x) {++x;});
}
32.4.2. Sequence Predicates
Sequence Predicates (§iso.25.2.1)

all_of(b,e,f)

Is f(x) true for all x in [b:e)?

any_of(b,e,f)

Is f(x) true for any x in [b:e)?

none_of(b,e,f)

Is f(x) false for all x in [b:e)?

For example:

Click here to view code image

vector<double> scale(const vector<double>& val, const vector<double>& div)
{
     assert(val.size()<=div.size());
     assert(all_of(div.begin(),div.end(),[](double x){ return 0<x; }));

     vector <double>res(val.size());
     for (int i = 0; i<val.size(); ++i)
           res[i] = val[i]/div[i];
     return res;
}
When one of these sequence predicates fails, it does not tell which element caused the failure.

32.4.3. count()
count (§iso.25.2.9)

x=count(b,e,v)

x=count_if(b,e,f)

x is the number of elements *p in [b:e) such that v==*p

x is the number of elements *p in [b:e) such that f(*p)

For example:

Click here to view code image

void f(const string& s)
{
     auto n_space = count(s.begin(),s.end(),' ');
     auto n_whitespace = count_if(s.begin(),s.end(),isspace);
      //...
}
The isspace() predicate (§36.2) lets us count all whitespace characters, rather than just space.

32.4.4. find()
The find() family of algorithms do linear searches for some element or predicate match:

The find Family (§iso.25.2.5)

p=find(b,e,v)

p points to the first element in [b:e) such that *p==v

p=find_if(b,e,f)

p points to the first element in [b:e) such that f(*p)

p=find_if_not(b,e,f)

p points to the first element in [b:e) such that !f(*p)

p=find_first_of(b,e,b2,e2)

p points to the first element in [b:e) such that *p==*q

for some q in [b2:e2)

p=find_first_of(b,e,b2,e2,f)

p points to the first element in [b:e) such that f(*p,*q)

for some q in [b2:e2)

p=adjacent_find(b,e)

p points to the first element in [b:e) such that *p==*(p+1)

p=adjacent_find(b,e,f)

p points to the first element in [b:e) such that f(*p,*(p+1))

p=find_end(b,e,b2,e2)

p points to the last *p in [b:e) such that *p==*q for

an element *q in [b2:e2)

p=find_end(b,e,b2,e2,f)

p points to the last *p in [b:e) such that f(*p,*q) for

an element *q in [b2:e2)

The algorithms find() and find_if() return an iterator to the first element that matches a value and a predicate, respectively.

Click here to view code image

void f(const string& s)
{
     auto p_space = find(s.begin(),s.end(),' ');
     auto p_whitespace = find_if(s.begin(),s.end(), isspace);
      //...
}
The find_first_of() algorithms find the first occurrence in a sequence of an element from another sequence. For example:

Click here to view code image

array<int,3> x = {1,3,4 };
array<int,5> y = {0,2,3,4,5};

void f()
{
     auto p = find_first_of(x.begin(),x.end(),y.begin(),y.end());      // p = &x[1]
     auto q = find_first_of(p+1,x.end(),y.begin(),y.end());          // q = &x[2]
}
The iterator p will point to x[1] because 3 is the first element of x with a match in y. Similarly, q will point to x[2].

32.4.5. equal() and mismatch()
The equal() and mismatch() algorithms compare pairs of sequences:

equal and mismatch() (§iso.25.2.11, §iso.25.2.10)

equal(b,e,b2)

Is v==v2 for all corresponding elements of

[b:e) and [b2:b2+(e-b))?

equal(b,e,b2,f)

Is f(v,v2) for all corresponding elements of

[b:e) and [b2:b2+(e-b))?

pair(p1,p2)=mismatch(b,e,b2)

p1 points to the first element in [b:e) and

p2 points to the first element in [b2:b2+(e-b))

such that !(*p1==*p2) or p1==e

pair(p1,p2)=mismatch(b,e,b2,f)

p1 points to the first element in [b:e) and

p2 points to the first element in [b2:b2+(e-b))

such that !f(*p1,*p2) or p1==e

The mismatch() algorithm looks for the first pair of elements of two sequences that compare unequal and returns iterators to those elements. No end is specified for the second sequence; that is, there is no last2. Instead, it is assumed that there are at least as many elements in the second sequence as in the first, and first2+(last–first) is used as last2. This technique is used throughout the standard library, where pairs of sequences are used for operations on pairs of elements. We could implement mismatch() like this:

Click here to view code image

template<typename In, typename In2, typename Pred = equal_to<Value_type<In>>>
pair<In, In2> mismatch(In first, In last, In2 first2, Pred p ={})
{
     while (first != last && p(*first,*first2)) {
           ++first;
           ++first2;
     }
     return {first,first2};
}
I used the standard function object equal_to (§33.4) and the type function Value_type (§28.2.1).

32.4.6. search()
The search() and search_n() algorithms find one sequence as a subsequence in another:

Searching for Sequences (§iso.25.2.13)

p=search(b,e,b2,e2)

p points to the first *p in [b:e) such that

[p:p+(e2-b2)) equals [b2:e2)

p=search(b,e,b2,e2,f)

p points to the first *p in [b:e) such that

[p:p+(e2-b2)) equals [b2:e2), using f for element comparison

p=search_n(b,e,n,v)

p points to the first element of [b:e) such that

each element of [p:p+n) has the value v

p=search_n(b,e,n,v,f)

p points to the first element of [b:e) such that

for each element *q in [p:p+n)wehave f(*p,v)

The search() algorithm looks for its second sequence as a subsequence of its first. If that second sequence is found, an iterator for the first matching element in the first sequence is returned. As usual, the end of the sequence is used to represent “not found.” For example:

Click here to view code image

string quote {"Why waste time learning, when ignorance is instantaneous?"};

bool in_quote(const string& s)
{
     auto p = search(quote.begin(),quote.end(),s.begin(),s.end());  // find s in quote
     return p!=quote.end();
}

void g()
{
     bool b1 = in_quote("learning");     // b1 = true
     bool b2 = in_quote("lemming");      // b2 = false
}
Thus, search() is a useful algorithm for finding a substring generalized to all sequences.

Use find() or binary_search() (§32.6) to look for just a single element.

32.5. Modifying Sequence Algorithms
The modifying algorithms (also called mutating sequence algorithms) can (and often do) modify elements of their argument sequences.

transform (§iso.25.3.4)

p=transform(b,e,out,f)

Apply *q=f(*p1) to every *p1 in [b:e), writing to

the corresponding *q in [out:out+(e-b)); p=out+(e-b)

p=transform(b,e,b2,out,f)

Apply *q=f(*p1,*p2) to every element in *p1 in [b:e) and

the corresponding *p2 in [b2:b2+(e-b)), writing to

the corresponding *q in [out:out+(e-b)); p=out+(e-b)

Somewhat confusingly, transform() doesn’t necessarily change its input. Instead, it produces an output that is a transformation of its input based on a user-supplied operation. The one-input-sequence version of transform() may be defined like this:

Click here to view code image

template<typename In, typename Out, typename Op>
Out transform(In first, In last, Out res, Op op)
{
     while (first!=last)
           *res++ = op(*first++);
     return res;
}
The output sequence may be the same as the input sequence:

Click here to view code image

void toupper(string& s)   // remove case
{
     transform(s.begin(),s.end(),s.begin(),[](char c) { return toupper(c); });
}
This really transforms the input s.

32.5.1. copy()
The copy() family of algorithms copies elements from one sequence into another. The following sections list versions of copy() combined with other algorithms, such as replace_copy() (§32.5.3).

The copy Family (§iso.25.3.1)

p=copy(b,e,out)

Copy all elements in [b:e)to [out:p); p=out+(e-b)

p=copy_if(b,e,out,f)

Copy elements x in [b:e) for which f(x) to [out:p)

p=copy_n(b,n,out)

Copy the first n elements in [b:b+n)to [out:p); p=out+n

p=copy_backward(b,e,out)

Copy all elements in [b:e)to [out:p),

starting with its last element; p=out-(e-b)

p=move(b,e,out)

Move all elements in [b:e)to [out:p); p=out+(e-b)

p=move_backward(b,e,out)

Move all elements in [b:e)to [out:p),

starting with its last element; p=out+(e-b)

The target of a copy algorithm need not be a container. Anything that can be described by an output iterator (§38.5) will do. For example:

Click here to view code image

void f(list<Club>& lc, ostream& os)
{
     copy(lc.begin(),lc.end(),ostream_iterator<Club>(os));
}
To read a sequence, we need a pair of iterators describing where to begin and where to end. To write, we need only an iterator describing where to write to. However, we must take care not to write beyond the end of the target. One way to ensure that we don’t do this is to use an inserter (§33.2.2) to grow the target as needed. For example:

Click here to view code image

void f(const vector<char>& vs, vector<char>& v)
{
     copy(vs.begin(),vs.end(),v.begin());           // might overwrite end of v
     copy(vs.begin(),vs.end(),back_inserter(v));    // add elements from vs to end of v
}
The input sequence and the output sequence may overlap. We use copy() when the sequences do not overlap or if the end of the output sequence is in the input sequence.

We use copy_if() to copy only elements that fulfill some criterion. For example:

Click here to view code image

void f2(list<int>&ld, int n, ostream& os)
{
     copy_if(ld.begin(),ld.end(),
         ostream_iterator<int>(os),
         [n](int x) { return x>n); });
}
See also remove_copy_if().

32.5.2. unique()
The unique() algorithm removes adjacent duplicate elements from a sequence:

The unique Family (§iso.25.3.9)

p=unique(b,e)

Move elements in [b:e) such that [b:p) has no adjacent duplicates

p=unique(b,e,f)

Move elements in [b:e) such that [b:p) has no adjacent duplicates;

f(*p,*(p+1)) defines “duplicate”

p=unique_copy(b,e,out)

Copy [b:e)to [out:p); don’t copy adjacent duplicates

p=unique_copy(b,e,out,f)

Copy [b:e)to [out:p); don’t copy adjacent duplicates;

f(*p,*(p+1)) defines ‘‘duplicate’’

The unique() and unique_copy() algorithms eliminate adjacent duplicate values. For example:

Click here to view code image

void test(list<string>& ls, vector<string>& vs)
{
     ls.sort();     // list sort (§31.4.2)
     unique_copy(ls.begin(),ls.end(),back_inserter(vs));
}
This copies ls to vs, eliminating duplicates in the process. I used sort() to get equal strings adjacent.

Like other standard algorithms, unique() operates on iterators. It does not know which container these iterators point into, so it cannot modify that container. It can only modify the values of the elements. This implies that unique() does not eliminate duplicates from its input sequence in the way we naively might expect. Therefore, this does not eliminate duplicates in a vector:

Click here to view code image

void bad(vector<string>& vs)        // warning: doesn't do what it appears to do!
{
     sort(vs.begin(),vs.end());     // sort vector
     unique(vs.begin(),vs.end());   // eliminate duplicates (no it doesn't!)
}
Rather, unique() moves unique elements toward the front (head) of a sequence and returns an iterator to the end of the subsequence of unique elements. For example:

Click here to view code image

int main()
{
     string s ="abbcccde";

     auto p = unique(s.begin(),s.end());
     cout << s << ' ' << p–s.begin() << '\n';
}
produces

abcdecde 5
That is, p points to the second c (that is, the first of the duplicates).

Algorithms that might have removed elements (but can’t) generally come in two forms: the “plain” version that reorders elements in a way similar to unique() and a _copy version that produces a new sequence in a way similar to unique_copy().

To eliminate duplicates from a container, we must explicitly shrink it:

Click here to view code image

template<typename C>
void eliminate_duplicates(C& c)
{
     sort(c.begin(),c.end());             // sort
     auto p = unique(c.begin(),c.end());  // compact
     c.erase(p,c.end());                  // shrink
}
I could equivalently have written c.erase(unique(c.begin(),c.end()),c.end()), but I don’t think such terseness improves readability or maintainability.

32.5.3. remove(), reverse(), and replace()
The remove() algorithm “removes” elements to the end of a sequence:

remove (§iso.25.3.8)

p=remove(b,e,v)

Remove elements with value v from [b:e),

such that [b:p) becomes the elements for which !(*q==v)

p=remove_if(b,e,f)

Remove elements *q from [b:e),

such that [b:p) becomes the elements for which !f(*q)

p=remove_copy(b,e,out,v)

Copy elements from [b:e) for which !(*q==v) to [out:p)

p=remove_copy_if(b,e,out,f)

Copy elements from [b:e) for which !f(*q) to [out:p)

reverse(b,e)

Reverse the order of elements in [b:e)

p=reverse_copy(b,e,out)

Copy [b:e) into [out:p) in reverse order

The replace() algorithm assigns new values to selected elements:

replace (§iso.25.3.5)

replace(b,e,v,v2)

Replace elements *p in [b:e) for which *p==v with v2

replace_if(b,e,f,v2)

Replace elements *p in [b:e) for which f(*p) with v2

p=replace_copy(b,e,out,v,v2)

Copy [b:e)to [out:p),

replacing elements *q for which *q==v with v2

p=replace_copy_if(b,e,out,f,v2)

Copy [b:e)to [out:p),

replacing elements *q for which f(*q,v) with v2

These algorithms cannot change the size of their input sequence, so even remove() leaves the size of its input sequence unchanged. Like unique(), it “removes” by moving elements towards the end. For example:

Click here to view code image

string s {"*CamelCase*IsUgly*"};
cout << s << '\n';                                   //*CamelCase*IsUgly*
auto p = remove(s.begin(),s.end(),'*');
copy(s.begin(),p,ostream_iterator<char>{cout});      // CamelCaseIsUgly
cout << s << '\n';                                   // CamelCaseIsUglyly*
32.5.4. rotate(), random_shuffle(), and partition()
The rotate(), random_shuffle(), and partition() algorithms provide systematic ways of moving elements around in a sequence:

rotate() (§iso.25.3.11)

p=rotate(b,m,e)

Left-rotate elements: treat [b:e) as a circle

with the first element right after the last;

move *(b+i) to *(b+(i+(e-m))%(e-b));

note: *b moves to *m; p=b+(e-m)

p=rotate_copy(b,m,e,out)

Copy [b:e) into a rotated sequence [out:p)

The movement of elements done by rotate() (and by the shuffle and partition algorithms) is done using swap().

random_shuffle() (§iso.25.3.12)

random_shuffle(b,e)

Shuffle elements of [b:e), using

the default random number generator

random_shuffle(b,e,f)

Shuffle elements of [b:e), using

the random number generator f

shuffle(b,e,f)

Shuffle elements of [b:e), using

the uniform random number generator f

A shuffle algorithm shuffles its sequence much in the way we would shuffle a pack of cards. That is, after a shuffle, the elements are in a random order, where “random” is defined by the distribution produced by the random number generator.

By default, random_shuffle() shuffles its sequence using a uniform distribution random number generator. That is, it chooses a permutation of the elements of the sequence so that each permutation has the same chances of being chosen. If you want a different distribution or a better random number generator, you can supply one. For a call random_shuffle(b,e,r), the generator is called with the number of elements in the sequence (or a subsequence) as its argument. For example, for a call r(e–b) the generator must return a value in the range [0,e–b). If My_rand is such a generator, we might shuffle a deck of cards like this:

Click here to view code image

void f(deque<Card>& dc, My_rand& r)
{
     random_shuffle(dc.begin(),dc.end(),r);
      //...
}
The partition algorithm separates a sequence into two parts based on a partition criterion:

partition() (§iso.25.3.13)

p=partition(b,e,f)

Place elements for which f(*p1) in [b:p)

and other elements in [p:e)

p=stable_partition(b,e,f)

Place elements for which f(*p1) in [b:p)

and other elements in [p:e);

preserve relative order

pair(p1,p2)=partition_copy(b,e,out1,out2,f)

Copy elements of [b:e) for which f(*p)

into [out1:p1) and elements of [b:e)

for which !f(*p) into [out2:p2)

p=partition_point(b,e,f)

For [b:e) p is the point

such that all_of(b,p,f) and none_of(p,e,f)

is_partitioned(b,e,f)

Does every element of [b:e) for which f(*p)

precede every element for which !f(*p)?

32.5.5. Permutations
The permutation algorithms provide a systematic way of generating all permutations of a sequence.

Permutations (§iso.25.4.9, §iso.25.2.12)

x is true if the next_* operation succeeded, otherwise false

x=next_permutation(b,e)

Make [b:e) the next permutation in lexicographical order

x=next_permutation(b,e,f)

Make [b:e) the next permutation, using f for comparison

x=prev_permutation(b,e)

Make [b:e) the previous permutation in lexicographical order

x=prev_permutation(b,e,f)

Make [b:e) the previous permutation, using f for comparison

is_permutation(b,e,b2)

Is there a permutation of [b2:b2+(e-b)) that compares equal

to [b,e)?

is_permutation(b,e,b2,f)

Is there a permutation of [b2:b2+(e-b)) that compares equal

to [b,e), using f(*p,*q) as the element comparison?

Permutations are used to generate combinations of elements of a sequence. For example, the permutations of the letters abc are acb, bac, bca, cab, and cba.

The next_permutation() algorithm takes a sequence [b:e) and transforms it into the next permutation. The next permutation is found by assuming that the set of all permutations is lexicographically sorted. If such a permutation exists, next_permutation() returns true; otherwise, it transforms the sequence into the smallest permutation, that is, the ascendingly sorted one (abc in the example), and returns false. So, we can generate the permutations of abc like this:

Click here to view code image

vector<char> v {'a','b','c'};
while(next_permutation(v.begin(),v.end()))
     cout << v[0] << v[1] << v[2] << ' ';
cout << '\n';
Similarly, the return value for prev_permutation() is false if [b:e) already contains the first permutation (abc in the example); in that case, it transforms the sequence into the last permutation (cba in the example).

32.5.6. fill()
The fill() family of algorithms provide ways of assigning to and initializing elements of a sequence:

The fill Family (§iso.25.3.6, §iso.25.3.7, §iso.20.6.12)

fill(b,e,v)

Assign v to each element of [b:e)

p=fill_n(b,n,v)

Assign v to each element of [b:b+n); p=b+n

generate(b,e,f)

Assign f() to each element of [b:e)

p=generate_n(b,n,f)

Assign f() to each element of [b:b+n); p=b+n

uninitialized_fill(b,e,v)

Initialize each element in [b:e) with v

p=uninitialized_fill_n(b,n,v)

Initialize each element in [b:b+n) with v; p=b+n

p=uninitialized_copy(b,e,out)

Initialize each element of [out:out+(e-b)); p=out+n

with its corresponding element from [b:e)

p=uninitialized_copy_n(b,n,out)

Initialize each element of [out:out+n)

with its corresponding element from [b:b+n); p=out+n

The fill() algorithm repeatedly assigns the specified value, whereas generate() assigns values obtained by calling its function argument repeatedly. For example, using the random number generator Rand_int from §40.7:

Click here to view code image

int v1[900];
array<int,900> v2;
vector<int> v3;

void f()
{
     fill(begin(v1),end(v1),99);                      // set all elements of v1 to 99
     // set to random values int the range [500:1500]:
     generate(begin(v2),end(v2),Rand_int{500,1500});
     // output 200 random integers in the range [0:100]:
     generate_n(ostream_iterator<int>{cout,"\n"},200,Rand_int{0,100});
     fill_n(back_inserter(v3),20,99);        // add 20 elements with the value 99 to v3
}
The generate() and fill() functions assign rather than initialize. If you need to manipulate raw storage, say, to turn a region of memory into objects of well-defined type and state, you use one of the uninitialized_ versions (presented in <memory>).

Uninitialized sequences should only occur at the lowest level of programming, usually inside the implementation of containers. Elements that are targets of uninitialized_fill() or uninitialized_copy() must be of built-in type or uninitialized. For example:

Click here to view code image

vector<string> vs {"Breugel","El Greco","Delacroix","Constable"};
vector<string> vs2 {"Hals","Goya","Renoir","Turner"};
copy(vs.begin(),vs.end(),vs2.begin());                      // OK
uninitialized_copy(vs.begin(),vs.end(),vs2.begin());        // leaks!
A few more facilities for dealing with uninitialized memory are described in §34.6.

32.5.7. swap()
A swap() algorithm exchanges the values of two objects:

The swap Family (§iso.25.3.3)

swap(x,y)

Exchange the values of x and y

p=swap_ranges(b,e,b2)

swap(v,v2) corresponding elements in [b:e) and [b2,b2+(e-b))

iter_swap(p,q)

swap(*p,*q)

for example:

Click here to view code image

void use(vector<int>& v, int* p)
{
     swap_ranges(v.begin(),v.end(),p);   // exchange values
}
The pointer p had better point to an array with at least v.size() elements.

The swap() algorithm is possibly the simplest and arguably the most crucial algorithm in the standard library. It is used as part of the implementaton of many of the most widely used algorithms. Its implementation is used as an example in §7.7.2 and the standard-library version is presented in §35.5.2.

32.6. Sorting and Searching
Sorting and searching in sorted sequences are fundamental, and the needs of programmers are quite varied. Comparison is by default done using the < operator, and equivalence of values a and b is determined by !(a<b)&&!(b<a) rather than requiring operator ==.

The sort Family (§iso.25.4.1) (continues)

sort(b,e)

Sort [b:e)

sort(b,e,f)

Sort [b:e), using f(*p,*q) as the sorting criterion

In addition to the “plain sort” there are many variants:

The sort Family (continued)(§iso.25.4.1)

stable_sort(b,e)

Sort [b:e) maintaining order of equal elements

stable_sort(b,e,f)

Sort [b:e), using f(*p,*q) as the sorting criterion,

maintaining order of equal elements

partial_sort(b,m,e)

Sort enough of [b:e) to get [b:m) into order;

[m:e) need not be sorted

partial_sort(b,m,e,f)

Sort enough of [b:e) to get [b:m) into order, using

f(*p,*q) as the sorting criterion; [m:e) need not be sorted

p=partial_sort_copy(b,e,b2,e2)

Sort enough of [b:e) to copy the first e2-b2 elements

into [b2:e2);

p is the smaller of e2 and b2+(e-b)

p=partial_sort_copy(b,e,b2,e2,f)

Sort enough of [b:e) to copy the first e2-b2 elements

into [b2:e2), using f for comparison;

p is the smaller of e2 and b2+(e-b)

is_sorted(b,e)

Is [b:e) sorted?

is_sorted(b,e,f)

Is [b:e) sorted, using f for comparison?

p=is_sorted_until(b,e)

p points to the first element in [b:e) that is not in order

p=is_sorted_until(b,e,f)

p points to the first element in [b:e) that is not in order,

using f for comparison

nth_element(b,n,e)

*n is in the position it would be in if [b:e) was sorted;

elements in [b:n) are <= *n and *n <= ele ments in [n:e)

nth_element(b,n,e,f)

*n is in the position it would be in if [b:e) was sorted;

elements in [b:n)x are <= *n and *n <= elements in [n:e),

using f for comparison

The sort() algorithms require random-access iterators (§33.1.2).

Despite its name, is_sorted_until() returns an iterator, rather than a bool.

The standard list (§31.3) does not provide random-access iterators, so lists should be sorted using the specific list operations (§31.4.2) or by copying their elements into a vector, sorting that vector, and then copying the elements back into the list:

Click here to view code image

template<typename List>
void sort_list(List& lst)
{
     vector<Value_type<lst>> v {lst.begin(),lst.end()};    // initialize from lst; use Value_type from §28.2.4
     sort(v);                             // use container sort (§32.2.1)
     copy(v,lst);                       // use container copy
}
The basic sort() is efficient (on average N*log(N)). If a stable sort is required, stable_sort() should be used, that is, an N*log(N)*log(N) algorithm that improves toward N*log(N) when the system has sufficient extra memory. The get_temporary_buffer() function may be used for getting such extra memory (§34.6). The relative order of elements that compare equal is preserved by stable_sort() but not by sort().

Sometimes, only the first elements of a sorted sequence are needed. In that case, it makes sense to sort the sequence only as far as is needed to get the first part in order, that is, a partial sort. The plain partial_sort(b,m,e) algorithms put the elements in the range [b:m) in order. The partial_sort_copy() algorithms produce N elements, where N is the lower of the number of elements in the output sequence and the number of elements in the input sequence. We need to specify both the start and the end of the result sequence because that’s what determines how many elements we need to sort. For example:

Click here to view code image

void f(const vector<Book>& sales)  // find the top ten books
{
     vector<Book> bestsellers(10);
     partial_sort_copy(sales.begin(),sales.end(),
               bestsellers.begin(),bestsellers.end(),
               [](const Book& b1, const Book& b2) { return b1.copies_sold()>b2.copies_sold(); });
     copy(bestsellers.begin(),bestsellers.end(),ostream_iterator<Book>{cout,"\n"});
}
Because the target of partial_sort_copy() must be a random-access iterator, we cannot sort directly to cout.

If the number of elements desired to be sorted by a partial_sort() is small compared to the total number of elements, these algorithms can be significatly faster than a complete sort(). Then, their complexity approaches O(N) compared to sort()’s O(N*log(N)).

The nth_element() algorithm sorts only as far as is necessary to get the Nth element to its proper place with no element comparing less than the Nth element placed after it in the sequence. For example:

Click here to view code image

vector<int> v;
for (int i=0; i<1000; ++i)      //§40.7
for (int i=0; i<1000; ++i)
      v.push_back(gen()); 
constexpr int n = 30;
nth_element(v.begin(), v.begin()+n, v.end());
cout << "nth: " << v[n] << '\n';
for (int i=0; i<n; ++i)
      cout << v[i] << ' ';
This produces:

Click here to view code image

nth: 24
10 8 15 19 21 15 8 7 6 17 21 2 18 8 1 9 3 21 20 18 10 7 3 3 8 11 11 22 22 23
The nth_element() differs from partial_sort() in that the elements before n are not necessarily sorted, just all less than the nth element. Replacing nth_element with partial_sort in that example (and using the same seed for the random number generator to get the same sequence), I got:

Click here to view code image

nth: 24
1 2 3 3 3 6 7 7 8 8 8 8 9 10 10 11 11 15 15 17 18 18 19 20 21 21 21 22 22 23
The nth_element() algorithm is particularly useful for people – such as economists, sociologists, and teachers – who need to look for medians, percentiles, etc.

Sorting C-style strings requires an explicit sorting criterion. The reason is that C-style strings are simply pointers with a set of conventions for their use, so < on pointers compares machine addresses rather than character sequences. For example:

Click here to view code image

vector<string> vs = {"Helsinki","Copenhagen","Oslo","Stockholm"};
vector<const char*> vcs = {"Helsinki","Copenhagen","Oslo","Stockholm"};

void use()
{
     sort(vs);  // I have defined a range version of sort()
     sort(vcs);

     for (auto& x : vs)
           cout << x << ' '
     cout << '\n';
     for (auto& x : vcs)
           cout << x << ' ';
}
This prints:

Copenhagen Helsinki Oslo Stockholm
Helsinki Copenhagen Oslo Stockholm
Naively, we might have expected the same output from both vectors. However, to sort C-style strings by string value rather than by address we need a proper sort predicate. For example:

sort(vcs, [](const char* p, const char* q){ return strcmp(p,q)<0; });
The standard-library function strcmp() is described in §43.4.

Note that I did not have to supply a == to sort C-style strings. To simplify the user interface, the standard library uses !(x<y||y<x) rather than x==y to compare elements (§31.2.2.2).

32.6.1. Binary Search
The binary_search() family of algorithms provide binary searches of ordered (sorted) sequences:

Binary Search (§iso.25.4.3)

p=lower_bound(b,e,v)

p points to the first occurrence of v in [b:e)

p=lower_bound(b,e,v,f)

p points to the first occurrence of v in [b:e),

using f for comparison

p=upper_bound(b,e,v)

p points to the first value larger than v in [b:e)

p=upper_bound(b,e,v,f)

p points to the first value larger than v in [b:e),

using f for comparison

binary_search(b,e,v)

Is v in the sorted sequence [b:e)?

binary_search(b,e,v,f)

Is v in the sorted sequence [b:e), using f for comparison?

pair(p1,p2)=equal_range(b,e,v)

[p1,p2) is the subsequence of [b:e) with the value v;

basically, a binary search for v

pair(p1,p2)=equal_range(b,e,v,f)

[p1,p2) is the subsequence of [b:e) with the value v,

using f for comparison; basically, a binary search for v

A sequential search such as find() (§32.4) is terribly inefficient for large sequences, but it is about the best we can do without sorting or hashing (§31.4.3.2). Once a sequence is sorted, however, we can use a binary search to determine whether a value is in a sequence. For example:

Click here to view code image

void f(vector<int>& c)
{
     if (binary_search(c.begin(),c.end(),7)){   // is 7 in c?
            //...
     }
      //...
}
A binary_search() returns a bool indicating whether a value is present. As with find(), we often also want to know where the elements with that value are in that sequence. However, there can be many elements with a given value in a sequence, and we often need to find either the first or all such elements. Consequently, algorithms are provided for finding a range of equal elements, equal_range(), and algorithms for finding the lower_bound() and upper_bound() of that range. These algorithms correspond to the operations on multimaps (§31.4.3). We can think of lower_bound() as a fast find() and find_if() for sorted sequences. For example:

Click here to view code image

void g(vector<int>& c)
{
     auto p = find(c.begin(),c.end(),7);          // probably slow: O(N); c needn't be sorted
     auto q = lower_bound(c.begin(),c.end(),7);   // probably fast: O(log(N)); c must be sorted
      //...
}
If lower_bound(first,last,k) doesn’t find k, it returns an iterator to the first element with a key greater than k, or last if no such greater element exists. This way of reporting failure is also used by upper_bound() and equal_range(). This means that we can use these algorithms to determine where to insert a new element into a sorted sequence so that the sequence remains sorted: just insert before the second of the returned pair.

Curiously enough, the binary search algorithms do not require random-access iterators: a forward iterator suffices.

32.6.2. merge()
The merge algorithms combine two ordered (sorted) sequences into one:

The merge Family (§iso.25.4.4)

p=merge(b,e,b2,e2,out)

Merge two sorted sequences [b2:e2) and [b:e) into [out:p)

p=merge(b,e,b2,e2,out,f)

Merge two sorted sequences [b2:e2) and [b:e)

into [out,p), using f as the comparison

inplace_merge(b,m,e)

Merge two sorted subsequences [b:m) and [m:e)

into a sorted sequence [b:e)

inplace_merge(b,m,e,f)

Merge two sorted subsequences [b:m) and [m:e)

into a sorted sequence [b:e), using f as the comparison

The merge() algorithm can take different kinds of sequences and elements of different types. For example:

Click here to view code image

vector<int> v {3,1,4,2};
list<double> lst {0.5,1.5,2,2.5};     // lst is in order

sort(v.begin(),v.end());              // put v in order

vector<double> v2;
merge(v.begin(),v.end(),lst.begin(),lst.end(),back_inserter(v2));     // merge v and lst into v2
for (double x : v2)
      cout << x << ", ";
cout << '\n';
For inserters, see §33.2.2. The output is:

0.5, 1, 1.5, 2, 2, 2.5, 3, 4,
32.6.3. Set Algorithms
These algorithms treat a sequence as a set of elements and provide the basic set operations. The input sequences are supposed to be sorted and the output sequences are also sorted.

Set Algorithms (§iso.25.4.5)

includes(b,e,b2,e2)

Are all elements of [b2:e2) also in [b:e)?

includes(b,e,b2,e2,f)

Are all elements of [b2:e2) also in [b:e),

using f for comparison?

p=set_union(b,e,b2,e2,out)

Construct a sorted sequence [out:p)

of elements that are in either [b:e) or [b2:e2)

p=set_union(b,e,b2,e2,out,f)

Construct a sorted sequence [out:p)

of elements that are in either [b:e) or [b2:e2),

using f for comparison

p=set_intersection(b,e,b2,e2,out)

Construct a sorted sequence [out:p)

of elements that are in both [b:e) and [b2:e2)

p=set_intersection(b,e,b2,e2,out,f)

Construct a sorted sequence [out:p)

of elements that are in both [b:e) and [b2:e2),

using f for comparison

p=set_difference(b,e,b2,e2,out)

Construct a sorted sequence [out:p)

of elements that are in [b:e) but not in [b2:e2)

p=set_difference(b,e,b2,e2,out,f)

Construct a sorted sequence [out:p)

of elements that are in [b:e) but not in [b2:e2),

using f for comparison

p=set_symmetric_difference(b,e,b2,e2,out)

Construct a sorted sequence [out:p)

of elements that are in [b:e)or [b2:e2)

but not in both

p=set_symmetric_difference(b,e,b2,e2,out,f)

Construct a sorted sequence [out:p)

of elements that are in [b:e)or [b2:e2)

but not in both, using f for comparison

For example:

Click here to view code image

string s1 = "qwertyasdfgzxcvb";
string s2 = "poiuyasdfg/.,mnb";
sort(s1.begin(),s1.end());                // the set algorithms require sorted sequences
sort(s2.begin(),s2.end());

string s3(s1.size()+s2.size(),'*');       // set aside enough space for the largest possible result
cout << s3 << '\n';
auto up = set_union(s1.begin(),s1.end(),s2.begin(),s2.end(),s3.begin());
cout << s3 << '\n';
for (auto p = s3.begin(); p!=up; ++p) cout << *p;
cout << '\n';

s3.assign(s1.size()+s2.size(),'+');
up = set_difference(s1.begin(),s1.end(),s2.begin(),s2.end(),s3.begin());
cout << s3 << '\n';
for (auto p = s3.begin(); p!=up; ++p) cout << *p;
cout << '\n';
This little test produces:

Click here to view code image

*******************************
,./abcdefgimnopqrstuvxyz*******
,./abcdefgimnopqrstuvxyz
ceqrtvwxz++++++++++++++++++++++
ceqrtvwxz
32.6.4. Heaps
A heap is a compact data structure that keeps the element with the highest value first. Think of a heap as a representation of a binary tree. The heap algorithms allow a programmer to treat a random-access sequence as a heap:

Heap Operations (§iso.25.4.6)

make_heap(b,e)

Make [b:e) ready to be used as a heap

make_heap(b,e,f)

Make [b:e) ready to be used as a heap, using f for comparison

push_heap(b,e)

Add *(e-1) to the heap [b:e-1); afterward [b:e) is a heap

push_heap(b,e,f)

Add an element to the heap [b:e-1), using f for comparison

pop_heap(b,e)

Remove *(e-1) from the heap [b:e); afterward, [b:e-1) is a heap

pop_heap(b,e,f)

Remove element from the heap [b:e), using f for comparison

sort_heap(b,e)

Sort the heap [b:e)

sort_heap(b,e,f)

Sort the heap [b:e), using f for comparison

is_heap(b,e)

Is [b:e) a heap?

is_heap(b,e,f)

Is [b:e) a heap, using f for comparison?

p=is_heap_until(b,e)

p is the largest p such that [b:p) is a heap

p=is_heap_until(b,e,f)

p is the largest p such that [b:p) is a heap, using f for comparison

Think of the end, e, of a heap [b:e) as a pointer, which it decremented by pop_heap() and incremented by push_heap(). The largest element is extracted by reading through b (e.g., x=*b) and then doing a pop_heap(). A new element is inserted by writing through e (e.g., *e=x) and then doing a push_heap(). For example:

Click here to view code image

string s = "herewego";             // herewego
make_heap(s.begin(),s.end());       // worheege
pop_heap(s.begin(),s.end());        // rogheeew
pop_heap(s.begin(),s.end()–1);      // ohgeeerw
pop_heap(s.begin(),s.end()–2);      // hegeeorw

*(s.end()–3)='f';
push_heap(s.begin(),s.end()–2);     // hegeefrw
*(s.end()–2)='x';
push_heap(s.begin(),s.end()–1);     // xeheefge
*(s.end()–1)='y';
push_heap(s.begin(),s.end());       // yxheefge
sort_heap(s.begin(),s.end());       // eeefghxy
reverse(s.begin(),s.end());         // yxhgfeee
The way to understand the changes to s is that a user reads only s[0] and writes only s[x] where x is the index of the current end of the heap. The heap removes an element (always s[0]) by swapping it with s[x].

The point of a heap is to provide fast addition of elements and fast access to the element with the highest value. The main use of heaps is to implement priority queues.

32.6.5. lexicographical_compare()
A lexicographical compare is the rule we use to order words in dictionaries.

Lexicographical Compare (§iso.25.4.8)

lexicographical_compare(b,e,b2,e2)

Is [b:e)<[b2:e2)?

lexicographical_compare(b,e,b2,e2,f)

Is [b:e)<[b2:e2), using f for element comparison?

We might implement lexicographical_compare(b,e,b2,e2) like this:

Click here to view code image

template<typename In, typename In2>
bool lexicographical_compare(In first, In last, In2 first2, In2 last2)
{
     for (; first!=last && first2!=last2; ++first,++first2) {
            if (*first<*first2)
                   return true;    //[first:last)<[first2:last2)
            if (*first2<*first)
                   return false;   //[first2:last2)<[first:last)
     }
     return first==last && first2!=last2;  //[first:last)<[first2:last2) if [first:last) is shorter
}
That is, a string compares as a sequence of characters. For example:

Click here to view code image

string n1 {"10000"};
string n2 {"999"};

bool b1 = lexicographical_compare(n1.begin(),n1.end(),n2.begin(),n2.end());     // b1 == true

n1 = "Zebra";
n2 = "Aardvark";
bool b2 = lexicographical_compare(n1.begin(),n1.end(),n2.begin(),n2.end());     // b2 == false
32.7. Min and Max
Value comparisons are useful in many contexts:

The min and max Family (§iso.25.4.7)

x=min(a,b)

x is the smaller of a and b

x=min(a,b,f)

x is the smaller of a and b, using f for comparison

x=min({elem})

x is the smallest element in {elem}

x=min({elem},f)

x is the smallest element in {elem},

using f for the element comparison

x=max(a,b)

x is the larger of a and b

x=max(a,b,f)

x is the larger of a and b, using f for comparison

x=max({elem})

x is the largest element in {elem}

x=max({elem},f)

x is the largest element in {elem},

using f for the element comparison

pair(x,y)=minmax(a,b)

x is min(a,b) and y is max(a,b)

pair(x,y)=minmax(a,b,f)

x is min(a,b,f) and y is max(a,b,f)

pair(x,y)=minmax({elem})

x is min({elem}) and y is max({elem})

pair(x,y)=minmax({elem},f)

x is min({elem},f) and y is max({elem},f)

p=min_element(b,e)

p points to the smallest element of [b:e)or e

p=min_element(b,e,f)

p points to the smallest element of [b:e)or e,

 

using f for the element comparison

p=max_element(b,e)

p points to the largest element of [b:e)or e

p=max_element(b,e,f)

p points to the largest element of [b:e)or e, using f for the element comparison

pair(x,y)=minmax_element(b,e)

x is min_element(b,e) and y is max_element(b,e)

pair(x,y)=minmax_element(b,e,f)

x is min_element(b,e,f) and y is max_element(b,e,f)

If we compare two lvalues, the result is a reference to the result; otherwise, an rvalue is returned. Unfortunately, the versions that take lvalues take const lvalues, so you can never modify the result of one of these functions. For example:

Click here to view code image

int x = 7;
int y = 9;

++min(x,y);     // error: the result of min(x,y) is a const int&
++min({x,y});   // error: the result of min({x,y}) is an rvalue (an initializer_list is immutable)
The _element functions return iterators and the minmax function returns pairs, so we can write:

Click here to view code image

string s = "Large_Hadron_Collider";
auto p = minmax_element(s.begin(),s.end(),
                      [](char c1,char c2) { return toupper(c1)<toupper(c2); });
cout << "min==" << *(p.first) << ' ' << "max==" << *(p.second) << '\n';
With the ASCII character set on my machine, this little test produces:

min==a max==_
32.8. Advice
[1] An STL algorithm operates on one or more sequences; §32.2.

[2] An input sequence is half-open and defined by a pair of iterators; §32.2.

[3] When searching, an algorithm usually returns the end of the input sequence to indicate “not found”; §32.2.

[4] Prefer a carefully specified algorithm to “random code”; §32.2.

[5] When writing a loop, consider whether it could be expressed as a general algorithm; §32.2.

[6] Make sure that a pair of iterator arguments really do specify a sequence; §32.2.

[7] When the pair-of-iterators style becomes tedious, introduce a container/range algorithm; §32.2.

[8] Use predicates and other function objects to give standard algorithms a wider range of meanings; §32.3.

[9] A predicate must not modify its argument; §32.3.

[10] The default == and < on pointers are rarely adequate for standard algorithms; §32.3.

[11] Know the complexity of the algorithms you use, but remember that a complexity measure is only a rough guide to performance; §32.3.1.

[12] Use for_each() and transform() only when there is no more-specific algorithm for a task; §32.4.1.

[13] Algorithms do not directly add or subtract elements from their argument sequences; §32.5.2, §32.5.3.

[14] If you have to deal with uninitialized objects, consider the uninitialized_* algorithms; §32.5.6.

[15] An STL algorithm uses an equality comparison generated from its ordering comparison, rather than ==; §32.6.

[16] Note that sorting and searching C-style strings requires the user to supply a string comparison operation; §32.6.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


32. STL Algorithms
33. STL Iterators
34. Memory and Resources
47h 26m remaining
33. STL Iterators
The reason that STL containers and algorithms work so well together is that they know nothing of each other.

– Alex Stepanov

• Introduction

• Iterator Model

Iterator Categories; Iterator Traits; Iterator Operations

• Iterator Adaptors

Reverse Iterators; Insert Iterators; Move Iterator

• Range Access Functions

• Function Objects

• Function Adaptors

bind(); mem_fn(); function

• Advice

33.1. Introduction
This chapter presents the STL iterators and utilities, notably standard-library function objects. The STL consists of the iterator, container, algorithm, and function object parts of the standard library. The rest of the STL is presented in Chapter 31 and Chapter 32.

Iterators are the glue that ties standard-library algorithms to their data. Conversely, you can say that iterators are the mechanism used to minimize an algorithm’s dependence on the data structures on which it operates:



33.1.1. Iterator Model
An iterator is akin to a pointer in that it provides operations for indirect access (e.g., * for dereferencing) and for moving to point to a new element (e.g., ++ for moving to the next element). A sequence is defined by a pair of iterators defining a half-open range [begin:end):



That is, begin points to the first element of the sequence, and end points to the one-beyond-the-last element of the sequence. Never read from or write to *end. Note that the empty sequence has begin==end; that is, [p:p] is the empty sequence for any iterator p.

To read a sequence, an algorithm usually takes a pair of iterators (b,e)representing the halfopen sequence [b:e), and iterates using ++ until the end is reached:

Click here to view code image

while (b!=e) {        // use != rather than <
    // do something
   ++b;    // go to next element
}
The reason to use != rather than < for testing whether we have reached the end is partially because that is the more precise statement of what we are testing for and partially because only random-access iterators support <.

Algorithms that search for something in a sequence usually return the end of the sequence to indicate “not found”; for example:

Click here to view code image

auto p = find(v.begin(),v.end(),x);       // look for x in v

if (p!=v.end()) {
     // x found at p
}
else {
    // x not found in [v.begin():v.end())
}
Algorithms that write to a sequence often are given only an iterator to its first element. In that case, it is the programmer’s responsibility not to write beyond the end of that sequence. For example:

Click here to view code image

template<typename Iter>
void forward(Iter p, int n)
{
    while (n>0)
           *p++ = ––n;
}

void user()
{
     vector<int> v(10);
     forward(v.begin(),v.size());     // OK
     forward(v.begin(),1000);         // big trouble
}
Some standard-library implementations range check – that is, throw an exception for that last call of forward() – but you can’t rely on that for portable code: many implementations don’t check. For a simple and safe alternative use an insert iterator (§33.2.2).

33.1.2. Iterator Categories
The standard library provides five kinds of iterators (five iterator categories):

• Input iterator : We can iterate forward using ++ and read each element using *. We can compare input iterators using == and !=. This is the kind of iterator that istream offers; see §38.5.

• Output iterator: We can iterate forward using ++ and write an element once only using *. This is the kind of iterator that ostream offers; see §38.5.

• Forward iterator: We can iterate forward repeatedly using ++ and read and write (unless the elements are const) elements repeatedly using *. If a forward iterator points to a class object, we can use –> to refer to a member. We can compare forward iterators using == and !=. This is the kind of iterator forward_list offers (§31.4).

• Bidirectional iterator: We can iterate forward (using ++) and backward (using ––) and read and write (unless the elements are const) elements repeatedly using *. If a bidirectional iterator points to a class object, we can use –> to refer to a member. We can compare bidirectional iterators using == and !=. This is the kind of iterator that list, map, and set offer (§31.4).

• Random-access iterator: We can iterate forward (using ++ or +=) and backward (using –– or –=) and read and write (unless the elements are const) elements repeatedly using * or []. If a random-access iterator points to a class object, we can use –> to refer to a member. We can subscript a random-access iterator using [], add an integer using +, and subtract an integer using –. We can find the distance between two random-access iterators to the same sequence by subtracting one from the other. We can compare random-access iterators using ==, !=, <, <=, >, and >=. This is the kind of iterator that vector offers (§31.4).

Logically, these iterators are organized in a hierarchy (§iso.24.2):



The iterator categories are concepts (§24.3) rather than classes, so this hierarchy is not a class hierarchy implemented using derivation. If you need to do something advanced with iterator categories, use iterator_traits (directly or indirectly).

33.1.3. Iterator Traits
In <iterator>, the standard library provides a set of type functions that allow us to write code specialized for specific properties of an iterator:

Iterator Traits (§iso.24.4.1)

iterator_traits<Iter>

Traits type for a non-pointer Iter

iterator_traits<T*>

Traits type for a pointer T*

iterator<Cat,T,Dist,Ptr,Re>

Simple class defining the basic iterator member types

input_iterator_tag

Category for input iterators

output_iterator_tag

Category for output iterators

forward_iterator_tag

Category for forward iterators;

derived from input_iterator_tag;

provided for forward_list, unordered_set,

unordered_multiset, unordered_map, and unordered_multimap

bidirectional_iterator_tag

Category for bidirectional iterators;

derived from forward_iterator_tag;

provided for list, set, multiset, map, multimap

random_access_iterator_tag

Category for random-access iterators;

derived from bidirectional_iterator_tag;

provided for vector, deque, array, built-in arrays, and string

The iterator tags are types used to select among algorithms based on the type of an iterator. For example, a random-access iterator can go directly to an element:

Click here to view code image

template<typename Iter>
void advance_helper(Iter& p, int n, random_access_iterator_tag)
{
     p+=n;
}
On the other hand, a forward iterator must get to the nth element by moving one step at a time (e.g., following links on a list):

Click here to view code image

template<typename Iter>
void advance_helper(Iter& p, int n, bidirectional_iterator_tag)
{
     if (0<n)
           while (n––) ++p;
     else if (n<0)
           while (n++) ––p;
}
Given these helpers, advance() can consistently use the optimal algorithm:

Click here to view code image

template<typename Iter>
void advance(Iter& p, int n)   // use the optimal algorithm
{
     advance_helper(p,n,typename iterator_traits<Iter>::iterator_category{});
}
Typically, advance() and/or advance_helper() will be inlined to ensure that no run-time overhead is introduced by this tag dispatch technique. Variants of this technique are pervasive in the STL.

The key properties of an iterator are described by the aliases in iterator_traits:

Click here to view code image

template<typename Iter>
struct iterator_traits {
     using value_type = typename Iter::value_type;
     using difference_type = typename Iter::difference_type;
     using pointer = typename Iter::pointer;                      // pointer type
     using reference = typename Iter::reference;                  // reference type
     using iterator_category = typename Iter::iterator_category;  //(tag)
};
For an iterator that does not have these member types (e.g., an int*), we provide a specialization of iterator_traits:

Click here to view code image

template<typename T>
struct iterator_traits<T*>{               // specialization for pointers
     using difference_type = ptrdiff_t;
     using value_type = T;
     using pointer = T*;
     using reference = T&;
     using iterator_category = random_access_iterator_tag;
};
We cannot in general say:

Click here to view code image

template<typename Iter>
typename Iter::value_type read(Iter p, int n)     // not general
{
      //... do some checking ...
     return p[n];
{
This is an error waiting to happen. Calling this read() with a pointer argument would be an error. The compiler would catch it, but the error messages might be voluminous and obscure. Instead, we can write:

Click here to view code image

template<typename Iter>
typename iterator_traits<Iter>::value_type read(Iter p, int n)     // more general
{
      //... do some checking ...
     return p[n];
{
The idea is that to find a property of an iterator, you look in its iterator_traits (§28.2.4), rather than at the iterator itself. To avoid directly referring to the iterator_traits, which after all is just an implementation detail, we can define an alias. For example:

Click here to view code image

template<typename Iter>
using Category = typename std::iterator_traits<Iter>::iterator_category;

template<typename Iter>
using Difference_type = typename std::iterator_traits<Iter>::difference_type;
So, if we want to know the type of the difference between two iterators (pointing to the same sequence), we have some choices:

Click here to view code image

template<typename Iter>
void f(Iter p, Iter q)
{
     Iter::difference_type d1 = distance(p,q);           // syntax error: "typename" missing

     typename Iter::difference_type d2 = distance(p,q);  // doesn't work for pointers, etc.

     typename iterator_traits<Iter>::difference_type d3 = distance(p,q);          // OK, but ugly
     Difference_type<Iter> d4 = distance(p,q);                                    // OK, much better

     auto d5 = distance(p,q);       // OK, if you don't need to mention the type explicitly
      //...
}
I recommend the last two alternatives.

The iterator template simply bundles the key properties of an iterator into a struct for the convenience of iterator implementers and provides a few defaults:

Click here to view code image

template<typename Cat, typename T, typename Dist = ptrdiff_t, typename Ptr = T*, typename Ref = T&>
struct iterator {
     using value_type = T;
     using difference_type = Dist ;    // type used by distance()
     using pointer = Ptr;              // pointer type
     using reference = Ref;            // reference type
     using iterator_category = Cat;    // category (tag)
};
33.1.4. Iterator Operations
Depending on its category (§33.1.2), an iterator provides some or all of these operations:

Iterator Operations (§iso.24.2.2)

++p

Pre-increment (advance one element): make p refer to the next element or to the one-beyond-the-last element;

the resulting value is the incremented value

p++

Post-increment (advance one element): make p refer to the next element

or to the one-beyond-the-last element;

the resulting value is p’s value before the increment

*p

Access (dereference): *p refers to the element pointed to by p

--p

Pre-decrement (go back one element): make p point to the previous element;

the resulting value is the decremented value

p--

Post-decrement (go back one element): make p point to the previous element;

the resulting value is p’s value before the decrement

p[n]

Access (subscripting): p[n] refers to the element pointed to by p+n;

equivalent to *(p+n)

p->m

Access (member access): equivalent to (*p).m

p==q

Equality: Do p and q point to the same element or do both

point to the one-beyond-the-last element?

p!=q

Inequality: !(p==q)

p<q

Does p point to an element before the one q points to?

p<=q

p<q || p==q

p>q

Does p point to an element after the one q points to?

p>=q

p>q || p==q

p+=n

Advance n: make p point to the nth element after the one to which it points

p-=n

Advance -n: make p point to the nth element before the one to which it points

q=p+n

q points to the nth element after the one p points to

q=p-n

q points to the nth element before the one p points to

A ++p returns a reference to p, whereas p++ must return a copy of p holding the old value. Thus, for more complicated iterators, ++p is likely to be more efficient than p++.

The following operations work for every iterator for which they can be implemented, but they may work more efficiently for random-access iterators (see §33.1.2):

Iterator Operations (§iso.24.4.4)

advance(p,n)

Like p+=n; p must be at least an input iterator

n=distance(p,q)

Like n=q-p; p must be at least an input iterator

q=next(p,n)

Like q=p+n; p must be at least a forward iterator

q=next(p)

q=next(p,1)

q=prev(p,n)

Like q=p-n; p must be at least a bidirectional iterator

q=prev(p)

q=prev(p,1)

In each case, if p is not a random-access iterator, the algorithm will take n steps.

33.2. Iterator Adaptors
In <iterator>, the standard library provides adaptors to generate useful related iterator types from a given iterator type:

Iterator Adaptors

reverse_iterator

Iterate backward

§33.2.1

back_insert_iterator

Insert at end

§33.2.2

front_insert_iterator

Insert at beginning

§33.2.2

insert_iterator

Insert anywhere

§33.2.2

move_iterator

Move rather than copy

§33.2.3

raw_storage_iterator

Write to uninitialized storage

§34.6.2.

Iterators for iostreams are described in §38.5.

33.2.1. Reverse Iterator
Using an iterator we can traverse a sequence [b:e) from b to e. If the sequence allows bidirectional access, we can also traverse the sequence in reverse order, from e to b. An iterator that does that is called a reverse_iterator. A reverse_iterator iterates from the end of the sequence defined by its underlying iterator to the beginning of that sequence. To get a half-open sequence, we must consider b–1 as one past the end and e–1 as the start of the sequence: [e–1, b–1). Thus, the fundamental relation between a reverse iterator and its corresponding iterator is &*(reverse_iterator(p))==&*(p–1). In particular, if v is a vector, v.rbegin() points to its last element, v[v.size()–1]. Consider:



This sequence can be viewed like this using a reverse_iterator:



The definition of reverse_iterator looks something like this:

Click here to view code image

template<typename Iter>
class reverse_iterator
     : public iterator<Iterator_category<Iter>,
                      Value_type<Iter>,
                      Difference_type<Iter>,
                      Pointer<Iter>,
                      Reference<Iter>> {
public:
     using iterator_type = Iter;

     reverse_iterator(): current{} { }
     explicit reverse_iterator(Iter p): current{p} { }
     template<typename Iter2>
         reverse_iterator(const reverse_iterator<Iter2>& p) :current(p.base()) { }

     Iter base() const { return current; }  // current iterator value

     reference operator*() const { tmp = current; return *––tmp; }
     pointer operator–>() const;
     reference operator[](difference_type n) const;

     reverse_iterator& operator++() { ––current; return *this; }      // note: not ++
     reverse_iterator operator++(int) { reverse_iterator t = current; ––current; return t; }
     reverse_iterator& operator––() { ++current; return *this; }      // note: not ––
     reverse_iterator operator––(int) { reverse_iterator t = current; ++current; return t; }

     reverse_iterator operator+(difference_type n) const;
     reverse_iterator& operator+=(difference_type n);
     reverse_iterator operator–(difference_type n) const;
     reverse_iterator& operator–=(difference_type n);
      //...
protected:
     Iter current;    // current points to the element after the one *this refers to
private:
      //...
     Iter tmp;        // for temporaries that need to outlive a function scope
};
A reverse_iterator<Iter> has the same member types and operations as Iter. In particular, if Iter is a random-access operator, its reverse_iterator<Iter> has [], +, and <. For example:

Click here to view code image

void f(vector<int>& v, list<char>& lst)
{
     v.rbegin()[3] = 7;               // OK: random-access iterator
     lst.rbegin()[3] = '4';           // error: bidirectional iterator doesn't support []
     *(next(lst.rbegin(),3)) = '4';   // OK!
}
I use next() to move the iterator because (like []) + wouldn’t work for a bidirectional iterator, such as list<char>::iterator.

Reverse iterators allow us to use algorithms in a way that views a sequence in the reverse order. For example, to find the last occurrence of an element in a sequence, we can apply find() to its reverse sequence:

auto ri = find(v.rbegin(),v.rend(),val);     // last occurrence
Note that C::reverse_iterator is not the same type as C::iterator. So, if I wanted to write a find_last() algorithm using a reverse sequence, I would have to decide which type of iterator to return:

Click here to view code image

template<typename C, typename Val>
auto find_last(C& c, Val v) –> decltype(c.begin())     // use C's iterator in the interface
{
     auto ri = find(c.rbegin(),c.rend(),v);
     if (ri == c.rend()) return c.end();               // use c.end() to indicate "not found"
     return prev(ri.base());
}
For a reverse_iterator, ri.base() returns an iterator pointing one beyond the position pointed to by ri. So, to get an iterator pointing to the same element as the reverse iterator ri, I have to return ri.base()–1. However, my container may be a list that does not support – for its iterators, so I use prev() instead.

A reverse iterator is a perfectly ordinary iterator, so I could write the loop explicitly:

Click here to view code image

template<typename C, typename Val>
auto find_last(C& c, Val v) –> decltype(c.begin())
{
     for (auto p = c.rbegin(); p!=c.rend(); ++p)     // view sequence in reverse order
           if (*p==v) return ––p.base();
     return c.end();                                 // use c.end() to indicate "not found"
}
The equivalent code searching backward using a (bidirectional) iterator is:

Click here to view code image

template<typename C, typename Val>
auto find_last(C& c, Val v) –> decltype(c.begin())
{
     for (auto p = c.end(); p!=c.begin(); )     // search backward from end
           if (*––p==v) return p;
     return c.end();                            // use c.end() to indicate "not found"
}
As for the earlier definitions of find_last(), this version requires at least a bidirectional iterator.

33.2.2. Insert Iterators
Producing output through an iterator into a container implies that elements following the one pointed to by the iterator can be overwritten. This implies the possibility of overflow and consequent memory corruption. For example:

Click here to view code image

void f(vector<int>& vi)
{
     fill_n(vi.begin(),200,7);      // assign 7 to vi[0]..[199]
}
If vi has fewer than 200 elements, we are in trouble.

In <iterator>, the standard library provides a solution in the form of an inserter: when written to, an inserter inserts a new element into a sequence rather than overwriting an existing element. For example:

Click here to view code image

void g(vector<int>& vi)
{
     fill_n(back_inserter(vi),200,7);      // add 200 7s to the end of vi
}
When writing to an element through an insert iterator, the iterator inserts its value rather than overwriting the element pointed to. So, a container grows by one element each time a value is written to it through an insert iterator. Inserters are as simple and efficient as they are useful.

There are three insert iterators:

• insert_iterator inserts before the element pointed to using insert().

• front_insert_iterator inserts before the first element of a sequence using push_front().

• back_insert_iterator inserts after the last element of the sequence using push_back().

An inserter is usually constructed by a call to a helper function:

Inserter Construction Functions (§iso.24.5.2)

ii=inserter(c,p)

ii is an insert_iterator pointing to p in container c

ii=back_inserter(c)

ii is a back_insert_iterator pointing to back() in container c

ii=front_inserter(c)

ii is a front_insert_iterator pointing to front() in container c

The iterator passed to inserter() must be an iterator into the container. For a sequence container, that implies that it must be a bidirectional iterator (so that you can insert before it). For example, you can’t use inserter() to make an iterator to insert into a forward_list. For an associative container, where that iterator is only used as a hint for where to insert, a forward iterator (e.g., as provided by an unordered_set) can be acceptable.

An inserter is an output iterator:

insert_iterator<C> Operations (§iso.24.5.2) (continues)

insert_iterator p {c,q};

Inserter for container c pointing to *q; q must point into c

insert_iterator p {q};

Copy constructor: p is a copy of q

p=q

Copy assignment: p is a copy of q

p=move(q)

Move assignment: p points to what q pointed to

insert_iterator<C> Operations (continued) (§iso.24.5.2)

++p

do nothing (exists for compatibility with other iterators)

p++

do nothing (exists for compatibility with other iterators)

*p=x

Insert x before p

The front_insert_iterator and back_insert_iterator differ in that their constructors don’t require an iterator. For example:

vector<string> v;
back_inser t_iterator<vector<string>> p {v};
You cannot read through an inserter.

33.2.3. Move Iterator
A move iterator is an iterator where reading from the pointed-to element moves rather than copies. We usually make a move iterator from another iterator using a helper function:

Move Iterator Construction Function

mp=make_move_iterator(p)

mp is a move_iterator pointing to the same element as p;

p must be an input iterator

A move iterator has the same operations as the iterator from which it is made. For example, we can do ––p if the move iterator p was made from a bidirectional iterator. A move iterator’s operator*() simply returns an rvalue reference (§7.7.2) to the element pointed to: std::move(q). For example:

Click here to view code image

vector<string> read_strings(istream&);
auto vs = read_strings(cin);                // get some strings

vector<string> vs2;
copy(vs.begin(),vs.end(),back_inserter(vs2));                // copy str ings from vs into vs2

vector<string> vs3;
copy(make_move_iterator(vs2.begin()),make_move_iterator(vs2.end()),back_inserter(vs3));     // move
The make_move_iterator() is basically what the move() algorithm (§32.5.1) uses internally.

33.3. Range Access Functions
In <iterator>, the standard library provides nonmember begin() and end() functions for containers:

begin() and end() (§iso.24.6.5)

p=begin(c)

p is an iterator for the first element of c; c is a built-in array or has c.begin()

p=end(c)

p is an iterator for the one-past-the-end of c; c is a built-in array or has c.end()

These functions are very simple:

Click here to view code image

template<typename C>
    auto begin(C& c) –> decltype(c.begin());
template<typename C>
    auto begin(const C& c) –> decltype(c.begin());
template<typename C>
    auto end(C& c) –> decltype(c.end());
template<typename C>
    auto end(const C& c) –> decltype(c.end());

template<typename T, size_t N>             // for built-in arrays
    auto begin(T (&array)[N]) –> T*;
template<typename T, size_t N>
    auto end(T (&array)[N]) –> T*;
These functions are used by the range-for-statement (§9.5.1) but can of course also be used directly by users. For example:

Click here to view code image

template<typename Cont>
void print(Cont& c)
{
     for (auto p=begin(c); p!=end(c); ++p)
          cout << *p << '\n';
}

void f()
{
     vector<int> v {1,2,3,4,5};
     print(v);

     int a[] {1,2,3,4,5};
     print(a);
}
Had I said c.begin() and c.end(), the call print(a) would have failed.

A user-defined container with member begin() and end() automatically gets nonmember versions when <iterator> is #included. To provide nonmember begin() and end() for a container, My_container, that doesn’t have them, I have to write something like:

Click here to view code image

template<typename T>
Iterator<My_container<T>> begin(My_container<T>& c)
{
     return Iterator<My_container<T>>{&c[0]};              // iterator to the first element
}

template<typename T>
Iterator<My_container<T>> end(My_container<T>& c)
{
     return Iterator<My_container<T>>{&c[0]+c.size()};     // iterator to the one-past-the-last element
}
Here, I assume that passing the address of the first element is a way to create an iterator to the first element of My_container and that My_container has a size().

33.4. Function Objects
Many of the standard algorithms take function objects (or functions) as arguments to control the way they work. Common uses are comparison criteria, predicates (functions returning bool), and arithmetic operations. In <functional>, the standard library supplies a few common function objects:

Predicates (§iso.20.8.5, §iso.20.8.6, §iso.20.8.7)

p=equal_to<T>{}

p(x,y) means x==y when x and y are of type T

p=not_equal_to<T>{}

p(x,y) means x!=y when x and y are of type T

p=greater<T>{}

p(x,y) means x>y when x and y are of type T

p=less<T>{}

p(x,y) means x<y when x and y are of type T

p=greater_equal<T>{}

p(x,y) means x>=y when x and y are of type T

p=less_equal<T>{}

p(x,y) means x<=y when x and y are of type T

p=logical_and<T>{}

p(x,y) means x&&y when x and y are of type T

p=logical_or<T>{}

p(x,y) means x||y when x and y are of type T

p=logical_not<T>{}

p(x) means !x when x is of type T

p=bit_and<T>{}

p(x,y) means x&y when x and y are of type T

p=bit_or<T>{}

p(x,y) means x|y when x and y are of type T

p=bit_xor<T>{}

p(x,y) means xy when x and y are of type T

For example:

Click here to view code image

vector<int> v;
 //...
sort(v.begin(),v.end(),greater<int>{});           // sort v into decreasing order
Such predicates are roughly equivalent to simple lambdas. For example:

Click here to view code image

vector<int> v;
 //...
sort(v.begin(),v.end(),[](int a, int b) { return a>b; });      // sort v into decreasing order
Note that logical_and and logical_or always evaluate both their arguments (&& and || do not).

Arithmetic Operations (§iso.20.8.4)

f=plus<T>{}

f(x,y) means x+y when x and y are of type T

f=minus<T>{}

f(x,y) means x-y when x and y are of type T

f=multiplies<T>{}

f(x,y) means x*y when x and y are of type T

f=divides<T>{}

f(x,y) means x/y when x and y are of type T

f=modulus<T>{}

f(x,y) means x%y when x and y are of type T

f=negate<T>{}

f(x) means -x when x is of type T

33.5. Function Adaptors
A function adaptor takes a function as argument and returns a function object that can be used to invoke the original function.

Adaptors (§iso.20.8.9, §iso.20.8.10, §iso.20.8.8)

g=bind(f,args)

g(args2) is equivalent to f(args3) where args3 is obtained

by replacing placeholders in args with arguments from args2

for the use of placeholders, such as _1, _2, and _3

g=mem_fn(f)

g(p,args) means p->f(args) if p is a pointer and p.f(args) if p is not;

args is a (possibly empty) list of arguments

g=not1(f)

g(x) means !f(x)

g=not2(f)

g(x,y) means !f(x,y)

The bind() and mem_fn() adaptors do argument binding, also called Currying or partial evaluation. These binders, and their deprecated predecessors (such as bind1st(), mem_fun(), and mem_fun_ref()), were heavily used in the past, but most uses seem to be more easily expressed using lambdas (§11.4).

33.5.1. bind()
Given a function and a set of arguments, bind() produces a function object that can be called with “the remaining” arguments, if any, of the function. For example:

double cube(double);

auto cube2 = bind(cube,2);
A call cube2() will invoke cube with the argument 2, that is, cube(2). We don’t have to bind every argument of a function. For example:

Click here to view code image

using namespace placeholders;

void f(int,const string&);
auto g = bind(f,2,_1);       // bind f()'s first argument to 2
f(2,"hello");
g("hello");                  // also calls f(2,"hello");
The curious _1 argument to the binder is a placeholder telling bind() where arguments to the resulting function object should go. In this case, g()’s (first) argument is used as f()’s second argument.

The placeholders are found in the (sub)namespace std::placeholders that is part of <functional>. The placeholder mechanism is very flexible. Consider:

Click here to view code image

f(2,"hello");
bind(f)(2,"hello");         // also calls f(2,"hello");
bind(f,_1,_2)(2,"hello");   // also calls f(2,"hello");
bind(f,_2,_1)("hello",2);   // reverse order of arguments: also calls f(2,"hello");

auto g = [](const string& s, int i) { f(i,s); }  // reverse order of arguments
g("hello",2);                                    // also calls f(2,"hello");
To bind arguments for an overloaded function, we have to explicitly state which version of the function we want to bind:

Click here to view code image

int pow(int,int);
double pow(double,double);    // pow() is overloaded

auto pow2 = bind(pow,_1,2);                            // error: which pow()?
auto pow2 = bind((double(*)(double,double))pow,_1,2);  // OK (but ugly)
Note that bind() takes ordinary expressions as arguments. This implies that references are dereferenced before bind() gets to see them. For example:

Click here to view code image

void incr(int& i)
{
     ++i;
}

void user()
{
     int i = 1;
     incr(i);                          // i becomes 2
     auto inc = bind(incr,_1);
     inc(i);                           // i stays 2; inc(i) incremented a local copy of i
}
To deal with that, the standard library provides yet another pair of adaptors:

reference_wrapper<T> (§iso.20.8.3)

r=ref(t)

r is a reference_wrapper for T& t; noexcept

r=cref(t)

r is a reference_wrapper for a const T& t; noexcept

This solves the “reference problem” for bind():

Click here to view code image

void user2()
{
     int i = 1;
     incr(i);                       // i becomes 2
     auto inc = bind(incr,_1);
     inc(ref(i));                   // i becomes 3
}
This ref() is needed to pass references as arguments to threads because thread constructors are variadic templates (§42.2.2).

So far, I either used the result of bind() immediately or assigned it to a variable declared using auto. This saves me the bother of specifying the return type of a call of bind(). That can be useful because the return type of bind() varies with the type of function to be called and the argument values stored. In particular, the returned function object is larger when it has to hold values of bound parameters. However, we sometimes want to be specific about the types of the arguments required and the type of result returned. If so, we can specify them for a function (§33.5.3).

33.5.2. mem_fn()
The function adaptor mem_fn(mf) produces a function object that can be called as a nonmember function. For example:

Click here to view code image

void user(Shape* p)
{
     p–>draw();
     auto draw = mem_fn(&Shape::draw);
     draw(p);
}
The major use of mem_fn() is when an algorithm requires an operation to be called as a nonmember function. For example:

Click here to view code image

void draw_all(vector<Shape*>& v)
{
     for_each(v.begin(),v.end(),mem_fn(&Shape::draw));
}
Thus, mem_fn() can be seen as a mapping from the object-oriented calling style to the functional one.

Often, lambdas provide a simple and general alternative to binders. For example:

Click here to view code image

void draw_all(vector<Shape*>& v)
{
     for_each(v.begin(),v.end(),[](Shape* p) { p–>draw(); });
}
33.5.3. function
A bind() can be used directly, and it can be used to initialize an auto variable. In that, bind() resembles a lambda.

If we want to assign the result of bind() to a variable with a specific type, we can use the standard-library type function. A function is specified with a specific return type and a specific argument type.

function<R(Argtypes...)> (§iso.20.8.11.2) (continues)

function<type> f {};

f is an empty function; noexcept

function<type> f {nullptr};

f is an empty function; noexcept

function<type> f {g};

f is a function holding g; g can be anything that

can be invoked with f’s argument types

function<type> f {allocator_arg_t,a};

f is an empty function; use allocator a; noexcept

function<type> f {allocator_arg_t,a,nullptr_t};

f is an empty function; use allocator a; noexcept

function<type> f {allocator_arg_t,a,g};

f is a function holding g; use allocator a; noexcept

f2=f

f2 is a copy of f

f=nullptr

f becomes empty

function<R(Argtypes...)> (continued) (§iso.20.8.11.2)

f.swap(f2)

Swap the contents of f and f2;

f and f2 must be of the same function type; noexcept

f.assign(f2,a)

f gets a copy of f2 and the allocator a

bool b {f};

conversion of f to bool;

b is true if f is nonempty; explicit; noexcept

r=f(args)

Invoke the contained function with args;

the argument types must match f’s

ti=f.target_type()

ti is the type_info for f;if f doesn’t contain

something callable ti==typeid(void); noexcept

p=f.target<F>()

If f.target_type()==typeid(F), p points to the

contained object, otherwise, p==nullptr; noexcept

f==nullptr

Is f empty? noexcept

nullptr==f

f==nullptr

f!=nullptr

!(f==nullptr)

nullptr!=f

!(f==nullptr)

swap(f,f2)

f.swap(f2)

For example:

Click here to view code image

int f1(double);
function<int(double)> fct {f1}; // fct takes a double argument and returns an int; initialize to f1
int f2(int);
int f3(char);

void user()
{
     fct = [](double d) { return round(d); };    // assign lambda to fct
     fct = f1;                                   // assign function to fct
     fct = f2;                                   // warning: double to int conversion
     fct = f3;                                   // error: incorrect argument type
}
A function invokes the function (or function object) that it holds. Ths may lead to argument conversions. For example, if fct holds f2, a call fct(2.2) will invoke f1(2).

The target functions are provided for the rare cases where someone wants to examine a function, rather than simply call it as usually intended.

The standard-library function is a type that can hold any object you can invoke using the call operator () (§2.2.1, §3.4.3, §11.4, §19.2.2). That is, an object of type function is a function object. For example:

Click here to view code image

int round(double x) { return static_cast<int>(floor(x+0.5)); }   // conventional 4/5 rounding

function<int(double)> f;  // f can hold anything that can be called with a double and return an int

enum class Round_style { truncate, round };

struct Round {    // function object carrying a state
     Round_style s;
     Round(Round_style ss) :s(ss) { }
     int operator()(double x) const { return static_cast<int>((s==Round_style::round) ? (x+0.5) : x); };
};
void t1()
{
     f = round;
     cout << f(7.6) << '\n';                              // call through f to the function round

     f = Round(Round_style::truncate);
     cout << f(7.6) << '\n';                              // call the function object

     Round_style style = Round_style::round;
     f = [style] (double x){ return static_cast<int>((style==Round_style::round) ? x+0.5 : x); };

     cout << f(7.6) << '\n';                              // call the lambda

     vector<double> v {7.6};
     f = Round(Round_style::round);
     std::transform(v.begin(),v.end(),v.begin(),f);       // pass to algorithm

     cout << v[0] << '\n';                                // transformed by the lambda
}
We get 8, 7, 8, and 8.

Obviously, functions are useful for callbacks, for passing operations as arguments, etc.

33.6. Advice
[1] An input sequence is defined by a pair of iterators; §33.1.1.

[2] An output sequence is defined by a single iterator; avoid overflow; §33.1.1.

[3] For any iterator p, [p:p] is the empty sequence; §33.1.1.

[4] Use the end of a sequence to indicate “not found”; §33.1.1.

[5] Think of iterators as more general and often better behaved pointers; §33.1.1.

[6] Use iterator types, such as list<char>::iterator, rather than pointers to refer to elements of a container; §33.1.1.

[7] Use iterator_traits to obtain information about iterators; §33.1.3.

[8] You can do compile-time dispatch using iterator_traits; §33.1.3.

[9] Use iterator_traits to select an optimal algorithm based on an iterator’s category; §33.1.3.

[10] iterator_traits are an implementation detail; prefer to use them implicitly; §33.1.3.

[11] Use base() to extract an iterator from a reverse_iterator; §33.2.1.

[12] You can use an insert iterator to add elements to a container; §33.2.2.

[13] A move_iterator can be used to make copy operations into move operations; §33.2.3.

[14] Make sure that your containers can be traversed using a range-for; §33.3.

[15] Use bind() to create variants of functions and function objects; §33.5.1.

[16] Note that bind() dereferences references early; use ref() if you want to delay dereferencing; §33.5.1.

[17] A mem_fn() or a lambda can be used to convert the p–>f(a) calling convention into f(p,a); §33.5.2.

[18] Use function when you need a variable that can hold a variety of callable objects; §33.5.3.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


33. STL Iterators
34. Memory and Resources
35. Utilities
47h 26m remaining
34. Memory and Resources
Anyone can have an idea; it’s what you do with the idea that’s the important thing.

– Terry Pratchett

• Introduction

• “Almost Containers”

array; bitset; vector<bool>; Tuples

• Resource Management Pointers

unique_ptr; shared_ptr; weak_ptr

• Allocators

The Default Allocator; Allocator Traits; Pointer Traits; Scoped Allocators

• The Garbage Collection Interface

• Uninitialized Memory

Temporary Buffers; raw_storage_iterator

• Advice

34.1. Introduction
The STL (Chapter 31, Chapter 32, Chapter 33) is the most highly structured and general part of the standard-library facilities for the management and manipulation of data. This chapter presents facilities that are more specialized or deal with raw memory (as opposed to typed objects).

34.2. “Almost Containers”
The standard library provides several containers that don’t fit perfectly into the STL framework (§31.4, §32.2, §33.1). Examples are built-in arrays, array, and string. I sometimes refer to those as “almost containers” (§31.4), but that is not quite fair: they hold elements, so they are containers, but each has restrictions or added facilities that make them awkward in the context of the STL. Describing them separately also simplifies the description of the STL.

‘‘Almost Containers’’

T[N]

Built-in array: a fixed-size continuously allocated sequence of N

elements of type T; implicitly converts to a T*

array<T,N>

A fixed-size continuously allocated sequence of N elements

of type T; like the built-in array, but with most problems solved

bitset<N>

A fixed-size sequence of N bits

vector<bool>

A sequence of bits compactly stored in a specialization of vector

pair<T,U>

Tw o elements of types T and U

tuple<T...>

A sequence of an arbitrary number of elements of arbitrary types

basic_string<C>

A sequence of characters of type C; provides string operations

valarray<T>

An array of numeric values of type T; provides numeric operations

Why does the standard library provide so many containers? They serve common but different (often overlapping) needs. If the standard library didn’t provide them, many people would have to design and implement their own. For example:

• pair and tuple are heterogeneous; all other containers are homogeneous (all elements are of the same type).

• array, vector, and tuple elements are contiguously allocated; forward_list and map are linked structures.

• bitset and vector<bool> hold bits and access them through proxy objects; all other standard-library containers can hold a variety of types and access elements directly.

• basic_string requires its elements to be some form of character and provide string manipulation, such as concatenation and locale-sensitive operations (Chapter 39) and valarray requires its elements to be numbers and to provide numeric operations.

All of these containers can be seen as providing specialized services needed by large communities of programmers. No single container could serve all of these needs because some needs are contradictory, for example, “ability to grow” vs. “guaranteed to be allocated in a fixed location,” and “elements do not move when elements are added” vs. “contiguously allocated.” Furthermore, a very general container would imply overhead deemed unacceptable for individual containers.

34.2.1. array
An array, defined in <array>, is a fixed-size sequence of elements of a given type where the number of elements is specified at compile time. Thus, an array can be allocated with its elements on the stack, in an object, or in static storage. The elements are allocated in the scope where the array is defined. An array is best understood as a built-in array with its size firmly attached, without implicit, potentially surprising conversions to pointer types, and with a few convenience functions provided. There is no overhead (time or space) involved in using an array compared to using a built-in array. An array does not follow the “handle to elements” model of STL containers. Instead, an array directly contains its elements:

Click here to view code image

template<typename T, size_t N>               // an array of N Ts (§iso.23.3.2)
struct array {
/*
     types and operations like vector's (§31.4),
     except operations that change the container size, constructors, and assign() functions
*/
     void fill(const T& v); // assign N copies of v
     void swap(array&) noexcept(noexcept(swap(declval<T&>(), declval<T&>())));

     T __elem[N];   // implementation detail
};
No “management information” (e.g., a size) is stored in an array. This implies that moving (§17.5) an array is no more efficient than copying it (unless the array’s elements are resource handles with efficient moves). An array does not have a constructor or an allocator (because it does not directly allocate anything).

The number of elements and subscript values for array are of an unsigned type (size_t), just like vector’s, but different from the built-in array’s. So, array<int,–1> might be accepted by an inattentive compiler. Hope for a warning.

An array can be initialized by an initializer list:

array<int,3> a1 = { 1, 2, 3 };
The number of elements in the initializer must be equal to or less than the number of elements specified for the array. As usual, if the initializer list provides values for some but not all elements, the remainder is initialized with the appropriate default value. For example:

Click here to view code image

void f()
{
     array<string, 4> aa = {"Churchill", "Clare"};
     //
}
The last two elements will be empty strings.

The element count is not optional:

array<int> ax = { 1, 2, 3 };  // error size not specified
To save us from a special case, the number of elements can be zero:

array<int,0> a0;
The element count must be a constant expression:

Click here to view code image

void f(int n)
{
     array<string,n> aa = {"John's", "Queens' "};      // error: size not a constant expression
     // ...
}
If you need the element count to be variable, use vector. On the other hand, since array’s element count is known at compile time, array’s size() is a constexpr function.

There is no constructor for array that copies an argument value (as there is for vector; §31.3.2). Instead, a fill() operation is provided:

Click here to view code image

void f()
{
     array<int,8> aa;    // uninitialized, so far
     aa.fill(99);        // assign eight copies of 99
      //...
}
Because an array doesn’t follow the “handle to elements” model, swap() has to actually swap elements so that swapping two array<T,N>s applies swap() to N pairs of Ts. The declaration of array<T,N>::swap() basically says that if a swap() of Ts can throw, then so can a swap() of an array<T,N>. Obviously, throwing swap()s should be avoided like the plague.

When necessary, an array can be explicitly passed to a C-style function that expects a pointer. For example:

Click here to view code image

void f(int* p, int sz);  // C-style interface

void g()
{
     array<int,10> a;

     f(a,a.size());              // error: no conversion
     f(&a[0],a.size());          // C-style use
     f(a.data(),a.size());       // C-style use

     auto p = find(a.begin(),a.end(),777);        // C++/STL-style use
      //...
}
Why would we use an array when vector is so much more flexible? Because an array is less flexible, it is simpler. Occasionally, there is a significant performance advantage to be had by directly accessing elements allocated on the stack rather than allocating elements on the free store, accessing them indirectly through the vector (a handle), and then deallocating them. On the other hand, the stack is a limited resource (especially on some embedded systems), and stack overflow is nasty.

Why would we use an array when we could use a built-in array? An array knows its size, so it is easy to use with standard-library algorithms, and it can be copied (using = or initialization). However, my main reason to prefer array is that it saves me from surprising nasty conversions to pointers. Consider:

Click here to view code image

void h()
{
     Circle a1[10];
     array<Circle,10> a2;
      //...
     Shape* p1 = a1;       // OK: disaster waiting to happen
     Shape* p2 = a2;       // error: no conversion of array<Circle,10> to Shape*
     p1[3].draw();         // disaster
}
The “disaster” comment assumes that sizeof(Shape)<sizeof(Circle), so that subscripting a Circle[] through a Shape* gives a wrong offset (§27.2.1, §17.5.1.4). All standard containers provide this advantage over built-in arrays.

An array can be seen as a tuple (§34.2.4) where all elements are of the same type. The standard library provides support for that view. The tuple helper type functions tuple_size and tuple_element can be applied to arrays:

Click here to view code image

tuple_size<array<T,N>>::value         // N
tuple_element<S,array<T,N>>::type     // T
We can also use a get<i> function to access the ith element:

Click here to view code image

template<size_t index, typename T, size_t N>
    T& get(array<T,N>& a) noexcept;
template<size_t index, typename T, size_t N>
    T&& get(array<T,N>&& a) noexcept;
template<size_t index, typename T, size_t N>
    const T& get(const array<T,N>& a) noexcept;
For example:

Click here to view code image

array<int,7> a = {1,2,3,5,8,13,25};
auto x1 = get<5>(a);                                  //13
auto x2 = a[5];                                       //13
auto sz = tuple_size<decltype(a)>::value;             //7
typename tuple_element<5,decltype(a)>::type x3 = 13;  // x3 is an int
These type functions are for people writing code that expects tuples.

Use a constexpr function (§28.2.2) and a type alias (§28.2.1) to improve readability:

Click here to view code image

auto sz = tuple_size<decltype(a)>();         //7

tuple_element<5,decltype(a)> x3 = 13;  // x3 is an int
The tuple syntax is meant for use in generic code.

34.2.2. bitset
Aspects of a system, such as the state of an input stream (§38.4.5.1), are often represented as a set of flags indicating binary conditions such as good/bad, true/false, and on/off. C++ supports the notion of small sets of flags efficiently through bitwise operations on integers (§11.1.1). Class bitset<N> generalizes this notion and offers greater convenience by providing operations on a sequence of N bits [0:N), where N is known at compile time. For sets of bits that don’t fit into a long long int, using a bitset is much more convenient than using integers directly. For smaller sets, bitset is usually optimized. If you want to name the bits, rather than numbering them, the alternatives are to use a set (§31.4.3), an enumeration (§8.4), or a bit-field (§8.2.7).

A bitset<N> is an array of N bits. It is presented in <bitset>. A bitset differs from a vector<bool> (§34.2.3) by being of fixed size, from set (§31.4.3) by having its bits indexed by integers rather than associatively by value, and from both vector<bool> and set by providing operations to manipulate the bits.

It is not possible to address a single bit directly using a built-in pointer (§7.2). Consequently, bitset provides a reference-to-bit (proxy) type. This is actually a generally useful technique for addressing objects for which a built-in pointer for some reason is unsuitable:

Click here to view code image

template<size_t N>
class bitset {
public:
     class reference {          // reference to a single bit:
          friend class bitset;
          reference() noexcept;
     public:                   // support zero-based subscripting in [0:b.size())
          ~reference() noexcept;
          reference& operator=(bool x) noexcept;                      // for b[i] = x;
          reference& operator=(const reference&) noexcept;            // for b[i] = b[j];
          bool operator~() const noexcept;                            // return ~b[i]
          operator bool() const noexcept;                             // for x = b[i];
          reference& flip() noexcept;                                 // b[i].flip();
     };
      //...
};
For historical reasons, bitset differs in style from other standard-library classes. For example, if an index (also known as a bit position) is out of range, an out_of_range exception is thrown. No iterators are provided. Bit positions are numbered from right to left in the same way bits often are in a word, so the value of b[i] is pow(2,i). Thus, a bitset can be thought of as an N-bit binary number:



34.2.2.1. Constructors
A bitset can be constructed with a specified number of zeros, from the bits in an unsigned long long int, or from a string:

bitset<N> Constructors (§iso.20.5.1) (continues)

bitset<N> bs {};

N zero bits

bitset<N> bs {n};

Bits from n; n is an unsigned long long

bitset<N> bs {s,i,n,z,o};

n bits [i:i+n)of s; s is a basic_string<C,Tr,A>;

 

z is the character of type C used for zero;

o is the character of type C used for one; explicit

bitset<N> bs {s,i,n,z};

bitset bs {s,i,n,z,C{‘1’}};

bitset<N> bs {s,i,n};

bitset bs {s,i,n,C{‘0’},C{‘1’}};

bitset<N> bs {s,i};

bitset bs {s,i,npos,C{‘0’},C{‘1’}};

bitset<N> bs {s};

bitset bs {s,0,npos,C{‘0’},C{‘1’}};

bitset<N>

Constructors (continued) (§iso.20.5.1)

bitset<N> bs {p,n,z,o};

n bits [p:p+n); p is a C-style string of type C*;

z is the character of type C used for zero;

o is the character of type C used for one; explicit

bitset<N> bs {p,n,z};

bitset bs {p,n,z,C{‘1’}};

bitset<N> bs {p,n};

bitset bs {p,n,C{‘0’},C{‘1’}};

bitset<N> bs {p};

bitset bs {p,npos,C{‘0’},C{‘1’}};

The position npos is string<C>’s “beyond the end” position, meaning “all characters until the end” (§36.3).

When an unsigned long long int argument is supplied, each bit in the integer is used to initialize the corresponding bit in the bitset (if any). A basic_string (§36.3) argument does the same, except that the character '0' gives the bit value 0, the character '1' gives the bit value 1, and other characters cause an invalid_argument exception to be thrown. For example:

Click here to view code image

void f()
{
     bitset<10> b1;  // all 0

     bitset<16> b2 = 0xaaaa;                         // 1010101010101010
     bitset<32> b3 = 0xaaaa;                         // 00000000000000001010101010101010

     bitset<10> b4 {"1010101010"};                   // 1010101010
     bitset<10> b5 {"10110111011110",4};             // 0111011110

     bitset<10> b6 {string{"1010101010"}};           // 1010101010
     bitset<10> b7 {string{"10110111011110"},4};           // 0111011110
     bitset<10> b8 {string{"10110111011110"},2,8};   // 11011101

     bitset<10> b9 {string{"n0g00d"}};               // invalid_argument thrown
     bitset<10> b10 = string{"101001"};              // error: no implicit string to bitset conversion
}
A key idea in the design of bitset is that an optimized implementation can be provided for bitsets that fit in a single word. The interface reflects this assumption.

34.2.2.2. bitset Operations
A bitset provides the operators for accessing individual bits and for manipulating all bits in the set:

bitset<N> Operations (§iso.20.5) (continues)

bs[i]

The ith bit of bs

bs.test(i)

The ith bit of bs; throw out_of_range if i is not in [0:bs.size())

bs&=bs2

Bitwise and

bs|=bs2

Bitwise or

bs=bs2

Bitwise exclusive or

bitset<N> Operations (continued) (§iso.20.5)

bs<<=n

Logical left shift (fill with zeros)

bs>>=n

Logical right shift (fill with zeros)

bs.set()

Set every bit of bs to 1

bs.set(i,v)

bs[i]=v

bs.reset()

Set every bit of bs to 0

bs.reset(i)

b[i]=0;

bs.flip()

bs[i]=-bs[i] for every bit in bs

bs.flip(i)

bs[i]=-bs[i]

bs2=-bs

Make complement set: bs2=bs, bs2.flip()

bs2=bs<<n

Make left-shifted set: bs2=bs, bs2<<=n

bs2=bs>>n

Make right-shifted set: bs2=bs, bs2>>=n

bs3=bs&bs2

Bitwise and: bs3[i]=bs[i]&bs2[i] for each bit in bs

bs3=bs|bs2

Bitwise or: bs3[i]=bs[i]|bs2[i] for each bit in bs

bs3=bsbs2

Bitwise exclusive or: bs3[i]=bs[i]bs2[i] for each bit in bs

is>>bs

Read from is into bs; is is an istream

os<<bs

Write bs to os; os is an ostream

The >> and << are I/O operators when their first operand is an iostream; othewise, they are shift operators and their second operand must be an integer. For example:

Click here to view code image

bitset<9> bs ("110001111"};
cout << bs << '\n';           // write "110001111" to cout
auto bs2 = bs<<3;             // bs2 == "001111000";
cout << bs2 << '\n';          // write "001111000" to cout
cin >> bs;                    // read from cin
bs2 = bs>>3;                  // bs2 == "000110001" if the input were "110001111"
cout << bs2 << '\n';          // write "000110001" to cout
When bits are shifted, a logical (rather than cyclic) shift is used. That implies that some bits “fall off the end” and that some positions get the default value 0. Note that because size_t is an unsigned type, it is not possible to shift by a negative number. It does, however, imply that b<<–1 shifts by a very large positive value, thus leaving every bit of the bitset b with the value 0. Your compiler should warn against this.

A bitset also supports common operations such as size(), ==, and conversion to string:

More bitset<N> Operations (§iso.20.5)

C, Tr, and A have defaults for basic_string<C,Tr,A>

n=bs.to_ulong()

n is the unsigned long corresponding to bs

n=bs.to_ullong()

n is the unsigned long long corresponding to bs

s=bs.to_string<C,Tr,A>(c0,c1)

s[i]=(b[i])?c1:c0; s is a basic_string<C,Tr,A>

s=bs.to_string<C,Tr,A>(c0)

s=bs.template to_string<C,Tr,A>(c0,C{’1’})

s=bs.to_string<C,Tr,A>()

s=bs.template to_string<C,Tr,A>(C{’0’},C{’1’})

More bitset<N> Operations (continued) (§iso.20.5)

C, Tr, and A have defaults for basic_string<C,Tr,A>

n=bs.count()

n is the number of bits with value 1 in bs

n=bs.size()

n is the number of bits in bs

bs==bs2

Do bs and b2 have the same value?

bs!=bs2

!(bs==bs2)

bs.all()

Do all bits in bs have the value 1?

bs.any()

Does any bit in bs have the value 1?

bs.none()

Does no bit in bs have the value 1?

hash<bitset<N>>

Specialization of hash for bitset<N>

The operations to_ullong() and to_string() provide the inverse operations to the constructors. To avoid nonobvious conversions, named operations were preferred over conversion operators. If the value of the bitset has so many significant bits that it cannot be represented as an unsigned long, to_ulong() throws overflow_error; so does to_ullong() if its bitset argument doesn’t fit.

Fortunately, the template arguments for the basic_string returned by to_string are defaulted. For example, we could write out the binary representation of an int:

Click here to view code image

void binary(int i)
{
     bitset<8*sizeof(int)> b = i;           // assume 8-bit byte (see also §40.2)

     cout << b.to_string<char,char_traits<char>,allocator<char>>() << '\n';  // general and verbose
     cout << b.to_string<char>() << '\n';  // use default traits and allocator
     cout << b.to_string<>() << '\n';      // use all defaults
     cout << b.to_string() << '\n';        // use all defaults
}
This prints the bits represented as 1s and 0s from left to right, with the most significant bit leftmost, so that argument 123 would give the output

00000000000000000000000001111011
00000000000000000000000001111011
00000000000000000000000001111011
00000000000000000000000001111011
For this example, it is simpler to directly use the bitset output operator:

Click here to view code image

void binary2(int i)
{
     bitset<8*sizeof(int)> b = i;    // assume 8-bit byte (see also §40.2)
     cout << b << '\n';
}
34.2.3. vector<bool>
The vector<bool> from <vector> is a specialization of vector (§31.4) providing compact storage of bits (bools):

Click here to view code image

template<typename A>
class vector<bool,A> {   // specialization of vector<T,A> (§31.4)
public:
     using const_reference = bool;
     using value_type = bool;
      // like vector<T,A>

     class reference {     // support zero-based subscripting in [0:v.size())
          friend class vector;
          reference() noexcept;
     public:
          ~reference();
          operator bool() const noexcept;
          reference& operator=(const bool x) noexcept;          // v[i] = x
          reference& operator=(const reference& x) noexcept;    // v[i] = v[j]
          void flip() noexcept;                                 // flip the bit: v[i]=~v[i]
     };

     void flip() noexcept;  // flip all bits of v

      //...
};
The similarity to bitset is obvious. However, unlike bitset but like vector<T>, vector<bool> has an allocator and can have its size changed.

As in a vector<T>, elements of a vector<bool> with higher indices have higher addresses:



This is exactly the opposite of the layout in a bitset. Also, there is no direct support for converting integers and strings to and from a vector<bool>.

Use vector<bool> as you would any other vector<T>, but expect operations on a single bit to be less efficient than the equivalent operations on a vector<char>. Also, it is impossible in C++ to completely faithfully mimic the behavior of a (built-in) reference with a proxy, so don’t try to be subtle about rvalue/lvalue distinctions when using a vector<bool>.

34.2.4. Tuples
The standard library provides two ways of grouping values of arbitrary types into a single object:

• A pair (§34.2.4.1) holds two values.

• A tuple (§34.2.4.2) holds zero or more values.

We use pair when it is useful to know (statically) that we have exactly two values. With tuple, we always have to deal with all possible numbers of values.

34.2.4.1. pair
In <utility>, the standard library provides class pair for manipulating pairs of values:

Click here to view code image

template<typename T, typename U>
struct pair {
     using first_type = T;   // the type of the first element
     using second_type = U;  // the type of the second element

     T first;      // first element
     U second;     // second element

      //...
};
pair<T,U> (§iso.20.3.2)

pair<T,U> p {}

Default constructor: pair p {T{},U{}}; constexpr

pair<T,U> p {x,y}

p.first is initialized to x and p.second is initialized to y

pair<T,U> p {p2}

Construct from the pair p2: pair p {p2.first,p2.second};

pair<T,U> p {piecewise_construct,t,t2}

p.first is constructed from the elements of tuple t, and p.second is constructed from the elements of tuple t2

p.-pair()

Destructor: destroy t.first and t.second

p2=p

Copy assignment: p2.first=p.first and p2.second=p.second

p2=move(p)

Move assignment:

p2.first=move(p.first) and p2.second=move(p.second)

p.swap(p2)

Exchange the values of p and p2

An operation on pair is noexcept if the corresponding operations on its elements are. Similarly, copy or move operations exist for a pair if the corresponding operations on its elements do.

The elements first and second are members that we can directly read and write. For example:

Click here to view code image

void f()
{
     pair<string,int> p {"Cambridge",1209};
     cout << p.first;      // print "Cambridge"
     p.second += 800;      // update year
      //...
}
The piecewise_construct is the name of an object of type piecewise_construct_t used to distinguish between constructing a pair with members of tuple types and constructing a pair using tuples as argument lists for its first and second. For example:

Click here to view code image

struct Univ {
     Univ(const string& n, int r) : name{n}, rank{r} { }
     string name;
     int rank;
     string city = "unknown";
};
     using Tup = tuple<string,int>;
     Tup t1 {"Columbia",11};            // U.S. News 2012
     Tup t2 {"Cambridge",2};

     pair<Tup,Tup> p1 {t1,t2};                          // pair of tuples
     pair<Univ,Univ> p2 {piecewise_construct,t1,t2};     // pair of Univs
That is, p1.second is t2, that is, {"Cambridge",2}. To contrast, p2.second is Univ{t2}, that is, {"Cambridge",2,"unknown"}.

pair<T,U> Helpers (§iso.20.3.3, §iso.20.3.4)

p==p2

p.first==p2.first && p.second==p2.second

p<p2

p.first<p2.first || (!(p2.first<p.first) && p.second<p2.second)

p!=p2

!(p==p2)

p>p2

p2<p

p<=p2

!(p2<p)

p>=p2

!(p<p2)

swap(p,p2)

p.swap(p2)

p=make_pair(x,y)

p is a pair<decltype(x),decltype(y)> holding the value x,y;

if possible, move rather than copy x and y

tuple_size<T>::value

The size of a pair of type T

tuple_element<N,T>::type

The type of first (if N==0)or second (if N==1)

get<N>(p)

A reference to the Nth element of the pair p; N must be 0 or 1

The make_pair function avoids explicit mention of the element types of a pair. For example:

auto p = make_pair("Harvard",1736);
34.2.4.2. tuple
In <tuple>, the standard library provides class tuple and various supporting facilities. A tuple is a sequence of N elements of arbitrary types:

template<typename ... Types>
class tuple {
public:
     //...
};
The number of elements is zero or positive.

For details of tuple design, implementation, and use, see §28.5 and §28.6.4.

tuple<Types...> Members (§iso.20.4.2) (continues)

tuple<types> t {}

Default constructor: the empty tuple; constexpr

tuple<types> t {args}

t has one element for each element of args; explicit

tuple<types> t {t2}

Construct from tuple t2

tuple<types> t {p}

Construct from pair p

tuple<Types...> Members (continued) (§iso.20.4.2)

tuple<types> t {allocator_arg,a,args}

Construct from args using the allocator a

tuple<types> t {allocator_arg,a,t2}

Construct from tuple t2, using the allocator a

tuple<types> t {allocator_arg,a,p}

Construct from pair p, using the allocator a

t.~tuple()

Destructor: destroy each element

t=t2

Copy assignment of tuples

t=move(t2)

Move assignment of tuples

t=p

Copy assignment of pair p

t=move(p)

Move assignment of pair p

t.swap(t2)

Exchange the values of tuples t and t2; noexcept

The types of tuple and operands of = and arguments to swap(), etc., are not required to be the same. An operation is valid if (and only if) the implied operations on elements are valid. For example, we can assign one tuple to another if each element of the assigned tuple can be assigned to the target element. For example:

tuple<string,vector<double>,int> t2 = make_tuple("Hello, tuples!",vector<double>{1,2,3},'x');
An operation is noexcept if all the element operations are, and an operation throws only if a member operation throws. Similarly, a tuple operation is constexpr if the element operations are.

The number of elements in each tuple of a pair of operands (or arguments) must be the same.

Note that the general tuple constructor is explicit. In particular, this does not work:

Click here to view code image

tuple<int,int,int> rotate(tuple<int,int,int> t)
{
     return {get<2>(t),get<0>(t),get<1>(t)};  // error: explicit tuple constructor
}

auto t2 = rotate({3,7,9});  // error: explicit tuple constructor
If all you need is two elements, you can use pair:

pair<int,int> rotate(pair<int,int> p)
{
     return {p.second,p.first};
}

auto p2 = rotate({3,7});
For more examples, see §28.6.4.

tuple<Types...> Helpers (§iso.20.4.2.4, §iso.20.4.2.9) (continues)

t=make_tuple(args)

Make tuple from args

t=forward_as_tuple(args)

t is a tuple of rvalue references to the elements in args

so you can forward the elements of args through t

t=tie(args)

t is a tuple of lvalue references to the elements of args

so you can assign to the elements of args through t

tuple<Types...> Helpers (continued) (§iso.20.4.2.4, §iso.20.4.2.9)

t=tuple_cat(args)

Concatenate tuples: args is one or more tuples;

t has the members of the tuplesin args in order

tuple_size<T>::value

The number of elements of the tuple T

tuple_element<N,T>::type

The type of the Nth element of the tuple T

get<N>(t)

A reference to the Nth element of the tuple t

t==t2

Are all elements of t and t2 equal?

t and t2 must have the same number of elements

t!=t2

!(t==t2)

t<t2

Does t lexicographically compare less than t2?

t>t2

t2<t

t<=t2

!(t>t2)

t>=t2

!(t<t2)

uses_allocator<T,A>::value

Can a tuple<T> be allocated by an allocator of type A?

swap(t,t2)

t.swap(t2)

For example, tie() can be used to extract elements from a tuple:

Click here to view code image

auto t = make_tuple(2.71828,299792458,"Hannibal");
int c;
string name;
tie(ignore,c,name) = t;       // c=299792458; name="Hannibal"
The name ignore refers to an object of a type that ignores assignments. Thus, an ignore in a tie() implies that attempts to assign to its tuple position are ignored. An alternative would be:

Click here to view code image

int c = get<0>(t);         // c=299792458
string name = get<2>(t);      // name="Hannibal"
Obviously, this would be more interesting if the tuple came from “elsewhere” so that we didn’t trivially know the element values. For example:

Click here to view code image

tuple<double,int,string> compute();
 //...
int c;
string name;
tie(ignore,c,name) = compute();       // results in c and name
34.3. Resource Management Pointers
A pointer points to an object (or not). However, a pointer does not indicate who (if anyone) owns the objects. That is, looking just at a pointer, we have no idea who is supposed to delete the object pointed to, or how, or if at all. In <memory>, we find “smart pointers” to express ownership:

• unique_ptr (§34.3.1) to represent exclusive ownership

• shared_ptr (§34.3.2) to represent shared ownership

• weak_ptr (§34.3.3) to break loops in circular shared data structures

These resource handles are introduced in §5.2.1.

34.3.1. unique_ptr
The unique_ptr (defined in <memory>) provides a semantics of strict ownership:

• A unique_ptr owns the object to which it holds a pointer. That is, it is the unique_ptr’s obligation to destroy the object pointed to (if any) by its contained pointer.

• A unique_ptr cannot be copied (has no copy constructor or copy assignment). However, it can be moved.

• A unique_ptr stores a pointer and deletes the object pointed to (if any) using the associated deleter (if any) when it is itself destroyed (such as when a thread of control leaves the unique_ptr’s scope; §17.2.2).

The uses of unique_ptr include:

• Providing exception safety for dynamically allocated memory (§5.2.1, §13.3)

• Passing ownership of dynamically allocated memory to a function

• Returning dynamically allocated memory from a function

• Storing pointers in containers

Think of unique_ptr as being represented by a simple pointer (“the contained pointer”) or (if it has a deleter) as a pair of pointers:



When a unique_ptr is destroyed, its deleter is called to destroy the owned object. The deleter represents what it means to destroy an object. For example:

• A deleter for a local variable should do nothing.

• A deleter for a memory pool should return the object to the memory pool and destroy it or not, depending on how that pool is defined.

• The default (“no deleter”) version of unique_ptr uses delete. It doesn’t even store the default deleter. It can be a specialization or rely on the empty-base optimization (§28.5).

This way unique_ptr supports general resource management (§5.2).

Click here to view code image

template<typename T, typename D = default_delete<T>>
class unique_ptr {
public:
     using pointer = ptr;  // type of the contained pointer;
                           // ptr is D::pointer if that is defined, otherwise T*
     using element_type = T;
     using deleter_type = D;

      //...
};
The contained pointer is not directly accessible to users.

unique_ptr<T,D> (§iso.20.7.1.2)

cp is the contained pointer

unique_ptr<types> up {}

Default constructor: cp=nullptr; constexpr; noexcept

unique_ptr<types> up {p}

cp=p; use the default deleter; explicit; noexcept

unique_ptr<types> up {p,del}

cp=p; del is the deleter; noexcept

unique_ptr<types> up {up2}

Move constructor: cp.p=up2.p; up2.p=nullptr; noexcept

up.-unique_ptr()

Destructor: if cp!=nullptr invoke cp’s deleter

up=up2

Move assigment: up.reset(up2.cp); up2.cp=nullptr;

up gets up2’s deleter; up’s old object (if any) is deleted; noexcept

up=nullptr

up.reset(nullptr); that is, delete up’s old object, if any

bool b {up};

Conversion to bool: up.cp!=nullptr; explicit

x=*up

x=*up.cp; for contained non-arrays only

x=up->m

x=up.cp->m; for contained non-arrays only

x=up[n]

x=up.cp[n]; for contained arrays only

p=up.get()

p=up.cp

del=up.get_deleter()

del is up’s deleter

p=up.release()

p=up.cp; up.cp=nullptr

up.reset(p)

If up.cp!=nullptr call deleter for up.cp; up.cp=p

up.reset()

up.cp=pointer{} (probably nullptr);

call the deleter for the old value of up.cp

up.swap(up2)

Exchange up and up2’s values; noexcept

up==up2

up.cp==up2.cp

up<up2

up.cp<up2.cp

up!=up2

!(up==up2)

up>up2

up2<up

up<=up2

!(up>up2)

up>=up2

!(up<up2)

swap(up,up2)

up.swap(up2)

Note: unique_ptr does not offer a copy constructor or copy assignment. Had it done so, the meaning of “ownership” would have been very hard to define and/or use. If you feel the need for copies, consider using a shared_ptr (§34.3.2).

It is possible to have a unique_ptr for a built-in array. For example:

unique_ptr<int[]> make_sequence(int n)
{
     unique_ptr<int[]> p {new int[n]};
     for (int i=0; i<n; ++i)
           p[i]=i;
     return p;
}
This is provided as a specialization:

Click here to view code image

template<typename T, typename D>
class unique_ptr<T[],D> {   // specialization for arrays (§iso.20.7.1.3)
                            // the default D=default_delete<T> comes from the general unique_ptr
public:
//   ... like the unique_ptr for individual objects, but with [] instead of * and -> ...
};
To avoid slicing (§17.5.1.4), a Derived[] is not accepted as an argument to a unique_ptr<Base[]> even if Base is a public base of Derived. For example:

Click here to view code image

class Shape {
      //...
};

class Circle : public Base {
public:
     Circle(Point,int);
     //...
};

unique_ptr<Shape> ps {new Circle{p,20}};                               // OK
unique_ptr<Shape[]> pa {new Circle[] {Circle{p,20}, Circle{p2,40}};    // error: would have sliced
How can we best think of a unique_ptr? What are the best ways to use a unique_ptr? It is called a pointer (_ptr) and I pronounce it “unique pointer,” but clearly it is not just an ordinary pointer (or there would be no point in defining it). Consider a simple technical example:

Click here to view code image

unique_ptr<int> f(unique_ptr<int> p)
{
     ++*p;
     return p;
}

void f2(const unique_ptr<int>& p)
{
     ++*p;
}

void use()
{
     unique_ptr<int> p {new int{7}};
     p=f(p);             // error: no copy constructor
     p=f(move(p));       // transfer ownership there and back
     f2(p);              // pass a reference
}
The f2() body is slightly shorter than f() and f2() is simpler to call, but I find f() easier to think about. The style illustrated by f() is explicit about ownership (and the use of unique_ptr is typically motivated by ownership issues). See also the discussion of the use of non-const references in §7.7.1. On balance, a notation f(x) that modifies x is more error-prone than a y=f(x) notation that does not.

It is a fair estimate that the call of f2() is one or two machine instructions faster than a call of f() (because of the need to place a nullptr in the original unique_ptr), but that is unlikely to be significant. On the other hand, access to the contained pointer involves an extra indirection in f2() compared to f(). This, too, is unlikely to be significant in most programs, so the choice between the styles of f() and f2() has to be made on reasoning about code quality.

Here is a simple example of a deleter used to provide guaranteed release of data obtained from a C program fragment using malloc() (§43.5):

Click here to view code image

extern "C" char* get_data(const char* data);  // get data from C program fragment

using PtoCF = void(*)(void*);

void test()
{
  unique_ptr<char,PtoCF> p {get_data("my_data"),free};
   //... use *p ...
}  // implicit free(p)
Currently, there is no standard-library make_unique() similar to make_pair() (§34.2.4.1) and make_shared() (§34.3.2). However, it is easily defined:

Click here to view code image

template<typename T, typename ... Args>
unique_ptr<T> make_unique(Args&&... args)     // default deleter version
{
    return unique_ptr<T>{new T{args...}};
}
34.3.2. shared_ptr
A shared_ptr represents shared ownership. It is used where two pieces of code need access to some data but neither has exclusive ownership (in the sense of being responsible for destroying the object). A shared_ptr is a kind of counted pointer where the object pointed to is deleted when the use count goes to zero. Think of a shared pointer as a structure with two pointers: one to the object and one to the use count:



The deleter is what is used to delete the shared object when the use count goes to zero. The default deleter is the usual delete (invoke the destructor, if any, and deallocate free store).

For example, consider a Node in a general graph used by an algorithm that adds and removes both nodes and connections between nodes (edges). Obviously, to avoid resource leaks, a Node must be deleted if and only if no other node refers to it. We could try:

struct Node {
     vector<Node*> edges;
      //...
};
Given that, answering questions such as “How many nodes point to this node?” is very hard and requires much added “housekeeping” code. We could plug in a garbage collector (§34.5), but that could have negative performance implications if the graph was only a small part of a large application data space. Worse, if the container contained non-memory resources, such as thread handles, file handles, locks, etc., even a garbage collector would leak resources.

Instead, we can use a shared_ptr:

Click here to view code image

struct Node {
     vector<shared_ptr<Node>> edges;
     thread worker;
      //...
};
Here, Node’s destructor (the implicitly generated destructor will do fine) deletes its edges. That is, the destructor for each edges[i] is invoked, and the Node pointed to (if any) is deleted if edges[i] was the last pointer to it.

Don’t use a shared_ptr just to pass a pointer from one owner to another; that’s what unique_ptr is for, and unique_ptr does it better and more cheaply. If you have been using counted pointers as return values from factory functions (§21.2.4) and the like, consider upgrading to unique_ptr rather than shared_ptr.

Do not thoughtlessly replace pointers with shared_ptrs in an attempt to prevent memory leaks; shared_ptrs are not a panacea nor are they without costs:

• A circular linked structure of shared_ptrs can cause a resource leak. You need some logical complication to break the circle, for example, use a weak_ptr (§34.3.3).

• Objects with shared ownership tend to stay “live” for longer than scoped objects (thus causing higher average resource usage).

• Shared pointers in a multi-threaded environment can be expensive (because of the need to prevent data races on the use count).

• A destructor for a shared object does not execute at a predictable time, so the algorithms/logic for the update of any shared object are easier to get wrong than for an object that’s not shared. For example, which locks are set at the time of the destructor’s execution? Which files are open? In general, which objects are “live” and in appropriate states at the (unpredictable) point of execution?

• If a single (last) node keeps a large data structure alive, the cascade of destructor calls triggered by its deletion can cause a significant “garbage collection delay.” That can be detrimental to real-time response.

A shared_ptr represents shared ownership and can be very useful, even essential, but shared ownership isn’t my ideal, and it always carries a cost (independently of how you represent the sharing). It is better (simpler) if an object has a definite owner and a definite, predictable life span. When there is a choice:

• Prefer unique_ptr to shared_ptr.

• Prefer ordinary scoped objects to objects on the heap owned by a unique_ptr.

The shared_ptr provides a fairly conventional set of operations:

shared_ptr<T> Operations (§iso.20.7.2.2)

cp is the contained pointer; uc is the use count

shared_ptr<T> sp {}

Default constructor: cp=nullptr; uc=0; noexcept

shared_ptr<T> sp {p}

Constructor: cp=p; uc=1

shared_ptr<T> sp {p,del}

Constructor: cp=p; uc=1; use deleter del

shared_ptr<T> sp {p,del,a}

Constructor: cp=p; uc=1; use deleter del and allocator a

shared_ptr<T> sp {sp2}

Move and copy constructors:

the move constructor moves and then sets sp2.cp=nullptr;

the copy constructor copies and sets ++uc for the now-shared uc

sp.-shared_ptr()

Destructor: --uc; delete the object pointed to by cp if uc became 0,

using the deleter (the default deleter is delete)

sp=sp2

Copy assignment: ++uc for the now-shared uc; noexcept

sp=move(sp2)

Move assignment: sp2.cp=nullptr for the now-shared uc; noexcept

bool b {sp};

Conversion to bool: sp.cp!=nullptr; explicit

sp.reset()

shared_ptr{}.swap(sp); that is, sp contains pointer{},

and the destruction of the temporary shared_ptr{}

decreases the use count for the old object; noexcept

sp.reset(p)

shared_ptr{p}.swap(sp); that is, sp.cp=p; sp.uc==1;

the destruction of the temporary shared_ptr

decreases the use count for the old object

sp.reset(p,d)

Like sp.reset(p) but with the deleter d

sp.reset(p,d,a)

Like sp.reset(p) but with the deleter d and the allocator a

p=sp.get()

p=sp.cp; noexcept

x=*sp

x=*sp.cp; noexcept

x=sp->m

x=sp.cp->m; noexcept

n=sp.use_count()

n is the value of the use count (0 if sp.cp==nullptr)

sp.unique()

sp.uc==1? (does not check if sp.cp==nullptr)

x=sp.owner_before(pp)

x is an ordering function (strict weak order; §31.2.2.1)

pp is a shared_ptr or a weak_ptr

sp.swap(sp2)

Exchange sp’s and sp2’s values; noexcept

In addition, the standard library provides a few helper functions:

shared_ptr<T> Helpers (§iso.20.7.2.2.6, §iso.20.7.2.2.7) (continues)

sp=make_shared<T>(args)

sp is a shared_ptr<T> for an object of type T

constructed from the arguments args; allocated using new

sp=allocate_shared<T>(a,args)

sp is a shared_ptr<T> for an object of type T

constructed from the arguments args;

allocated using allocator a

shared_ptr<T> Helpers (continued) (§iso.20.7.2.2.6, §iso.20.7.2.2.7)

sp==sp2

sp.cp==sp2.cp; sp or sp2 may be the nullptr

sp<sp2

less<T*>(sp.cp,sp2.cp); sp or sp2 may be the nullptr

sp!=sp2

!(sp==sp2)

sp>sp2

sp2<sp

sp<=sp2

!(sp2<sp)

sp>=sp2

!(sp<sp2)

swap(sp,sp2)

sp.swap(sp2)

sp2=static_pointer_cast<T>(sp)

static_cast for shared pointers:

sp2=shared_ptr<T>(static_cast<T*>(sp.cp)); noexcept

sp2=dynamic_pointer_cast<T>(sp)

dynamic_cast for shared pointers:

sp2=shared_ptr<T>(dynamic_cast<T*>(sp.cp)); noexcept

sp2=const_pointer_cast<T>(sp)

const_cast for shared pointers:

sp2=shared_ptr<T>(const_cast<T*>(sp.cp)); noexcept

dp=get_deleter<D>(sp)

If sp has a deleter of type D, *dp is sp’s deleter;

otherwise, dp==nullptr; noexcept

os<<sp

os<<sp.get()

For example:

Click here to view code image

struct S {
     int i;
     string s;
     double d;
      //...
};

auto p = make_shared<S>(1,"Ankh Morpork",4.65);
Now, p is a shared_ptr<S> pointing to an object of type S allocated on the free store, containing {1,string{"Ankh Morpork"},4.65}.

Note that unlike unique_ptr::get_deleter(), shared_ptr’s get_deleter() is not a member function.

34.3.3. weak_ptr
A weak_ptr refers to an object managed by a shared_ptr. To access the object, a weak_ptr can be converted to a shared_ptr using the member function lock(). A weak_ptr allows access to an object, owned by someone else, that

• You need access to (only) if it exists

• May get deleted (by someone else) at any time

• Must have its destructor called after its last use (usually to delete a non-memory resource)

In particular, we use weak pointers to break loops in data structures managed using shared_ptrs.

Think of a weak_ptr as a structure with two pointers: one to the (potentially shared) object and one to the use count structure of that object’s shared_ptrs:



The “weak use count” is needed to keep the use count structure alive because there may be weak_ptrs after the last shared_ptr for an object (and the object) is destroyed.

template<typename T>
class weak_ptr {
public:
     using element_type = T;
      //...
};
A weak_ptr has to be converted to a shared_ptr to access “its” object, so it provides relatively few operations:

weak_ptr<T> (§iso.20.7.2.3)

cp is the contained pointer; wuc is the weak use count

weak_ptr<T> wp {}

Default constructor: cp=nullptr; constexpr; noexcept

weak_ptr<T> wp {pp}

Copy constructor: cp=pp.cp; ++wuc;

pp is a weak_ptr or a shared_ptr; noexcept

wp.-weak_ptr()

Destructor: no effect on *cp; --wuc

wp=pp

Copy: decrease wuc and set wp to pp: weak_ptr(pp).swap(wp);

pp is a weak_ptr or a shared_ptr; noexcept

wp.swap(wp2)

Exchange wp’s and wp2’s values; noexcept

wp.reset()

Decrease wuc and set wp to nullptr:

weak_ptr{}.swap(wp); noexcept

n=wp.use_count()

n is the number of shared_ptrsto *cp; noexcept

wp.expired()

Are there any shared_ptrsto *cp? noexcept

sp=wp.lock()

Make a new shared_ptr for *cp; noexcept

x=wp.owner_before(pp)

x is an ordering function (strict weak order; §31.2.2.1);

pp is a shared_ptr or a weak_ptr

swap(wp,wp2)

wp.swap(wp2); noexcept

Consider an implementation of the old “asteroid game.” All asteroids are owned by “the game,” but each asteroid must keep track of neighboring asteroids and handle collisions. A collision typically leads to the destruction of one or more asteroids. Each asteroid must keep a list of other asteroids in its neighborhood. Note that being on such a neighbor list should not keep an asteroid “alive” (so a shared_ptr would be inappropriate). On the other hand, an asteroid must not be destroyed while another asteroid is looking at it (e.g., to calculate the effect of a collision). And obviously, an asteroid destructor must be called to release resources (such as a connection to the graphics system). What we need is a list of asteroids that might still be intact and a way of “grabbing onto one” for a while. A weak_ptr does just that:

Click here to view code image

void owner()
{
      //...
     vector<shared_ptr<Asteroid>> va(100);
     for (int i=0; i<va.size(); ++i) {
            //... calculate neighbors for new asteroid ...
           va[i].reset(new Asteroid(weak_ptr<Asteroid>(va[neighbor])));
           launch(i);
     }
      //...
}
Obviously, I radically simplified “the owner” and gave each new Asteroid just one neighbor. The key is that we give the Asteroid a weak_ptr to that neighbor. The owner keeps a shared_ptr to represent the ownership that’s shared whenever an Asteroid is looking (but not otherwise). The collision calculation for an Asteroid will look something like this:

Click here to view code image

void collision(weak_ptr<Asteroid> p)
{
     if (auto q = p.lock()) {         // p.lock returns a shared_ptr to p's object
            //... that Asteroid still existed: calculate ...
     }
     else {         // Oops: that Asteroid has already been destroyed
          p.reset();
     }
}
Note that even if a user decides to shut down the game and deletes all Asteroids (by destroying the shared_ptrs representing ownership), every Asteroid that is in the middle of calculating a collision still finishes correctly: after the p.lock(), it holds a shared_ptr that will not become invalid.

34.4. Allocators
The STL containers (§31.4) and string (Chapter 36) are resource handles that acquire and release memory to hold their elements. To do so, they use allocators. The basic purpose of an allocator is to provide a source of memory for a given type and a place to return that memory to once it is no longer needed. Thus, the basic allocator functions are:

Click here to view code image

p=a.allocate(n);     // acquire space for n objects of type T
a.deallocate(p,n);   // release space for n objects of type T pointed to by p
For example:

Click here to view code image

template<typename T>
struct Simple_alloc {           // use new[] and delete[] to allocate and deallocate bytes
     using value_type = T;

     Simple_alloc() {}

     T* allocate(size_t n)
           { return reinterpret_cast<T*>(new char[n*sizeof(T)]); }
     void deallocate(T* p, size_t n)
           { delete[] reinterpret_cast<char*>(p); }

      //...
};
Simple_alloc happens to be the simplest standards-conforming allocator. Note the casts to and from char*: allocate() does not invoke constructors and deallocate() does not invoke destructors; they deal with memory, not typed objects.

I can build my own allocator to allocate from an arbitrary area of memory:

Click here to view code image

class Arena {
     void* p;
     int s;
public:
     Arena(void* pp, int ss);  // allocate from p[0..ss-1]
};

template<typename T>
struct My_alloc {         // use an Arena to allocate and deallocate bytes
     Arena& a;
     My_alloc(Arena& aa) : a(aa) { }
     My_alloc() {}
      // usual allocator stuff
};
Once Arenas are made, objects can be constructed in the memory allocated:

Click here to view code image

constexpr int sz {100000};
Arena my_arena1{new char[sz],sz};
Arena my_arena2{new char[10*sz],10*sz};

vector<int> v0;     // allocate using default allocator

vector<int,My_alloc<int>> v1 {My_alloc<int>{my_arena1}};      // construct in my_arena1

vector<int,My_alloc<int>> v2 {My_alloc<int>{my_arena2}};      // construct in my_arena2

vector<int,Simple_alloc<int>> v3;                             // construct on free store
Typically, the verbosity would be alleviated by the use of aliases. For example:

Click here to view code image

template<typename T>
    using Arena_vec = std::vector<T,My_alloc<T>>;
template<typename T>
    using Simple_vec = std::vector<T,Simple_alloc<T>>;

My_alloc<complex<double>> Alloc2 {my_arena2};      // named allocator object

Arena_vec<complex<double>> vcd {{{1,2}, {3,4}}, Alloc2};              // explicit allocator
Simple_vec<string> vs {"Sam Vimes", "Fred Colon", "Nobby Nobbs"};     // default allocator
An allocator imposes space overhead in a container only if its objects actually have state (like My_alloc). This is usually achieved by relying on the empty-base optimization (§28.5).

34.4.1. The Default Allocator
A default allocator that allocates using new and deallocates using delete is used (by default) by all standard-library containers.

Click here to view code image

template<typename T>
class allocator {
public:
     using size_type = size_t;
     using difference_type = ptrdiff_t;
     using pointer = T*;
     using const_pointer = const T*;
     using reference = T&;
     using const_reference = const T&;
     using value_type = T;

     template<typename U>
         struct rebind { using other = allocator<U>; };

     allocator() noexcept;
     allocator(const allocator&) noexcept;
     template<typename U>
         allocator(const allocator<U>&) noexcept;
     ~allocator();

     pointer address(reference x) const noexcept;
     const_pointer address(const_reference x) const noexcept;

     pointer allocate(size_type n, allocator<void>::const_pointer hint = 0);     // allocate space for n Ts
     void deallocate(pointer p, size_type n);                                    // deallocate space for n Ts

     size_type max_size() const noexcept;

     template<typename U, typename... Args>
         void construct(U* p, Args&&... args); // new(p) U{args}
     template<typename U>
         void destroy(U* p);                             // p->~U()
};
The curious rebind template is an archaic alias. It should have been:

template<typename U>
using other = allocator<U>;
However, allocator was defined before such aliases were supported by C++. It is provided to allow an allocator to allocate objects of arbitrary type. Consider:

using Link_alloc = typename A::template rebind<Link>::other;
If A is an allocator, then rebind<Link>::other is an alias for allocator<Link>. For example:

Click here to view code image

template<typename T, typename A = allocator<T>>
class list {
private:
     class Link { /* ... */ };

     using Link_alloc = typename A:: template rebind<Link>::other;    // allocator<Link>

     Link_alloc a;  // link allocator

      //...
};
A more restricted specialization of allocator<T> is provided:

Click here to view code image

template<>
class allocator<void> {
public:
     using pointer = void;
     using const_pointer =const void;
     using value_type = void;
     template<typename U> struct rebind { using other = allocator<U>; };
};
This allows us to avoid special cases: We can mention allocator<void> as long as we don’t dereference its pointers.

34.4.2. Allocator Traits
The allocators are “wired together” using allocator_traits. A property of an allocator, say, its pointer type, is found in its trait: allocator_traits<X>::pointer. As usual, the traits technique is used so that I can build an allocator for a type that does not have member types matching the requirements of an allocator, such as int, and a type designed without any thought of allocators.

Basically, allocator_traits provide defaults for the usual set of type aliases and allocator functions. Compared to the default allocator (§34.4.1), address() is missing and select_on_container_copy_construction() is added:

Click here to view code image

template<typename A>                         //§iso.20.6.8
struct allocator_traits {
     using allocator_type = A;
     using value_type = typename A::value_type;
     using pointer = value_type*;                                                   // trick
     using const_pointer = Pointer_traits<pointer>::rebind<const value_type>;      // trick
     using void_pointer = Pointer_traits<pointer>::rebind<void>;                   // trick
     using const_void_pointer = Pointer_traits<pointer>::rebind<const void>;       // trick
     using difference_type = Pointer_traits<pointer>::difference_type;             // trick
     using size_type = Make_unsigned<difference_type>;                             // trick
     using propagate_on_container_copy_assignment = false_type;                    // trick
     using propagate_on_container_move_assignment = false_type;                    // trick
     using propagate_on_container_swap = false_type;                               // trick

     template<typename T> using rebind_alloc = A<T,Args>;                          // trick
     template<typename T> using rebind_traits = Allocator_traits<rebind_alloc<T>>;

     static pointer allocate(A& a, size_type n) { return a.allocate(n); }          // trick
     static pointer allocate(A& a, size_type n, const_void_pointer hint)           // trick
           { return a.allocate(n,hint); }
     static void deallocate(A& a, pointer p, size_type n) { a.deallocate(p, n); }  // trick

     template<typename T, typename ... Args>
           static void construct(A& a, T* p, Args&&... args)                       // trick
           { ::new (static_cast<void*>(p)) T(std::forward<Args>(args)...); }
     template<typename T>
           static void destroy(A& a, T* p) { p–>~T(); }                             // trick

     static size_type max_size(const A& a)                                         // trick
           { return numeric_limits<size_type>::max() }
     static A select_on_container_copy_construction(const A& a) { return a; }     // trick
};
The “trick” is to use the equivalent member of the allocator A if it exists; otherwise, the default specified here. For allocate(n,hint), A::allocate(n) will be called if A has no allocate() taking a hint. The Args are any type arguments needed by A.

I am no fan of trickery in the definition of the standard library, but liberal use of enable_if() (§28.4) allows this to be implemented in C++.

To make the declarations readable, I assume a few type aliases.

34.4.3. Pointer Traits
An allocator uses pointer_traits to determine properties of pointers and proxy types for pointers:

Click here to view code image

template<typename P>                          //§iso.20.6.3
struct pointer_traits {
     using pointer = P;
     using element_type = T;                  // trick: T is the element type of P
     using difference_type = ptrdiff_t;       // trick
     template<typename U>
        using rebind = T*;                    // trick: T is the element type of P

     static pointer pointer_to(a);            // trick
};

template<typename T>
struct pointer_traits<T*>{
     using pointer = T*;
     using element_type = T;
     using difference_type = ptrdiff_t;
     template<typename U>
         using rebind = U*;

     static pointer pointer_to(x) noexcept { return addressof(x); }
};
The “trick” is the same as used by allocator_traits (§34.4.2): to use the equivalent member of the pointer P if it exists; otherwise, the default specified here. To use the T, the template argument P must be the first argument of a Ptr<T,args> template.

This specification does violence to the C++ language.

34.4.4. Scoped Allocators
A rather sneaky problem can occur when using containers and user-defined allocators: Should an element be in the same allocation area as its container? For example, if you use Your_allocator for Your_string to allocate its elements and I use My_allocator to allocate elements of My_vector then which allocator should be used for string elements in My_vector<Your_string>>?



The solution is the ability to tell a container which allocator to pass to elements. The key to that is the class scoped_allocator_adaptor, which provides the mechanism to keep track of an outer allocator (to be used for elements) and an inner allocator (to be passed to elements for their use):

Click here to view code image

template<typename OuterA, typename... InnerA>          // §iso.20.12.1
class scoped_allocator_adaptor : public OuterA {
private:
     using Tr = allocator_traits<OuterA>;
public:
     using outer_allocator_type = OuterA;
     using inner_allocator_type = /* see §iso.20.12.1 */;

     using value_type = typename Tr::value_type;
     using size_type = typename Tr::size_type;
     using difference_type = typename Tr::difference_type;
     using pointer = typename Tr::pointer;
     using const_pointer = typename Tr::const_pointer;
     using void_pointer = typename Tr::void_pointer;
     using const_void_pointer = typename Tr::const_void_pointer;
     using propagate_on_container_copy_assignment = /* see §iso.20.12.2 */;
     using propagate_on_container_move_assignment = /* see §iso.20.12.2 */;
     using propagate_on_container_swap = /* see §iso.20.12.2 */;

      //...
};
We have four alternatives for allocation of vectors of strings:

Click here to view code image

 // vector and string use their own (the default) allocator:
using Svec0 = vector<string>;
Svec0 v0;

 // vector (only) uses My_alloc and string uses its own allocator (the default):
using Svec1 = vector<string,My_alloc<string>>;
Svec1 v1 {My_alloc<string>{my_arena1}};

 // vector and string use My_alloc:
using Xstring = basic_string<char,char_traits<char>, My_alloc<char>>;
using Svec2 = vector<Xstring,scoped_allocator_adaptor<My_alloc<Xstring>>>;
Svec2 v2 {scoped_allocator_adaptor<My_alloc<Xstring>>{my_arena1}};

 // vector uses its own allocator (the default) and string uses My_alloc:
using Xstring2 = basic_string<char, char_traits<char>, My_alloc<char>>;
using Svec3 = vector<xstring2,scoped_allocator_adaptor<My_alloc<xstring>,My_alloc<char>>>;
Svec3 v3 {scoped_allocator_adaptor<My_alloc<xstring2>,My_alloc<char>>{my_arena1}};
Obviously, the first variant, Svec0, will be by far the most common, but for systems with serious memory-related performance constraints, the other versions (especially Svec2) can be important. A few more aliases would make that code a bit more readable, but it is good that this is not the kind of code you have to write every day.

The definition of scoped_allocator_adaptor is somewhat involved, but basically it is an allocator much like the default allocator (§34.4.1) that also keeps track of its “inner” allocator to be passed along for use by contained containers, such as string:

scoped_allocator_adaptor<OuterA,InnerA> (Abbreviated, §iso.20.12.1) (continues)

rebind<T>::other

Alias for a version of this allocator allocating objects of type T

x=a.inner_allocator()

x is the inner allocator; noexcept

x=a.outer_allocator()

x is the outer allocator; noexcept

p=a.allocate(n)

Acquire space for n objects of value_type using OuterA

scoped_allocator_adaptor<OuterA,InnerA> (continued) (Abbreviated, §iso.20.12.1)

p=a.allocate(n,hint)

Acquire space for n objects of value_type using OuterA;

hint is an implementation-dependent help for the allocator;

often, hint is a pointer to an object

to which we would like *p to be near

a.deallocate(p,n)

Free the space for n objects of value_type pointed to by p using OuterA

n=a.max_size()

n is the largest possible number of elements allocated using OuterA

t=a.construct(p,args)

Construct a value_type from args: t=new(p) value_type{args}

a.destroy(p)

Destroy *p: p->-value_type()

34.5. The Garbage Collection Interface
Garbage collection (automatic recycling of unreferenced regions of memory) is sometimes presented as a panacea. It is not. In particular, resources that are not pure memory can be leaked by a garbage collector. Examples are file handles, thread handles, and locks. I see garbage collection as a convenient last resort after the usual techniques for preventing leaks have been exhausted:

[1] Use resource handles with the proper semantics for an application whenever possible. The standard library provides string, vector, unordered_map, thread, lock_guard, and more. Move semantics allow such objects to be efficiently returned from a function.

[2] Use unique_ptrs to hold on to objects that do not implicitly manage their own resources (such as pointers), need to be protected from premature deletion (because they don’t have proper destructors), or need to be allocated in ways that require special attention (deleters).

[3] Use shared_ptrs to hold objects that require shared ownership.

If consistently used, this sequence of techniques ensures the absence of leaks (i.e., no garbage collection is needed because no garbage is generated). However, in a very large number of real-world programs these techniques (all based on RAII; §13.3) are not consistently used and cannot be easily applied because they involve huge amounts of code structured in different ways. These “different ways” often involve complicated pointer uses, naked news and deletes, explicit type conversions that obscure resource ownership, and similar error-prone low-level techniques. In such cases, a garbage collector is an appropriate last resort. It can reclaim/recycle memory, even if it cannot handle non-memory resources. Don’t even think of using general “finalizers” called at collection time to try to deal with non-memory resources. A garbage collector can sometimes extend the running time for leaking systems (even systems that leak non-memory resources) significantly. For example, a garbage collector might extend the time between resource exhaustion from hours to days for a system that is taken down every night for maintenance. Also, a garbage collector can be instrumented to find the sources of leaks.

It is worth remembering that a garbage-collected system can have its own variants of leaks. For example, if we put a pointer to an object into a hash table and forget its key, the object is de facto leaked. Similarly, a resource referred to by an infinite thread can live forever, even if the thread wasn’t meant to be infinite (e.g., it could be waiting for input that never arrives). Sometimes, resources “living” for an excessive time can be as bad for a system as a permanent leak.

From this basic philosophy it follows that garbage collection is optional in C++. A garbage collector will not be invoked unless explicitly installed and activated. A garbage collector is not even a required part of a standard C++ implementation, but good free and commercial collectors are available. C++ provides a definition of what a garbage collector can do if one is used and an ABI (Application Binary Interface) to help control its actions.

The rules for pointers and lifetimes are expressed in terms of safely-derived pointers (§iso.3.7.4.3). A safely-derived pointer is (roughly) “a pointer to something allocated by new or to a subobject thereof.” Here are some examples of pointers that are not safely derived, also known as disguised pointers. Make a pointer point “elsewhere” for a while:

Click here to view code image

int* p = new int[100];
p+=10;
 //... collector may run here ...
p –=10;
*p = 10;  // can we be sure that the int is still there?
Hide the pointer in an int:

Click here to view code image

int* p = new int;
int x = reinterpret_cast<int>(p);      // not even portable
p = nullptr;
 //... collector may run here ...
p = reinterpret_cast<int*>(x);
*p = 10;   // can we be sure that the int is still there?
Write a pointer to a file and read it back later:

Click here to view code image

int* p = new int;
cout << reinterpret_cast<int>(p); // not even portable
p = nullptr;
 //... collector may run here ...
cin >> reinterpret_cast<int&>(p);
*p = 10;  // can we be sure that the int is still there?
Use the “xor trick” (look it up if you need to) to compress doubly-linked lists:

Click here to view code image

struct Link { int value; Link. link; };  // use whatever value type you want

Link* xor2(Link* pre, Link* suc)  // '2' because plain 'xor' is a reserved word
{
     static_assert(sizeof(Link*)<=sizeof(long),"a long is smaller than a pointer");
     return long{pre}^long{suc};
}

void insert_between(Value val, Link* pre, Link* suc)
{
     Link* p = new Link{val,xor(pre,suc)};
     pre–>second = xor(xor(pre–>second,suc),p);
     suc–>second = xor(p,xor(suc–>second,pre));
}
Using that trick, only disguised pointers to links are stored.

Don’t use such tricks in a program you want to be considered well behaved and comprehensible to ordinary mortals – even if you don’t plan to use a garbage collector. There are many more and even nastier tricks, such as scattering the bits of a pointer around in different words.

There are legitimate reasons to disguise pointers (e.g., the xor trick in exceptionally memory-constrained applications), but not as many as some programmers think.

A disguised pointer can still be found by a careful garbage collector if its bitpattern is stored in memory with a wrong type (e.g., long or char[4]) and is still properly aligned. Such pointers are called traceable.

The standard library allows a programmer to specify where there are no pointers to be found (e.g., in an image) and what memory should not be reclaimed even if the collector can’t find a pointer into it (§iso.20.6.4):

Click here to view code image

void declare_reachable(void* p);         // the object pointed to by p must not be collected
template<typename T>
    T* undeclare_reachable(T* p);        // undo a declare_reachable()

void declare_no_pointers(char* p, size_t n);        // p[0:n) holds no pointers
void undeclare_no_pointers(char* p, size_t n);      // undo a declare_no_pointers()
C++ garbage collectors have traditionally been conservative collectors; that is, they do not move objects around in memory and have to assume that every word in memory might contain a pointer. Conservative garbage collection is more efficient than it is reputed to be, especially when a program doesn’t generate much garbage, but declare_no_pointers() can make it very efficient by safely eliminating large parts of memory from consideration. For example, we might use declare_no_pointers() to tell the collector where our photographic images are in an application, so as to allow the collector to ignore potentially gigabytes of non-pointer data.

A programmer can inquire which rules for pointer safety and reclamation are in force:

Click here to view code image

enum class pointer_safety {relaxed, preferred, strict };

pointer_safety get_pointer_safety();
The standard says (§iso.3.7.4.3): “a pointer value that is not a safely-derived pointer value is an invalid pointer value unless the referenced complete object is of dynamic storage duration and has previously been declared reachable ... the effect of using an invalid pointer value (including passing it to a deallocation function) is undefined.”

The enumerators mean:

• relaxed: Safely-derived and not safely-derived pointers are treated equivalently (as in C and C++98). Collect every object that does not have a safely derived or traceable pointer to it.

• preferred: Like relaxed, but a garbage collector may be running as a leak detector and/or a detector of dereferences of “bad pointers.”

• strict: Safely-derived and not safely-derived pointers may be treated differently; that is, a garbage collector may be running and will ignore pointers that are not safely derived.

There is no standard way of saying which alternative you prefer. Consider that a quality-of-implementation issue or a programming environment issue.

34.6. Uninitialized Memory
Most of the time, it is best to avoid uninitialized memory. Doing so simplifies programming and eliminates many kinds of errors. However, in relatively rare cases, such as when writing memory allocators, implementing containers, and dealing directly with hardware, direct use of uninitialized memory, also known as raw memory, is essential.

In addition to the standard allocator, the <memory> header provides the fill* family of functions for dealing with uninitialized memory (§32.5.6). They share the dangerous and occasionally essential property of using a type name T to refer to space sufficient to hold an object of type T rather than to a properly constructed object of type T. These functions are intended primarily for implementers of containers and algorithms. For example, reserve() and resize() are most easily implemented using these functions (§13.6).

34.6.1. Temporary Buffers
Algorithms often require temporary space to perform acceptably. Often, such temporary space is best allocated in one operation but not initialized until a particular location is actually needed. Consequently, the library provides a pair of functions for allocating and deallocating uninitialized space:

Click here to view code image

template<typename T>
    pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t);  // allocate, don't initialize
template<typename T>
    void return_temporary_buffer(T*);                    // deallocate, don't destroy
A get_temporary_buffer<X>(n) operation tries to allocate space for n or more objects of type X. If it succeeds in allocating some memory, it returns a pointer to the first uninitialized space and the number of objects of type X that will fit into that space; otherwise, the second value of the pair is zero. The idea is that a system may keep space ready for fast allocation so that requesting space for n objects of a given size may yield space for more than n. It may also yield less, however, so one way of using get_temporary_buffer() is to optimistically ask for a lot and then use what happens to be available.

A buffer obtained by get_temporary_buffer() must be freed for other use by a call of return_temporary_buffer(). Just as get_temporary_buffer() allocates without constructing, return_temporary_buffer() frees without destroying. Because get_temporary_buffer() is low-level and likely to be optimized for managing temporary buffers, it should not be used as an alternative to new or allocator::allocate() for obtaining longer-term storage.

34.6.2. raw_storage_iterator
The standard algorithms that write into a sequence assume that the elements of that sequence have been previously initialized. That is, the algorithms use assignment rather than copy construction for writing. Consequently, we cannot use uninitialized memory as the immediate target of an algorithm. This can be unfortunate because assignment can be significantly more expensive than initialization, and to initialize immediately before overwriting is a waste. The solution is to use a raw_storage_iterator from <memory> that initializes instead of assigns:

Click here to view code image

template<typename Out, typename T>
class raw_storage_iterator : public iterator<output_iterator_tag,void,void,void,void> {
     Out p;
public:
     explicit raw_storage_iterator(Out pp) : p{pp} { }
     raw_storage_iterator& operator*() { return *this; }

     raw_storage_iterator& operator=(const T& val)
     {
         new(&*p) T{val};    // place val in *p (§11.2.4)
         return *this;
     }

     raw_storage_iterator& operator++() {++p; return *this; }     // pre-increment
     raw_storage_iterator operator++(int)                         // post-increment
     {
         auto t = *this;
         ++p;
         return t;
     }
};
A raw_storage_iterator should never be used to write to initialized data. This tends to limit its use to the depth of implementations of containers and algorithms. Consider generating a set of permutations (§32.5.5) of strings for use in testing:

Click here to view code image

void test1()
{
     auto pp = get_temporary_buffer<string>(1000);     // get uninitialized space
     if (pp.second<1000) {
           //... handle allocation failure ...
     }
     auto p = raw_storage_iterator<string*,string>(pp.first);  // the iterator
     generate_n(p,pp.second,
         [&]{ next_permutation(seed,seed+sizeof(seed)–1); return seed; });
      //...
     return_temporary_buffer(pp.first);
}
This is a somewhat contrived example because I see nothing wrong in allocating default initialized storage for the strings and then assigning the test strings. Also, it fails to use RAII (§5.2, §13.3).

Note that there are no == or != operators for raw_storage_iterator, so don’t try to use it to write to a [b:e) range. For example iota(b,e,0) (§40.6) will not work if b and e are raw_storage_iterators. Don’t mess with uninitialized memory unless you absolutely have to.

34.7. Advice
[1] Use array where you need a sequence with a constexpr size; §34.2.1.

[2] Prefer array over built-in arrays; §34.2.1.

[3] Use bitset if you need N bits and N is not necessarily the number of bits in a built-in integer type; §34.2.2.

[4] Avoid vector<bool>; §34.2.3.

[5] When using pair, consider make_pair() for type deduction; §34.2.4.1.

[6] When using tuple, consider make_tuple() for type deduction; §34.2.4.2.

[7] Use unique_ptr to represent exclusive ownership; §34.3.1.

[8] Use shared_ptr to represent shared ownership; §34.3.2.

[9] Minimize the use of weak_ptrs; §34.3.3.

[10] Use allocators (only) when the usual new/delete semantics is insufficient for logical or performance reasons; §34.4.

[11] Prefer resource handles with specific semantics to smart pointers; §34.5.

[12] Prefer unique_ptr to shared_ptr; §34.5.

[13] Prefer smart pointers to garbage collection; §34.5.

[14] Have a coherent and complete strategy for management of general resources; §34.5.

[15] Garbage collection can be really useful for dealing with leaks in programs with messy pointer use; §34.5.

[16] Garbage collection is optional; §34.5.

[17] Don’t disguise pointers (even if you don’t use garbage collection); §34.5.

[18] If you use garbage collection, use declare_no_pointers() to let the garbage collector ignore data that cannot contain pointers; §34.5.

[19] Don’t mess with uninitialized memory unless you absolutely have to; §34.6.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


34. Memory and Resources
35. Utilities
36. Strings
47h 26m remaining
35. Utilities
The time you enjoy wasting is not wasted time.

– Bertrand Russell

• Introduction

• Time

duration; time_point; Clocks; Time Traits

• Compile-Time Rational Arithmetic

• Type Functions

Type Traits; Type Generators

• Minor Utilities

move() and forward(); swap(); Relational Operators; Comparing and Hashing type_info

• Advice

35.1. Introduction
The standard library provides many “utility components” that are so widely useful that they are not easily classified as part of some major standard-library component.

35.2. Time
In <chrono>, the standard library provides facilities for dealing with time durations and time points. All chrono facilities are in the std::chrono (sub)namespace, so we have to either explicitly qualify with chrono:: or add a using-directive:

using namespace std::chrono;
We often want to time things or to do things that depend on timing. For example, the standard-library mutexes and locks provide the option for a thread to wait for a period of time (a duration) or to wait until a given point in time (a time_point).

If you want to know the current time_point, you can call now() for one of three clocks: system_clock, steady_clock, high_resolution_clock. For example:

Click here to view code image

steady_clock::time_point t = steady_clock::now();
 //... do something ...
steady_clock::duration d = steady_clock::now()–t;     // something took d time units
A clock returns a time_point, and a duration is the difference between two time_points from the same clock. As usual, if you are not interested in details, auto is your friend:

Click here to view code image

auto t = steady_clock::now();
 //... do something ...
auto d = steady_clock::now()–t;    // something took d time units
cout << "something took " << duration_cast<milliseconds>(d).count() << "ms";  // print as milliseconds
The time facilities here are intended to efficiently support uses deep in the system; they do not provide convenience facilities to help you maintain your social calendar. In fact, the time facilities originated with the stringent needs of high-energy physics.

It turns out that “time” is far more complicated to deal with than we usually think. For example, we have leap seconds, clocks that are not accurate and must be adjusted (possibly causing time as reported by a clock to go backward), clocks of differing precision, etc. Furthermore, language facilities for dealing with short time spans (e.g., nanoseconds) must not themselves take significant time. Consequently, the chrono facilities are not simple, but many uses of those facilities can be very simple.

The C-style time utilities can be found in §43.6.

35.2.1. duration
In <chrono>, the standard library provides type duration to represent the time between two points in time (time_points §35.2.2):

Click here to view code image

template<typename Rep, typename Period = ratio<1>>
class duration {
public:
     using rep = Rep;
     using period = Period;
      //...
};
duration<Rep,Period> (§iso.20.11.5)

duration d {}

Default constructor: d becomes {Rep{},Period{}}; constexpr

duration d {r}

Constructor from r;

r must be convertible to Rep without narrowing; constexpr; explicit

duration d {d2}

Copy constructor: d gets the same value as d2;

d2 must be convertible to Rep without narrowing; constexpr

d=d2

d gets the same value as d2; d2 must be representable as a Rep

r=d.count()

r is the number of clock ticks in d; constexpr

We can define a duration with a specific period value. For example:

Click here to view code image

duration<long long,milli> d1 {7};   //7 milliseconds
duration<double,pico> d2 {3.33};    //3.33 picoseconds
duration<int,ratio<1,1>> d3 {};     //0 seconds
A duration’s period holds the number of clock ticks of the period.

cout << d1.count() << '\n';        //7
cout << d2.count() << '\n';        //3.33
cout << d3.count() << '\n';        //0
Naturally, the value of count() depends on the period:

Click here to view code image

d2=d1;
cout << d1.count() << '\n';         //7
cout << d2.count() << '\n';         //7e+009
if (d1!=d2) cerr<<"insane!";
Here, d1 and d2 are equal but report very different count() values.

Care is taken to avoid truncation or loss of precision during initialization (even if the {} notation is not used). For example:

Click here to view code image

duration<int, milli> d {3};          // OK
duration<int, milli> d {3.5};        // error: 3.5 to int is narrowing

duration<int, milli> ms {3};
duration<int, micro> us {ms};        // OK
duration<int, milli> ms2 {us};       // error: we could lose many microseconds
The standard library provides meaningful arithmetic operations on durations:

duration<Rep,Period> (continued) (§iso.20.11.5)

r is a Rep; arithmetic is done in the common_type of the representations

++d

++d.r

d++

duration{d.r++}

--d

--d.r

d--

duration{d.r-- }

+d

d

-d

duration{-d.r}

d+=d2

d.r+=d2.r

d-=d2

d.r-=d2.r

d%=d2

d.r%=d2.r.count()

d%=r

d.r%=r

d*=r

d.r*=r

d/=r

d.r/=r

The period is a unit system, so there is no = or += taking a plain value. Allowing that would be like allowing the addition of 5 of an unknown SI unit to a length in meters. Consider:

Click here to view code image

duration<long long,milli> d1 {7};   //7 milliseconds
d1 += 5;        // error

duration<int,ratio<1,1>> d2 {7};          //7 seconds
d2 = 5;         // error
d2 += 5;        // error
What would 5 mean here? 5 seconds? 5 milliseconds? Something else? If you know what you mean, be explicit about it. For example:

Click here to view code image

d1 += duration<long long,milli>{5};  // OK: milliseconds
d2 += decltype(d2){5};               // OK: seconds
Arithmetic involving durations with different representations is allowed as long as the combination makes sense (§35.2.4):

duration<Rep,Period> (continued) (§iso.20.11.5)

arithmetic is done in the common_type of the representations

d3=d+d2

constexpr

d3=d-d2

constexpr

d2=d*r

ris a Rep; constexpr

d2=r*d

ris a Rep; constexpr

d2=d/x

x is a duration or a Rep; constexpr

d2=d%x

x is a duration or a Rep; constexpr

Comparisons between and explicit conversion between durations with compatible representations are supported:

duration<Rep,Period> (continued) (§iso.20.11.5)

d=zero()

The 0 for Rep: d=duration{duration_values<rep>::zero()};

constexpr

d=min()

The smallest Rep value (less than or equal to zero()): d=duration{duration_values<rep>::min()}; static; constexpr

d=max()

The largest Rep value (larger than or equal to zero()): d=duration{duration_values<rep>::max()}; static; constexpr

d==d2

Comparison is done in the common_type of d and d2; constexpr

d!=d2

!(d==d2)

d<d2

Comparison is done in the common_type of d and d2; constexpr

d<=d2

!(d2<d)

d>d2

Comparison is done in the common_type of d and d2; constexpr

d>=d2

!(d<d2)

d2=duration_cast<D>(d)

Convert duration d to duration type D;

no implicit conversions are used for the representation

or period; constexpr

The standard library provides some convenience aliases using the SI units from <ratio> (§35.3):

Click here to view code image

using nanoseconds = duration<si64,nano>;
using microseconds = duration<si55,micro>;
using milliseconds = duration<si45,milli>;
using seconds = duration<si35>;
using minutes = duration<si29,ratio<60>>;
using hours = duration<si23,ratio<3600>>;
Here, siN means “an implementation-defined signed integer type of at least N bits.”

The duration_cast is used to get a duration with a known unit of measurement. For example:

Click here to view code image

auto t1 = system_clock::now();
f(x);  // do something
auto t2 = system_clock::now();

auto dms = duration_cast<milliseconds>(t2–t1);
cout << "f(x) took " << dms.count() << " milliseconds\n";

auto ds = duration_cast<seconds>(t2–t1);
cout << "f(x) took " << ds.count() << " seconds\n";
The reason we need a cast in this example is that we are throwing away information: on the system I used, the system_clock counts in nanoseconds.

Alternatively, we can simply (try to) construct a suitable duration:

Click here to view code image

auto t1 = system_clock::now();
f(x);  // do something
auto t2 = system_clock::now();

cout << "f(x) took " << milliseconds(t2–t1).count() << " milliseconds\n";         // error: truncation
cout << "f(x) took " << nanoseconds(t2–t1).count() << " microseconds\n";
The precision of a clock is implementation-dependent.

35.2.2. time_point
In <chrono>, the standard library provides type time_point to represent a point in time of a given epoch as measured by a given clock:

Click here to view code image

template<typename Clock, typename Duration = typename Clock::duration>
class time_point {
public:
     using clock = Clock;
     using duration = Duration;
     using rep = typename duration::rep;
     using period = typename duration::period;
      //...
};
An epoch is a range of time determined by a clock, measured in terms of a duration, starting at the duration's zero()(e.g., nanoseconds::zero()).

time_point<Clock,Duration> (§iso.20.11.6)

time_point tp {}

Default constructor: start of epoch: duration::zero()

time_point tp {d}

Constructor: time point d of epoch: time_point{}+d; explicit

time_point tp {tp2}

Constructor: tp refers to the same point in time as tp2;

tp2’s duration type must be implicitly convertible to tp’s

d=tp.time_since_epoch()

d is tp’s stored duration

tp=tp2

tp refers to the same point in time as tp2;

tp2’s duration type must be implicitly convertible to tp’s

For example:

Click here to view code image

void test()
{
     time_point<steady_clock,milliseconds> tp1(milliseconds(100));
     time_point<steady_clock,microseconds> tp2(microseconds(100*1000));

     tp1=tp2;      // error: would truncate
     tp2=tp1;      // OK

     if (tp1!=tp2) cerr << "Insane!";
}
As for durations, meaningful arithmetic and comparisons are supported for time_points:

time_point<Clock,Duration> (continued) (§iso.20.11.6)

tp+=d

Move tp forward: tp.d+=d

tp-=d

Move tp backward: tp.d-=d

tp2=tp+d

tp2=time_point<Clock>{tp.time_since_epoch()+d}

tp2=d+tp

tp2=time_point<Clock>{d+tp.time_since_epoch()}

tp2=tp-d

tp2=time_point<Clock>{tp.time_since_epoch()-d}

d=tp-tp2

d=duration{tp.time_since_epoch()-tp2.time_since_epoch()}

tp=min()

tp=time_point(duration::min()); static; constexpr

tp=max()

tp=time_point(duration::max()); static; constexpr

tp==tp2

tp.time_since_epoch()==tp2.time_since_epoch()

tp!=tp2

!(tp==tp2)

tp<tp2

tp.time_since_epoch()<tp2.time_since_epoch()

tp<=tp2

!(tp2<tp)

tp>tp2

tp2<tp

tp>=tp2

!(tp<tp2)

tp2=time_point_cast<D>(tp)

Convert the time_point tp to time_point<C,D>:

time_point<C,D>(duration_cast<D>(tp.time_since_epoch()))

For example:

Click here to view code image

void test2()
{
     auto tp = steady_clock::now();
     auto d1 = time_point_cast<hours>(tp).time_since_epoch().count()/24;  // days since start of epoch

     using days = duration<long,ratio<24*60*60,1>>;                       // a day's duration
     auto d2 = time_point_cast<days>(tp).time_since_epoch().count();      // days since start of epoch

     if (d1!=d2) cout << "Impossible!\n";
}
The time_point operations that do not access a clock can be constexpr, but are not currently guaranteed to be so.

35.2.3. Clocks
The time_point and duration values are ultimately obtained from hardware clocks. In <chrono>, the standard library provides basic interfaces for clocks. Class system_clock represents “wall clock time” as obtained from a system’s real-time clock:

Click here to view code image

class system_clock {
public:
     using rep = /* implementation-defined signed type */;
     using period = /* implementation-defined ratio<> */;
     using duration = chrono::duration<rep,period>;
     using time_point = chrono::time_point<system_clock>;
      //...
};
All data and function members are static. We don’t explicitly deal with clock objects. Instead, we use clock types:

Clock Members (§iso.20.11.7)

is_steady

Is this clock type steady?

That is, is c.now()<=c.now() for all consecutive calls of now()

and is the time between clock ticks constant? static

tp=now()

tp is system_clock’s time_point for the time of call; noexcept

t=to_time_t(tp)

t is the time_t (§43.6) for the time_point tp; noexcept

tp=from_time_t(t)

tp is the time_point for the time_t t; noexcept

For example:

Click here to view code image

void test3()
{
     auto t1 = system_clock::now();
     f(x);  // do something
     auto t2 = system_clock::now();
     cout << "f(x) took " << duration_cast<milliseconds>(t2–t1).count() << " ms\n";
}
A system provides three named clocks:

Clock Types (§iso.20.11.7)

system_clock

The system’s real-time clock; the system’s clock may be reset

(jump forward or backward) to match external clocks

steady_clock

A clock where time moves steadily forward;

that is, time does not go backward

and the time between clock ticks is constant

high_resolution_clock

A clock with the shortest time increment on a system

These three clocks need not be different; a standard-library clock name may be an alias.

We can determine the basic properties of the clocks like this:

Click here to view code image

cout << "min " << system_clock::duration::min().count()
     << ", max " << system_clock::duration::max().count()
     << ", " << (treat_as_floating_point<system_clock::duration>::value ? "FP" : "integral") << '\n';

cout << (system_clock::is_steady?"steady\n": "not steady\n");
When I ran it on one of my systems, this produced:

Click here to view code image

min –9223372036854775808, max 9223372036854775807, integral
not steady
Different systems and different clocks can give different results.

35.2.4. Time Traits
Implementations of the chrono facilities depend on a few standard facilities, collectively known as time traits.

The conversion rules for duration and time_point depend on whether their representation is floating-point (so that rounding is acceptable) or integral:

Click here to view code image

template<typename Rep>
struct treat_as_floating_point : is_floating_point<Rep> { };
A few standard values are provided:

duration_values<Rep> (§iso.20.11.4.2)

r=zero()

r=Rep(0); static; constexpr

r=min()

r=numeric_limits<Rep>::lowest(); static; constexpr

r=max()

r=numeric_limits<Rep>::max(); static; constexpr

The common type of two durations is determined by computing their greatest common denominator (GCD):

Click here to view code image

template<typename Rep1, typename P1, typename Rep2, typename P2>
struct common_type<duration<Rep1,P1>, duration<Rep2, P2>> {
     using type = duration<typename common_type<Rep1,Rep2>::type, GCD<P1,P2>> ;
};
This makes common_type<duration<R1,P1>,duration<R2,P2>>::type an alias for the duration with the largest tick period that both duration arguments will convert to without requiring a division operation. Thus, it can hold any value from duration<R1,P2> and duration<R2,P2> without truncation error. Howev er, floating-point durations may have round-off errors.

Click here to view code image

template<typename Clock, typename Duration1, typename Duration2>
struct common_type<time_point<Clock, Duration1>, time_point<Clock, Duration2>> {
     using type = time_point<Clock, typename common_type<Duration1, Duration2>::type>;
};
In words, to have a common_type, two time_points must have a common clock type. Their common_type is a time_point with the common_type of their durations.

35.3. Compile-Time Rational Arithmetic
In <ratio>, we find class ratio, which provides compile-time rational arithmetic. The standard library uses ratio to provide a compile-time representation of time duration and time points (§35.2):

template<intmax_t N, intmax_t D = 1>
struct ratio {
     static constexpr intmax_t num;  // (num,den) is (N,D) reduced to the simplest form
     static constexpr intmax_t den;

     using type = ratio<num,den>;
};
The basic idea is to encode the numerator and denominator of a rational number as (value) template arguments. The denominator must always be nonzero.

ratio Arithmetic Operations (§iso.20.10.4)

z=ratio_add<x,y>

z.num=x::num*y::den+y::num*x::den; z.den=x::den*y::den

z=ratio_subtract<x,y>

z.num=x::num*y::den-y::num*x::den; z.den=x::den*y::den

z=ratio_multiply<x,y>

z.num=x::num*y::num; z.den=x::den*y::den

z=ratio_divide<x,y>

z.num=x::num*y::den; z.den=x::den*y::num

ratio_equal<x,y>

x::num==y::num && x::den==y::den

ratio_not_equal<x,y>

!ratio_equal<x,y>::value

ratio_less<x,y>

x::num*y::den < y::num*x::den

ratio_less_equal<x,y>

!ratio_less<y,x>::value

ratio_greater<x,y>

ratio_less<y,x>::value

ratio_greater_equal<x,y>

!ratio_less<x,y>::value

For example:

Click here to view code image

static_assert(ratio_add<ratio<1,3>, ratio<1,6>>::num == 1, "problem: 1/3+1/6 != 1/2");
static_assert(ratio_add<ratio<1,3>, ratio<1,6>>::den == 2, "problem: 1/3+1/6 != 1/2");
static_assert(ratio_multiply<ratio<1,3>, ratio<3,2>>::num == 1, "problem: 1/3*3/2 != 1/2");
static_assert(ratio_multiply<ratio<1,3>, ratio<3,2>>::den == 2, "problem: 1/3*3/2 != 1/2");
Obviously, this is not a convenient way of expressing numbers and arithmetic. In <chrono>, we find the conventional notation (e.g., + and *) for rational arithmetic for time (§35.2). Similarly, to help express unit values, the standard library provides common SI magnitude names:

Click here to view code image

using yocto  = ratio<1,1000000000000000000000000>;      // conditionally supported
using zepto  = ratio<1,1000000000000000000000>;   // conditionally supported
using atto   = ratio<1,1000000000000000000>;
using femto  = ratio<1,1000000000000000>;
using pico   = ratio<1,1000000000000>;
using nano   = ratio<1,1000000000>;
using micro  = ratio<1,1000000>;
using milli  = ratio<1,1000>;
using centi  = ratio<1,100>;
using deci   = ratio<1,10>;
using deca   = ratio<10,1>;
using hecto  = ratio<100,1>;
using kilo   = ratio<1000,1>;
using mega   = ratio<1000000,1>;
using giga   = ratio<1000000000,1>;
using tera   = ratio<1000000000000,1>;
using peta   = ratio<1000000000000000,1>;
using exa    = ratio<1000000000000000000,1>;
using zetta  = ratio<1000000000000000000000,1>;    // conditionally supported
using yotta  = ratio<1000000000000000000000000,1>;       // conditionally supported
For an example of use, see §35.2.1.

35.4. Type Functions
In <type_traits>, the standard library provides type functions (§28.2) to determine properties of types (type traits; §35.4.1) and to generate new types from existing ones (type generators; §35.4.2). These type functions are primarily used at compile time to support simple, and not so simple, metaprogramming.

35.4.1. Type Traits
In <type_traits>, the standard library provides a large set of type functions that allow a programmer to determine properties of a type or a pair of types. Their names are mostly self-explanatory. The primary type predicates test fundamental properties of a type:

Primary Type Predicates (§iso.20.9.4.1)

is_void<X>

Is X void?

is_integral<X>

Is X an integral type?

is_floating_point<X>

Is X a floating-point type?

is_array<X>

Is X a built-in array?

is_pointer<X>

Is X a pointer (not including pointers to members)?

Primary Type Predicates (continued) (§iso.20.9.4.1)

is_lvalue_reference<X>

Is X an lvalue reference?

is_rvalue_reference<X>

Is X an rvalue reference?

is_member_object_pointer<X>

Is X a pointer to a non -static data member?

is_member_function_pointer<X>

Is X a pointer to a non -static member function?

is_enum<X>

Is X an enum (either plain enum or enum class)?

is_union<X>

Is X a union?

is_class<X>

Is X a class (including structs, but not unions)?

is_function<X>

Is X a function?

A type trait returns a value that is used as a Boolean. To access that value, use the suffix ::value. For example:

Click here to view code image

template<typename T>
void f(T& a)
{
     static_assert(std::is_floating_point<T>::value ,"FP type expected");
      //...
}
If you tire of the ::value notation, define a constexpr function (§28.2.2):

Click here to view code image

template<typename T>
constexpr bool Is_floating_point()
{
    return std::is_floating_point<T>::value;
}

template<typename T>
void f(T& a)
{
     static_assert(Is_floating_point<T>(),"FP type expected");
      //...
}
Ideally, use a library that provides such functions for all standard library type traits.

Some type functions inquire about a combination of fundamental properties:

Composite Type Predicates (§iso.20.9.4.2)

is_reference<X>

Is x a reference (lvalue or rvalue reference)?

is_arithmetic<X>

Is x an arithmetic type (integral or floating-point; §6.2.1)?

is_fundamental<X>

Is x a fundamental type (§6.2.1)?

is_object<X>

Is x an object type (not a function)?

is_scalar<X>

Is x a scalar type (not a class or a function)?

is_compound<X>

Is x a compound type (!is_fundamental<X>)?

is_member_pointer<X>

Is x a pointer to a non -static data or function member?

These composite type predicates simply offer notational convenience. For example, is_reference<X> is true if X is either an lvalue reference or an rvalue reference.

Like the primary type predicates, type property predicates provide tests for fundamental aspects of a type:

Type property predicates (§iso.20.9.4.3)

is_const<X>

Is X a const?

is_volatile<X>

Is X a volatile (§41.4)?

is_trivial<X>

Is X a trivial type (§8.2.6)?

is_trivially_copyable<X>

Can X be copied, moved, and destroyed

as a simple collection of bits (§8.2.6)?

is_standard_layout<X>

Is X a standard-layout type (§8.2.6)?

is_pod<X>

Is X a POD (§8.2.6)?

is_literal_type<X>

Does X have a constexpr constructor (§10.4.3)?

is_empty<X>

Does X have a member that requires space in an object?

is_polymorphic<X>

Does X have a virtual function?

is_abstract<X>

Does X have a pure virtual function?

is_signed<X>

Is X an arithmetic type and signed?

is_unsigned<X>

Is X an arithmetic type and unsigned?

is_constructible<X,args>

Can an X be constructed from args?

is_default_constructible<X>

Can an X be constructed from {}?

is_copy_constructible<X>

Can an X be constructed from an X&?

is_move_constructible<X>

Can an X be constructed from an X&&?

is_assignable<X,Y>

Can a Y be assigned to an X?

is_copy_assignable<X>

Can a X& be assigned to an X?

is_move_assignable<X>

Can a X&& be assigned to an X?

is_destructible<X>

Can an X be destroyed (i.e., ~X() has not been deleted)?

For example:

Click here to view code image

template<typename T>
class Cont {
     T* elem;  // store elements in an array pointed to by elem
     size_t sz;   // sz elements
      //...
     Cont(const Cont& a)      // copy constructor
         :elem{new T[a.sz]}, sz{a.sz}
     {
         static_assert(Is_copy_constructable<T>(),"Cont::Cont(): no copy");
         if (Is_trivially_copyable<T>())
                memcpy(elem,a.elem,sz*sizeof(T));     // memcopy optimization
         else
                uninitialized_copy(a.begin(),a.end(),elem);  // use copy constructors
     }
      //...
};
This optimization may be unnecessary, though, because uninitialized_copy() is likely to already have been optimized in this way.

For a class to be empty, it can have no virtual functions, no virtual bases, and no base classes for which !is_empty<Base>::value.

The type property predicates don’t do access checking depending on where they are used. Instead, they consistently give the result you would expect for a use outside members and friends. For example:

Click here to view code image

class X {
public:
     static void inside();
private:
     X& operator=(const X&);
     ~X();
};

void X::inside()
{
     cout << "inside =: " << is_copy_assignable<X>::value << '\n';
     cout << "inside ~: " << is_destructible<X>::value << '\n';
}

void outside()
{
     cout << "outside =: " << is_copy_assignable<X>::value << '\n';
     cout << "outside ~: " << is_destructible<X>::value << '\n';
}
Both inside() and outside() will write 00 to report that an X is neither destructible nor copy assignable. Also, if you want to eliminate an operation, use =delete (§17.6.4) rather than relying as private.

Type Property Predicates (continued) (§iso.20.9.4.3)

is_trivially_constructible<X,args>

Can X be constructed from args

using only trivial operations?

is_trivially_default_constructible<X>

 

is_trivially_copy_constructible<X>

§8.2.6

is_trivially_move_constructible<X>

 

is_trivially_assignable<X,Y>

 

is_trivially_copy_assignable<X>

 

is_trivially_move_assignable<X>

 

is_trivially_destructible<X>

 

For example, consider how we might optimize the destructor for a container type:

Click here to view code image

template<class T>
Cont::~Cont()          // destructor for a container Cont
{
    if (!Is_trivially_destructible<T>())
           for (T* p = elem; p!=elem+sz; ++p)
                 p–>~T();
}
Type Property Predicates (continued) (§iso.20.9.4.3)

is_nothrow_constructible<X,args>

Can X be constructed from args using only noexcept operations?

is_nothrow_default_constructible<X>

 

is_nothrow_copy_constructible<X>

 

is_nothrow_move_constructible<X>

 

is_nothrow_assignable<X,Y>

 

is_nothrow_copy_assignable<X>

 

is_nothrow_move_assignable<X>

 

is_nothrow_destructible<X>

 

has_virtual_destructor<X>

Does X have a virtual destructor?

Like sizeof(T), a property query returns a numeric value related to a type argument:

Type Property Queries (§iso.20.9.5)

n=alignment_of<X>

n=alignof(X)

n=rank<X>

If X is an array, n is the number of dimensions; otherwise n==0

n=extent<X,N>

If X is an array, n is the number of elements in the Nth dimension;

otherwise n==0

n=extent<X>

n=extent<X,0>

For example:

Click here to view code image

template<typename T>
void f(T a)
{
     static_assert(Is_array<T>(), "f(): not an array");
     constexpr int dn {Extent<T,2>()};      // the number of elements in the 2nd dimension (zero based)
      //..
}
Here, I again used constexpr versions of the type functions returning numeric values (§28.2.2).

The type relations are predicated on two types:

Type Relations (§iso.20.9.6)

is_same<X,Y>

Is X the same type as Y?

is_base_of<X,Y>

Is X a base of Y?

is_convertible<X,Y>

Can an X be implicitly converted to a Y?

For example:

Click here to view code image

template<typename T>
void draw(T t)
{
     static_assert(Is_same<Shape*,T>() || Is_base_of<Shape,Remove_pointer<T>>(), "");
     t–>draw();
}
35.4.2. Type Generators
In <type_traits>, the standard library provides type functions for producing a type given other types as arguments.

const and volatile Modification (§iso.20.9.7.1)

remove_const<X>

Like X, but with any top-level const removed

remove_volatile<X>

Like X, but with any top-level volatile removed

remove_cv<X>

Like X, but with any top-level const or volatile removed

add_const<X>

If X is a reference, function, or const, then X; otherwise const X

add_volatile<X>

If X is a reference, function, or volatile, then X; otherwise volatile X

add_cv<X>

Add const and volatile: add_const<typename add_volatile<T>::type>::type

A type transformer returns a type. To access that type, use the suffix ::type. For example:

Click here to view code image

template<typename K, typename V>
class My_map {
     pair<typename add_const<K>::type,V> default_node;
      //...
};
If you tire of the typename and the ::type define a type alias (§28.2.1):

Click here to view code image

template<typename T>
using Add_const = typename add_const<T>::type;

template<typename K, typename V>
class My_map {
     pair<Add_const<K>,V> default_node;
     //...
};
Ideally, use a support library that provides such aliases systematically for the standard-library type transformers.

Reference Modification (§iso.20.9.7.2, §iso.20.9.7.6)

remove_reference<X>

If X is a reference type, the referred-to type; otherwise, X

add_lvalue_reference<X>

If X is an rvalue reference Y&&, Y&; otherwise, X&

add_rvalue_reference<X>

If X is a reference, X; otherwise, X&& (§7.7.3)

decay<X>

The type passed by value for a function argument of type X

The decay functions handle array decay as well as reference dereferencing.

The type functions for adding and removing references are important for writing templates that should work with an argument that may or may not be a reference. The remove_reference modifier is primarily used for functions that take rvalue references and need to deal with objects of the argument type, rather than references. For example:

Click here to view code image

template<typename T>
void f(T&& v) // T may deduce to T& (§23.5.2.1)
{
     Remove_reference<T> x = v;   // copy of v
     T y = v;                     // maybe copy of v; maybe a reference to v
     ++y;
     vector<Remove_reference<T>> vec1; // OK
    vector<T> vec2; // an error if T is a reference (§7.7.4)
      //...
}
Click here to view code image

void user()
{
     int val = 7;
     f(val);     // call f<int&>(): the ++y in f() will increment val
     f(7);       // call f<int>(): the ++y in f will increment a local copy
}
The different behavior of ++y for lvalue and rvalue arguments to f() could be an unpleasent surprise. Fortunately, the definition of vec2 prevents instantiation of f() with an lvalue argument.

Sign Modification (§iso.20.9.7.3)

make_signed<X>

Remove any (explicit or implied) unsigned modifier

and add signed;

X must be an integral type (except bool or an enumeration)

make_unsigned<X>

Remove any (explicit or implied) signed modifier

and add unsigned;

X must be an integral type (except bool or an enumeration)

For built-in arrays, we sometimes want to get the element type or to remove a dimension:

Array Modification (§iso.20.9.7.4)

remove_extent<X>

If X is an array type, the element type; otherwise X

remove_all_extents<X>

If X is an array type, the base type

(after removing all array modifiers); otherwise X

For example:

Click here to view code image

int a[10][20];
Remove_extent<decltype(a)> a10;  // an array[20]; [10] is removed
Remove_all_extents<decltype(a)> i;     // an int: [10][20] is removed
cout << Extent<decltype(a20)>() << ' ' << Extent<decltype(i)>() << '\n';  // prints 20 0
We can make a pointer type pointing to an arbitrary type, or find the pointed-to type:

Pointer Modification (§iso.20.9.7.5)

remove_pointer<X>

If X is a pointer type, the pointed-to type; otherwise X

add_pointer<X>

remove_reference<X>::type*

For example:

Click here to view code image

template<typename T>
void f(T&&x)
{
     Add_pointer<T> p = new Remove_reference<T>{};
     T* p2 = new T{};    // would not work if T is a reference
      //...
}
When dealing with memory at the lowest levels of a system, we must sometimes consider alignment (§6.2.9):

Alignments (§iso.20.9.7.6)

aligned_storage<n,a>

A POD type with size of at least n and whose alignment is

a divisor of a

aligned_storage<n>

aligned_storage<n,def> where def is the largest alignment

required for any object type, T, with sizeof(T)<=n

aligned_union<n,X... >

A POD type with size of at least n

that can hold a union with members of type X

The standard mentions this as a possible implementation of aligned_storage:

Click here to view code image

template<std::size_t N, std::size_t A>
struct aligned_storage {
     using type = struct { alignas(A) unsigned char data[N]; };    // N chars aligned to A (§6.2.9)
};
The final type functions for type selection, computing common types, etc. are arguably the most useful:

Other Transformations (§iso.20.9.7.6)

enable_if<b,X>

X if b==true; otherwise there is no member ::type,

leading to substitution failure (§23.5.3.2) for most uses

enable_if<b>

enable_if<b,void>

conditional<b,T,F>

T if b==true; otherwise F

common_type<X>

The common type of all types of a parameter pack X;

two types are common if they can be used as true

and false types of a ?:-expression

underlying_type<X>

X’s underlying type (§8.4); X must be an enumeration

result_of<FX>

The type of the result of F(X); FX must be

a type F(X) where F is invoked with an argument list X

For examples of enable_if and conditional, see §28.3.1.1 and §28.4.

It is often useful to find a type that can be used for operations on more than one type, such as the result of an addition of two values of related but different types. The type function common_type finds such common types. A type is the common type of itself (obviously):

template<typename... T>
struct common_type;

template<typename T>
struct common_type<T> {
     using type = T;
};
The common type of two types is what the rules for ?: (§11.1.3) give us:

Click here to view code image

template<typename T, typename U>
struct common_type<T, U> {
     using type = decltype(true ? declval<T>() : declval<U>());
};
The declval<T>() type function returns the type of an unevaluated variable of type T.

The common type for N types is found by applying the rules for and N==2 recursively:

Click here to view code image

template<typename T, typename U, typename ... V>
struct common_type<T, U, V...> {
     using type = typename common_type<typename common_type<T, U>::type, V...>::type;
};
For example:

Click here to view code image

template<typename... T>
using Common_type = typename common_type<T...>::type;

Common_type<int,double> x1;                // x1 is a double
Common_type<int,string> x2;                // error: no common type
Common_type<int,short,long,long long> x3;  // x3 is a long long
Common_type<Shape*,Circle*> x4;            // x4 is a Shape*
Common_type<void*,double*,Shape*> x5;      // x5 is a void*
Result_of is used to extract the type of the result of a callable type:

Click here to view code image

int ff(int) { return 2; }                       // function

typedef bool (*PF)(int);                        // pointer to function

struct Fct {                                    // function object
     double operator()(string);
     string operator()(int,int);
};

auto fx = [](char ch) { return tolower(ch,locale()); };  // lambda; see also §39.5.1

Result_of<decltype(&ff)()> r1 = 7;          // r1 is an int
Result_of<PF(int)> r2 = true;               // r2 is a bool
Result_of<Fct(string)> r3 = 9.9;            // r3 is a double
Result_of<Fct(int,int)> r4 = "Hero";        // r4 is a string
Result_of<decltype(fx)(char)> r5 = 'a';     // r5 is a char
Note that Result_of can distinguish between the two versions of Fct::operator()().

Curiously enough, the same does not apply to nonmember functions. For example:

Click here to view code image

int f();                               
string f(int);  // over load f()
Result_of<decltype(&f)()>r1 = 7;       // error: no overload resolution for pointer to function
Unfortunately, we don’t do overload resolution for pointers to functions, but why did I use Result_of in such a roundabout way, instead of:

Click here to view code image

Result_of<ff> r1 = 7;                  // error: no argument specification,
                                       // and ff is a function rather than a type
Result_of<ff()> r1 = 7;                // error: the argument to Result_of must be a type
Result_of<decltype(f)()> r2 = 7;       // error: decltype(f) is a function type
                                       // rather than a pointer to function type
Result_of<decltype(f)*()> r3 = 7;      // OK: r3 is an int
Result_of<decltype(ff(2))> r4 = 7;     // error : ff(2) is an int, rather than a function
Naturally, Result_of is usually found in templates where we can’t easily look up the answer in the program text. For example:

Click here to view code image

template<typename F, typename A>
auto temp(F f, A a) –> Result_of<F(A)>
{
     return f(a);
}

void f4()
{
     int x = temp(ff,1);
     char c = temp(fx,'a');
     double d = temp(Fct(),"Ulysses");
}
Note that the function ff is converted to a pointer to function in the call, so the reliance on pointers to functions in Result_of isn’t as odd as it may seem at first.

declval() (§iso.20.2.4)

declval<T>()

Returns an rvalue for T: typename add_rvalue_reference<T>::type;

never use a return value of declval

The declval() type function is unusual in the standard library because it is actually a function (without users needing to wrap it). It returns a value that must never be used. The intent is to use declval<X> as a type where the type of a variable of type X is needed. For example:

Click here to view code image

template<typename T, size_t N>
:: void array<T,N> swap(array& y) noexcept(noexcept(swap(declval<T&>(), declval<T&>())))
{
     for (int i=0; i<a.size(); ++i)
           swap((*this)[i],a[i]);
}
See also the definition of common_type.

35.5. Minor Utilities
These utilities are minor in size, but not in importance. They don’t fit into a larger grouping.

35.5.1. move() and forward()
In <utility>, we find some of the most useful small functions:

Other Transformations (§iso.20.9.7.6)

x2=forward(x)

x2 is an rvalue; x; noexcept

x2=move(x)

x2 is an rvalue; noexcept

x2=move_if_noexcept(x)

If x can be moved, x2=move(x); otherwise x2=x; noexcept

A move() is simply a cast to an rvalue:

Click here to view code image

template<typename T>
Remove_reference<T>&& move(T&& t) noexcept
{
   return static_cast<Remove_reference<T>&&>(t);
}
In my opinion, move() should have been called rvalue(), because it doesn’t actually move anything. Instead, it produces an rvalue for its argument, so that the object referred to can be moved from.

A move() is used to tell the compiler that an object will not be used anymore in a context, so that its value can be moved and an empty object left behind. The simplest example is the implementation of swap() (§35.5.2).

A forward() produces an rvalue from an rvalue only:

Click here to view code image

template<typename T>
T&& forward(Remove_reference<T>& t) noexcept
{
    return static_cast<T&&>(t);
}

template<typename T>
T&& forward(Remove_reference<T>&& t) noexcept;
{
    static_assert(!Is_lvalue_reference<T>,"forward of lvalue");
    return static_cast<T&&>(t);
}
This pair of forward() functions are meant always to be available together, and selection between them should be done by overload resolution. In that case, any lvalue goes to the first version and every rvalue to the second. For example:

int i = 7;
forward(i);        // call first version
forward(7);        // call second version
The assert is there for programmer who are too clever for their own good and calls the second version with an explicit template argument and an lvalue.

The archetypical use of forward() is for “perfect forwarding” of an argument from one function to another (§23.5.2.1, §28.6.3). The standard-library make_shared<T>(x) (§34.3.2) is a good example.

Use move() when the intent is to “steal the representation” of an object with a move operation, and use forward() for forwarding. Thus, forward(x) is safe, whereas move(x) marks x for destruction so that move(x) should be used with care. The only safe use of an x after a move(x) is destruction or as a target for an assignment. Obviously a particular type could provide further guarantees, and ideally the class’s invariant is left intact. However, don’t rely on that unless you really know.

35.5.2. swap()
In <utility>, the standard library provides a general swap() and a specialization for built-in arrays:

Other Transformations (§iso.20.2.2)

swap(x,y)

Exchange the values of x and y;

x and y are passed as non -const references;

noexcept if x’s and y’s copy operations are noexcept

swap(a1n,a2n)

a1n and a2n are passed as references to arrays: T(&)[N];

noexcept if *a1n and *a2n’s copy operations are noexcept

The relatively obvious implementation swap() is:

Click here to view code image

template<typename T>
void swap(T& a, T& b) noexcept(Is_nothrow_move_constructible<T>()
                          && Is_nothrow_move_assignable<T>())
{
     T tmp {move(a)};
     a = move(b);
     b = move(tmp);
}
This implies that swap() cannot be used to exchange rvalues:

Click here to view code image

vector<int> v{1,2,3,4};
swap(v,vector<int>{});         // error: second argument is an rvalue
v.clear();                    // clearer (less obscure)
35.5.3. Relational Operators
In <utility>, we find relational operators for arbitrary types in a sub-namespace rel_ops:

Relational Operators in std::rel_ops (§iso.20.2.1)

x!=y

!(x==y)

x>y

y<x

x<=y

!(y<x)

x>=y

!(x<y)

This requires that the programmer has made sure that x==y and x<y work.

For example:

Click here to view code image

bool operator==(Val v) const { /* ... */ }
     bool operator<(Val v) const { /* ... */ }
     // ...
};

void my_algo(vector<Val>& vv)
{
     using namespace std::rel_ops;

     for (int i=0; i<vv.size(); ++i)
           if (Val{0}>vv[i])  // OK: > from rel_ops
                 vv[i]=abs(vv[i]);
}
It can be hard to use rel_ops without polluting a namespace. In particular:

Click here to view code image

namespace Mine {
   struct Val {
        // ...
   };

   using namespace std::rel_ops;
}
This could expose the perfectly general templates from rel_ops to be found by argument-dependent lookup (§14.2.4) and applied to types for which they may be inappropriate. A safer approach is to place using-directives in local scopes.

35.5.4. Comparing and Hashing type_info
In <typeindex>, the standard library provides support for comparing and hashing type_indexs. A type_index is created from a type_info (§22.5), specifically to allow such comparison and hashing.

type_index Operations (§iso.20.13)

tip is a pointer to the type_info represented by a type_index

type_index tx {ti};

tx represents the type_info ti; noexcept

tx==tx2

tx and tx2 represent the same type_info: *tx.tip==*tx2.tip; noexcept

tx!=tx2

!(tx==tx2); noexcept

tx<tx2

tx.tip->before(tx2.tip); noexcept

tx<=tx2

!tx2.tip->before(tx.tip); noexcept

tx>tx2

tx2.tip->before(tx.tip); noexcept

tx>=tx2

!tx.tip->before(tx2.tip); noexcept

n=tx.hash_code()

n=tx.tip->hash_code()

p=tx.name()

p = tx.tip->name()

hash<type_index>

A specialization of hash (§31.4.3.4)

For example:

Click here to view code image

unordered_map<type_index,type_info*> types;
 //...
types[type_index{something}] = &typeid(something);
35.6. Advice
[1] Use <chrono> facilities, such as steady_clock, duration, and time_point for timing; §35.2.

[2] Prefer <clock> facilities over <ctime> facilities; §35.2.

[3] Use duration_cast to get durations in known units of time; §35.2.1.

[4] Use system_clock::now() to get the current time; §35.2.3.

[5] You can inquire about properties of types at compile time; §35.4.1.

[6] Use move(obj) only when the value of obj cannot be used again; §35.5.1.

[7] Use forward() for forwarding; §35.5.1.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


35. Utilities
36. Strings
37. Regular Expressions
47h 26m remaining
36. Strings
Prefer the standard to the offbeat.

– Strunk & White

• Introduction

• Character Classification

Classification Functions; Character Traits

• Strings

string vs. C-Style Strings; Constructors; Fundamental Operations; String I/O; Numeric Conversions; STL-like Operations; The find Family; Substrings

• Advice

36.1. Introduction
The standard library offers character classification operations in <cctype> (§36.2), strings with associated operations in <string> (§36.3), regular expression matching in <regex> (Chapter 37), and support for C-style strings in <cstring> (§43.4). Handling of different character sets, encodings, and conventions (locales) is discussed in Chapter 39.

A simplified string implementation is presented in §19.3.

36.2. Character Classification
The standard library provides classification functions to help users to manipulate strings (and other character sequences) and traits specifying properties of a character type to help implementers of operations on strings.

36.2.1. Classification Functions
In <cctype>, the standard library provides functions to classify the characters from the basic execution character set:

Character Classification

isspace(c)

Is c whitespace (space '', horizontal tab '\t', newline '\n', vertical tab '\v',

form feed '\f', carriage return '\r')?

isblank(c)

Is c a blank (space '', or horizontal tab '\t')?

isalpha(c)

Is c a letter ('a'..'z', 'A'..'Z')? note: not underscore '_'

isdigit(c)

Is c a decimal digit ('0'..'9')?

isxdigit(c)

Is c hexadecimal digit (decimal digit or 'a'..'f' or 'A'..'F')?

isupper(c)

Is c an uppercase letter?

islower(c)

Is c a lowercase letter?

isalnum(c)

isalpha(c) or isdigit(c)

iscntrl(c)

Is c a control character (ASCII 0..31 and 127)?

ispunct(c)

Is c not a letter, digit, whitespace, or invisible control character?

isprint(c)

Is c printable (ASCII ''..'~')?

isgraph(c)

isalpha(c) or isdigit(c) or ispunct(c)? note: not space

In addition, the standard library provides two useful functions for removing case differences:

Upper- and Lowercase

toupper(c)

c or c’s uppercase equivalent

tolower(c)

c or c’s lowercase equivalent

The equivalent functions for wide characters are provided in <cwctype>.

The character classification functions are sensitive to the "C" locale (§39.5.1, §39.5.2). Equivalent functions for other locales are provided in <locale> (§39.5.1).

One reason that these character classification functions are useful is that character classification can be trickier than it might appear. For example, a novice might write:

if ('a'<=ch && ch<'z')  // a character
This is more verbose (and most likely slower) than:

if (islower(ch))       // a lowercase character
Also, there is no guarantee that the characters are contiguous in a code space. Furthermore, the use of standard character classifications are far easier to convert to another locale (§39.5.1):

Click here to view code image

if (islower(ch,danish))    // a lowercase character in Danish
                           //(assuming "danish" is the name for a Danish locale)
Note that Danish has three more lowercase characters than English, so that the initial explicit test using 'a' and 'z' would be flat wrong.

36.2.2. Character Traits
As shown in §23.2, a string template can, in principle, use any type with proper copy operations as its character type. However, efficiency can be improved and implementations can be simplified for types that don’t have user-defined copy operations. Consequently, the standard string requires that a type used as its character type be a POD (§8.2.6). This also helps to make I/O of strings simple and efficient.

The properties of a character type are defined by its char_traits. A char_traits is a specialization of the template:

template<typename C> struct char_traits { };
All char_traits are defined in std, and the standard ones are presented in <string>. The general char_traits itself has no properties; only char_traits specializations for a particular character type have. Consider char_traits<char>:

Click here to view code image

template<>
struct char_traits<char> {    // char_traits operations should not throw exceptions
     using char_type = char;
     using int_type = int;             // type of integer value of character
     using off_type = streamoff;       // offset in stream
     using pos_type = streampos;       // position in stream
     using state_type = mbstate_t;     // multibyte stream state (§39.4.6)
      //...
};
The standard provides four specializations of char_traits (§iso.21.2.3):

Click here to view code image

template<> struct char_traits<char>;
template<> struct char_traits<char16_t>;
template<> struct char_traits<char32_t>;
template<> struct char_traits<wchar_t>;
The members of the standard char_traits are all static functions:

char_traits<C> static Members (§iso.21.2)

c=to_char_type(i)

int_type to char_type conversion

i=to_int_type(c)

char_type to int_type conversion

eq_int_type(c,c2)

to_int_type(c)==to_int_type(c2)

eq(c,c2)

Is c treated as equal to c2?

lt(c,c2)

Is c treated as less than c2?

i=compare(p,p2,n)

Lexicographical compare of [p:p+n) and [p2:p2+n)

assign(c,c2)

c=c2 for char_type

p2=assign(p,n,c)

Assign n copies of c to [p:p+n); p2=p

p3=move(p,p2,n)

Copy [p2:p2+n)to [p:p+n); [p:p+n) and [p2:p2+n) may overlap; p3=p

p3=copy(p,p2,n)

Copy [p2:p2+n)to [p:p+n); [p:p+n) and [p2:p2+n) may not overlap; p3=p

char_traits<C> static Members (§iso.21.2)

n=length(p)

n is the number of characters in [p:q)

where *q is the first element so that eq(q,charT{})

p2=find(p,n,c)

p2 points to the first occurrence of c in [p:p+n)or nullptr

i=eof()

i is the int_type value representing end-of-file

i2=not_eof(i)

i2=i if !eq_int_type(i,eof()); otherwise i2 can be any value not equal to eof()

Comparing with eq() is often not simply an ==. For example, a case-insensitive char_traits would define its eq() so that eq('b','B') would return true.

Because copy() does not protect against overlapping ranges, it may be faster than move(). The compare() function uses lt() and eq() to compare characters. It returns an int, where 0 represents an exact match, a negative number means that its first argument comes lexicographically before the second, and a positive number means that its first argument comes after its second.

The I/O-related functions are used by the implementation of low-level I/O (§38.6).

36.3. Strings
In <string>, the standard library provides a general string template basic_string:

Click here to view code image

template<typename C,
         typename Tr = char_traits<C>,
         typename A = allocator<C>>
class basic_string {
public:
     using traits_type = Tr;
     using value_type = typename Tr::char_type;
     using allocator_type = A;
     using size_type = typename allocator_traits<A>::size_type;
     using difference_type = typename allocator_traits<A>::difference_type;
     using reference = value_type&;
     using const_reference = const value_type&;
     using pointer = typename allocator_traits<A>::pointer;
     using const_pointer = typename allocator_traits<A>::const_pointer;
     using iterator = /* implementation-defined */;
     using const_iterator = /* implementation-defined */;
     using reverse_iterator = std::reverse_iterator<iterator>;
     using const_reverse_iterator = std::reverse_iterator<const_iterator>;

     static const size_type npos = –1;   // integer representing end-of-string

      //...
};
The elements (characters) are stored contiguously, so that low-level input operations can safely use a basic_string’s sequence of characters as a source or target.

The basic_string offers the strong guarantee (§13.2): if a basic_string operation throws, the string is left unchanged.

Specializations are offered for a few standard character types:

Click here to view code image

using string = basic_string<char>;
using u16string = basic_string<char16_t>;
using u32string = basic_string<char32_t>;
using wstring = basic_string<wchar_t>;
All these strings provide a host of operations.

Like containers (Chapter 31), basic_string is not meant to be used as a base class and offers move semantics so that it can be efficiently returned by value.

36.3.1. string vs. C-Style Strings
I assume some familiarity with string from the many examples in this book, so I start with a few examples contrasting string use with the use of C-style strings (§43.4) which are popular with programmers primarily familiar with C and C-style C++.

Consider making up an email address by concatenating a user identifier and a domain name:

Click here to view code image

string address(const string& identifier, const string& domain)
{
     return identifier + '@' + domain;
}

void test()
{
     string t = address("bs","somewhere");
     cout << t << '\n';
}
This is trivial. Now consider a plausible C-style version. A C-style string is a pointer to an array of zero-terminated characters. The user controls allocation and is responsible for deallocation:

Click here to view code image

char* address(const char* identifier, const char* domain)
{
     int iden_len = strlen(identifier);
     int dom_len = strlen(domain);
     char* addr = (char*)malloc(iden_len+dom_len+2);       // remember space for 0 and '@'
     strcpy(addr,identifier);
     addr[iden_len] = '@';
     strcpy(addr+iden_len+1,domain);
     return addr;
}

void test2()
{
     char* t = address("bs","somewhere");
     printf("%s\n",t);
     free(t);
}
Did I get that right? I hope so. At least it gave the output I expected. Like most experienced C programmers, I got the C version correct (I hope) the first time, but there are a lot of details to get right. However, experience (i.e., error logs) shows that this is not always the case. Often, such simple programming tasks are given to relative novices who still don’t know all the techniques needed to get it right. The implementation of the C-style address() contains a lot of tricky pointer manipulation, and its use requires the caller to remember to free the returned memory. Which code would you prefer to maintain?

Sometimes, it is claimed that C-style strings are more efficient than strings. However, for most uses, the string does fewer allocations and deallocations than a C-style equivalent (because of the small-string optimization and move semantics; §19.3.3, §19.3.1). Also, strlen() is an log(N) operation, whereas string::size() is a simple read. In the example, this implies that the C-style code traverses each input string twice, whereas the string version does only one traversal per input. Efficiency concerns at this level are often misguided, but the string version has a fundamental edge.

The fundamental difference between C-style strings and string is that string is a proper type with conventional semantics, whereas the C-style string is a set of conventions supported by a few useful functions. Consider assignment and comparison:

Click here to view code image

void test3()
{
     string s1 = "Ring";
     if (s1!="Ring") insanity();
     if (s1<"Opera")cout << "check";
     string s2 = address(s1,"Valkyrie");

     char s3[] = "Ring";
     if (strcmp(s3,"Ring")!=0) insanity();
     if (strcmp(s3,"Opera")<0) cout << "check";
     char* s4 = address(s3,"Valkyrie");
     free(s4);
}
Finally, consider sorting:

Click here to view code image

void test4()
{
     vector<string> vs = {"Grieg", "Williams", "Bach", "Handel" };
     sort(vs.begin(),vs.end());    // assuming that I haven't defined sort(vs)

     const char* as[] = {"Grieg", "Williams", "Bach", "Handel" };
     qsort(as,sizeof(*as),sizeof(as)/sizeof(*as),(int(*)(const void*,const void*))strcmp);
}
The C-style string sort function qsort() is presented in §43.7. Again, sort() is as fast as (and typically much faster than) qsort(), so there is no performance reason to choose the lower-level, more verbose, and less maintainable programming style.

36.3.2. Constructors
A basic_string offers a bewildering variety of constructors:

basic_string<C,Tr,A> Constructors (§iso.21.4.2)

x can be a basic_string, a C-style string, or an initializer_list<char_type>

basic_string s {a};

s is an empty string with allocator a; explicit

basic_string s {};

Default constructor: basic_string s {A{}};

basic_string s {x,a};

s gets the characters from x; use allocator a

basic_string s {x};

Move and copy constructor: basic string s {x,A{}};

basicstring s {s2,pos,n,a};

s gets the characters s2[pos:pos+n); use allocator a

basicstring s {s2,pos,n};

basic_string s {s2,pos,n,A{}};

basic_string s {s2,pos};

basic_string s {s2,pos,string::npos,A{}};

basic_string s {p,n,a};

Initialize s from [p:p+n); p is a C-style string; use allocator a

basic_string s {p,n};

basic_string s {p,n,A{}};

basic_string s {n,c,a};

s holds n copies of the character c; use allocator a

basic_string s(n,c);

basic_string s {n,c,A{}};

basic_string s {b,e,a};

s gets the characters from [b:e); use allocator a

basic_string s {b,e};

basic_string s {b,e,A{}};

s.-basic_string()

Destructor: free all resources

s=x

Copy: s gets the characters from x

s2=move(s)

Move: s2 gets the characters from s; noexcept

The most common variants are also the simplest:

Click here to view code image

string s0;                           // the empty string
string s1 {"As simple as that!"};    // construct from C-style string
string s2 {s1};                      // copy constructor
Almost always, the destructor is implicitly invoked.

There is no string constructor that takes only a number of elements:

Click here to view code image

string s3 {7};        // error: no string(int)
string s4 {'a'};      // error: no string(char)
string s5 {7,'a'};    // OK: 7 'a's
string s6 {0};        // danger: passing nullptr
The declaration of s6 shows a mistake sometimes made by programmers used to C-style strings:

const char* p = 0;      // set p to "no string"
Unfortunately, the compiler cannot catch the definition of s6 or the even nastier case of a const char* holding the nullptr:

Click here to view code image

string s6 {0};        // danger: passing nullptr
string s7 {p};        // may or may not be OK depending on the value of p
string s8 {"OK"};     // OK: pass pointer to C-style string
Don’t try to initialize a string with a nullptr. At best, you get a nasty run-time error. At worst, you get mysterious undefined behavior.

If you try to construct a string with more characters than your implementation can handle, the constructor throws std::length_error. For example:

string s9 {string::npos,'x'};   // throw length_error
The value string::npos represents a position beyond a string’s length and is generally used to mean “the end of the string.” For example:

Click here to view code image

string ss {"Fleetwood Mac"};
string ss2 {ss,0,9};                 //"Fleetwood"
string ss3 {ss,10,string::npos};     //"Mac"
Note that the substring notation is (position,length) rather than [start,end).

There are no literals of type string. A user-defined literal could be used for that (§19.2.6), for example, "The Beatles"s and "Elgar"s. Note the s suffix.

36.3.3. Fundamental Operations
A basic_string offers comparisons, control of size and capacity, and access operations.

basic_string<C,Tr,A> Comparisons (§iso.21.4.8)

s or s2 but not both can be a C-style string

s==s2

Is s equal to s2? compares character values using traits_type

s!=s2

!(s==s2)

s<s2

Is s lexicographically before s2?

s<=s2

Is s lexicographically before or equal to s2?

s>s2

Is s lexicographically after s2?

s>=s2

Is s lexicographically after or equal to s2?

For more comparison operations, see §36.3.8.

The size and capacity mechanisms for basic_string are the same as those for vector (§31.3.3):

basic_string<C,Tr,A> Size and Capacity (§iso.21.4.4)

n=s.size()

n is the number of characters in s

n=s.length()

n=s.size()

n=s.max_size()

n is the largest possible value of s.size()

s.resize(n,c)

Make s.size()==n; added elements get the value c

s.resize(n)

s.resize(n,C{})

s.reserve(n)

Ensure that s can hold n characters without further allocation

s.reserve()

No effect: s.reserve(0)

n=s.capacity()

s can hold n characters without further allocation

s.shrink_to_fit()

Make s.capacity()==s.size()

s.clear()

Make s empty

s.empty()

Is s empty?

a=s.get_allocator()

a is s’s allocator

A resize() or reserve() that would cause size() to exceed max_size() will throw std::length_error.

An example:

Click here to view code image

void fill(istream& in, string& s, int max)
      // use s as target for low-level input (simplified)
{
     s.reserve(max);                // make sure there is enough allocated space
     in.read(&s[0],max);
     const int n = in.gcount();     // number of characters read
     s.resize(n);
     s.shrink_to_fit();             // discard excess capacity
}
Here, I “forgot” to make use of the number of characters read. That’s sloppy.

basic_string<C,Tr,A> Access (§iso.21.4.5)

s[i]

Subscripting: s[i] is a reference to the ith element of s;

no range check

s.at(i)

Subscripting: s.at(i) is a reference to the ith element of s;

throw out_of_range if s.size()<=i

s.front()

s[0]

s.back()

s[s.size()-1]

s.push_back(c) s.pop_back()

Append the character c

Remove the last character from s: s.erase(s.size()-1)

s+=x

Append x at the end of s; x can be a character, a string,

a C-style string, or an initializer_list<char_type>

s=s1+s2

Concatenation: optimized version of s=s1; s+=s2;

n2=s.copy(p,n,pos)

copy characters from s[pos:pos+n2) to p[0:n2)

where n2 is min(n,s.size()-pos);

 

p is a C-style string, assumed to have at least n2 characters

throw out_of_range if s.size()<=pos

n2=s.copy(p,n)

n2=s.copy(p,n,0)

p=s.c_str()

p is a C-style string version (zero-terminated) of

the characters in s;a const C*

p=s.data()

p=s.c_str()

s.swap(s2)

Exchange the values of s and s2; noexcept

swap(s,s2)

s.swap(s2)

An out-of-range access using at() throws std::out_of_range. A +=(), push_back(), or + that would cause size() to exceed max_size() will throw std::length_error.

There is no implicit conversion of a string to a char*. That was tried in many places and found to be error-prone. Instead, the standard library provides the explicit conversion function c_str() to const char*.

A string can contain a zero value character (e.g., '\0'). Using a function, such as strcmp(), that assumes C-style string conventions on the result of s.c_str() or s.data() on a string containing a zero character may cause surprise.

36.3.4. String I/O
A basic_string can be written using << (§38.4.2) and read into using >> (§38.4.1):

basic_string<C,Tr,A> I/O Operations (§iso.21.4.8.9)

in>>s

Read a whitespace-separated word into s from in

out<<s

Write s to out

getline(in,s,d)

Read characters from in into s until the character

d is encountered; d is removed from in but not appended to s

getline(in,s)

getline(in,s,VT) where '\n' is widened to match the string’s character type

An input operation that would cause size() to exceed max_size() will throw std::length_error.

A getline() removes its terminator character (by default '\n') from the input stream but does not enter it into the string. This simplifies handling of lines. For example:

vector<string> lines;
for (string s; getline(cin,s);)
      lines.push_back(s);
The string I/O operations all return a reference to their input stream, so that operations can be chained. For example:

string first_name;
string second_name;
cin >> first_name >> second_name;
The string target of an input operation is set to empty before reading and expands to hold the characters read. A read operation can also be terminated by reaching end-of-file (§38.3).

36.3.5. Numeric Conversions
In <string>, the standard library provides a set of functions for extracting numeric values from their character representation in a string or wstring (note: not a basic_string<C,Tr,A>). The desired numeric types are encoded in the function names:

Numeric Conversions (§iso.21.5) (continues)

s can be a string or a wstring

x=stoi(s,p,b)

String to int; x is an integer; read starting with s[0]

if p!=nullptr, *p is set to the number of characters used for x;

b is the base of the number (between 2 and 36, inclusive)

x=stoi(s,p)

x=stoi(s,p,10); decimal numbers

x=stoi(s)

x=stoi(s,nullptr,10); decimal numbers; don’t report the character count

x=stol(s,p,b)

String to long

x=stoul(s,p,b)

String to unsigned long

x=stoll(s,p,b)

String to long long

x=stoull(s,p,b)

String to unsigned long long

Numeric Conversions (continued) (§iso.21.5)

s can be a string or a wstring

x=stof(s,p)

String to float

x=stod(s,p)

String to double

x=stold(s,p)

String to long double

s=to_string(x)

s is a string representation of x; x must be an integer or floating-point value

ws=to_wstring(x)

s is a wstring representation of x; x must be an integer or floating-point value

Each of these sto* (String to) functions has three variants, like stoi. For example:

string s = "123.45";
auto  x1 = stoi(s);       // x1 = 123
auto  x2 = stod(s);       // x2 = 123.45
The second argument of a sto* function is a pointer used to indicate how far into the string the search for a numeric value progressed. For example:

Click here to view code image

string ss = "123.4567801234";
size_t dist = 0;              // put number of characters read here
auto x = stoi(ss,&dist);      // x = 123 (an int)
++dist;                       // ignore the dot
auto y = stoll(&ss[dist]);    // x = 4567801234 (a long long)
This is not my favorite interface for parsing several numbers from a string. I prefer to use a string_stream (§38.2.2).

Initial whitespace is skipped. For example:

string s = " 123.45";
auto  x1 = stoi(s);            // x1 = 123
The base argument can be in the range [2:36] with the 0123456789abcdefghijklmnopqrstuvwxyz used as “digits” with their value determined by their position in this sequence. Any further base value will be an error or an extension. For example:

Click here to view code image

string s4 = "149F";
auto x5 = stoi(s4);                 // x5 = 149
auto x6 = stoi(s4,nullptr,10);      // x6 = 149
auto x7 = stoi(s4,nullptr,8);       // x7 = 014
auto x8 = stoi(s4,nullptr,16);      // x8 = 0x149F

string s5 = "1100101010100101";     // binary
auto x9 = stoi(s5,nullptr,2);       // x9 = 0xcaa5
If a conversion function doesn’t find characters in its string argument that it can convert to a number, it throws invalid_argument. If it finds a number that it cannot represent in its target type, it throws out_of_range; in addition, the conversions set errno to ERANGE (§40.3). For example:

Click here to view code image

stoi("Hello, World!");               // throws std::invalid_argument
stoi("12345678901234567890");        // throws std::out_of_range; errno=ERANGE
stof("123456789e1000");              // throws std::out_of_range; errno=ERANGE
The sto* functions encode their target type in their names. This makes them unsuitable for generic code where the target can be a template parameter. In such cases, consider to<X> (§25.2.5.1).

36.3.6. STL-like Operations
The basic_string provides the usual set of iterators:

basic_string<C,Tr,A> String Iterators (§iso.21.4.3)

All operations are noexcept

p=s.begin()

p is an iterator to the first character of s

p=s.end()

p is an iterator to one beyond the end of s

p=s.cbegin()

p is a const_iterator to the first character

p=s.cend()

p is a const_iterator to one beyond the end of s

p=s.rbegin()

p is the beginning of the reverse sequence for s

p=s.rend()

p is the end of the reverse sequence for s

p=s.crbegin()

p is a const_iterator to the beginning of the reverse sequence for s

p=s.crend()

p is a const_iterator to the end of the reverse sequence for s

Because string has the required member types and the functions for obtaining iterators, strings can be used together with the standard algorithms (Chapter 32). For example:

Click here to view code image

void f(string& s)
{
     auto p = find_if(s.begin(),s.end(),islower);
      //...
}
The most common operations on strings are supplied directly by string. Hopefully, these versions will be optimized for strings beyond what would be easy to do for general algorithms.

The standard algorithms (Chapter 32) are not as useful for strings as one might think. General algorithms tend to assume that the elements of a container are meaningful in isolation. This is typically not the case for a string.

A basic_string offers complex assignment()s:

basic_string<C,Tr,A> Assignment (§iso.21.4.6.3)

All operations return the string to which they are applied

s.assign(x)

s=x; x can be a string, a C-style string, or an initializer_list<char_type>

s.assign(move(s2))

Move: s2 is a string; noexcept

s.assign(s2,pos,n)

s gets the characters s2[pos:pos+n)

s.assign(p,n)

s gets the characters [p:p+n); p is a C-style string

s.assign(n,c)

s gets n copies of the character c

s.assign(b,e)

s gets the characters from [b:e)

We can insert(), append(), and erase() in a basic_string:

basic_string<C,Tr,A> Insertion and Deletion (§iso.21.4.6.2, §iso.21.4.6.4, §iso.21.4.6.5)

Unless otherwise stated, operations return the string to which they are applied

s.append(x)

Append x at the end of s; x can be a character, a string, a C-style string, or an initializer_list<char_type>

s.append(b,e)

Append [b:e) at the end of s

s.append(s2,pos,n)

Append s2[pos:pos+n) to the end of s

s.append(p,n)

Append the characters [p:p+n) to the end of s; p is a C-style string

s.append(n,c)

Append n copies of character c to the end of s

s.insert(pos,x)

Insert x before s[pos]; x can be a string or a C-style string

s.insert(pos,n,c)

Insert n copies of the character c before s[pos]

s.insert(pos,s2,pos2,n)

Insert s2[pos2:pos2+n) before s[pos]

s.insert(pos,p,n)

Insert the characters [p:p+n) before s[pos]

p2=s.insert(p,x)

Insert x before iterator p;

x can be a character or an initializer_list<char_type>;

p2 points to the first element inserted or p if x=={}

p2=s.insert(p,n,c)

Insert n copies of c before iterator p;

p2 points to the first element inserted or p if n==0

p2=s.insert(p,b,e)

Insert [b:e) before iterator p;

p2 points to the first element inserted or p if b==e

s.erase()

Make s the empty string

s.erase(pos)

Remove trailing characters from s: s becomes s[0:pos]

s.erase(pos,n)

Remove s[pos:pos+n-1]; s.size() becomes max(pos,s.size()-n)

p2=s.erase(p)

Remove the character referred to by iterator p;

p2 points to the element after p

p2=s.erase(b,e)

Remove the characters in [b:e); p2 points to e

For example:

Click here to view code image

void add_middle(string& s, const string& middle)      // add middle name
{
     auto p = s.find(' ');
     s.insert(p,' '+middle);
}

void test()
{
     string dmr = "Dennis Ritchie";
     add_middle(dmr,"MacAlistair");
     cout << dmr << '\n';
}
As for vectors, append()ing (adding characters at the end) is typically more efficient than insert()ing elsewhere.

In the following, I use s[b:e) to denote a sequence of elements [b:e) in s:

basic_string<C,Tr,A> Replace (§iso.21.4.6.6) (continues)

All operations return the string to which they are applied

s.replace(pos,n,s2,pos2,n2)

Replace s[pos:pos+n) with s2[pos2:pos2+n2)

s.replace(pos,n,p,n2)

Replace s[pos:pos+n) with [p:p+n2); p is a C-style string

s.replace(pos,n,s2)

Replace s[pos:pos+n) with s2; s2 is a string or a C-style string

s.replace(pos,n,n2,c)

Replace s[pos:pos+n) with n2 copies of the character c

s.replace(b,e,x)

Replace [b:e) with x; x is a string, a C-style string, or an initializer_list<char_type>

s.replace(b,e,p,n)

Replace [b:e) with [p:p+n); p is a C-style string

s.replace(b,e,n,c)

Replace [b:e) with n copies of the character c

s.replace(b,e,b2,e2)

Replace [b:e) with [b2:e2)

The replace() function replaces one substring with another and adjusts the string’s size accordingly. For example:

Click here to view code image

void f()
{
     string s = "but I have heard it works even if you don't believe in it";
     s.replace(0,4,"");                         // erase initial "but "
     s.replace(s.find("even"),4,"only");
     s.replace(s.find(" don't"),6,"");          // erase by replacing with ""
     assert(s=="I have heard it works only if you believe in it");
}
Code relying on “magic” constants like the number of characters to be replaced is error-prone.

A replace() function returns a reference to the object for which it was called. This can be used for chaining operations:

Click here to view code image

void f2()
{
     string s = "but I have heard it works even if you don't believe in it";
     s.replace(0,4,"").replace(s.find("even"),4,"only").replace(s.find(" don't"),6,"");
     assert(s=="I have heard it works only if you believe in it");
}
36.3.7. The find Family
There is a bewildering variety of functions for finding substrings. As usual, find() searches from s.begin() onward, whereas rfind() searches backward from s.end(). The find functions use string::npos (“not a position”) to represent “not found.”

basic_string<C,Tr,A> Find Element (§iso.21.4.7.2)

x can be a character, a string, or a C-style string. All operations are noexcept

pos=s.find(x,pos2)

Find x in s[pos2,s.size()); pos is the index of the first match or string::npos

pos=s.find(x)

Find x in s: pos=s.find(x,0)

pos=s.find(p,pos2,n)

pos=s.find(basic_string{p,n},pos2)

pos=s.rfind(x,pos2)

Find x in s[0:pos2); pos is the position of the first character

of the x closest to the end of s or string::npos

pos=s.rfind(x)

pos=s.rfind(x,string::npos)

pos=s.rfind(p,pos2,n)

pos=s.rfind(basic_string{p,n},pos2)

For example:

Click here to view code image

void f()
{
     string s {"accdcde"};

     auto i1 = s.find("cd");       // i1==2 s[2]=='c' && s[3]=='d'
     auto i2 = s.rfind("cd");      // i2==4 s[4]=='c' && s[5]=='d'
}
The find_*_of() functions differ from find() and rfind() by looking for a single character, rather than a whole sequence of characters:

basic_string<C,Tr,A> Find Elements from a Set (§iso.21.4.7.4)

x can be a character, a string, or a C-style string; p is a C-style string. All operations are noexcept.

pos2=s.find_first_of(x,pos)

Find a character from x in s[pos:s.size());

pos2 is the position of the first character from x

in s[pos:s.size()) or string::npos

pos=s.find_first_of(x)

pos=s.find_first_of(x,0)

pos2=s.find_first_of(p,pos,n)

pos2=s.find_first_of(basic_string{p,n},pos)

pos2=s.find_last_of(x,pos)

Find a character from x in s[0:pos);

pos2 is the position of the character from x

closest to the end of s or string::npos

pos=s.find_last_of(x)

pos=s.find_last_of(x,0)

pos2=s.find_last_of(p,pos,n)

pos2=s.find_last_of(basic_string{p,n},pos)

pos2=s.find_first_not_of(x,pos)

Find a character not from x in s[pos:s.size());

pos2 is the position of the first character not from x

in s[pos:s.size()) or string::npos

pos=s.find_first_not_of(x)

pos=s.find_first_not_of(x,0)

pos2=s.find_first_not_of(p,pos,n)

pos2=s.find_first_not_of(basic_string{p,n},pos)

pos2=s.find_last_not_of(x,pos)

Find a character not from x in s[0:pos);

pos2 is the position of the character not

from x closest to the end of s or string::npos

pos=s.find_last_not_of(x)

pos=s.find_last_not_of(x,string::npos)

pos2=s.find_last_not_of(p,pos,n)

pos2=s.find_last_not_of(basic_string{p,n},pos)

For example:

Click here to view code image

string s {"accdcde"};

auto i3 = s.find_first_of("cd");            // i3==1 s[1]=='c'
auto i4 = s.find_last_of("cd");             // i4==5 s[5]=='d'

auto i5 = s.find_first_not_of("cd");        // i5==0 s[0]!='c' && s[0]!='d'
auto i6 = s.find_last_not_of("cd");         // i6==6 s[6]!='c' && s[6]!='d'
36.3.8. Substrings
A basic_string offers a low-level notion of substring:

basic_string<C,Tr,A> Substrings (§iso.21.4.7.8)

s2=s.substr(pos,n)

s2=basic_string(&s[pos],m) where m=min(s.size()-pos,n)

s2=s.substr(pos)

s2=s.substr(pos,string::npos)

s2=s.substr()

s2=s.substr(0,string::npos)

Note that substr() creates a new string:

Click here to view code image

void user()
{
     string s = "Mary had a little lamb";
     string s2 = s.substr(0,4);       // s2 == "Mary"
     s2 = "Rose";                     // does not change s
}
We can compare substrings:

basic_string<C,Tr,A> Compare (§iso.21.4.7.9)

n=s.compare(s2)

A lexicographical comparison of s and s2;

using char_traits<C>::compare() for comparison;

n=0 if s==s2; n<0 if s<s2; n>0 if s>s2; noexcept;

n2=s.compare(pos,n,s2) n2=s.compare(pos,n,s2,pos2,n2)

n2=basic_string{s,pos,n}.compare(s2) n2=basic_string{s,pos,n}.compare(basic_string{s2,pos2,n2})

n=s.compare(p)

n=s.compare(basic_string{p});

p is a C-style string

n2=s.compare(pos,n,p)

n2=basic_string{s,pos,n}.compare(basic_string{p});

p is a C-style string

n2=s.compare(pos,n,p,n2)

n2=basic_string{s,pos,n}.compare(basic_string{p,n2});

p is a C-style string

For example:

Click here to view code image

void f()
{
     string s = "Mary had a little lamb";
     string s2 = s.substr(0,4);       // s2 == "Mary"
     auto i1 = s.compare(s2);         // i1 is positive
     auto i2 = s.compare(0,4,s2);     // i2==0
}
This explicit use of constants to denote positions and lengths is brittle and error-prone.

36.4. Advice
[1] Use character classifications rather than handcrafted checks on character ranges; §36.2.1.

[2] If you implement string-like abstractions, use character_traits to implement operations on characters; §36.2.2.

[3] A basic_string can be used to make strings of characters on any type; §36.3.

[4] Use strings as variables and members rather than as base classes; §36.3.

[5] Prefer string operations to C-style string functions; §36.3.1.

[6] Return strings by value (rely on move semantics); §36.3.2.

[7] Use string::npos to indicate “the rest of the string”; §36.3.2.

[8] Do not pass a nullptr to a string function expecting a C-style string; §36.3.2.

[9] A string can grow and shrink, as needed; §36.3.3.

[10] Use at() rather than iterators or [] when you want range checking; §36.3.3, §36.3.6.

[11] Use iterators and [] rather than at() when you want to optimize speed; §36.3.3, §36.3.6.

[12] If you use strings, catch length_error and out_of_range somewhere; §36.3.3.

[13] Use c_str() to produce a C-style string representation of a string (only) when you have to; §36.3.3.

[14] string input is type sensitive and doesn’t overflow; §36.3.4.

[15] Prefer a string_stream or a generic value extraction function (such as to<X>) over direct use of str* numeric conversion functions; §36.3.5.

[16] Use the find() operations to locate values in a string (rather than writing an explicit loop); §36.3.7.

[17] Directly or indirectly, use substr() to read substrings and replace() to write substrings; §36.3.8.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


36. Strings
37. Regular Expressions
38. I/O Streams
47h 26m remaining
37. Regular Expressions
If the code and the comments disagree, then both are probably wrong.

– Norm Schryer

• Regular Expressions

Regular Expression Notation

• regex

Match Results; Formatting

• Regular Expression Functions

regex_match(); regex_search(); regex_replace()

• Regular Expression Iterators

regex_iterator; regex_token_iterator

• regex_traits

• Advice

37.1. Regular Expressions
In <regex>, the standard library provides support for regular expressions:

• regex_match(): Match a regular expression against a string (of known size).

• regex_search(): Search for a string that matches a regular expression in an (arbitrarily long) stream of data.

• regex_replace(): Search for strings that match a regular expression in an (arbitrarily long) stream of data and replace them.

• regex_iterator: Iterate over matches and submatches.

• regex_token_iterator: Iterate over non-matches.

The result of a regex_search() is a collection of matches, typically represented as an smatch:

Click here to view code image

void use()
{
     ifstream in("file.txt");      // input file
     if (!in) cerr << "no file\n";

     regex pat {R"(\w{2}\s*\d{5}(–\d{4})?)"};   // U.S. postal code pattern

     int lineno = 0;
     for (string line; getline(in,line); ) {
           ++lineno;
           smatch matches;     // matched strings go here
           if (regex_search(line, matches, pat)) {
                 cout << lineno << ": " << matches[0] << '\n';  // the complete match
                 if (1<matches.size() && matches[1].matched)
                       cout << "\t: " << matches[1] << '\n'; // submatch
           }
     }
}
This function reads a file looking for U.S. postal codes, such as TX77845 and DC 20500–0001. An smatch type is a container of regex results. Here, matches[0] is the whole pattern and matches[1] is the optional four-digit subpattern. I used a raw string (§7.3.2.1) which is particularly suitable for regular expressions because they tend to contain a lot of backslashes. Had I used a conventional string, the pattern definition would have been:

regex pat {"\\w{2}\\s*\\d{5}(–\\d{4})?"};   // U.S. postal code pattern
The regular expression syntax and semantics are designed so that regular expressions can be compiled into state machines for efficient execution [Cox,2007]. The regex type performs this compilation at run time.

37.1.1. Regular Expression Notation
The regex library can recognize several variants of the notation for regular expressions (§37.2). Here, I first present the default notation used, a variant of the ECMA standard used for ECMAScript (more commonly known as JavaScript).

The syntax of regular expressions is based on characters with special meaning:

Regular Expression Special Characters

·

Any single character (a “wildcard”)

\

Next character has a special meaning

[

Begin character class

*

Zero or more (suffix operator)

]

End character class

+

One or more (suffix operator)

{

Begin count

?

Optional (zero or one) (suffix operator)

}

End count

|

Alternative (or)

(

Begin grouping

^

Start of line; negation

)

End grouping

$

End of line

For example, we can specify a line starting with zero or more As followed by one or more Bs followed by an optional C like this:

^A*B+C?$
Examples that match:

AAAAAAAAAAAABBBBBBBBBC
BC
B
Examples that do not match:

AAAAA        // no B
  AAAABC     // initial space
AABBCC       // too many Cs
A part of a pattern is considered a subpattern (which can be extracted separately from an smatch) if it is enclosed in parentheses.

A pattern can be optional or repeated (the default is exactly once) by adding a suffix:

Repetition

{n}

Exactly n times

{n,}

n or more times

{n,m}

At least n and at most m times

*

Zero or more, that is, {0,}

+

One or more, that is, {1,}

?

Optional (zero or one), that is {0,1}

For example:

A{3}B{2,4}C*
Examples that match:

AAABBC
AAABBB
Example that do not match:

AABBC         // too few As
AAABC         // too few Bs
AAABBBBBCCC   // too many Bs
A suffix ? after any of the repetition notations (i.e., *, +, ?, and {...}) makes the pattern matcher “lazy” or “non-greedy.” That is, when looking for a pattern, it will look for the shortest match rather than the longest. By default, the pattern matcher always looks for the longest match (similar to C++’s Max Munch rule; §10.3). Consider:

ababab
The pattern (ab)* matches all of ababab. However, (ab)*? matches only the first ab.

The most common character classifications have names:

Character Classes

[:alnum:]

Any alphanumeric character

[:alpha:]

Any alphabetic character

[:blank:]

Any whitespace character that is not a line separator

[:cntrl:]

Any control character

[:d:]

Any decimal digit

[:digit:]

Any decimal digit

[:graph:]

Any graphical character

[:lower:]

Any lowercase character

[:print:]

Any printable character

[:punct:]

Any punctuation character

[:s:]

Any whitespace character

[:space:]

Any whitespace character

[:upper:]

Any uppercase character

[:w:]

Any word character (alphanumeric characters plus the underscore)

[:xdigit:]

Any hexadecimal digit character

Several character classes are supported by shorthand notation:

Character Class Abbreviations

\d

A decimal digit

[[:digit:]]

\s

A space (space, tab, etc.)

[[:space:]]

\w

A letter (a-z) or digit (0-9) or underscore (_)

[_[:alnum:]]

\D

Not \d

[[:digit:]]

\S

Not \s

[[:space:]]

\W

Not \w

[“_[:alnum:]]

In addition, languages supporting regular expressions often provide:

Nonstandard (but Common) Character Class Abbreviations

\l

A lowercase character

[[:lower:]]

\u

An uppercase character

[[:upper:]]

\L

Not \l

[^[:lower:]]

\U

Not \u

[[:upper:]]

For full portability, use the character class names rather than these abbreviations.

As an example, consider writing a pattern that describes C++ identifiers: an underscore or a letter followed by a possibly empty sequence of letters, digits, or underscores. To illustrate the subtleties involved, I include a few false attempts:

Click here to view code image

[:alpha:][:alnum:]*              // wrong: characters from the set ":alph" followed by ...
[[:alpha:]][[:alnum:]]*          // wrong: doesn't accept underscore ('_' is not alpha)
([[:alpha:]]|_)[[:alnum:]]*      // wrong: underscore is not part of alnum either
([[:alpha:]]|_)([[:alnum:]]|_)*        // OK, but clumsy
[[:alpha:]_][[:alnum:]_]*              // OK: include the underscore in the character classes
[_[:alpha:]][_[:alnum:]]*              // also OK
[_[:alpha:]]\w*                        //\w is equivalent to [_[:alnum:]]
Finally, here is a function that uses the simplest version of regex_match() (§37.3.1) to test whether a string is an identifier:

bool is_identifier(const string& s)
{
     regex pat {"[_[:alpha:]]\\w*"};
     return regex_match(s,pat);
}
Note the doubling of the backslash to include a backslash in an ordinary string literal. As usual, backslashes can also denote special characters:

Special Characters (§iso.2.14.3, §6.2.3.2)

\n

Newline

\t

Tab

\\

One backslash

\xhh

Unicode characters expressed using two hexadecimal digits

\uhhhh

Unicode characters expressed using four hexadecimal digits

To add to the opportunities for confusion, two further logically different uses of the backslash are provided:

Special Characters (§iso.28.5.2, §37.2.2)

\b

The first or last character of a word (a ‘‘boundary character’’)

\B

Not a \b

\i

The ith sub_match in this pattern

Using raw string literals alleviates many problems with special characters. For example:

bool is_identifier(const string& s)
{
     regex pat {R"([_[:alpha:]]\w*)"};
     return regex_match(s,pat);
}
Here are some examples of patterns:

Click here to view code image

Ax*             // A, Ax, Axxxx
Ax+             // Ax, Axxx     Not A
\d–?\d          //1-2, 12      Not 1--2
\w{2}–\d{4,5}   // Ab-1234, XX-54321, 22-5432       Digits are in \w
(\d*:)?(\d+)    //12:3, 1:23, 123, :123  Not 123:
(bs|BS)         // bs, BS       Not bS
[aeiouy]        // a, o, u      An English vowel, not x
[^aeiouy]       // x, k         Not an English vowel, not e
[a^eiouy]       // a, ^, o, u   An English vowel or ^
A group (a subpattern) potentially to be represented by a sub_match is delimited by parentheses. If you need parentheses that should not define a subpattern, use (?: rather than plain (. For example:

(\s|:|,)*(\d*)    // spaces, colons, and/or commas followed by a number
Assuming that we were not interested in the characters before the number (presumably separators), we could write:

(?:\s|:|,)*(\d*)   // spaces, colons, and/or commas followed by a number
This would save the regular expression engine from having to store the first characters: the (?: variant has only one subpattern.

Regular Expression Grouping Examples

\d*\s\w+

No groups (subpatterns)

(\d*)\s(\w+)

Two groups

(\d*)(\s(\w+))+

Tw o groups (groups do not nest)

(\s*\w*)+

One group, but one or more subpatterns;

only the last subpattern is saved as a sub_match

<(.*?)>(.*?)</\1>

Three groups; the \1 means ‘‘same as group 1’’

That last pattern is useful for parsing XML. It finds tag/end-of-tag markers. Note that I used a non-greedy match (a lazy match), .*?, for the subpattern between the tag and the end tag. Had I used plain .*, this input would have caused a problem:

Always look on the <b>bright</b> side of <b>life</b>.
A greedy match for the first subpattern would match the first < with the last >. A greedy match on the second subpattern would match the first <b> with the last </b>. Both would be correct behavior, but unlikely what the programmer wanted.

It is possible to vary details of the regular expression notation using options (§37.2). For example, if regex_constants::grep is used, a?x:y is a sequence of five ordinary characters because ? does not mean “optional” in grep.

For a more exhaustive presentation of regular expressions, see [Friedl,1997].

37.2. regex
A regular expression is a matching engine (usually a state machine) constructed from a sequence of characters, such as a string:

Click here to view code image

template<typename C, typename Tr = regex_traits<C>>
class basic_regex {
public:
     using value_type = C;
     using traits_type = Tr;
     using string_type = typename Tr::string_type;
     using flag_type = regex_constants::syntax_option_type;
     using locale_type = typename Tr::locale_type;
     ~basic_regex(); //not virtual; basic_regex is not meant to be used as a base class
     //...
};
The regex_traits are presented in §37.5.

Like string, regex is an alias for the version that uses chars:

using regex = basic_regex<char>;
The meaning of regular expression patterns is controlled by syntax_option_type constants defined identically in regex_constants and regex:

basic_regex<C,Tr> Member Constants (syntax_option_type, §iso.28.5.1)

icase

No case is used when matching

nosubs

No subexpression matches are stored in the match results

optimize

Prefer fast matching to fast regular expression object construction

collate

Character ranges of the form [a-b] are locale sensitive

ECMAScript

The regular expression grammar is the one used by ECMAScript

in ECMA-262 (with minor modifications; §iso.28.13)

basic

The regular expression grammar is the one used by

basic regular expressions in POSIX

extended

The regular expression grammar is the one used by

extended regular expressions in POSIX

awk

The regular expression grammar is the one used by POSIX awk

grep

The regular expression grammar is the one used by POSIX grep

egrep

The regular expression grammar is the one used by POSIX grep -E

Use the default unless you have a good reason not to. Good reasons include a large body of existing regular expressions in a non-default notation.

A regex object can be constructed from a string or similar sequence of characters:

basic_regex<C,Tr> Constructors (§iso.28.8.2)

basic_regex r {};

Default constructor: an empty pattern;

flags set to regex_constants::ECMAScript

basic_regex r {x,flags};

x can be a basic_regex, a string,

a C-style string, or an initializer_list<value_type>

with the notation defined by flags; explicit

basic_regex r {x};

basic_regex{x,regex_constants::ECMAScript}; explicit

basic_regex r {p,n,flags};

Construct r from the characters in [p:p+n)

with the notation defined by flags

basic_regex r {p,n};

basic_regex{p,n,regex_constants::ECMAScript}

basic_regex r {b,e,flags}

Construct r from the characters in [b:e)

with the notation defined by flags

basic_regex r {b,e};

basic_regex{b,e,regex_constants::ECMAScript}

The main use of regex is through the search, match, and replace functions (§37.3), but there are also a few operations on regex itself:

basic_regex<C,Tr> Operations (§iso.28.8)

All assign() operations return a reference to the regex to which they were applied

r=x

Copy assignment: x can be a basic_regex,

a C-style string, a basic_string, oran initializer_list<value_type>

r2=move(r)

Move assignment

r3=r.assign(r2)

Copyormove

r2=r.assign(x,flags)

Copy or move; set r’s flags to flags; x can be a basic_string,

a C-style string, or an initializer_list<value_type>

r2=r.assign(x)

r=r.assign(x,regex_constants::ECMAScript)

r2=r.assign(p,n,flags)

Set r’s pattern to [p:p+n) and r’s flags to flags

r2=r.assign(b,e,flags)

Set r’s pattern to [b:e) and r’s flags to flags

r2=r.assign(b,e)

r2=r.assign(b,e,regex_constants::ECMAScript)

n=r.mark_count()

n is the number of marked subexpressions in r

x=r.flags()

x is r’s flags

loc2=r.imbue(loc)

r gets the locale loc; loc2 is r’s previous locale

loc=r.getloc()

loc is r’s locale

r.swap(r2)

Exchange values of r and r2

You can determine the locale or a regex by a call of getloc() and learn what flags are used from flags(), but unfortunately there is no (standard) way of reading out its pattern. If you need to output a pattern, keep a copy of the string used to initialize. For example:

Click here to view code image

regex pat1 {R"(\w+\d*)"};     // no way of outputting the pattern in pat1

string s {R"(\w+\d*)"};
regex pat2 {s};
cout << s << '\n';           // the pattern in pat2
37.2.1. Match Results
Results from a regular expression match are gathered in a match_results object which contains one or more sub_match objects:

Click here to view code image

template<typename Bi>
class sub_match : public pair<Bi,Bi> {
public:
     using value_type = typename iterator_traits<Bi>::value_type;
     using difference_type = typename iterator_traits<Bi>::difference_type;
     using iterator = Bi;
     using string_type = basic_string<value_type>;

     bool matched;  // true if *this contains a match
      //...
};
Bi must be a bidirectional iterator (§33.1.2). A sub_match can be seen as a pair of iterators into the string being matched.

sub_match<Bi> Operations

sub_match sm {};

Default constructor: an empty sequence; constexpr

n=sm.length()

n is the number of characters matched

s=sm

Implicit conversion of a sub_match to a basic_string;

s is a basic_string containing the characters matched

s=sm.str()

s is a basic_string containing the characters matched

n=sm.compare(x)

Lexicographical comparison: sm.str().compare(x);

x can be a sub_match, a basic_string, or a C-style string

x==y

Is x equal to y?

x and y can be a sub_match, a basic_string, a C-style string, or a value_type

x!=y

!(x==y)

x<y

x is lexicographically before y

x>y

y<x

x<=y

!(x>y)

x>=y

!(x<y)

sm.matched

true if sm contains a match; false otherwise

For example:

Click here to view code image

regex pat ("<(.*?)>(.*?)</(.*?)>");

string s = "Always look on the <b> bright </b> side of <b> death </b>";
smatch m;        // match results go here: m holds mach_results for a string

if (regex_search(s,m,pat))
      if (m[1]==m[3]) cout << "match\n";
The output is match.

A match_results is a container of sub_matches:

Click here to view code image

template<typename Bi, typename A = allocator<sub_match<Bi>>>
class match_results {
public:
     using value_type = sub_match<Bi>;
     using const_reference = const value_type&;
     using reference = const_reference;
     using const_iterator = /* implementation-defined */;
     using iterator = const_iterator;
     using difference_type = typename iterator_traits<Bi>::difference_type;
     using size_type = typename allocator_traits<A>::size_type;
     using allocator_type = A;
     using char_type = typename iterator_traits<Bi>::value_type;
     using string_type = basic_string<char_type>;

     ~match_results();  // not virtual

      //...
};
Bi must be a bidirectional iterator (§33.1.2).

As for basic_string and basic_ostream, a few standard aliases are provided for the most common match_results:

Click here to view code image

using cmatch = match_results<const char*>;                // C-style string
using wcmatch = match_results<const wchar_t*>;            // wide C-style string
using smatch = match_results<string::const_iterator>;     // string
using wsmatch = match_results<wstring::const_iterator>;   // wstring
A match_results provides access to its match string, its sub_matches, and the characters before and after the match:



A match_results provides a conventional set of operations:

regex<C,Tr> Matches and Submatches (§iso.28.9, §iso.28.10)

match_results m {};

Default constructor: use allocator_type{}

match_results m {a};

Use allocator a; explicit

match_results m {m2};

Copy and move constructor

m2=m

Copy assignment

m2=move(m)

Move assignment

m.-match_results()

Destructor: release all resources

m.ready()

Does m hold a complete match?

n=m.size()

n-1 is the number of subexpressions in m; n==0 if there was no match

n=m.max_size()

n is the largest possible number of sub_matches for m

m.empty()

m.size()==0?

r=m[i]

r is a const reference to the ith sub_match of m;

m[0] represents the complete match;

if i>= size(), m[i] refers to a sub_match representing

an unmatched subexpression.

n=m.length(i)

n=m[i].length(); the number of characters of m[i]

n=m.length()

n=m.length(0)

pos=m.position(i)

pos=m[i].first; the index of the first character of m[i]

pos=m.position()

pos=m.position(0)

s=m.str(i)

s=m[i].str(); a string representation of m[i]

s=m.str()

s=m.str(0)

sm=m.prefix()

sm is a sub_match representing the characters not matched

by m in the input string coming before the match

sm=m.suffix()

sm is a sub_match representing the characters not matched

by m in the input string coming after the match

regex<C,Tr> Matches and Submatches (continued)(§iso.28.9, §iso.28.10)

p=m.begin() p=m.end()

p points to the first sub_match of m

p points to the one-beyond-the-last sub_match of m

p=m.cbegin()

p points to the first sub_match of m (const iterator)

p=m.cend()

p points to the one-beyond-the-last sub_match of m (const iterator)

a=m.get_allocator()

a is m’s allocator

m.swap(m2)

Exchange the states of m and m2

m==m2

Are the values of sub_matches of m and m2 equal?

m!=m2

!(m==m2)

We can subscript a regex_match to access a sub_match, for example, m[i]. If a subscript, i, refers to a nonexistent sub_match, the result of m[i] represents an unmatched sub_match. For example:

Click here to view code image

void test()
{
     regex pat ("(AAAA)(BBB)?");
     string s = "AAAA";
     smatch m;
     regex_search(s,m,pat);

     cout << boolalpha;
     cout << m[0].matched << '\n';      // true: we found a match
     cout << m[1].matched << '\n';      // true: there was a first sub_match
     cout << m[2].matched << '\n';      // false: no second sub_match
     cout << m[3].matched << '\n';      // false: there couldn't be a third sub_match for pat
}
37.2.2. Formatting
In regex_replace(), formatting is done using a format() function:

regex<C,Tr> Formatting (§iso.28.10.5)

Formatting is controlled by match_flag_type options

out=m.format(out,b,e,flags)

Copy the format in [b:e)to out;

substituting submatches from m for format characters

out=m.format(out,b,e)

out=m.format(out,b,e,regex_constants::format_default)

out=m.format(out,fmt,flags)

out=m.format(out,begin(fmt),end(fmt),flags);

fmt can be a basic_string or a C-style string

out=m.format(out,fmt)

out=m.format(out,fmt,regex_constants::format_default)

s=m.format(fmt,flags)

Construct s as a copy of fmt;

substituting submatches from m for format characters;

fmt can be a basic_string or a C-style string

s=m.format(fmt)

s=m.format(fmt,regex_constants::format_default)

Formats can contain formatting characters:

Format Substitution Notation

$&

The match

$′

The prefix ($ open quote)

$’

The suffix ($ straight quote)

$i

The ith submatch, e.g., $1

$ii

The iith submatch, e.g., $12

$$

Not a match, the $ character

For an example, see §37.3.3.

The details of formatting done by format() are controlled by a set of options (flags):

regex<C,Tr> Formatting Options (regex_constants::match_flag_type; §iso.28.5.2)

format_default

Use ECMAScript (ECMA-262) rules (§iso.28.13)

format_sed

Use POSIX sed notation

format_no_copy

Copy only matches

format_first_only

Only the first occurrence of the regular expression is replaced

37.3. Regular Expression Functions
The functions for applying regular expression patterns to data are regex_search() for searching in a sequence of characters, regex_match() for matching a fixed-length sequence of characters, and regex_replace() for doing replacement of patterns.

The details of matching are controlled by a set of options (flags):

regex<C,Tr> Matching Options (regex_constants::match_flag_type; §iso.28.5.2)

match_not_bol

The character ^ is not considered to mean ‘‘beginning of line’’

match_not_eol

The character $ is not considered to mean ‘‘end of line’’

match_not_bow

\b does not match the subsequence [first,first)

match_not_eow

\b does not match the subsequence [last,last)

match_any

If more than one match is possible, then any match is acceptable

match_not_null

Do not match an empty sequence

match_continuous

Match only a subsequence that begins at first

match_prev_avail

--first is a valid iterator position

37.3.1. regex_match()
To look for a pattern matching a whole sequence with a known length, such as a line of text, use regex_match():

Regular Expression Matching (§iso.28.11.2)

Matching is controlled by match_flag_type options (§37.3)

regex_match(b,e,m,pat,flags)

Does the input [b:e) match the regex pattern pat?

place the result in match_results m; use options flags

regex_match(b,e,m,pat)

regex_match(b,e,m,pat,regex_constants::match_default)

regex_match(b,e,pat,flags)

Does the input [b:e) match the regex pattern pat? use options flags

regex_match(b,e,pat)

regex_match(b,e,pat,regex_constants::match_default)

regex_match(x,m,pat,flags)

Does the input x match the regex pattern pat?

x can be a basic_string or a C-style string;

place the result in match_results m; use options flags

regex_match(x,m,pat)

regex_match(x,m,pat,regex_constants::match_default)

regex_match(x,pat,flags)

Does the input x match the regex pattern pat?

x can be a basic_string or a C-style string; use options flags

regex_match(x,pat)

regex_match(x,pat,regex_constants::match_default)

As an example, consider a naive program for validating the format of a table. If the table format is as expected, the program writes “all is well” to cout; if not, it writes error messages to cerr. A table is a series of rows, each with four tab-separated fields, except for the first (title row) which may have only three fields. For example:

Class

Boys

Girls

Total

1a

12

15

27

1b

16

14

30

Total

28

29

57

The numbers are supposed to add up horizontally and vertically.

The program reads the title line and then does the sums for each line until it reaches the final line labeled “Total”:

Click here to view code image

int main()
{
     ifstream in("table.txt");     // input file
     if (!in) cerr << "no file\n";

     string line;    // input buffer
     int lineno = 0;

     regex header {R"(^[\w ]+(\t[\w ]+)*$)"};                 // tab-separated words
     regex row {R"(^([\w ]+)(\t\d+)(\t\d+)(\t\d+)$)"};  // label followed by three tab-separated numbers

     if (getline(in,line)) {  // check and discard the header line
           smatch matches;
           if (!regex_match(line,matches,header))
                  cerr << "no header\n";
     }

     int boys = 0;         // running totals
     int girls = 0;

     while (getline(in,line)) {
          ++lineno;
          smatch matches;                                   // submatches go here

          if (!regex_match(line,matches,row))
                 cerr << "bad line: " << lineno << '\n';

          int curr_boy = stoi(matches[2]);                  // for stoi() see §36.3.5
          int curr_girl = stoi(matches[3]);
          int curr_total = stoi(matches[4]);
          if (curr_boy+curr_girl != curr_total) cerr << "bad row sum \n";

          if (matches[1]=="Total") {                        // last line
               if (curr_boy != boys) cerr << "boys do not add up\n";
               else if (curr_girl != girls) cerr << "girls do not add up\n";
               else cout << "all is well\n";
               return 0;
          }
          boys += curr_boy;
          girls += curr_girl;
     }

     cerr << "didn't find total line\n";
     return 1;
}
37.3.2. regex_search()
To look for a pattern in a part of a sequence, such as a file, use regex_search():

Regular Expression Searching (§iso.28.11.3)

Matching is controlled by match_flag_type options (§37.3)

regex_search(b,e,m,pat,flags)

Does the input [b:e) contain a match for the regex pattern pat?

place the result in match_results m; use options flags

regex_search(b,e,m,pat)

regex_search(b,e,m,pat,regex_constants::match_default)

regex_search(b,e,pat,flags)

Does the input [b:e) contain a match

for the the regex pattern pat? use options flags

regex_search(b,e,pat)

regex_search(b,e,pat,regex_constants::match_default)

regex_search(x,m,pat,flags)

Does the input x contain a match for the regex pattern pat?

x can be a basic_string or a C-style string;

place the result in match_results m; use options flags

regex_search(x,m,pat)

regex_search(x,m,pat,regex_constants::match_default)

regex_search(x,pat,flags)

Does the input x contain a match for the regex pattern pat?

x can be a basic_string or a C-style string; use options flags

regex_search(x,pat)

regex_search(x,pat,regex_constants::match_default)

For example, I could look for some of the more popular misspellings of my name like this:

Click here to view code image

regex pat {"[Ss]tro?u?v?p?stra?o?u?p?b?"};

smatch m;
for (string s; cin>>s; )
           if (regex_search(s,m,pat))
                 if (m[0]!="stroustrup" && m[0]!="Stroustrup" )
                       cout << "Found: " << m[0] << '\n';
Given suitable input, this will output misspellings of Stroustrup, such as:

Found: strupstrup
Found: Strovstrup
Found: stroustrub
Found: Stroustrop
Note that regex_search() will find its pattern even if it is “hidden” among other characters. For example, it will find strustrub in abstrustrubal. If you want to match a pattern against every character in an input string, use regex_match (§37.3.1).

37.3.3. regex_replace()
To make simple substitutions of a pattern in a part of a sequence, such as a file, use regex_replace():

Regular Expression Replacement (§iso.28.11.4)

Matching is controlled by match_flag_type options (§37.3)

out=regex_replace(out,b,e,pat,fmt,flags)

Copy [b:e)to out,

searching for the regex pattern pat;

when a match for pat is found,

copy it to out using the format fmt

controlled by flags;

fmt can be a basic_string or a C-style string

out=regex_replace(out,b,e,pat,fmt)

out=regex_replace(out,b,e,pat,fmt,

         regex_constants::match_default)

s=regex_replace(x,pat,fmt,flags)

Copy x to s,

searching for the regex pattern pat;

when a match for pat is found

copy it to s using the format fmt

controlled by flags;

x can be a basic_string or a C-style string;

fmt can be a basic_string or a C-style string

s=regex_replace(x,pat,fmt)

s=regex_replace(x,pat,fmt,

         regex_constants::match_default)

Copying a format is done using the regex’s format() (§37.2.2) with the $ prefix notation, for example, $& for the match and $2 for the second submatch. Here is a little test program that takes a string of word and number pairs and outputs them as {word,number}, one per line:

Click here to view code image

void test1()
{
     string input {"x 1 y2 22 zaq 34567"};
     regex pat {"(\w+)\s(\d+)"};     // word space number
     string format {"{$1,$2}\n"};

     cout << regex_replace(input,pat,format);
}
The output is:

{x,1}
 {y2,22}
 {zaq,34567}
Note the annoying “spurious” spaces at the beginning of the lines. By default, regex_match() copies unmatched characters to its output, so the two spaces that were not matched by pat are printed.

To eliminate those spaces, we can use the format_no_copy option (§37.2.2):

cout << regex_replace(input,pat,format,regex_constants::format_no_copy);
Now we get:

{x,1}
{y2,22}
{zaq,34567}
Submatches do not have to be output in order:

Click here to view code image

void test2()
{
     string input {"x 1 y2 22 zaq 34567"};
     regex pat {"(\w)\s(\d+)"};   // word space number
     string format {"$2: $1\n"};

     cout << regex_replace(input,pat,format,regex_constants::format_no_copy);
}
Now we get:

1: x
22: y2
34567: zaq
37.4. Regular Expression Iterators
The regex_search() function allows us to find a single occurrence of a pattern in a data stream. What if we wanted to find and do something to all such occurrences? If the data is organized as a sequence of easily recognized lines or records, we can iterate over those and use regex_match() for each. If what we want to do with each occurrence of a pattern is a simple substitution, we can use regex_replace(). If we want to iterate over a sequence of characters doing something for each occurrence of a pattern, we use a regex_iterator.

37.4.1. regex_iterator
A regex_iterator is an adaptor for a bidirectional iterator. It searches a sequence for the next match of a pattern when incremented:

Click here to view code image

template<typename Bi,
         class C = typename iterator_traits<Bi>::value_type,
         class Tr = reg ex_traits<C>>
class regex_iterator {
public:
     using regex_type = basic_regex<C,Tr>;
     using value_type = match_results<Bi>;
     using difference_type = ptrdiff_t;
     using pointer = const value_type*;
     using reference = const value_type&;
     using iterator_category = forward_iterator_tag;
      //...
}
The regex_traits are described in §37.5.

The usual set of aliases is provided:

Click here to view code image

using cregex_iterator = regex_iterator<const char*>;
using wcregex_iterator = regex_iterator<const wchar_t*>;
using sregex_iterator = regex_iterator<string::const_iterator>;
using wsregex_iterator = regex_iterator<wstring::const_iterator>;
A regex_iterator provides a minimal set of iterator operations:

regex_iterator<Bi,C,Tr> (§iso.28.12.1)

regex_iterator p {};

p is end-of-sequence

regex_iterator p {b,e,pat,flags);

Iterate over [b:e), looking for matches of pat using options flags

regex_iterator p {b,e,pat);

p is initialized with {b,e,pat,regex_constants::match_default}

regex_iterator p {q};

Copy constructor (no move constructor)

p=q

Copy assignment (no move assignment)

p==q

Does p point to the same sub_match as q?

p!=q

!(p==q)

c=*p

cis the current sub_match

x=p->m

x=(*p).m

++p

Make p point to the next occurrence of p’s pattern

q=p++

q=p, then ++p

A regex_iterator adapts a bidirectional iterator, so we cannot directly iterate over an istream.

As an example, we can output all whitespace-separated words in a string:

Click here to view code image

void test()
{
     string input = "aa as; asd ++e^asdf asdfg";
     regex pat {R"(\s+(\w+))"};
     for (sregex_iterator p(input.begin(),input.end(),pat); p!=sregex_iterator{}; ++p)
           cout << (*p)[1] << '\n';
}
This outputs:

as
asd
asdfg
Note that we are missing the first word, aa, because it has no preceding whitespace. If we simplify the pattern to R"((\w+))", we get

aa
as
asd
e
asdf
asdfg
You cannot write through a regex_iterator and regex_iterator{} is the only possible end-of-sequence.

37.4.2. regex_token_iterator
A regex_token_iterator is an adaptor for regex_iterator that iterates over sub_matches of the match_results found:

Click here to view code image

template<typename Bi,
     class C = typename iterator_traits<Bi>::value_type,
     class Tr = typename regex_traits<C>::type>
class regex_token_iterator {
public:
     using regex_type = basic_regex<C,Tr>;
     using value_type = sub_match<Bi>;
     using difference_type = ptrdiff_t;
     using pointer = const value_type*;
     using reference = const value_type&;
     using iterator_category = forward_iterator_tag;
      //...
The regex_traits are described in §37.5.

The usual set of aliases is provided:

Click here to view code image

using cregex_token_iterator = regex_token_iterator<const char*>;
using wcregex_token_iterator = regex_token_iterator<const wchar_t*>;
using sregex_token_iterator = regex_token_iterator<string::const_iterator>;
using wsregex_token_iterator = regex_token_iterator<wstring::const_iterator>;
A regex_token_iterator provides a minimal set of iterator operations:

regex_token_iterator (§iso.28.12.2)

regex_token_iterator p {};

p is the end-of-sequence

regex_token_iterator p {b,e,pat,x,flags};

x lists the indices of the sub_matches to be

included in the iteration or 0, meaning

‘‘the whole match,’’ or -1, meaning

‘‘represent each character sequence not

matched as a subjmatch”;

x can be an int, an initializer_list<int>,

a const vector<int>&,ora const int (&sub_match)[N]

regex_token_iterator p {b,e,pat,x};

p is initialized with

{b,e,pat,x,regex_constants::match_default}

regex_token_iterator p {b,e,pat};

p is initialized with

{b,e,pat,0,regex_constants::match_default}

regex_token_iterator p {q};

Copy constructor (no move constructor)

p.-regex_token_iterator()

Destructor: release all resources

p=q

Copy assignment (no move assignment)

p==q

Does p point to the same sub_match as q?

p!=q

!(p==q)

c=*p

cis the current sub_match

x=p->m

x=(*p).m

++p

Make p point to the next occurrence of p’s pattern

q=p++

q=p, then ++p

The x argument lists the sub_matches to be included in the iteration. For example (iterating over matches 1 and 3):

Click here to view code image

void test1()
{
     string input {"aa::bb cc::dd ee::ff"};
     regex pat {R"((\w+)([[:punct:]]+)(\w+)\s*)"};
     sregex_token_iterator end {};
     for (sregex_token_iterator p{input.begin(),input.end(),pat,{1,3}}; p!=end; ++p)
           cout << *p << '\n';
}
This gives the output:

aa
bb
cc
dd
ee
ff
The –1 option basically inverts the strategy for reporting matches by representing each character sequence that does not match as a sub_match. This is often referred to as token splitting (that is, splitting a character stream into tokens) because when your pattern matches the token separators, option –1 leaves you with the tokens. For example:

Click here to view code image

void test2()
{
     string s {"1,2 , 3 ,4,5, 6 7"};    // input
     regex pat {R"(\s*,\s*)"};          // use comma as token    separator
     copy(sregex_token_iterator{s.begin(),s.end(),pat,–1},
         sregex_token_iterator{},
         ostream_iterator<string>{cout,"\n"});
}
The output is:

1
2
3
4
5
6 7
This could equivalently be written using an explicit loop:

Click here to view code image

void test3()
{
     string s {"1,2 , 3 ,4,5, 6 7"};    // input
     regex pat {R"(\s*,\s*)"};          // use comma as token
     sregex_token_iterator end{};
     for (sreg ex_token_iterator p {s.begin(),s.end(),pat,–1}; p!=end; ++p)
           cout << *p << '\n';
}
37.5. regex_traits
A regex_traits<T> represents the correspondence between a character type, a string type, and a locale as needed for a regex implementer:

Click here to view code image

template<typename C>
struct regex_traits {
public:
     using char_type = C;
     using string_type = basic_string<char_type>;
     using locale_type = locale;
     using char_class_type = /* implementation-defined bitmask type */;
      //...
};
The standard library provides specializations regex_traits<char> and regex_traits<wchar_t>.

regex_traits<C> Operations (§iso.28.7)

regex_traits<C> tr {};

Make a default regex_trait<C>

n=length(p)

n is the number of characters in the C-style string p;

n=char_traits<C>::length(); static

c2=tr.translate(c)

c2=c, that is, a no-op

c2=tr.translate_nocase(c) s=tr.transform(b,e)

use_facet<ctype<C>>(getloc()).tolower(c); §39.4.5

s is a string that can be used to compare

[b:e) to others strings; §39.4.1

s=tr.transform_primary(b,e)

s is a string that can be used to compare

[b:e) to others strings; ignore case; §39.4.1

s=tr.lookup_collatename(b,e)

s is the string

name of the collating element named [b:e) or the empty string

m=tr.lookup_classname(b,e,ign) m=tr.lookup_classname(b,e)

m is the char_class_type for the classification mask

for the character classification named [b:e);

ignore case if ign==true m=tr.lookup_classname(b,e,false)

tr.isctype(c,m)

Is c classified as an m? m is a char_class_type

i=tr.value(c,b)

i is the integer value represented by c in base b;

b must be 8,10, or 16

loc2=tr.imbue(loc)

Set tr’s locale to loc; loc2 is tr’s previous locale

loc=tr.getloc()

loc is tr’s locale

A transform is used to generate strings for fast comparisons in pattern-matching implementations.

A classification name is one of the character classifications listed in §37.1.1, such as alpha, s, and xdigit.

37.6. Advice
[1] Use regex for most conventional uses of regular expressions; §37.1.

[2] The regular expression notation can be adjusted to match various standards; §37.1.1, §37.2.

[3] The default regular expression notation is that of ECMAScript; §37.1.1.

[4] For portability, use the character class notation to avoid nonstandard abbreviations; §37.1.1.

[5] Be restrained; regular expressions can easily become a write-only language; §37.1.1.

[6] Prefer raw string literals for expressing all but the simplest patterns; §37.1.1.

[7] Note that \i allows you to express a subpattern in terms of a previous subpattern; §37.1.1.

[8] Use ? to make patterns “lazy”; §37.1.1, §37.2.1.

[9] regex can use ECMAScript, POSIX, awk, grep, and egrep notation; §37.2.

[10] Keep a copy of the pattern string in case you need to output it; §37.2.

[11] Use regex_search() for looking at streams of characters and regex_match() to look for fixed layouts; §37.3.2, §37.3.1.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


37. Regular Expressions
38. I/O Streams
39. Locales
47h 26m remaining
38. I/O Streams
What you see is all you get.

– Brian W. Kernighan

• Introduction

• The I/O Stream Hierarchy

File Streams; String Streams

• Error Handling

• I/O Operations

Input Operations; Output Operations; Manipulators; Stream State; Formatting

• Stream Iterators

• Buffering

Output Streams and Buffers; Input Streams and Buffers; Buffer Iterators

• Advice

38.1. Introduction
The I/O stream library provides formatted and unformatted buffered I/O of text and numeric values. The definitions for I/O stream facilities are found in <istream>, <ostream>, etc.; see §30.2.

An ostream converts typed objects to a stream of characters (bytes):



An istream converts a stream of characters (bytes) to typed objects:



An iostream is a stream that can act as both an istream and an ostream. The buffers in the diagrams are stream buffers (streambufs; §38.6). You need them to define a mapping from an iostream to a new kind of device, file, or memory. The operations on istreams and ostreams are described in §38.4.1 and §38.4.2.

Knowledge of the techniques used to implement the stream library is not needed to use the library. So I present only the general ideas needed to understand and use iostreams. If you need to implement the standard streams, provide a new kind of stream, or provide a new locale, you need a copy of the standard, a good systems manual, and examples of working code in addition to what is presented here.

The key components of the stream I/O system can be represented graphically like this:



The solid arrows represent “derived from.” The dotted arrows represent “pointer to.” The classes marked with <> are templates parameterized by a character type and containing a locale.

The I/O stream operations:

• Are type-safe and type sensitive

• Are extensible (when someone designs a new type, matching I/O stream operators can be added without modifying existing code)

• Are locale sensitive (Chapter 39)

• Are efficient (though their potential is not always fully realized)

• Are interoperable with C-style stdio (§43.3)

• Include formatted, unformatted, and character-level operations

The basic_iostream is defined based on basic_istream (§38.6.2) and basic_ostream (§38.6.1):

Click here to view code image

template<typename C, typename Tr = char_traits<C>>
class basic_iostream :
     public basic_istream<C,Tr>, public basic_ostream<C,Tr> {
public:
     using char_type = C;
     using int_type = typename Tr::int_type;
     using pos_type = typename Tr::pos_type;
     using off_type = typename Tr::off_type;
     using traits_type = Tr;

     explicit basic_iostream(basic_streambuf<C,Tr>* sb);
     virtual ~basic_iostream();
protected:
     basic_iostream(const basic_iostream& rhs) = delete;
     basic_iostream(basic_iostream&& rhs);

     basic_iostream& operator=(const basic_iostream& rhs) = delete;
     basic_iostream& operator=(basic_iostream&& rhs);
     void swap(basic_iostream& rhs);
};
The template parameters specify the character type and the traits used to manipulate characters (§36.2.2), respectively.

Note that no copy operations are provided: sharing or cloning the fairly complex state of a stream would be difficult to implement and expensive to use. The move operations are intended for use by derived classes and are therefore protected. Moving an iostream without moving the state of its defining derived class (e.g., an fstream) would lead to errors.

There are eight standard streams:

Standard I/O Streams

cout

The standard character output (often by default a screen)

cin

The standard character input (often by default a keyboard)

cerr

The standard character error output (unbuffered)

clog

The standard character error output (buffered)

wcin

wistream version of cin

wcout

wostream version of cout

wcerr

wostream version of cerr

wclog

wostream version of clog

Forward declarations for stream types and stream objects are provided in <iosfwd>.

38.2. The I/O Stream Hierarchy
An istream can be connected to an input device (e.g., a keyboard), a file, or a string. Similarly, an ostream can be connected to an output device (e.g., a text window or an HTML engine), a file, or a string. The I/O stream facilities are organized in a class hierarchy:



The classes suffixed by <> are templates parameterized on the character type. A dotted line indicates a virtual base class (§21.3.5).

The key class is basic_ios in which most of the implementation and many of the operations are defined. However, most casual (and not-so-casual) users never see it: it is mostly an implementation detail of the streams. It is described in §38.4.4. Most of its facilities are described in the context of their function (e.g., formatting; §38.4.5).

38.2.1. File Streams
In <fstream>, the standard library provides streams to and from a file:

• ifstreams for reading from a file

• ofstreams for writing to a file

• fstreams for reading from and writing to a file

The file streams follow a common pattern, so I describe only fstream:

Click here to view code image

template<typename C, typename Tr=char_traits<C>>
class basic_fstream
: public basic_iostream<C,Tr> {
public:
     using char_type = C;
     using int_type = typename Tr::int_type;
     using pos_type = typename Tr::pos_type;          // for positions in file
     using off_type = typename Tr::off_type;   // for offsets in file
     using traits_type = Tr;
      //...
};
The set of fstream operations is fairly simple:

basic_fstream<C,Tr> (§iso.27.9)

fstream fs {};

fs is a file stream not attached to a file

fstream fs {s,m};

fs is a file stream opened for a file called s with mode m;

s can be a string or a C-style string

fstream fs {fs2};

Move constructor: fs2 is moved to fs; fs2 becomes unattached

fs=move(fs2)

Move assignment: fs2 is moved to fs; fs2 becomes unattached

fs.swap(fs2)

Exchange the states of fs and fs2

p=fs.rdbuf()

p is a pointer to fs’s file stream buffer (basic_filebuf<C,Tr>)

fs.is_open()

Is fs open?

fs.open(s,m)

Open a file called s with mode m and have fs refer to it;

sets fs’s failbit if it couldn’t open the file;

s can be a string or a C-style string

fs.close()

Close the file associated with fs (if any)

In addition, the string streams override the basic_ios protected virtual functions underflow(), pbackfail(), overflow(), setbuf(), seekoff(), and seekpos() (§38.6).

A file stream does not have copy operations. If you want two names to refer to the same file stream, use a reference or a pointer, or carefully manipulate file streambufs (§38.6).

If an fstream fails to open, the stream is in the bad() state (§38.3).

There are six file stream aliases defined in <fstream>:

Click here to view code image

using ifstream = basic_ifstream<char>;
using wifstream = basic_ifstream<wchar_t>;
using ofstream = basic_ofstream<char>;
using wofstream = basic_ofstream<wchar_t>;
using fstream = basic_fstream<char>;
using wfstream = basic_fstream<wchar_t>;
You can open a file in one of several modes, as specified in ios_base (§38.4.4):

Stream Modes (§iso.27.5.3.1.4)

ios_base::app

Append (i.e., add to the end of the file)

ios_base::ate

‘‘At end’’ (open and seek to the end)

ios_base::binary

Binary mode; beware of system-specific behavior

ios_base::in

For reading

ios_base::out

For writing

ios_base::trunc

Truncate the file to 0 length

In each case, the exact effect of opening a file may depend on the operating system, and if an operating system cannot honor a request to open a file in a certain way, the result will be a stream that is in the bad() state (§38.3). For example:

Click here to view code image

ofstream ofs("target");                //"o" for "output" implying ios::out
if (!ofs)
       error("couldn't open 'target' for writing");

fstream ifs;             //"i" for "input" implying ios::in
ifs.open("source",ios_base::in);
if (!ifs)
       error("couldn't open 'source' for reading");
For positioning in a file, see §38.6.1.

38.2.2. String Streams
In <sstream>, the standard library provides streams to and from a string:

• istringstreams for reading from a string

• ostringstreams for writing to a string

• stringstreams for reading from and writing to a string

The string streams follow a common pattern, so I describe only stringstream:

Click here to view code image

template<typename C, typename Tr = char_traits<C>, typename A = allocator<C>>
class basic_stringstream
     : public basic_iostream<C,Tr> {
public:
     using char_type = C;
     using int_type = typename Tr::int_type;
     using pos_type = typename Tr::pos_type;         // for positions in string
     using off_type = typename Tr::off_type;  // for offsets in string
     using traits_type = Tr;
     using allocator_type = A;

      //...
The stringstream operations are:

basic_stringstream<C,Tr,A> (§iso.27.8)

stringstream ss {m};

ss is an empty string stream with mode m

stringstream ss {};

Default constructor: stringstream ss {ios_base::out|ios_base::in};

stringstream ss {s,m};

ss is a string stream with its buffer initialized from the string s

with mode m

stringstream ss {s};

stringstream ss {s,ios_base::out|ios_base::in};

stringstream ss {ss2};

Move constructor: ss2 is moved to ss; ss2 becomes empty

ss=move(ss2)

Move assignment: ss2 is moved to ss; ss2 becomes empty

p=ss.rdbuf()

p points to ss’s string stream buffer (a basic_stringbuf<C,Tr,A>)

s=ss.str()

s is a string copy of the characters in ss: s=ss.rdbuf()->str()

ss.str(s)

ss’s buffer is initialized from the string s: ss.rdbuf()->str(s);

if ss’s mode is ios::ate (‘‘at end’’) values written to ss

are added after the characters from s;

otherwise values written overwrites the characters from s

ss.swap(ss2)

Exchange the states of ss and ss2

The open modes are described in §38.4.4. For an istringstream, the default mode is ios_base::in. For an ostringstream, the default mode is ios_base::out.

In addition, the string streams override the basic_ios protected virtual functions underflow(), pbackfail(), overflow(), setbuf(), seekoff(), and seekpos() (§38.6).

A string stream does not have copy operations. If you want two names to refer to the same string stream, use a reference or a pointer.

There are six string stream aliases defined in <sstream>:

Click here to view code image

using istringstream = basic_istringstream<char>;
using wistringstream = basic_istringstream<wchar_t>;
using ostringstream = basic_ostringstream<char>;
using wostringstream = basic_ostringstream<wchar_t>;
using stringstream = basic_stringstream<char>;
using wstringstream = basic_stringstream<wchar_t>;
For example:

Click here to view code image

void test()
{
     ostringstream oss {"Label: ",ios::ate};             // write at end
     cout << oss.str() << '\n';  // writes "Label: "
     oss<<"val";
     cout << oss.str() << '\n';  // writes "Label: val" ("val" appended after "Label: ")

     ostringstream oss2 {"Label: "};                     // write at beginning
     cout << oss2.str() << '\n';  // writes "Label: "
     oss2<<"val";
     cout << oss2.str() << '\n';  // writes "valel: " (val overwrites "Label: ")
}
I tend to use str() only to read a result from an istringstream.

It is not possible to directly output a string stream; str() must be used:

Click here to view code image

void test2()
{
     istringstream iss;
     iss.str("Foobar");          // Fill iss

     cout << iss << '\n';        // writes 1
     cout << iss.str() << '\n';  // OK: writes "Foobar"
}
The reason for the probably surprising 1 is that an iostream converts to its state for testing:

Click here to view code image

if (iss) {  // the last operation of iss succeeded; iss's state is good() or eof()
       //...
}
else {
      // handle problem
}
38.3. Error Handling
An iostream can be in one of four states, defined in basic_ios from <ios> (§38.4.4):

Stream State Readers (§iso.27.5.5.4)

good()

The previous iostream operations succeeded

eof()

We hit end-of-input (“end-of-file”)

fail()

Something unexpected happened (e.g., we looked for a digit and found 'x')

bad()

Something unexpected and serious happened (e.g., disk read error); bad() implies fail()

Any operation attempted on a stream that is not in the good() state has no effect; it is a no-op. An iostream can be used as a condition. In that case, the condition is true (succeeds) if the state of the iostream is good(). That is the basis for the idiom for reading a stream of values:

Click here to view code image

for (X x; cin>>x; ) {   // read into an input buffer of type X
      //... do something with x ...
}
 // we get here when >> couldn't read another X from cin
After a read failure, we might be able to clear the stream and proceed:

Click here to view code image

int i;
if (cin>>i) {
      //... use i ...
} else if (cin.fail()){  // possibly a formatting error
     cin.clear();
     string s;
     if (cin>>s) {       // we might be able to use a string to recover
            //... use s ...
     }
}
Alternatively, errors can be handled using exceptions:

Exception Control: basic_ios<C,Tr> (§38.4.4, §iso.27.5.5)

st=ios.exceptions()

st is the iostate of ios

ios.exceptions(st)

Set ios’s iostate to st

For example, we can make cin throw a basic_ios::failure when its state is set to bad() (e.g., by a cin.setstate(ios_base::badbit)):

cin.exceptions(cin.exceptions()|ios_base::badbit);
For example:

Click here to view code image

struct Io_guard {    // RAII class for iostream exceptions
     iostream& s;
     auto old_e = s.exceptions();
     Io_guard(iostream& ss, ios_base::iostate e) :s{ss} { s.exceptions(s.exceptions()|e); }
     ~Io_guard() { s.exceptions(old_e); }
};

void use(istream& is)
{
     Io_guard guard(is.ios_base::badbit);
      //... use is ...
}
catch (ios_base::badbit) {
      //... bail out! ...
}
I tend to use exceptions to handle iostream errors that I don’t expect to be able to recover from. That usually means all bad() exceptions.

38.4. I/O Operations
The complexity of the I/O operations reflects tradition, the need for I/O performance, and the variety of human expectations. The description here is based on the conventional English small character set (ASCII). The ways in which different character sets and different natural languages are handled are described in Chapter 39.

38.4.1. Input Operations
Input operations are provided by istream (§38.6.2), found in <istream> except for the ones reading into a string; those are found in <string>. The basic_istream is primarily intended as a base class for more specific input classes, such as istream and istringstream:

Click here to view code image

template<typename C, typename Tr = char_traits<C>>
class basic_istream : virtual public basic_ios<C,Tr> {
public:
     using char_type = C;
     using int_type = typename Tr::int_type;
     using pos_type = typename Tr::pos_type;
     using off_type = typename Tr::off_type;
     using traits_type = Tr;

     explicit basic_istream(basic_streambuf<C,Tr>* sb);
     virtual ~basic_istream();  // release all resources

     class sentry;
      //...
protected:
      // move but no copy:
     basic_istream(const basic_istream& rhs) = delete;
     basic_istream(basic_istream&& rhs);
     basic_istream& operator=(const basic_istream& rhs) = delete;
     basic_istream& operator=(basic_istream&& rhs);
      //...
};
To users of an istream, the sentry class is an implementation detail. It provides common code for standard-library and user-defined input operations. Code that needs to be executed first (the “prefix code”) – such as flushing a tied stream – is provided as the sentry’s constructor. For example:

Click here to view code image

template<typename C, typename Tr = char_traits<C>>
basic_ostream<C,Tr>& basic_ostream<C,Tr>::operator<<(int i)
{
     sentry s {*this};
     if (!s) {               // check whether all is well for output to start
            setstate(failbit);
            return *this;
     }

      //... output the int ...
     return *this;
}
A sentry is used by implementers of input operations rather than by their users.

38.4.1.1. Formatted Input
Formatted input is primarily supplied by the >> (“input,” “get,” or “extraction”) operator:

 

Formatted Input (§iso.27.7.2.2, §iso.21.4.8.9)

in>>x

Read from in into x according to x’s type; x can be an arithmetic type,

a pointer, a basic_string, a valarray, a basic_streambuf,

or any type for which the user has supplied a suitable operator>>()

getline(in,s)

Read a line from in into the string s

Built-in types are “known” to istream (and ostream), so if x is a built-in type, cin>>x means cin.operator>>(x). If x is a user-defined type, cin>>x, means operator>>(cin,x) (§18.2.5). That is, iostream input is type sensitive, inherently type-safe, and extensible. A designer of a new type can provide I/O operations without direct access to the implementation of iostream.

If a pointer to a function is the target of >>, that function will be invoked with the istream as its argument. For example, cin>>pf yields pf(cin). This is the basis for the input manipulators, such as skipws (§38.4.5.2). Output stream manipulators are more common than input stream manipulators, so the technique is explained further in §38.4.3.

Unless otherwise stated, an istream operation returns a reference to its istream, so that we can “chain” operations. For example:

Click here to view code image

template<typename T1, typename T2>
void read_pair(T1& x, T2& y)
{
     char c1, c2, c3;
     cin >> c1 >> x >> c2 >> y >> c3;
     if (c1!='{' || c2!=',' || c3!='}') {           // unrecoverable input format error
           cin.setstate(ios_base::badbit);          // set badbit
           throw runtime_error("bad read of pair");
     }
}
By default >> skips whitespace. For example:

for (int i; cin>>i && 0<i; )
      cout << i << '\n';
This will take a sequence of whitespace-separated positive integers and print them one to a line.

Skipping of whitespace can be suppressed using noskipws (§38.4.5.2).

The input operations are not virtual. That is, a user cannot do an in>>base where base is a class hierarchy and automatically have the >> resolved to an operation on the appropriate derived class. However, a simple technique can deliver that behavior; see §38.4.2.1. Furthermore, it is possible to extend such a scheme to be able to read objects of essentially arbitrary types from an input stream; see §22.2.4.

38.4.1.2. Unformatted Input
Unformatted input can be used for finer control of reading and potentially for improved performance. One use of unformatted input is the implementation of formatted input:

Unformatted Input (§iso.27.7.2.3)

x=in.get()

Read one character from in and return its integer value;

return EOF for end-of-file

in.get(c)

Read a character from in into c

in.get(p,n,t)

Read at most n characters from in into [p:...); consider t a terminator

in.get(p,n)

in.get(p,n,'\n')

in.getline(p,n,t)

Read at most n characters from in into [p:...); consider t a terminator;

remove terminator from in

in.getline(p,n)

in.getline(p,n,’\n’)

in.read(p,n)

read at most n characters from in into [p:... )

x=in.gcount()

x is the number of characters read

by the most recent unformatted input operation on in

in.putback(c)

Put c back into in’s stream buffer

in.unget()

Back up in’s stream buffer by one, so that the next character read

is the same as the previous character

in.ignore(n,d)

Extract characters from in and discard them until either n

characters have been discarded or d is found (and discarded)

in.ignore(n)

in.ignore(n,traits::eof())

in.ignore()

in.ignore(1,traits::eof())

in.swap(in2)

Exchange the values of in and in2

If you have a choice, use formatted input (§38.4.1.1) instead these low-level input functions.

The simple get(c) is useful when you need to compose your values out of characters. The other get() function and getline() read sequences of characters into a fixed-size area [p:...). They read until they reach the maximum number of characters or find their terminator character (by default '\n'). They place a 0 at the end of the characters (if any) written to; getline() removes its terminator from the input, if found, whereas get() does not. For example:

Click here to view code image

void f()   // low-level, old-style line read
{
     char word[MAX_WORD][MAX_LINE];                 // MAX_WORD arrays of MAX_LINE char each
     int i = 0;
     while(cin.getline(word[i++],MAX_LINE,'\n') && i<MAX_WORD)
          /* do nothing */ ;
      //...
}
For these functions, it is not immediately obvious what terminated the read:

• We found the terminator.

• We read the maximum number of characters.

• We hit end-of-file.

• There was a non-format input error.

The last two alternatives are handled by looking at the file state (§38.3). Typically, the appropriate actions are quite different for these cases.

A read(p,n) does not write a 0 to the array after the characters read. Obviously, the formatted input operators are simpler to use and less error-prone than the unformatted ones.

The following functions depend on the detailed interaction between the stream buffer (§38.6) and the real data source and should be used only if necessary and then very carefully:

Unformatted Input (§iso.27.7.2.3)

x=in.peek()

x is the current input character; x is not extracted from in’s

stream buffer and will be the next character read

n2=in.readsome(p,n)

If rdbuf()->in_avail()==-1, call setstate(eofbit); otherwise

read at most min(n,rdbuf()->in_avail()) characters into [p:...);

n2 is the number of characters read

x=in.sync()

Synchronize buffers: in.rdbuf()->pubsync(); x==-1 indicates failure

pos=in.tellg()

pos is the position of in’s get pointer

in.seekg(pos)

Place in’s get pointer at position pos

in.seekg(off,dir)

Place in’s get pointer at the offset off in the direction dir

38.4.2. Output Operations
Output operations are provided by ostream (§38.6.1), found in <ostream> except for the ones writing out a string; those are found in <string>:

Click here to view code image

template<typename C, typename Tr = char_traits<C>>
class basic_ostream : virtual public basic_ios<C,Tr> {
public:
     using char_type = C;
     using int_type = typename Tr::int_type;
     using pos_type = typename Tr::pos_type;
     using off_type = typename Tr::off_type;
     using traits_type = Tr;

     explicit basic_ostream(basic_streambuf<char_type,Tr>* sb);
     virtual ~basic_ostream();  // release all resources

     class sentry;  // see §38.4.1
      //...
protected:
      // move but no copy:
     basic_ostream(const basic_ostream& rhs) = delete;
     basic_ostream(basic_ostream&& rhs);
     basic_ostream& operator=(basic_ostream& rhs) = delete;
     basic_ostream& operator=(const basic_ostream&& rhs);
      //...
};
An ostream offers formatted output, unformatted output (output of characters), and simple operations on its streambuf (§38.6):

Output Operations (§iso.27.7.3.6, §iso.27.7.3.7, §iso.21.4.8.9)

out<<x

Write x to out according to x’s type; x can be an arithmetic type,

a pointer, a basic_string, a bitset, a complex, a valarray,

or any type for which a user has defined a suitable operator<<()

out.put(c)

Write the character c to out

out.write(p,n)

Write the characters [p:p+n)to out

out.flush()

Empty the character buffer to the destination

pos=out.tellp()

pos is the position of out’s put pointer

out.seekp(pos)

Place out’s put pointer at position pos

out.seekp(off,dir)

Place out’s put pointer at the offset off in the direction dir

Unless otherwise stated, an ostream operation returns a reference to its ostream, so that we can “chain” operations. For example:

cout << "The value of x is " << x << '\n';
Note that char values are output as characters rather than small integers. For example:

Click here to view code image

void print_val(char ch)
{
     cout << "the value of '" << ch << "' is " << int{ch} << '\n';
}

void test()
{
     print_val('a');
     print_val('A');
}
This prints:

the value of 'a' is 97
the value of 'A' is 65
Versions of operator << for user-defined types are usually trivial to write:

Click here to view code image

template<typename T>
struct Named_val {
     string name;
     T value;
};

ostream& operator<<(ostream& os, const Named_val& nv)
{
     return os << '{' << nv.name << ':' << nv.value << '}';
}
This will work for every Named_val<X> where X has a << defined. For full generality, << must be defined for basic_string<C,Tr>.

38.4.2.1. Virtual Output Functions
The ostream members are not virtual. The output operations that a programmer can add are not members, so they cannot be virtual either. One reason for this is to achieve close to optimal performance for simple operations such as putting a character into a buffer. This is a place where runtime efficiency is often crucial so that inlining is a must. Virtual functions are used to achieve flexibility for the operations dealing with buffer overflow and underflow only (§38.6).

However, a programmer sometimes wants to output an object for which only a base class is known. Since the exact type isn’t known, correct output cannot be achieved simply by defining a << for each new type. Instead, a virtual output function can be provided in an abstract base:

Click here to view code image

class My_base {
public:
      //...
     virtual ostream& put(ostream& s) const = 0;  // write *this to s
};

ostream& operator<<(ostream& s, const My_base& r)
{
     return r.put(s);  // use the right put()
}
That is, put() is a virtual function that ensures that the right output operation is used in <<.

Given that, we can write:

Click here to view code image

class Sometype : public My_base {
public:
      //...
     ostream& put(ostream& s) const override;    // the real output function
};

void f(const My_base& r, Sometype& s)  // use << which calls the right put()
{
     cout << r << s;
}
This integrates the virtual put() into the framework provided by ostream and <<. The technique is generally useful to provide operations that act like virtual functions, but with the run-time selection based on their second argument. This is similar to the technique that under the name double dispatch is often used to select an operation based on two dynamic types (§22.3.1). A similar technique can be used to make input operations virtual (§22.2.4).

38.4.3. Manipulators
If a pointer to function is given as the second argument to <<, the function pointed to is called. For example, cout<<pf means pf(cout). Such a function is called a manipulator. Manipulators that take arguments can be useful. For example:

cout << setprecision(4) << angle;
This prints the value of the floating-point variable angle with four digits.

To do this, setprecision returns an object that is initialized by 4 and calls cout.precision(4) when invoked. Such a manipulator is a function object that is invoked by << rather than by (). The exact type of that function object is implementation-defined, but it might be defined like this:

Click here to view code image

struct smanip {
     ios_base& (*f)(ios_base&,int);    // function to be called
     int i;                            // value to be used
     smanip(ios_base&(*ff)(ios_base&,int), int ii) :f{ff}, i{ii} { }
};

template<typename C, typename Tr>
basic_ostream<C,Tr>& operator<<(basic_ostream<C,Tr>& os, const smanip& m)
{
     m.f(os,m.i);  // call m's f with m's stored value
     return os;
}
We can now define setprecision() like this:

Click here to view code image

inline smanip setprecision(int n)
{
     auto h = [](ios_base& s, int x) –> ios_base& { s.precision(x); return s; };
     return smanip(h,n);       // make the function object
}
The explicit specification of the return type for the lambda is needed to return a reference. An ios_base cannot be copied by a user.

We can now write:

cout << setprecision(4) << angle;
A programmer can define new manipulators in the style of smanip as needed. Doing this does not require modification of the definitions of standard-library templates and classes.

The standard-library manipulators are described in §38.4.5.2.

38.4.4. Stream State
In <ios>, the standard library defines the base class ios_base defining most of the interface to a stream class:

Click here to view code image

template<typename C, typename Tr = char_traits<C>>
class basic_ios : public ios_base {
public:
     using char_type = C;
     using int_type = typename Tr::int_type;
     using pos_type = typename Tr::pos_type;
     using off_type = typename Tr::off_type;
     using traits_type = Tr;
      //...
};
The basic_ios class manages the state of a stream:

• The mapping between a stream and its buffers (§38.6)

• The formatting options (§38.4.5.1)

• The use of locales (Chapter 39)

• Error handling (§38.3)

• Connections to other streams and stdio (§38.4.4)

It might be the most complicated class in the standard library.

The ios_base holds information that does not depend on template arguments:

Click here to view code image

class ios_base {
public:
     using fmtflags = /* implementation-defined type */;
     using iostate = /* implementation-defined type */;
     using openmode = /* implementation-defined type */;
     using seekdir = /* implementation-defined type */;

     class failure;        // exception class
     class Init;           // initialize standard iostreams
};
The implementation-defined types are all bitmask types; that is, they support bitwise logical operations, such as & and |. Examples are int (§11.1.2) and bitset (§34.2.2).

The ios_base controls an iostream’s connection (or lack thereof) to stdio (§43.3):

Fundamental ios_base Operations (§iso.27.5.3.4)

ios_base b {};

Default constructor; protected

ios.-ios_base()

Destructor; virtual

b2=sync_with_stdio(b)

If b==true synchronize ios with stdio;

otherwise shared buffers might be corrupted;

b2 is the previous synchronization state; static

b=sync_with_stdio()

b=sync_with_stdio(true)

A call of sync_with_stdio(true) before the first iostream operation in the execution of a program guarantees that the iostream and stdio (§43.3) I/O operations share buffers. A call of sync_with_stdio(false) before the first stream I/O operation prevents buffer sharing and can improve I/O performance significantly on some implementations.

Note that ios_base has no copy or move operations.

ios_base Stream State iostate Member Constants (§iso.27.5.3.1.3)

badbit

Something unexpected and serious happened (e.g., a disk read error)

failbit

Something unexpected happened (e.g., we looked for a digit and found ‘x’)

eofbit

We hit end-of-input (e.g., end-of-file)

goodbit

All is well

Functions for reading these bits (good(), fail(), etc.) in a stream are provided by basic_ios.

ios_base Mode openmode Member Constants (§iso.27.5.3.1.4)

app

Append (insert output at end-of-stream)

ate

At end (position to end-of-stream)

binary

Don’t apply formatting to characters

in

Input stream

out

Output stream

trunc

Truncate stream before use (set the stream’s size to zero)

The exact meaning of ios_base::binary is implementation-dependent. However, the usual meaning is that a character gets mapped to a byte. For example:

Click here to view code image

template<typename T>
char* as_bytes(T& i)
{
     return static_cast<char*>(&i);  // treat that memory as bytes
}

void test()
{
     ifstream ifs("source",ios_base::binary);        // stream mode is binary
     ofstream ofs("target",ios_base::binary);        // stream mode is binary

     vector<int> v;

     for (int i; ifs.read(as_bytes(i),sizeof(i)); )   // read bytes from binary file
           v.push_back(i);

      //... do something with v ...

     for (auto i : v)                                // write bytes to binary file:
           ofs.write(as_bytes(i),sizeof(i));
}
Use binary I/O when dealing with objects that are “just bags of bits” and do not have an obvious and reasonable character string representation. Images and sound/video streams are examples.

The seekg() (§38.6.2) and seekp() (§38.6.2) operations require a direction:

ios_base Direction seekdir Member Constants (§iso.27.5.3.1.5)

beg

Seek from beginning of current file

cur

Seek from current position

end

Seek backward from end of current file

Classes derived from basic_ios format output and extract objects based on the information stored in their basic_io.

The basic_io operations can be summarized:

basic_ios<C,Tr> (§iso.27.5.5)

basic_ios ios {p};

Construct ios given the stream buffer pointed to by p

ios.-basic_ios()

Destroy ios: release all of ios’s resources

bool b {ios};

Conversion to bool: b is initialized to !ios.fail(); explicit

b=!ios

b=ios.fail()

st=ios.rdstate()

st is the iostate of ios

ios.clear(st)

Set the iostate of ios to st

ios.clear()

Set the iostate of ios to good

ios.setstate(st)

Add st to ios’s iostate

ios.good()

Is the state of ios good (is goodbit set)?

ios.eof()

Is the state of ios end-of-file?

ios.fail()

Is the state of ios fail or bad (failbit| badbit)?

ios.bad()

Is the state of ios bad?

st=ios.exceptions()

st is the exceptions bits of the iostate of ios

ios.exceptions(st)

Set the exceptions bits of ios’s iostate to st

p=ios.tie()

p is a pointer to a tied stream or nullptr

p=ios.tie(os)

Tie output stream os to ios;

p is a pointer to the previously tied stream or nullptr

p=ios.rdbuf()

p is a pointer to ios’s stream buffer

p=ios.rdbuf(p2)

Set ios’s stream buffer to the one pointed to by p2;

p is a pointer to the previous stream buffer

ios3=ios.copyfmt(ios2)

Copy the parts of ios2’s state related to formatting to ios;

call any ios2 callback of type copyfmt_event;

copy the values pointed to by ios2.pword and ios2.iword;

ios3 is the previous format state

c=ios.fill()

c is the fill character of ios

c2=ios.fill(c)

Set c to be the fill character of ios;

c2 is the previous fill character

loc2=ios.imbue(loc)

Set ios’s locale to loc; loc2 is the previous locale

c2=narrow(c,d)

c2 is a char value obtained by converting c of char_type,

d is a default value:

use_facet<ctype<char_type>>(getloc()).narrow(c,d)

basic_ios<C,Tr> (continued) (§iso.27.5.5)

c2=widen(c)

c2 is a char_type value obtained by converting c of char type:

use_facet<ctype<char_type>>(getloc()).widen(c)

ios.init(p)

Set ios to the default state and use the stream buffer pointed to by p; protected

ios.set_rdbuf(p)

Make ios use the stream buffer pointed to by p; protected

ios.move(ios2)

Copy and move operation; protected

ios.swap(ios2)

Exchange the states of ios and ios2; protected; noexcept

The conversion of an ios (including istreams and ostreams) to bool is essential to the usual idiom for reading many values:

for (X x; cin>>x; ) {
      //...
}
Here, the return value of cin>>x is a reference to cin’s ios. This ios is implicitly converted to a bool representing the state of cin. Thus, we could equivalently have written:

for (X x; !(cin>>x).fail();) {
      //...
}
The tie() is used to ensure that output from a tied stream appears before an input from the stream to which it is tied. For example, cout is tied to cin:

cout << "Please enter a number: ";
int num;
cin >> num;
This code does not explicitly call cout.flush(), so had cout not been tied to cin, the user would not see the request for input.

ios_base Operations (§iso.27.5.3.5, §iso.27.5.3.6)

i=xalloc()

i is the index of a new (iword,pword) pair; static

r=iob.iword(i)

r is a reference to the ith long

r=iob.pword(i)

r is a reference to the ith void*

iob.register_callback(fn,i)

Register callback fn to iword(i)

Sometimes, people want to add to the state of a stream. For example, one might want a stream to “know” whether a complex should be output in polar or Cartesian coordinates. Class ios_base provides a function xalloc() to allocate space for such simple state information. The value returned by xalloc() identifies a pair of locations that can be accessed by iword() and pword().

Sometimes, an implementer or a user needs to be notified about a change in a stream’s state. The register_callback() function “registers” a function to be called when its “event” occurs. Thus, a call of imbue(), copyfmt(), or ~ios_base() will call a function “registered” for an imbue_event, copyfmt_event, or erase_event, respectively. When the state changes, registered functions are called with the argument i supplied by their register_callback().

The event and event_callback types are defined in ios_base:

Click here to view code image

enum event {
    erase_event,
    imbue_event,
    copyfmt_event
};
using event_callback = void (*)(event, ios_base&, int index);
38.4.5. Formatting
The format of stream I/O is controlled by a combination of object type, stream state (§38.4.4), format state (§38.4.5.1), locale information (Chapter 39), and explicit operations (e.g., manipulators; §38.4.5.2).

38.4.5.1. Formatting State
In <ios>, the standard library defines a set of formatting constants of an implementation-defined bitmask type fmtflags as members of class ios_base:

ios_base Formatting fmtflags Constants (§iso.27.5.3.1.2)

boolalpha

Use symbolic representation of true and false

dec

Integer base is 10

hex

Integer base is 16

oct

Integer base is 8

fixed

Floating-point format dddd.dd

scientific

Scientific format d.dddd Edd

internal

Pad between a prefix (such as +) and the number

left

Left-adjust: pad after the value

right

Right-adjust: pad before the value

showbase

On output, prefix octal numbers by 0

and hexadecimal numbers by 0x

showpoint

Always show the decimal point (e.g., 123.)

showpos

Show + for positive numbers (e.g., +123)

skipws

Skip whitespace on input

unitbuf

Flush after each output operation

uppercase

Use uppercase in numeric output, e.g., 1.2E10 and 0X1A2

adjustfield

Set a value’s placement in its field: left, right, or internal

basefield

Set the integer’s base: dec, oct, or hex

floatfield

Set the floating-point format: scientific or fixed

Curiously, there are no defaultfloat or hexfloat flags. To get the equivalent, use manipulators defaultfloat and hexfloat (§38.4.5.2), or manipulate the ios_base directly:

Click here to view code image

ios.unsetf(ios_base::floatfield);                                // use the default floating-point format
ios.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);            // use hexadecimal floats
An iostream’s format state can be read and written (set) by operations provided in its ios_base:

ios_base Formatting fmtflags Operations (§iso.27.5.3.2)

f=ios.flags()

f is ios’s formatting flags

f2=ios.flags(f)

Set ios’s formatting flags to f; f2 is the old value of the flags

f2=ios.setf(f)

Set f in ios’s formatting flags; f2 is the old value of the flags

f2=ios.setf(f,m)

f2=ios.setf(f&m)

ios.unsetf(f)

Clear the flags f in ios

n=ios.precision()

n is ios’s precision

n2=ios.precision(n)

Set ios’s precision to n; n2 is the old precision

n=ios.width()

n is ios’s width

n2=ios.width(n)

Set ios’s width to n; n2 is the old width

Precision is an integer that determines the number of digits used to display a floating-point number:

• The general format (defaultfloat) lets the implementation choose a format that presents a value in the style that best preserves the value in the space available. The precision specifies the maximum number of digits.

• The scientific format (scientific) presents a value with one digit before a decimal point and an exponent. The precision specifies the maximum number of digits after the decimal point.

• The fixed format (fixed) presents a value as an integer part followed by a decimal point and a fractional part. The precision specifies the maximum number of digits after the decimal point. For example, see §38.4.5.2.

Floating-point values are rounded rather than just truncated, and precision() doesn’t affect integer output. For example:

Click here to view code image

cout.precision(8);
cout << 1234.56789 << ' ' << 1234.56789 << ' ' << 123456 << '\n';

cout.precision(4);
cout << 1234.56789 << ' ' << 1234.56789 << ' ' << 123456 << '\n';
This produces:

1234.5679 1234.5679 123456
1235 1235 123456
The width() function specifies the minimum number of characters to be used for the next standard-library << output operation of a numeric value, bool, C-style string, character, pointer, string, and bitset (§34.2.2). For example:

Click here to view code image

cout.width(4);
cout << 12;    // print 12 preceded by two spaces
The “padding” or “filler” character can be specified by the fill() function. For example:

cout.width(4);
cout.fill('#');
cout << "ab";       // print ##ab
The default fill character is the space character, and the default field size is 0, meaning “as many characters as needed.” The field size can be reset to its default value like this:

cout.width(0);    //"as many characters as needed"
A call width(n) sets the minimum number of characters to n. If more characters are provided, they will all be printed. For example:

cout.width(4);
cout << "abcdef";    // print abcdef
It does not truncate the output to abcd. It is usually better to get the right output looking ugly than to get the wrong output looking just fine.

A width(n) call affects only the immediately following << output operation. For example:

Click here to view code image

cout.width(4);
cout.fill('#');
cout << 12 << ':' << 13;    // print ##12:13
This produces ##12:13, rather than ##12###:##13.

If the explicit control of formatting options through many separate operations becomes tedious, we can combine them using a user-defined manipulator (§38.4.5.3).

An ios_base also allows the programmer to set an iostream’s locale (Chapter 39):

ios_base locale Operations (§iso.27.5.3.3)

loc2=ios.imbue(loc)

Set ios’s locale to loc; loc2 is the old value of the locale

loc=ios.getloc()

loc is ios’s locale

38.4.5.2. Standard Manipulators
The standard library provides manipulators corresponding to the various format states and state changes. The standard manipulators are defined in <ios>, <istream>, <ostream>, and <iomanip> (for manipulators that take arguments):

I/O Manipulators from <ios> (§iso.27.5.6) (continues)

s<<boolalpha

Use symbolic representation of true and false (input and output)

s<<noboolalpha

s.unsetf(ios_base::boolalpha)

s<<showbase

On output prefix octal numbers by 0

and hexadecimal numbers by 0x

s<<noshowbase

s.unsetf(ios_base::showbase)

s<<showpoint

Always show decimal point

s<<noshowpoint

s.unsetf(ios_base::showpoint)

s<<showpos

Show + for positive numbers

s<<noshowpos

s.unsetf(ios_base::showpos)

s<<uppercase

Use uppercase in numeric output, e.g., 1.2E10 and 0X1A2

s<<nouppercase

Use lowercase in numeric output, e.g., 1.2e10 and 0x1a2

s<<unitbuf

Flush after each output operation

s<<nounitbuf

Do not flush after each output operation

I/O Manipulators from <ios> (continued) (§iso.27.5.6)

s<<internal

Pad where marked in formatting pattern

s<<left

Left-justified: pad after value

s<<right

Right-justified: pad before value

s<<dec

Integer base is 10

s<<hex

Integer base is 16

s<<oct

Integer base is 8

s<<fixed

Floating-point format dddd.dd

s<<scientific

Scientific format d.dddd Edd

s<<hexfloat

Use base 16 for mantissa and exponent, using p to start

an exponent, e.g., A.1BEp-C and a.bcdef

s«defaultfloat

Use the default floating point format

s>>skipws

Skip whitespace

s>>noskipws

s.unsetf(ios_base::skipws)

Each of these operations returns a reference to its first (stream) operand, s. For example:

cout << 1234 << ',' << hex << 1234 << ',' << oct << 1234 << '\n';        // print 1234,4d2,2322
We can explicitly set the output format for floating-point numbers:

     constexpr double d = 123.456;

     cout << d << "; "
          << scientific << d << "; "
          << hexfloat << d << "; "
          << fixed << d << "; "
          << defaultfloat << d << '\n';
This produces:

123.456; 1.234560e+002; 0x1.edd2f2p+6; 123.456000; 123.456
The floating-point format is “sticky”; that is, it persists for subsequent floating-point operations.

I/O Manipulators from <ostream> (§iso.27.7.3.8)

os<<endl

Put '\n' and flush

os<<ends

Put '\0'

os«flush

Flush stream

An ostream is flushed when it is destroyed, when a tie()d istream needs input (§38.4.4), and when the implementation finds it advantageous. Explicitly flushing a stream is very rarely necessary. Similarly, <<endl can be considered equivalent to <<'\n', but the latter is probably a bit faster. I find

cout << "Hello, World!\n";
easier to read and write than

cout << "Hello, World!" << endl;
If you have a genuine need for frequent flushing, consider cerr and unitbuf.

I/O Manipulators from <iomanip> (§iso.27.7.4 §iso.27.7.5)

s<<resetiosflags(f)

Clear flags f

s<<setiosflags(f)

Set flags f

s<<setbase(b)

Output integers in base b

s«setfill(int c)

Make c the fill character

s<<setprecision(n)

Precision is n digits

s<<setw(n)

Next field width is n char

is>>get_money(m,intl)

Read from is using is’s money_get facet;

m is a long double or a basic_string;

if intl==true, use standard three-letter currency names

is>>get_money(m)

s>>get_money(m,false)

os<<put_money(m,intl)

Write m to os using os’s money_put facet;

that money_put determines which types are acceptable for m;

if intl==true, use standard three-letter currency names

os<<put_money(m)

s<<put_money(m,false)

is>>get_time(tmp,fmt)

Read into *tmp according to the format fmt,

using is’s time_get facet

os<<put_time(tmp,fmt)

Write *tmp to os according to the format fmt,

using os’s time_put facet

The time facets are found in §39.4.4 and the time formats in §43.6.

For example:

cout << '(' << setw(4) << setfill('#') << 12 << ") (" << 12 << ")\n";       // print (##12) (12)
istream Manipulators (§iso.27.5.6.1, §iso.27.7.2.4) |

s>>skipws

Skip whitespace (in <ios>)

s>>noskipws

s.unsetf(ios_base::skipws) (in <ios>)

is>>ws

Eat whitespace (in <istream>)

By default >> skips whitespace (§38.4.1). This default can be modified by >>skipws and >>noskipws. For example:

Click here to view code image

string input {"0 1 2 3 4"};
istringstream iss {input};
string s;
for (char ch; iss>>ch;)
      s += ch;
cout << s;                 // print "01234"

istringstream iss2 {input};
iss>>noskipws;
for (char ch; iss2>>ch;)
      s += ch;
cout << s;                 // print "0 1 2 3 4"
}
If you want to explicitly deal with whitespace (e.g., to make a newline significant) and still use >>, noskipws and >>ws become a convenience.

38.4.5.3. User-Defined Manipulators
A programmer can add manipulators in the style of the standard ones. Here, I present an additional style that I have found useful for formatting floating-point numbers.

Formatting is controlled by a confusing multitude of separate functions (§38.4.5.1). For example, a precision() persists for all output operations, but a width() applies to the next numeric output operation only. What I want is something that makes it simple to output a floating-point number in a predefined format without affecting future output operations on the stream. The basic idea is to define a class that represents formats, another that represents a format plus a value to be formatted, and then an operator << that outputs the value to an ostream according to the format. For example:

Click here to view code image

Form gen4 {4};       // general format, precision 4

void f(double d)
{
     Form sci8;
     sci8.scientific().precision(8);        // scientific format, precision 8
     cout << d << ' ' << gen4(d) << ' ' << sci8(d) << ' ' << d << '\n';

     Form sci {10,ios_base::scientific};    // scientific format, precision 10
     cout << d << ' ' << gen4(d) << ' ' << sci(d) << ' ' << d << '\n';
}
A call f(1234.56789) writes:

Click here to view code image

1234.57 1235 1.23456789e+003 1234.57
1234.57 1235 1.2345678900e+003 1234.57
Note how the use of a Form doesn’t affect the state of the stream, so that the last output of d has the same default format as the first.

Here is a simplified implementation:

Click here to view code image

class Form;        // our formatting type

struct Bound_form {      // Form plus value
     const Form& f;
     double val;
};

class Form {
     friend ostream& operator<<(ostream&, const Bound_form&);

     int prc;                     // precision
     int wdt;                    // width 0 means "as wide as necessary"
     ios_base::fmtflags fmt;   // general, scientific, or fixed (§38.4.5.1)
      //...
public:
     explicit Form(int p =6, ios_base::fmtflags f =0, int w =0) : prc{p}, fmt{f}, wdt{w} {}

     Bound_form Form::operator()(double d) const           // make a Bound_form for *this and d
     {
         return Bound_form{*this,d};
     }

     Form& scientific() { fmt = ios_base::scientific; return *this; }
     Form& fixed() { fmt = ios_base::fixed; return *this; }
     Form& general() { fmt = 0; return *this; }

     Form& uppercase();
     Form& lowercase();
     Form& precision(int p) { prc = p; return *this; }

     Form& width(int w) { wdt = w; return *this; }        // applies to all types
     Form& fill(char);

     Form& plus(bool b = true);                           // explicit plus
     Form& trailing_zeros(bool b = true);                 // print trailing zeros
      //...
};
The idea is that a Form holds all the information needed to format one data item. The default is chosen to be reasonable for many uses, and the various member functions can be used to reset individual aspects of formatting. The () operator is used to bind a value with the format to be used to output it. A Bound_form (that is, a Form plus a value) can then be output to a given stream by a suitable << function:

Click here to view code image

ostream& operator<<(ostream& os, const Bound_form& bf)
{
    ostringstream s;                  //§38.2.2
    s.precision(bf.f.prc);
    s.setf(bf.f.fmt,ios_base::floatfield);
    s << bf.val;                // compose string in s
    return os << s.str();       // output s to os
}
Writing a less simplistic implementation of << is left as an exercise.

Note that these declarations make the combination of << and () into a ternary operator; cout<<sci4{d} collects the ostream, the format, and the value into a single function before doing any real computation.

38.5. Stream Iterators
In <iterator>, the standard library provides iterators to allow input and output streams to be viewed as sequences [input-begin:end-of-input) and [output-begin:end-of-output):

Click here to view code image

template<typename T,
         typename C = char,
         typename Tr = char_traits<C>,
         typename Distance = ptrdiff_t>
class istream_iterator
     :public iterator<input_iterator_tag, T, Distance, const T*, const T&> {
     using char_type = C;
     using traits_type = Tr;
     using istream_type = basic_istream<C,Tr>;
      //...
};

template<typename T, typename C = char, typename Tr = char_traits<C>>
class ostream_iterator: public iterator<output_iterator_tag, void, void, void, void> {
     using char_type = C;
     using traits_type = Tr;
     using ostream_type = basic_ostream<C,Tr>;
      //...
};
For example:

Click here to view code image

copy(istream_iterator<double>{cin}, istream_iterator<double,char>{},
     ostream_iterator<double>{cout,";\n"});
When an ostream_iterator is constructed with a second (string) argument, that string is output as a terminator after every element value. So, if you enter 1 2 3 to that call of copy(), the output is:

1;
2;
3;
The operators provided for a stream_iterator are the same as for other iterator adaptors (§33.2.2):

Stream Iterator Operations (§iso.24.6)

istream_iterator p {};

End-of-stream iterator

istream_iterator p {st};

Iterator for input stream st

istream_iterator p {p2};

Copy constructor: p is a copy of the istream_iterator p2

ostream_iterator p {st};

Iterator for output stream st

ostream_iterator p {p2};

Copy constructor: p is a copy of the ostream_iterator p2

ostream_iterator p {st,s};

Iterator for output stream st; use the C-style string s

as the separator between output elements

p=p2

p is a copy of p2

p2=++p

p and p2 point to the next element

p2=p++

p2=p,++p

*p=x

Insert x before p; ostream_iterator only

*p++=x

Insert x before p, then increment p; ostream_iterator only

x=*p

Read *p into x; istream_iterator only

x=p->m

Read p->m into x; istream_iterator only

Except for the constructors, these operations are typically used by general algorithms, such as copy(), rather than directly.

38.6. Buffering
Conceptually, an output stream puts characters into a buffer. Sometime later, the characters are then written to (“flushed to”) wherever they are supposed to go. Such a buffer is called a streambuf. Its definition is found in <streambuf>. Different types of streambufs implement different buffering strategies. Typically, the streambuf stores characters in an array until an overflow forces it to write the characters to their real destination. Thus, an ostream can be represented graphically like this:



The set of template arguments for an ostream and its streambuf must be the same, and they determine the type of character used in the character buffer.

An istream is similar, except that the characters flow the other way.

Unbuffered I/O is simply I/O where the streambuf immediately transfers each character, rather than holding on to characters until enough have been gathered for efficient transfer.

The key class in the buffering mechanisms is basic_streambuf:

Click here to view code image

template<typename C, typename Tr = char_traits<C>>
class basic_streambuf {
public:
     using char_type = C;                        // the type of a character
     using int_type = typename Tr::int_type;     // the integer type to which
                                                 // a character can be converted
     using pos_type = typename Tr::pos_type;     // type of position in buffer
     using off_type = typename Tr::off_type;     // type of offset from position in buffer
     using traits_type = Tr;
      //...
     virtual ~basic_streambuf();
};
As usual, a couple of aliases are provided for the (supposedly) most common cases:

Click here to view code image

using streambuf = basic_streambuf<char>;
using wstreambuf = basic_streambuf<wchar_t>;
The basic_streambuf has a host of operations. Many of the public operations simply call a protected virtual function that ensures that a function from a derived class implemented the operation appropriately for the particular kind of buffer:

public basic_streambuf<C,Tr> Operations (§iso.27.6.3)

sb.~basic_streambuf()

Destructor: release all resources; virtual

loc=sb.getloc()

loc is sb’s locale

loc2=sb.pubimbue(loc)

sb.imbue(loc); loc2 is a pointer to the previous locale

psb=sb.pubsetbuf(s,n)

psb=sb.setbuf(s,n)

pos=sb.pubseekoff(n,w,m)

pos=sb.seekoff(n,w,m)

pos=sb.pubseekoff(n,w)

pos=sb.seekoff(n,w)

pos=sb.pubseekpos(n,m)

pos=sb.seekpos(n,m)

pos=sb.pubseekpos(n)

pos=sb.seekpos(n)

sb.pubsync()

sb.sync()

All constructors are protected because basic_streambuf is designed as a base class.

public basic_streambuf<C,Tr> Operations (§iso.27.6.3)

basic_streambuf sb {};

Construct sb with no character buffer and the global locale

basic_streambuf sb {sb2};

sb is a copy of sb2 (they share a character buffer)

sb=sb2

sb is a copy of sb2 (they share a character buffer);

sb’s old resources are released

sb.swap(sb2)

Exchange the states of sb and sb2

sb.imbue(loc)

loc becomes sb’s locale; virtual

psb=sb.setbuf(s,n)

Set sb’s buffer; psb=&sb;

s is a const char* and n is a streamsize; virtual

pos=sb.seekoff(n,w,m)

Seek with an offset n, a direction w, and a mode m;

pos is the resulting position or pos_type(off_type(-1)),

indicating an error; virtual

pos=sb.seekoff(n,w)

pos=sb.seekoff(n,w,ios_base::in|ios_base::out)

pos=sb.seekpos(n,m)

Seek to position n and a mode m;

pos is the resulting position or pos_type(off_type(-1)),

indicating an error; virtual

pos=sb.seekpos(n,m)

pos=sb.seekpos(n,ios_base::in|ios_base::out)

n=sb.sync()

Synchronize the buffer with the destination or source; virtual

The exact meaning of the virtual functions are determined by derived classes.

A streambuf has a put area into which << and other output operations write (§38.4.2), and a get area from which >> and other input operations read (§38.4.1). Each area is described by a beginning pointer, current pointer, and one-past-the-end pointer:



Overflow is handled by the virtual functions overflow(), underflow(), and uflow().

For a use of positioning, see §38.6.1.

The put-and-get interface is separated into a public and a protected one:

public Put and Get basic_streambuf<C,Tr> Operations (§iso.27.6.3) (continues)

n=sb.in_avail()

If a read position is available, n=sb.egptr()-sb.gptr();

otherwise returns sb.showmanyc()

n=sb.snextc()

n = sb.sbumpc()==Tr::eof() ? Tr::eof() : sb.sgetc()

n=sb.sbumpc()

Increase sb’s get pointer: If there is no character left, n=sb.uflow();

otherwise n=Tr::to_int_type(*sb.gptr())

n=sb.sgetc()

If there is no character left to get, n=sb.underflow();

otherwise n=Tr::to_int_type(*sb.gptr())

n2=sb.sgetn(p,n)

n2=sb.xsgetn(p,n); p is a char*

n=sb.sputbackc(c)

Put c back into the get area and decrease the gptr;

n=Tr::to_int_type(*sb.gptr()) if the putback succeeded;

otherwise n=sb.pbackfail(Tr::to_int_type(c))

n=sb.sungetc()

Decrease the get pointer;

n=Tr::to_int_type(*sb.gptr()) if the unget succeeded;

otherwise n=sb.pbackfail(Tr::to_int_type())

n=sb.sputc(c)

If there is no character left to put into,

n=sb.overflow(Tr::to_int_type(c));

otherwise *sb.pptr()=c; n=Tr::to_int_type(c)

n2=sb.sputn(s,n)

n2=sb.xsputn(s,n); s is a const char*

The protected interface provides simple, efficient, and typically inlined functions manipulating the put and get pointers. In addition, there are virtual functions to be overridden by derived classes.

protected Put and Get basic_streambuf<C,Tr> Operations (continued) (§iso.27.6.3)

sb.setg(b,n,end)

The get area is [b:e); the current get pointer is n

pc=sb.eback()

[pc:sb.egptr()) is the get area

pc=sb.gptr()

pc is the get pointer

pc=sb.egptr()

[sb.eback():pc) is the get area

sb.gbump(n)

Increase sb’s get pointer by n

n=sb.showmanyc()

“Show how many characters”; n is an estimate of how many

characters can be read without calling sb.underflow()

or n=-1 indicating that no characters are ready to be read; virtual

n=sb.underflow()

No more characters in the get area; replenish the get area;

n=Tr::to_int_type(c) where c is the new current get character; virtual

n=sb.uflow()

Like sb.underflowQ, but advance the get pointer after reading

the new current get character; virtual

n=sb.pbackfail(c)

A putback operation failed; n=Tr::eof() if an overriding

pbackfail() could not put back; virtual

n=sb.pbackfail()

n=sb.pbackfail(Tr::eof())

protected Put and Get basic_streambuf<C,Tr> Operations (continued) (§iso.27.6.3)

sb.setp(b,e)

The put area is [b:e); the current put pointer is b

pc=sb.pbase()

[pc:sb.epptr()) is the put area

pc=sb.pptr()

pc is the put pointer

pc=sb.epptr()

[sb.pbase():pc) is the put area

sb.pbump(n)

Add n to the put pointer

n2=sb.xsgetn(s,n)

s is a char*;do *p=sb.sgetc() for each p in [s:s+n);

n2 is the number of characters read; virtual

n2=sb.xsputn(s,n)

s is a const char*; sb.sputc(*p) for each p in [s:s+n);

n2 is the number of character written; virtual

n=sb.overflow(c)

Flush the put area to the destination, then n=sb.sputc(c); virtual

n=sb.overflow()

n=sb.overflow(Tr::eof())

The showmanyc() (“show how many characters”) function is an odd function intended to allow a user to learn something about the state of a machine’s input system. It returns an estimate of how many characters can be read “soon,” say, by emptying the operating system’s buffers rather than waiting for a disk read. A call to showmanyc() returns –1 if it cannot promise that any character can be read without encountering end-of-file. This is (necessarily) rather low-level and highly implementation-dependent. Don’t use showmanyc() without a careful reading of your system documentation and conducting a few experiments.

38.6.1. Output Streams and Buffers
An ostream provides operations for converting values of various types into character sequences according to conventions (§38.4.2) and explicit formatting directives (§38.4.5). In addition, an ostream provides operations that deal directly with its streambuf:

Click here to view code image

template<typename C, typename Tr = char_traits<C>>
class basic_ostream : virtual public basic_ios<C,Tr> {
public:
      //...
     explicit basic_ostream(basic_streambuf<C,Tr>* b);

     pos_type tellp();                                    // get current position
     basic_ostream& seekp(pos_type);                      // set current position
     basic_ostream& seekp(off_type, ios_base::seekdir);   // set current position

     basic_ostream& flush();                              // empty buffer (to real destination)

     basic_ostream& operator<<(basic_streambuf<C,Tr>* b);      // write from b
};
The basic_ostream functions override their equivalents in the basic_ostream’s basic_ios base.

An ostream is constructed with a streambuf argument, which determines how the characters written are handled and where they eventually go. For example, an ostringstream (§38.2.2) or an ofstream (§38.2.1) is created by initializing an ostream with a suitable streambuf (§38.6).

The seekp() functions are used to position an ostream for writing. The p suffix indicates that it is the position used for putting characters into the stream. These functions have no effect unless the stream is attached to something for which positioning is meaningful, such as a file. The pos_type represents a character position in a file, and the off_type represents an offset from a point indicated by an ios_base::seekdir.

Stream positions start at 0, so we can think of a file as an array of n characters. For example:

Click here to view code image

int f(ofstream& fout) // fout refers to some file
{
      fout << "0123456789";
      fout.seekp(8);                     //8 from beginning
      fout << '#';                       // add '#' and move position (+1)
      fout.seekp(–4,ios_base::cur);      //4 backward
      fout << '*';                       // add '*' and move position (+1)
}
If the file was initially empty, we get:

01234*67#9
There is no similar way to do random access on elements of a plain istream or ostream. Attempting to seek beyond the beginning or the end of a file typically puts the stream into the bad() state (§38.4.4). However, some operating systems have operating modes where the behavior differs (e.g., positioning might resize a file).

The flush() operation allows the user to empty the buffer without waiting for an overflow.

It is possible to use << to write a streambuf directly into an ostream. This is primarily handy for implementers of I/O mechanisms.

38.6.2. Input Streams and Buffers
An istream provides operations for reading characters and converting them into values of various types (§38.4.1). In addition, an istream provides operations that deal directly with its streambuf:

Click here to view code image

template<typename C, typename Tr = char_traits<C>>
class basic_istream : virtual public basic_ios<C,Tr> {
public:
      //...
     explicit basic_istream(basic_streambuf<C,Tr>* b);
     pos_type tellg();                                      // get current position
     basic_istream& seekg(pos_type);                        // set current position
     basic_istream& seekg(off_type, ios_base::seekdir);     // set current position

     basic_istream& putback(C c);      // put c back into the buffer
     basic_istream& unget();           // put back most recent char read
     int_type peek();                  // look at next character to be read

     int sync();                       // clear buffer (flush)

     basic_istream& operator>>(basic_streambuf<C,Tr>* b);       // read into b
     basic_istream& get(basic_streambuf<C,Tr>& b, C t = Tr::newline());
     streamsize readsome(C* p, streamsize n);    // read at most n char
};
The basic_istream functions override their equivalents in the basic_istream’s basic_ios base.

The positioning functions work like their ostream counterparts (§38.6.1). The g suffix indicates that it is the position used for getting characters from the stream. The p and g suffixes are needed because we can create an iostream derived from both istream and ostream, and such a stream needs to keep track of both a get position and a put position.

The putback() function allows a program to put a character “back” into an istream to be the next character read. The unget() function puts the most recently read character back. Unfortunately, backing up an input stream is not always possible. For example, trying to back up past the first character read will set ios_base::failbit. What is guaranteed is that you can back up one character after a successful read. The peek() function reads the next character and also leaves that character in the streambuf so that it can be read again. Thus, c=peek() is logically equivalent to (c=get(),unget(),c). Setting failbit might trigger an exception (§38.3).

Flushing an istream is done using sync(). This cannot always be done right. For some kinds of streams, we would have to reread characters from the real source – and that is not always possible or desirable (e.g., for a stream attached to a network). Consequently, sync() returns 0 if it succeeded. If it failed, it sets ios_base::badbit (§38.4.4) and returns –1. Setting badbit might trigger an exception (§38.3). A sync() on a buffer attached to an ostream flushes the buffer to output.

The >> and get() operations that directly read from a streambuf are primarily useful for implementers of I/O facilities.

The readsome() function is a low-level operation that allows a user to peek at a stream to see if there are any characters available to read. This can be most useful when it is undesirable to wait for input, say, from a keyboard. See also in_avail() (§38.6).

38.6.3. Buffer Iterators
In <iterator>, the standard library provides istreambuf_iterator and ostreambuf_iterator to allow a user (mostly an implementer of a new kind of iostream) to iterate over the contents of a stream buffer. In particular, these iterators are widely used by locale facets (Chapter 39).

38.6.3.1. istreambuf_iterator
An istreambuf_iterator reads a stream of characters from an istream_buffer:

Click here to view code image

template<typename C, typename Tr = char_traits<C>>  //§iso.24.6.3
class istreambuf_iterator
     :public iterator<input_iterator_tag, C, typename Tr::off_type, /*unspecified*/, C> {
public:
     using char_type = C;
     using traits_type = Tr;
     using int_type = typename Tr::int_type;
     using streambuf_type = basic_streambuf<C,Tr>;
     using istream_type = basic_istream<C,Tr>;
      //...
};
The reference member of the iterator base is not used and is consequently left unspecified.

If you use an istreambuf_iterator as an input iterator, its effect is like that of other input iterators: a stream of characters can be read from input using c=*p++:

istreambuf_iterator<C,Tr> (§iso.24.6.3)

istreambuf_iterator p {};

p is an end-of-stream iterator; noexcept; constexpr

istreambuf_iterator p {p2};

Copy constructor; noexcept

istreambuf_iterator p {is};

p is an iterator for is.rdbuf(); noexcept

istreambuf_iterator p {psb};

p is an iterator to the istreambuf *psb; noexcept

istreambuf_iterator p {nullptr};

p is an end-of-stream iterator

istreambuf_iterator p {prox};

p points to the istreambuf designated by prox; noexcept

p.~istreambuf_iterator()

Destructor

c=*p

c is the character returned by the streambuf’s sgetc()

p->m

The member m of *p, if that is a class object

p=++p

The streambuf’s sbumpc()

prox=p++

Let prox designate the same position as p; then ++p

p.equal(p2)

Are both p and p2, or neither, at end-of-stream

p==p2

p.equal(p2)

p!=p2

!p.equal(p2)

Note that any attempt to be clever when comparing istreambuf_iterators will fail: you cannot rely on two iterators referring to the same character while input is going on.

38.6.3.2. ostreambuf_iterator
An ostreambuf_iterator writes a stream of characters to an ostream_buffer:

Click here to view code image

template<typename C, typename Tr = char_traits<C>>   //§iso.24.6.4
class ostreambuf_iterator
     :public iterator<output_iterator_tag, void, void, void, void> {
public:
     using char_type = C;
     using traits_type = Tr;
     using streambuf_type = basic_streambuf<C,Tr>;
     using ostream_type = basic_ostream<C,Tr>;
      //...
};
By most measures, ostreambuf_iterator’s operations are odd, but the net effect is that if you use it as an output iterator, its effect is like that of other output iterators: a stream of characters can be written to output using *p++=c:

ostreambuf_iterator<C,Tr> (§iso.24.6.4) (continues)

ostreambuf_iterator p {os};

p is an iterator for os.rdbuf(); noexcept

ostreambuf_iterator p {psb};

p is an iterator for the istreambuf *psb; noexcept

ostreambuf_iterator<C,Tr> (continued) (§iso.24.6.4)

p=c

If !p.failed() call the streambuf’s sputc(c)

*p

Do nothing

++p

Do nothing

p++

Do nothing

p.failed()

Has a sputc() on p’s streambuf reached eof? noexcept

38.7. Advice
[1] Define << and >> for user-defined types with values that have meaningful textual representations; §38.1, §38.4.1, §38.4.2.

[2] Use cout for normal output and cerr for errors; §38.1.

[3] There are iostreams for ordinary characters and wide characters, and you can define an iostream for any kind of character; §38.1.

[4] There are standard iostreams for standard I/O streams, files, and strings; §38.2.

[5] Don’t try to copy a file stream; §38.2.1.

[6] Binary I/O is system specific; §38.2.1.

[7] Remember to check that a file stream is attached to a file before using it; §38.2.1.

[8] Prefer ifstreams and ofstreams over the generic fstream; §38.2.1.

[9] Use stringstreams for in-memory formatting; §38.2.2.

[10] Use exceptions to catch rare bad() I/O errors; §38.3.

[11] Use the stream state fail to handle potentially recoverable I/O errors; §38.3.

[12] You don’t need to modify istream or ostream to add new << and >> operators; §38.4.1.

[13] When implementing a iostream primitive operation, use sentry; §38.4.1.

[14] Prefer formatted input over unformatted, low-level input; §38.4.1.

[15] Input into strings does not overflow; §38.4.1.

[16] Be careful with the termination criteria when using get(), getline(), and read(); §38.4.1.

[17] By default >> skips whitespace; §38.4.1.

[18] You can define a << (or a >>) so that it behaves as a virtual function based on its second operand; §38.4.2.1.

[19] Prefer manipulators to state flags for controlling I/O; §38.4.3.

[20] Use sync_with_stdio(true) if you want to mix C-style and iostream I/O; §38.4.4.

[21] Use sync_with_stdio(false) to optimize iostreams; §38.4.4.

[22] Tie streams used for interactive I/O; §38.4.4.

[23] Use imbue() to make an iostream reflect “cultural differences” of a locale; §38.4.4.

[24] width() specifications apply to the immediately following I/O operation only; §38.4.5.1.

[25] precision() specifications apply to all following floating-point output operations; §38.4.5.1.

[26] Floating-point format specifications (e.g., scientific) apply to all following floating-point output operations; §38.4.5.2.

[27] #include <iomanip> when using standard manipulators taking arguments; §38.4.5.2.

[28] You hardly ever need to flush(); §38.4.5.2.

[29] Don’t use endl except possibly for aesthetic reasons; §38.4.5.2.

[30] If iostream formatting gets too tedious, write your own manipulators; §38.4.5.3.

[31] You can achieve the effect (and efficiency) of a ternary operator by defining a simple function object; §38.4.5.3.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


38. I/O Streams
39. Locales
40. Numerics
47h 26m remaining
39. Locales
When in Rome, do as the Romans do.

– Proverb

• Handling Cultural Differences

• Class locale

Named locales; Comparing strings

• Class facet

Accessing facets in a locale; A Simple User-defined facet; Uses of locales and facets

• Standard facets

string Comparison; Numeric Formatting; Money Formatting; Date and Time Formatting; Character Classification; Character Code Conversion; Messages

• Convenience Interfaces

Character Classifications; Character Conversions; String Conversions; Buffer Conversions

• Advice

39.1. Handling Cultural Differences
A locale is an object that represents a set of cultural preferences, such as how strings are compared, the way numbers appear as human-readable output, and the way characters are represented in external storage. The notion of a locale is extensible so that a programmer can add new facets to a locale representing locale-specific entities not directly supported by the standard library, such as postal codes (zip codes) and phone numbers. The primary use of locales in the standard library is to control the appearance of information written to an ostream and the format of data read by an istream.

This chapter describes how to use a locale, how a locale is constructed out of facets, and how a locale affects an I/O stream.

The notion of a locale is not primarily a C++ notion. Most operating systems and application environments have a notion of locale. Such a notion is – in principle – shared among all programs on a system, independently of which programming language they are written in. Thus, the C++ standard-library notion of a locale can be seen as a standard and portable way for C++ programs to access information that has very different representations on different systems. Among other things, a C++ locale is an interface to system information that is represented in incompatible ways on different systems.

Consider writing a program that needs to be used in several countries. Writing a program in a style that allows that is often called internationalization (emphasizing the use of a program in many countries) or localization (emphasizing the adaptation of a program to local conditions). Many of the entities that a program manipulates will conventionally be displayed differently in those countries. We can handle this by writing our I/O routines to take this into account. For example:

Click here to view code image

void print_date(const Date& d)      // print in the appropriate format
{
     switch(where_am_I) {     // user-defined style indicator
     case DK:            // e.g., 7. marts 1999
          cout << d.day() << ". " << dk_month[d.month()] << " " << d.year();
          break;
     case ISO:           // e.g., 1999-3-7
          cout << d.year() << " – " << d.month() << " – " << d.day();
          break;
     case US:            // e.g., 3/7/1999
          cout << d.month() << "/" << d.day() << "/" << d.year();
          break;
      //...
     }
}
This style of code does the job. However, such code is ugly and hard to maintain. In particular, we have to use this style consistently to ensure that all output is properly adjusted to local conventions. If we want to add a new way of writing a date, we must modify the application code. Worse yet, writing dates is only one of many examples of cultural differences.

Consequently, the standard library provides an extensible way of handling cultural conventions. The iostream library relies on this framework to handle both built-in and user-defined types (§38.1). For example, consider a simple loop copying (Date,double) pairs that might represent a series of measurements or a set of transactions:

Click here to view code image

void cpy(istream& is, ostream& os) // copy (Date,double) stream
{
     Date d;
     double volume;

     while (is >> d >> volume)
           os << d << ' '<< volume << '\n';
}
Naturally, a real program would do something with the records and ideally also be a bit more careful about error handling.

How would we make this program read a file that conformed to French conventions (where a comma is the character used to represent the decimal point in a floating-point number; for example, 12,5 means twelve and a half) and write it according to American conventions? We can define locales and I/O operations so that cpy() can be used to convert between conventions:

Click here to view code image

void f(istream& fin, ostream& fout, istream& fin2, ostream& fout2)
{
     fin.imbue(locale{"en_US.UTF–8"});        // American English
     fout.imbue(locale{"fr_FR.UTF–8"});       // French
     cpy(fin,fout);                           // read American English, write French
      //...

     fin2.imbue(locale{"fr_FR.UTF–8"});       // French
     fout2.imbue(locale{"en_US.UTF–8"});      // American English
     cpy(fin2,fout2);                         // read French, write American English
      //...
}
Given these streams:

Apr 12, 1999    1000.3
Apr 13, 1999    345.45
Apr 14, 1999    9688.321
...
3 juillet 1950  10,3
3 juillet 1951  134,45
3 juillet 1952  67,9
...
this program would produce:

12 avril 1999 1000,3
13 avril 1999 345,45
14 avril 1999 9688,321
...
July 3, 1950 10.3
July 3, 1951 134.45
July 3, 1952 67.9
...
Much of the rest of this chapter is devoted to describing the mechanisms that make this possible and explaining how to use them. However, most programmers will have little reason to deal with the details of locales and will never explicitly manipulate a locale. At most, they will simply retrieve a standard locale and imbue a stream with it (§38.4.5.1).

The concept of localization (internationalization) is simple. However, practical constraints make the design and implementation of locale quite intricate:

[1] A locale encapsulates cultural conventions, such as the appearance of a date. Such conventions vary in many subtle and unsystematic ways. These conventions have nothing to do with programming languages, so a programming language cannot standardize them.

[2] The concept of a locale must be extensible, because it is not possible to enumerate every cultural convention that is important to every C++ user.

[3] A locale is used in operations (e.g., I/O and sorting) from which people demand run-time efficiency.

[4] A locale must be invisible to the majority of programmers who want to benefit from facilities “doing the right thing” without having to know exactly what “the right thing” is or how it is achieved.

[5] A locale must be available to designers of facilities that deal with culture-sensitive information beyond the scope of the standard.

The mechanisms provided to compose those locales and to make them trivial to use constitute a little programming language of their own.

A locale is composed of facets that control individual aspects, such as the character used for punctuation in the output of a floating-point value (decimal_point(); §39.4.2) and the format used to read a monetary value (moneypunct; §39.4.3). A facet is an object of a class derived from class locale::facet (§39.3). We can think of a locale as a container of facets (§39.2, §39.3.1).

39.2. Class locale
The locale class and its associated facilities are presented in <locale>.

locale Members (§iso.22.3.1)

locale loc {};

loc is a copy of the current global locale; noexcept

locale loc {loc2};

Copy constructor: loc holds a copy of loc2;

loc.name()==loc2.name(); noexcept

locale loc {s};

Initialize loc to the locale with the name s;

s can be a string or a C-style string; loc.name()==s; explicit

locale loc {loc2,s,cat};

loc is a copy of loc2 except for the facet with category cat,

which is copied from locale{s}; s can be a string or a C-style string;

if loc2 has a name, loc has a name

locale loc {loc2,pf};

loc is a copy of loc2 except for the facet *pf

provided pf!=nullptr; loc does not have a name

locale loc {loc2,loc3,cat};

loc is a copy of loc2 except for the facet with category cat,

which is copied from loc3;

loc has a name if loc2 and loc3 both have names

loc.~locale()

Destructor; not virtual; noexcept

loc2=loc

Assignment: loc2 is a copy of loc; noexcept

loc3=loc.combine<F>(loc2)

loc3 is a copy of loc except for facet F,

which is copied from loc2; loc3 does not have a name

s=loc.name()

s is the name of loc’s locale or "*"

loc==loc2

Is loc the same locale as loc2?

loc!=loc2

!(loc==loc2)

loc(s,s2)

Compare basic_string<C>s s and s2, using loc’s collate<C> facet

loc2=global(loc)

Set the global locale to loc; loc2 is the previous global locale

loc=classic()

loc is the classic “C” locale

If a locale of a given name or a facet referred to doesn’t exist, the locale operation naming it throws a runtime_error.

Naming of locales is a bit curious. When you make a new locale from another plus a facet and the resulting locale has a name, that name is implementation-defined. Often, such an implementation-defined name includes the name of the locale that supplied most of the facets. For a locale without a name, name() returns "*".

A locale can be thought of as an interface to a map<id,facet*>, that is, something that allows us to use a locale::id to find a corresponding object of a class derived from locale::facet. A real implementation of locale is an efficient variant of this idea. The layout will be something like this:



Here, collate<char> and numpunct<char> are standard-library facets (§39.4). All facets are derived from locale::facet.

A locale is meant to be copied freely and cheaply. Consequently, a locale is almost certainly implemented as a handle to the specialized map<id,facet*> that constitutes the main part of its implementation. The facets must be quickly accessible in a locale. Consequently, the specialized map<id,facet*> will be optimized to provide array-like fast access. The facets of a locale are accessed by using the use_facet<Facet>(loc) notation; see §39.3.1.

The standard library provides a rich set of facets. To help the programmer manipulate facets in logical groups, the standard facets are grouped into categories, such as numeric and collate (§39.4):

facet Categories (§iso.22.3.1)

collate

E.g., collate; §39.4.1

ctype

E.g., ctype; §39.4.5

numeric

E.g., num_put, num_get, numpunct; §39.4.2

monetary

money_put, money_get, moneypunct; §39.4.3

time

E.g., time_put, time_get; §39.4.4

messages

messages; §39.4.7

all

collate | ctype | monetary | numeric | time | messages

none

 

There are no facilities for a programmer to specify a name string for a newly created locale. Name strings are either defined in the program’s execution environment or created as combinations of such names by locale constructors.

A programmer can replace facets from existing categories (§39.4, §39.4.2.1). However, there is no way for a programmer to define a new category. The notion of “category” applies to standard-library facets only, and it is not extensible. Thus, a facet need not belong to any category, and many user-defined facets do not.

If a locale x does not have a name string, it is undefined whether locale::global(x) affects the C global locale. This implies that a C++ program cannot reliably and portably set the C locale to a locale that wasn’t retrieved from the execution environment. There is no standard way for a C program to set the C++ global locale (except by calling a C++ function to do so). In a mixed C and C++ program, having the C global locale differ from global() is error prone.

By far the dominant use of locales is implicitly, in stream I/O. Each istream and ostream has its own locale. The locale of a stream is by default the global locale (§39.2.1) at the time of the stream’s creation. The locale of a stream can be set by the imbue() operation, and we can extract a copy of a stream’s locale using getloc() (§38.4.5.1).

Setting the global locale does not affect existing I/O streams; those still use the locales that they were imbued with before the global locale was reset.

39.2.1. Named locales
A locale is constructed from another locale and from facets. The simplest way of making a locale is to copy an existing one. For example:

Click here to view code image

locale loc1;                           // copy of the current global locale
locale loc2 {""};                      // copy of "the user's preferred locale"

locale loc3 {"C"};                     // copy of the "C" locale
locale loc4 {locale::classic()};       // copy of the "C" locale

locale loc5 {"POSIX"};                 // copy of the locale named "POSIX"
locale loc6 {"Danish_Denmark.1252"};   // copy of the locale named "Danish_Denmark.1252"
locale loc7 {"en_US.UTF–8"};           // copy of the locale named "en_US.UTF-8"
The meaning of locale{"C"} is defined by the standard to be the “classic” C locale; this is the locale that has been used throughout this book. Other locale names are implementation-defined.

The locale{""} is deemed to be “the user’s preferred locale.” This locale is set by extralinguistic means in a program’s execution environment. So to see your current “preferred locale,” write:

locale loc("");
cout << loc.name() << '\n';
On my Windows laptop, I got:

English_United States.1252
On my Linux box, I got:

en_US.UTF–8
The names of locales are not standardized for C++. Instead, a variety of organizations, such as POSIX and Microsoft, maintain their own (differing) standards across different programming languages. For example:

GNU Locale Name Examples (Based on POSIX)

ja_JP

Japanese for Japan

da_DK

Danish for Denmark

en_DK

English for Denmark

en_GB

English for Great Britain

en_US

English for the U.S.A.

fr_CA

French for Canada

de_DE

German for Germany

de_CH

German for Switzerland

de_AT

German for Austria

de_DE@euro

German for Germany with the euro symbol €

de_DE.utf8

German for Germany using UTF-8

de_DE.utf8@euro

German for Germany using UTF-8 with the euro symbol €

POSIX recommends a format of a lowercase language name, optionally followed by an uppercase country name, optionally followed by an encoding specifier, for example, sv_FI@euro (Swedish for Finland including the euro symbol).

Microsoft Locale Name Examples

Arabic_Qatar.1256

Basque_Spain.1252

Chinese_Singapore.936

English_United Kingdom.1252

English_United States.1252

French_Canada.1252

Greek_Greece.1253

Hebrew_Israel.1255

Hindi_India.1252

Russian_Russia.1251

Microsoft uses a language name followed by a country name optionally followed by a code page number. A code page is a named (or numbered) character encoding.

Most operating systems have ways of setting a default locale for a program. Typically, that is done through environment variables with names such as LC_ALL, LC_COLLATE, and LANG. Often, a locale suitable to the person using a system is chosen when that person first encounters a system. For example, I would expect a person who configures a Linux system to use Argentine Spanish as its default setting will find locale{""} to mean locale{"es_AR"}. However, these names are not standardized across platforms. So, to use named locales on a given system, a programmer must refer to system documentation and experiment.

It is generally a good idea to avoid embedding locale name strings in the program text. Mentioning a file name or a system constant in the program text limits the portability of a program and often forces a programmer who wants to adapt a program to a new environment to find and change such values. Mentioning a locale name string has similar unpleasant consequences. Instead, locales can be picked up from the program’s execution environment (for example, using locale("") or reading a file). Alternatively, a program can request a user to specify alternative locales by entering a string. For example:

Click here to view code image

void user_set_locale(const string& question)
{
     cout << question;   // e.g., "If you want to use a different locale, please enter its name"
     string s;
     cin >> s;
     locale::global(locale{s});  // set global locale as specified by user
}
It is usually better to let a non-expert user pick from a list of alternatives. A function implementing this would need to know where and how a system keeps its locales. For example, many Linux systems keep their locales in the directory /usr/share/locale.

If the string argument doesn’t refer to a defined locale, the constructor throws the runtime_error exception (§30.4.1.1). For example:

Click here to view code image

void set_loc(locale& loc, const char* name)
try
{
     loc = locale{name};
}
catch (runtime_error&) {
     cerr << "locale \"" << name << "\" isn't defined\n";
      //...
}
If a locale has a name string, name() will return it. If not, name() will return string("*"). A name string is primarily a way to refer to a locale stored in the execution environment. Secondarily, a name string can be used as a debugging aid. For example:

Click here to view code image

void print_locale_names(const locale& my_loc)
{
     cout << "name of current global locale: " << locale().name() << "\n";
     cout << "name of classic C locale: " << locale::classic().name() << "\n";
     cout << "name of "user's preferred locale": " << locale("").name() << "\n";
     cout << "name of my locale: " << my_loc.name() << "\n";
}
39.2.1.1. Constructing New locales
A new locale is made by taking an existing locale and adding or replacing facets. Typically, a new locale is a minor variation on an existing one. For example:

Click here to view code image

void f(const locale& loc, const My_money_io* mio)        // My_money_io defined in §39.4.3.1
{
     locale loc1(locale{"POSIX"},loc,locale::monetary);  // use monetary facets from loc
     locale loc2 = locale(locale::classic(), mio);             // classic plus mio
      //...
}
Here, loc1 is a copy of the POSIX locale modified to use loc’s monetary facets (§39.4.3). Similarly, loc2 is a copy of the C locale modified to use a My_money_io (§39.4.3.1). The resulting locales can be represented like this:



If a Facet* argument (here, My_money_io) is nullptr, the resulting locale is simply a copy of the locale argument.

In a construction locale{loc,f}, the f argument must identify a specific facet type. A plain facet* is not sufficient. For example:

Click here to view code image

void g(const locale::facet* mio1, const money_put<char>* mio2)
{
     locale loc3 = locale(locale::classic(), mio1);     // error: type of facet not known
     locale loc4 = locale(locale::classic(), mio2);     // OK: type of facet known (moneyput<char>)
      //...
}
The locale uses the type of the Facet* argument to determine the type of the facet at compile time. Specifically, the implementation of locale uses a facet’s identifying type, facet::id (§39.3), to find that facet in the locale (§39.3.1). The constructor

template<typename Facet> locale(const locale& x, Facet* f);
is the only mechanism offered within the language for the programmer to supply a facet to be used through a locale. Other locales are supplied by implementers as named locales (§39.2.1). Named locales can be retrieved from the program’s execution environment. A programmer who understands the implementation-specific mechanism used for that might be able to add new locales.

The set of constructors for locale is designed so that the type of every facet is known either from type deduction (of the Facet template parameter) or because it came from another locale (that knew its type). Specifying a category argument specifies the type of facets indirectly, because the locale knows the type of the facets in the categories. This implies that the locale class can (and does) keep track of the types of facets so that it can manipulate them with minimal overhead.

The locale::id member type is used by locale to identify facet types (§39.3).

There is no way of modifying a locale. Instead, the locale operations provide ways of making new locales from existing ones. The fact that a locale is immutable after it has been created is essential for run-time efficiency. This allows someone using a locale to call virtual functions of a facet and to cache the values returned. For example, an istream can know what character is used to represent the decimal point and how true is represented without calling decimal_point() each time it reads a number and truename() each time it reads to a bool (§39.4.2). Only a call of imbue() for the stream (§38.4.5.1) can cause such calls to return a different value.

39.2.2. Comparing strings
Comparing two strings according to a locale is possibly the most common use of a locale outside I/O. Consequently, this operation is provided directly by locale so that users don’t have to build their own comparison function from the collate facet (§39.4.1). This string comparison function is defined as locale’s operator()(). For example:

Click here to view code image

void user(const string s1, const string s2, const locale& my_locale)
{
     if (my_locale(s,s2)) {   // is s<s2 according to my_locale?
           //...
     }
}
Having the comparison function as the () operator makes it directly useful as a predicate (§4.5.4). For example:

Click here to view code image

void f(vector<string>& v, const locale& my_locale)
{
     sort(v.begin(),v.end());            // sort using < to compare elements
      //...
     sort(v.begin(),v.end(),my_locale);  // sort according to the rules of my_locale
      //...
}
By default, the standard-library sort() uses < for the numerical value of the implementation character set to determine collation order (§32.6, §31.2.2.1).

39.3. Class facet
A locale is a collection of facets. A facet represents one specific cultural aspect, such as how a number is represented on output (num_put), how a date is read from input (time_get), and how characters are stored in a file (codecvt). The standard-library facets are listed in §39.4.

A user can define new facets, such as a facet determining how the names of the seasons are printed (§39.3.2).

A facet is represented in a program as an object of a class derived from std::locale::facet. Like all other locale facilities, facet is found in <locale>:

Click here to view code image

class locale::facet {
protected:
     explicit facet(size_t refs = 0);
     virtual ~facet();
     facet(const facet&) = delete;
     void operator=(const facet&) = delete;
};
The facet class is designed to be a base class and has no public functions. Its constructor is protected to prevent the creation of “plain facet” objects, and its destructor is virtual to ensure proper destruction of derived-class objects.

A facet is intended to be managed through pointers stored in locales. A 0 argument to the facet constructor means that locale should delete the facet when the last reference to it goes away. Conversely, a nonzero constructor argument ensures that locale never deletes the facet. A nonzero argument is meant for the rare case in which the lifetime of a facet is controlled directly by the programmer rather than indirectly through a locale.

Each kind of facet interface must have a separate id:

Click here to view code image

class locale::id {
public:
     id();
     void operator=(const id&) = delete;
     id(const id&) = delete;
};
The intended use of id is for the user to define a static member of type id of each class supplying a new facet interface (for example, see §39.4.1). The locale mechanisms use ids to identify facets (§39.2, §39.3.1). In the obvious implementation of a locale, an id is used as an index into a vector of pointers to facets, thereby implementing an efficient map<id,facet*>.

Data used to define a (derived) facet is defined in the derived class. This implies that the programmer defining a facet has full control over the data and that arbitrary amounts of data can be used to implement the concept represented by a facet.

A facet is intended to be immutable, so all member functions of a user-defined facet should be defined const.

39.3.1. Accessing facets in a locale
The facets of a locale are accessed using two template functions:

Non-member locale functions (§iso.22.3.2)

f=use_facet<F>(loc)

f is a reference to the facet F in loc; throw bad_cast if loc doesn’t have F

has_facet<F>(loc)

Does loc have facet F? noexcept

Think of these functions as doing a lookup in their locale argument for their template parameter F. Alternatively, think of use_facet as a kind of explicit type conversion (cast) of a locale to a specific facet. This is feasible because a locale can have only one facet of a given type. For example:

Click here to view code image

void f(const locale& my_locale)
{
     char c = use_facet<numpunct<char>>(my_locale).decimal_point();  // use standard facet
      //...

     if (has_facet<Encrypt>(my_locale)) {    // does my_locale contain an Encrypt facet?
           const Encrypt& f = use_facet<Encrypt>(my_locale);      // retrieve Encrypt facet
           const Crypto c = f.get_crypto();                       // use Encrypt facet
            //...
     }
      //...
}
The standard facets are guaranteed to be available for all locales (§39.4), so we don’t need to use has_facet for standard facets.

One way of looking at the facet::id mechanism is as an optimized implementation of a form of compile-time polymorphism. A dynamic_cast can be used to get very similar results to what use_facet produces. However, the specialized use_facet can be implemented more efficiently than the general dynamic_cast.

An id identifies an interface and a behavior rather than a class. That is, if two facet classes have exactly the same interface and implement the same semantics (as far as a locale is concerned), they should be identified by the same id. For example, collate<char> and collate_byname<char> are interchangeable in a locale, so both are identified by collate<char>::id (§39.4.1).

If we define a facet with a new interface – such as Encrypt in f() – we must define a corresponding id to identify it (see §39.3.2 and §39.4.1).

39.3.2. A Simple User-Defined facet
The standard library provides standard facets for the most critical areas of cultural differences, such as character sets and I/O of numbers. To examine the facet mechanism in isolation from the complexities of widely used types and the efficiency concerns that accompany them, let me first present a facet for a trivial user-defined type:

enum Season { spring, summer, fall, winter };  // very simple user-defined type
The style of I/O outlined here can be used with little variation for most simple user-defined types.

Click here to view code image

class Season_io : public locale::facet {
public:
     Season_io(int i = 0) : locale::facet{i} { }
     ~Season_io() { }            // to make it possible to destroy Season_io objects (§39.3)

     virtual const string& to_str(Season x) const = 0;             // string representation of x
     virtual bool from_str(const string& s, Season& x) const = 0;  // place Season for s in x

     static locale::id id;  // facet identifier object (§39.2, §39.3, §39.3.1)
};

locale::id Season_io::id;  // define the identifier object
For simplicity, this facet is limited to strings of chars.

The Season_io class provides a general and abstract interface for all Season_io facets. To define the I/O representation of a Season for a particular locale, we derive a class from Season_io, defining to_str() and from_str() appropriately.

Output of a Season is easy. If the stream has a Season_io facet, we can use that to convert the value into a string. If not, we can output the int value of the Season:

Click here to view code image

ostream& operator<<(ostream& os, Season x)
{
     locale loc {os.getloc()};   // extract the stream's locale (§38.4.4)

     if (has_facet<Season_io>(loc))
           return os << use_facet<Season_io>(loc).to_str(x);  // string representation
     return os << static_cast<int>(x);                        // integer representation
}
For maximum efficiency and flexibility, standard facets tend to operate directly on stream buffers (§39.4.2.2, §39.4.2.3). However, for a simple user-defined type, such as Season, there is no need to drop to the streambuf level of abstraction.

As is typical, input is a bit more complicated than output:

Click here to view code image

istream& operator>>(istream& is, Season& x)
{
     const locale& loc {is.getloc()};                       // extract the stream's locale (§38.4.4)

     if (has_facet<Season_io>(loc)) {
           const Season_io& f {use_facet<Season_io>(loc)};  // get hold of the locale's Season_io facet

           string buf;
           if (!(is>>buf && f.from_str(buf,x)))             // read alphabetic representation
                  is.setstate(ios_base::failbit);
           return is;
     }

     int i;
     is >> i;                                               // read numeric representation
     x = static_cast<Season>(i);
     return is;
}
The error handling is simple and follows the error-handling style for built-in types. That is, if the input string didn’t represent a Season in the chosen locale, the stream is put into the fail state. If exceptions are enabled, this implies that an ios_base::failure exception is thrown (§38.3).

Here is a trivial test program:

Click here to view code image

int main()
      // a trivial test
{
     Season x;
      // use the default locale (no Season_io facet) implies integer I/O:
     cin >> x;
     cout << x << endl;

     locale loc(locale(),new US_season_io{});
     cout.imbue(loc);          // use locale with Season_io facet
     cin.imbue(loc);           // use locale with Season_io facet

     cin >> x;
     cout << x << endl;
}
Given the input

2
summer
this program responds:

2
summer
To get this, we must derive a class US_season_io from Season_io, and define an appropriate string representation of the seasons:

Click here to view code image

class US_season_io : public Season_io {
     static const string seasons[];
public:
     const string& to_str(Season) const;
     bool from_str(const string&, Season&) const;

      // note: no US_season_io::id
};

const string US_season_io::seasons[] = {
     "spring",
     "summer",
     "fall",
     "winter"
};
Then, we override the Season_io functions that convert between the string representation and the enumerators:

Click here to view code image

const string& US_season_io::to_str(Season x) const
{
    if (x<spring || winter<x) {
          static const string ss = "no–such–season";
          return ss;
    }
    return seasons[x];
}
bool US_season_io::from_str(const string& s, Season& x) const
{
    const string* p = find(begin(seasons),end(seasons),s);
    if (p==end)
          return false;

    x = Season(p–begin(seasons));
    return true;
}
Note that because US_season_io is simply an implementation of the Season_io interface, I did not define an id for US_season_io. In fact, if we want US_season_io to be used as a Season_io, we must not give US_season_io its own id. Operations on locales, such as has_facet (§39.3.1), rely on facets implementing the same concepts being identified by the same id (§39.3).

The only interesting implementation question is what to do if asked to output an invalid Season. Naturally, that shouldn’t happen. However, it is not uncommon to find an invalid value for a simple user-defined type, so it is realistic to take that possibility into account. I could have thrown an exception, but when dealing with simple output intended for humans to read, it is often helpful to produce an “out-of-range” representation for an out-of-range value. Note that for input, the error-handling policy is left to the >> operator, whereas for output, the facet function to_str() implements an error-handling policy. This was done to illustrate the design alternatives. In a “production design,” the facet functions would either implement error handling for both input and output or just report errors for >> and << to handle.

This Season_io design relies on derived classes to supply the locale-specific strings. An alternative design would have Season_io itself retrieve those strings from a locale-specific repository (see §39.4.7). The possibility of having a single Season_io class to which the season strings are passed as constructor arguments is left as an exercise.

39.3.3. Uses of locales and facets
The primary use of locales within the standard library is in I/O streams. However, the locale mechanism is a general and extensible mechanism for representing culture-sensitive information. The messages facet (§39.4.7) is an example of a facet that has nothing to do with I/O streams. Extensions to the iostream library and even I/O facilities that are not based on streams might take advantage of locales. Also, a user may use locales as a convenient way of organizing arbitrary culture-sensitive information.

Because of the generality of the locale/facet mechanism, the possibilities for user-defined facets are unlimited. Plausible candidates for representation as facets are dates, time zones, phone numbers, social security numbers (personal identification numbers), product codes, temperatures, general (unit,value) pairs, postal codes (zip codes), clothing sizes, and ISBN numbers.

As with every other powerful mechanism, facets should be used with care. That something can be represented as a facet doesn’t mean that it is best represented that way. The key issues to consider when selecting a representation for cultural dependencies are – as ever – how the various decisions affect the difficulty of writing code, the ease of reading the resulting code, the maintainability of the resulting program, and the efficiency in time and space of the resulting I/O operations.

39.4. Standard facets
In <locale>, the standard library provides these facets:

Standard facets (§iso.22.3.1.1.1)

collate

String comparison

collate<C>

§39.4.1

numeric

Numeric formatting

numpunct<C>

num_get<C,In>

num_put<C,Out>

§39.4.2

monetary

Money formatting

moneypunct<C>

moneypunct<C,International>

money_get<C,In>

money_put<C,Out>

§39.4.3

time

Date and time formatting

time_put<C,Out>

time_put_byname<C,Out>

time_get<C,In>

§39.4.4

ctype

Character classification

ctype<C>

codecvt<In,Ex,SS>

codecvt_byname<In,Ex,SS>

§39.4.5

messages

Message retrieval

messages<C>

§39.4.7

The details are explained in the referenced subsections.

When instantiating a facet from this table, C must be a character type (§36.1). These facets are guaranteed to be defined for char or wchar_t. In addition, ctype<C> is guaranteed to support char16_t and char32_t. A user who needs standard I/O to deal with another character type X must rely on implementation-specific facet specializations or provide suitable versions of facets for X. For example, codecvt<X,char,mbstate_t> (§39.4.6) might be needed to control conversions between X and char.

International can be true or false; true means that a three-character (plus zero terminator) “international” representation of a currency symbol is used (§39.4.3.1), such as USD and BRL.

A shift-state parameter, SS, is used to represent the shift states of a multibyte character representation (§39.4.6). In <cwchar>, mbstate_t is defined to represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. The equivalent to mbstate_t for an arbitrary character type X is char_traits<X>::state_type (§36.2.2).

In and Out are input iterators and output iterators, respectively (§33.1.2, §33.1.4). Providing the _put and _get facets with these template arguments allows a programmer to provide facets that access nonstandard buffers (§39.4.2.2). Buffers associated with iostreams are stream buffers, so the iterators provided for those are ostreambuf_iterators (§38.6.3, §39.4.2.2). Consequently, the function failed() is available for error handling (§38.6.3).

Each standard facet has a _byname version. An F_byname facet is derived from the facet F. F_byname provides the identical interface to F, except that it adds a constructor taking a string argument naming a locale (e.g., see §39.4.1). The F_byname(name) provides the appropriate semantics for F defined in locale(name).

The idea is to pick a version of a standard facet from a named locale (§39.2.1) in the program’s execution environment. This implies that _byname constructors can be very slow compared to constructors that do not need to consult the environment. It is almost always faster to construct a locale and then to access its facets than it is to use _byname facets in many places in a program. Thus, reading a facet from the environment once and then using the copy in main memory repeatedly is usually a good idea. For example:

Click here to view code image

locale dk {"da_DK"};     // read the Danish locale (including all of its facets) once
                   // then use the dk locale and its facets as needed

void f(vector<string>& v, const locale& loc)
{
     const collate<char>& col {use_facet<collate<char>>(dk)};
     const ctype<char>& ctyp {use_facet<ctype<char>>(dk)};

     locale dk1 {loc,&col};         // use Danish string comparison
     locale dk2 {dk1,&ctyp};  // use Danish character classification and string comparison

     sort(v.begin(),v.end(),dk2);
      //...
}
This dk2 locale will use Danish-style strings but will retain the default conventions for numbers.

The notion of categories gives a simpler way of manipulating standard facets in locales. For example, given the dk locale, we can construct a locale that reads and compares strings according to the rules of Danish (which has three more vowels than English) but that retains the syntax of numbers used in C++:

locale dk_us(locale::classic(),dk,collate|ctype);   // Danish letters, American numbers
The presentations of individual standard facets contain more examples of facet use. In particular, the discussion of collate (§39.4.1) brings out many of the common structural aspects of facets.

Standard facets often depend on each other. For example, num_put depends on numpunct. Only if you have a detailed knowledge of individual facets can you successfully mix and match facets or add new versions of the standard facets. In other words, beyond the simple operations (such as imbue() for iostreams and using collate for sort()), the locale mechanisms are not meant to be directly used by novices. For an extensive discussion of locales, see [Langer,2000].

The design of an individual facet is often messy. The reason is partially that facets have to reflect messy cultural conventions outside the control of the library designer, and partially that the C++ standard library-facilities have to remain largely compatible with what is offered by the C standard library and various platform-specific standards.

On the other hand, the framework provided by locales and facets is general and flexible. A facet can be designed to hold any data, and the facet’s operations can provide any desired operation based on that data. If the behavior of a new facet isn’t overconstrained by convention, its design can be simple and clean (§39.3.2).

39.4.1. string Comparison
The standard collate facet provides ways of comparing arrays of characters:

Click here to view code image

template<typename C>
class collate : public locale::facet {
public:
     using char_type = C;
     using string_type = basic_string<C>;

     explicit collate(size_t = 0);

     int compare(const C* b, const C* e, const C* b2, const C* e2) const
          { return do_compare(b,e,b2,e2); }

     long hash(const C* b, const C* e) const
          { return do_hash(b,e); }
     string_type transform(const C* b, const C* e) const
          { return do_transform(b,e); }

     static locale::id id;  // facet identifier object (§39.2, §39.3, §39.3.1)

protected:
     ~collate();  // note: protected destructor

     virtual int do_compare(const C* b, const C* e, const C* b2, const C* e2) const;
     virtual string_type do_transform(const C* b, const C* e) const;
     virtual long do_hash(const C* b, const C* e) const;
};
This defines two interfaces:

• The public interface for users of the facet.

• The protected interface for implementers of derived facets.

The constructor argument specifies whether a locale or a user is responsible for deleting the facet. The default (0) means “let the locale manage” (§39.3).

All standard-library facets share a common structure, so the salient facts about a facet can be summarized by the key functions:

collate<C> facet (§iso.22.4.4.1)

int compare(const C* b, const C* e, const C* b2, const C* e2) const;

long hash(const C* b, const C* e) const;

string_type transform(const C* b, const C* e) const;

To define a facet use collate as the pattern. To derive from a standard pattern, simply define the do_* versions of the key functions providing the facet’s functionality. The full declarations of functions are listed (rather than use patterns) to give sufficient information to write an overriding do_* function. For an example, see §39.4.1.1.

The hash() function calculates a hash value for its input string. Obviously, this can be useful for building hash tables.

The transform() function produces a string that, when compared to another transform()ed string, gives the same result as comparing the strings. That is:

cf.compare(cf.transform(s),cf.transform(s2)) == cf.compare(s,s2)
The purpose of transform() is to allow optimization of code in which a string is compared to many others. This is useful when implementing a search among a set of strings.

The compare() function does the basic string comparison according to the rules defined for a particular collate. It returns:

1 if the first string is lexicographically greater than the second

0 if the strings are identical

–1 if the second string is greater than the first

For example:

Click here to view code image

void f(const string& s1, const string& s2, const collate<char>& cmp)
{
     const char* cs1 {s1.data()};    // because compare() operates on char[]s
     const char* cs2 {s2.data()};

     switch (cmp.compare(cs1,cs1+s1.size(),cs2,cs2+s2.size()) {
     case 0:       // identical strings according to cmp
          //...
         break;
     case –1:      // s1 < s2
          //...
         break;
     case 1:       // s1 > s2
          //...
         break;
     }
}
The collate member functions compare [b:e) ranges of C rather than basic_strings or zero-terminated C-style strings. In particular, a C with the numeric value 0 is treated as an ordinary character rather than as a terminator.

The standard-library string is not locale sensitive. That is, it compares strings according to the rules of the implementation’s character set (§6.2.3). Furthermore, the standard string does not provide a direct way of specifying comparison criteria (Chapter 36). To do a locale-sensitive comparison, we can use a collate’s compare(). For example:

Click here to view code image

void f(const string& s1, const string& s2, const string& name)
{
     bool b {s1==s2};                // compare using implementation's character set values

     const char* s1b {s1.data()};               // get start of data
     const char* s1e {s1.data()+s1.size()};      // get end of data
     const char* s2b {s2.data()};
     const char* s2e {s2.data()+s2.size()};

     using Col = collate<char>;

     const Col& global {use_facet<Col>(locale{})};           // from the current global locale
     int i0 {global.compare(s1b,s1e,s2b,s2e)};

     const Col& my_coll {use_facet<Col>(locale{""})};        // from my preferred locale
     int i1 {my_coll.compare(s1b,s1e,s2b,s2e)};

     const Col& n_coll {use_facet<Col>(locale{name})};       // from a named locale
     int i2 {n_coll.compare(s1b,s1e,s2b,s2e)};
}
Notationally, it can be more convenient to use collate’s compare() indirectly through a locale’s operator() (§39.2.2). For example:

Click here to view code image

void f(const string& s1, const string& s2, const string& name)
{
     int i0 = locale{}(s1,s2);       // compare using the current global locale
     int i1 = locale{""}(s1,s2);     // compare using my preferred locale
     int i2 = locale{name}(s1,s2);   // compare using the named locale
      //...
}
It is not difficult to imagine cases in which i0, i1, and i2 differ. Consider this sequence of words from a German dictionary:

Dialekt, Diät, dich, dichten, Dichtung
According to convention, nouns (only) are capitalized, but the ordering is not case sensitive.

A case-sensitive German sort would place all words starting with D before d:

Dialekt, Diät, Dichtung, dich, dichten
The ä (umlaut a) is treated as “a kind of a,” so it comes before c. However, in most common character sets, the numeric value of ä is larger than the numeric value of c. Consequently, int('c')<int('ä'), and the simple default sort based on numeric values gives:

Dialekt, Dichtung, Diät, dich, dichten
Writing a compare function that orders this sequence correctly according to the dictionary is an interesting exercise.

39.4.1.1. Named collate
A collate_byname is a version of collate for a locale named by a constructor string argument:

Click here to view code image

template<typename C>
class collate_byname : public collate<C> {    // note: no id and no new functions
public:
     typedef basic_string<C> string_type;

     explicit collate_byname(const char*, size_t r = 0);  // construct from named locale
     explicit collate_byname(const string&, size_t r = 0);
protected:
     ~collate_byname();  // note: protected destructor

     int do_compare(const C* b, const C* e, const C* b2, const C* e2) const override;
     string_type do_transform(const C* b, const C* e) const override;
     long do_hash(const C* b, const C* e) const override;
};
Thus, a collate_byname can be used to pick out a collate from a locale named in the program’s execution environment (§39.4). One obvious way of storing facets in an execution environment would be as data in a file. A less flexible alternative would be to represent a facet as program text and data in a _byname facet.

39.4.2. Numeric Formatting
Numeric output is done by a num_put facet writing into a stream buffer (§38.6). Conversely, numeric input is done by a num_get facet reading from a stream buffer. The format used by num_put and num_get is defined by a “numerical punctuation” facet called numpunct.

39.4.2.1. Numeric Punctuation
The numpunct facet defines the I/O format of built-in types, such as bool, int, and double:

numpunct<C> facet (§iso.22.4.3.1.1)

C decimal_point() const;

E.g.,

’·’

C thousands_sep() const;

E.g.,

’,’

string grouping() const;

E.g.,

"" meaning “no grouping”

string_type truename() const;

E.g.,

"true"

string_type falsename() const;

E.g.,

"false"

The characters of the string returned by grouping() are read as a sequence of small integer values. Each number specifies a number of digits for a group. Character 0 specifies the rightmost group (the least significant digits), character 1 the group to the left of that, etc. Thus, "\004\002\003" describes a number such as 123–45–6789 (provided you use '–' as the separation character). If necessary, the last number in a grouping pattern is used repeatedly, so "\003" is equivalent to "\003\003\003". The most common use of grouping is to make large numbers more readable. The grouping() and thousands_sep() functions define a format for both input and output of integers and the integer part of floating-point values.

We can define a new punctuation style by deriving from numpunct. For example, I could define facet My_punct to write integer values using spaces to group the digits in sets of three and floating-point values, using a European-style comma as the “decimal point”:

Click here to view code image

class My_punct : public numpunct<char> {
public:
     explicit My_punct(size_t r = 0) :numpunct<char>(r) { }
protected:
     char do_decimal_point() const override { return ','; }     // comma
     char do_thousands_sep() const override { return '_'; }     // underscore
     string do_grouping() const override { return "\003"; }     //3-digit groups
};

void f()
{
     cout << "style A: " << 12345678
          << " *** " << 1234567.8
          << " *** " << fixed << 1234567.8 << '\n';
     cout << defaultfloat;               // reset floating format
     locale loc(locale(),new My_punct);
     cout.imbue(loc);
     cout << "style B: " << 12345678
          << " *** " << 1234567.8
          << " *** " << fixed << 1234567.8 << '\n';
}
This produces:

Click here to view code image

style A: 12345678 *** 1.23457e+06 *** 1234567.800000
style B: 12_345_678 *** 1_234_567,800000 *** 1_234_567,800000
Note that imbue() stores a copy of its argument in its stream. Consequently, a stream can rely on an imbued locale even after the original copy of that locale has been destroyed. If an iostream has its boolalpha flag set (§38.4.5.1), the strings returned by truename() and falsename() are used to represent true and false, respectively; otherwise, 1 and 0 are used.

A _byname version (§39.4, §39.4.1) of numpunct is provided:

Click here to view code image

template<typename C>
class numpunct_byname : public numpunct<C> {
      //...
};
39.4.2.2. Numeric Output
When writing to a stream buffer (§38.6), an ostream relies on the num_put facet:

num_put<C,Out=ostreambuf_iterator<C>> facet (§iso.22.4.2.2)

Put value v to buffer position b in stream s

Out put(Out b, ios_base& s, C fill, bool v) const;

Out put(Out b, ios_base& s, C fill, long v) const;

Out put(Out b, ios_base& s, C fill, long long v) const;

Out put(Out b, ios_base& s, C fill, unsigned long v) const;

Out put(Out b, ios_base& s, C fill, unsigned long long v) const;

Out put(Out b, ios_base& s, C fill, double v) const;

Out put(Out b, ios_base& s, C fill, long double v) const;

Out put(Out b, ios_base& s, C fill, const void* v) const;

The value of put() is that iterator positioned one past the last character position written.

The default specialization of num_put (the one where the iterator used to access characters is of type ostreambuf_iterator<C>) is part of the standard locales (§39.4). To write elsewhere using a num_put, we must define an appropriate specialization. For example, here is a very simple num_put for writing into a string:

Click here to view code image

template<typename C>
class String_numput : public num_put<C,typename basic_string<C>::iterator> {
public:
     String_numput() :num_put<C,typename basic_string<C>::iterator>{1} { }
};
I don’t mean for String_numput to go into a locale, so I used the constructor argument to retain ordinary lifetime rules. The intended use is something like this:

Click here to view code image

void f(int i, string& s, int pos)  // format i into s starting at pos
{
     String_numput<char> f;
     f.put(s.begin()+pos,cout,' ',i);    // format i into s; use cout's formatting rules
}
The ios_base argument (here, cout) provides information about formatting state and locale. For example:

Click here to view code image

void test(iostream& io, char ch)
{
     locale loc = io.getloc();

     wchar_t wc = use_facet<ctype<char>>(loc).widen(ch);                // char to wchar_t conversion
     string s = use_facet<numpunct<char>>(loc).decimal_point();        // default: '.'
     string false_name = use_facet<numpunct<char>>(loc).falsename();   // default: "false"
     //...
}
A standard facet, such as num_put<char>, is typically used implicitly through a standard I/O stream function. Consequently, most programmers need not know about it. However, the use of such facets by standard-library functions is interesting because they show how I/O streams work and how facets can be used. As ever, the standard library provides examples of interesting programming techniques.

Using num_put, the implementer of ostream might write:

Click here to view code image

template<typename C, typename Tr>
basic_ostream<C,Tr>& basic_ostream<C,Tr>::operator<<(double d)
{
     sentry guard(*this);   // see §38.4.1
     if (!guard) return *this;

     try { // put to the stream’s streambuffer
           if (use_facet<num_put<C,ostreambuf_iterator<C,Tr>>>(getloc()).put(*this,*this,this–>fill(),d).failed())
                     setstate(badbit);
     }
     catch (...) {
           handle_ioexception(*this);
     }
     return *this;
}
A lot is going on here. The sentry ensures that all prefix and suffix operations are performed (§38.4.1). We get the ostream’s locale by calling its member function getloc() (§38.4.5.1). We extract num_put from that locale using use_facet (§39.3.1). That done, we call the appropriate put() function to do the real work. An ostreambuf_iterator can be constructed from an ostream (§38.6.3), and an ostream can be implicitly converted to its base class ios_base (§38.4.4), so the first two arguments to put() are easily supplied.

A call of put() returns its output iterator argument. This output iterator is obtained from a basic_ostream, so it is an ostreambuf_iterator. Consequently, failed() (§38.6.3) is available to test for failure and to allow us to set the stream state appropriately.

I did not use has_facet, because the standard facets (§39.4) are guaranteed to be present in every locale. If that guarantee is violated, bad_cast is thrown (§39.3.1).

The put() function calls the virtual do_put(). Consequently, user-defined code may be executed, and operator<<() must be prepared to handle an exception thrown by the overriding do_put(). Also, num_put may not exist for some character types, so use_facet() might throw bad_cast (§39.3.1). The behavior of a << for a built-in type, such as double, is defined by the C++ standard. Consequently, the question is not what handle_ioexception() should do but rather how it should do what the standard prescribes. If badbit is set in this ostream’s exception state (§38.3), the exception is simply re-thrown. Otherwise, an exception is handled by setting the stream state and continuing. In either case, badbit must be set in the stream state (§38.4.5.1):

Click here to view code image

template<typename C, typename Tr>
void handle_ioexception(basic_ostream<C,Tr>& s) // called from catch-clause
{
     if (s.exceptions()&ios_base::badbit) {
           try {
                s.setstate(ios_base::badbit);  // might throw basic_ios::failure
           }
           catch(...) {
                //... do nothing ...
           }
           throw;      // re-throw
     }
     s.setstate(ios_base::badbit);
}
The try-block is needed because setstate() might throw basic_ios::failure (§38.3, §38.4.5.1). However, if badbit is set in the exception state, operator<<() must re-throw the exception that caused handle_ioexception() to be called (rather than simply throwing basic_ios::failure).

The << for a built-in type, such as double, must be implemented by writing directly to a stream buffer. When writing a << for a user-defined type, we can often avoid the resulting complexity by expressing the output of the user-defined type in terms of output of existing types (§39.3.2).

39.4.2.3. Numeric Input
When reading from a stream buffer (§38.6), an istream relies on the num_get facet:

num_get<C, In = istreambuf_iterator<C>> facet (§iso.22.4.2.1)

Read [b:e) into v, using formatting rules from s, reporting errors by setting r

In get(In b, In e, ios_base& s, ios_base::iostate& r, bool& v) const;

In get(In b, In e, ios_base& s, ios_base::iostate& r, long& v) const;

In get(In b, In e, ios_base& s, ios_base::iostate& r, long long& v) const;

In get(In b, In e, ios_base& s, ios_base::iostate& r, unsigned shorts v) const;

In get(In b, In e, ios_base& s, ios_base::iostate& r, unsigned int& v) const;

In get(In b, In e, ios_base& s, ios_base::iostate& r, unsigned long& v) const;

In get(In b, In e, ios_base& s, ios_base::iostate& r, unsigned long long& v) const;

In get(In b, In e, ios_base& s, ios_base::iostate& r, floats v) const;

In get(In b, In e, ios_base& s, ios_base::iostate& r, doubles v) const;

In get(In b, In e, ios_base& s, ios_base::iostate& r, long doubles v) const;

In get(In b, In e, ios_bases s, ios_base::iostates r, void*s v) const;

Basically, num_get is organized like num_put (§39.4.2.2). Since it reads rather than writes, get() needs a pair of input iterators, and the argument designating the target of the read is a reference.

The iostate variable r is set to reflect the state of the stream. If a value of the desired type could not be read, failbit is set in r; if the end-of-input was reached, eofbit is set in r. An input operator will use r to determine how to set the state of its stream. If no error was encountered, the value read is assigned through v; otherwise, v is left unchanged.

A sentry is used to ensure that the stream’s prefix and suffix operations are performed (§38.4.1). In particular, the sentry is used to ensure that we try to read only if the stream is in a good state to start with. For example, an implementer of istream might write:

Click here to view code image

template<typename C, typename Tr>
basic_istream<C,Tr>& basic_istream<C,Tr>::operator>>(double& d)
{
     sentry guard(*this);     // see §38.4.1
     if (!guard) return *this;

     iostate state = 0;       // good
     istreambuf_iterator<C,Tr> eos;
     try {
          double dd;
          use_facet<num_get<C,Tr>>(getloc()).get(*this,eos,*this,state,dd);
          if (state==0 || state==eofbit) d = dd;    // set value only if get() succeeded
          setstate(state);
     }
     catch (...) {
          handle_ioexception(*this);        // see §39.4.2.2
     }
     return *this;
}
I took care not to modify the target of the >> unless the read operation succeeded. Unfortunately, that cannot be guaranteed for all input operations.

Exceptions enabled for the istream will be thrown by setstate() in case of error (§38.3).

By defining a numpunct, such as My_punct from §39.4.2.1, we can read using nonstandard punctuation. For example:

Click here to view code image

void f()
{
     cout << "style A: "
     int i1;
     double d1;
     cin >> i1 >> d1;            // read using standard "12345678" format

     locale loc(locale::classic(),new My_punct);
     cin.imbue(loc);
     cout << "style B: "
     int i2;
     double d2;
     cin >> i1 >> d2;           // read using the "12_345_678" format
}
If we want to read really unusual numeric formats, we have to override do_get(). For example, we might define a num_get that reads Roman numerals, such as XXI and MM.

39.4.3. Money Formatting
The formatting of monetary amounts is technically similar to the formatting of “plain” numbers (§39.4.2). However, the presentation of monetary amounts is even more sensitive to cultural differences. For example, a negative amount (a loss, a debit), such as –1.25, should in some contexts be presented as a (positive) number in parentheses: (1.25). Similarly, color is in some contexts used to ease the recognition of negative amounts.

There is no standard “money type.” Instead, the money facets are meant to be used explicitly for numeric values that the programmer knows to represent monetary amounts. For example:

Click here to view code image

struct Money {                       // simple type to hold a monetary amount
     using Value = long long;        // for currencies that have suffered inflation
     Value amount;
};

 //...

void f(long int i)
{
     cout << "value= " << i << " amount= " << Money{i} << '\n';
}
The task of the monetary facets is to make it reasonably easy to write an output operator for Money so that the amount is printed according to local convention (see §39.4.3.2). The output would vary depending on cout’s locale. Possible outputs are:

Click here to view code image

value= 1234567 amount= $12345.67
value= 1234567 amount= 12345,67 DKK
value= 1234567 amount= CAD 12345,67
value= –1234567 amount= $–12345.67
value= –1234567 amount= –€12345.67
value= –1234567 amount= (CHF12345,67)
For money, accuracy to the smallest currency unit is usually considered essential. Consequently, I adopted the common convention of having the integer value represent the number of cents (pence, øre, fils, cents, etc.) rather than the number of dollars (pounds, kroner, dinar, euro, etc.). This convention is supported by moneypunct’s frac_digits() function (§39.4.3.1). Similarly, the appearance of the “decimal point” is defined by decimal_point().

The facets money_get and money_put provide functions that perform I/O based on the format defined by the money_base facet.

A simple Money type can be used to control I/O formats or to hold monetary values. In the former case, we cast values of (other) types used to hold monetary amounts to Money before writing, and we read into Money variables before converting them to other types. It is less error-prone to consistently hold monetary amounts in a Money type; that way, we cannot forget to cast a value to Money before writing it, and we don’t get input errors by trying to read monetary values in locale-insensitive ways. However, it may be infeasible to introduce a Money type into a system that wasn’t designed for that. In such cases, applying Money conversions (casts) to read and write operations is necessary.

39.4.3.1. Money Punctuation
The facet controlling the presentation of monetary amounts, moneypunct, naturally resembles the facet for controlling plain numbers, numpunct (§39.4.2.1):

Click here to view code image

class money_base {
public:
     enum part {                              // parts of value layout
         none, space, symbol, sign, value
     };

     struct pattern {                         // layout specification
         char field[4];
     };
};

template<typename C, bool International = false>
class moneypunct : public locale::facet, public money_base {
public:
     using char_type = C;
     using string_type = basic_string<C>;
      //...
};
The moneypunct member functions define the layout of money input and output:

moneypunct<C,International>> facet (§iso.22.4.6.3)

C decimal_point() const;

E.g.,’.’

C thousands_sep() const;

E.g.,’,’

string grouping() const;

E.g., "" meaning “no grouping”

string_type curr_symbol() const;

E.g., "$"

string_type positive_sign() const;

E.g., ""

string_type negative_sign() const;

E.g., "-"

int frac_digits() const;

Number of digits after "·", e.g., 2

pattern pos_format() const;

symbol, space, sign, none, or value

pattern neg_format() const;

symbol, space, sign, none, or value

static const bool intl = International;

Use three-letter international abbreviations

The facilities offered by moneypunct are intended primarily for use by implementers of money_put and money_get facets (§39.4.3.2, §39.4.3.3).

A _byname version (§39.4, §39.4.1) of moneypunct is provided:

Click here to view code image

template<typename C, bool Intl = false>
class moneypunct_byname : public moneypunct<C, Intl> {
      //...
};
The decimal_point(), thousands_sep(), and grouping() members behave as in numpunct.

The curr_symbol(), positive_sign(), and negative_sign() members return the string to be used to represent the currency symbol (for example, $, ¥, INR, DKK), the plus sign, and the minus sign, respectively. If the International template argument is true, the intl member will also be true, and “international” representations of the currency symbols will be used. Such an “international” representation is a four-character C-style string. For example:

"USD"
"DKK"
"EUR"
The last (invisible) character is a terminating zero. The three-letter currency identifier is defined by the ISO-4217 standard. When International is false, a “local” currency symbol, such as $, £, and ¥, can be used.

A pattern returned by pos_format() or neg_format() is four parts defining the sequence in which the numeric value, the currency symbol, the sign symbol, and whitespace occur. Most common formats are trivially represented using this simple notion of a pattern. For example:

Click here to view code image

+$ 123.45      // { sign, symbol, space, value } where positive_sign() returns "+"
$+123.45       // { symbol, sign, value, none } where positive_sign() returns "+"
$123.45        // { symbol, sign, value, none } where positive_sign() returns ""
$123.45–       // { symbol, value, sign, none } where negative_sign() returns "_"
–123.45 DKK    // { sign, value, space, symbol } where negative_sign() returns "_"
($123.45)      // { sign, symbol, value, none } where negative_sign() returns "()"
(123.45DKK)    // { sign, value, symbol, none } where negative_sign() returns "()"
Representing a negative number using parentheses is achieved by having negative_sign() return a string containing the two characters (). The first character of a sign string is placed where sign is found in the pattern, and the rest of the sign string is placed after all other parts of the pattern. The most common use of this facility is to represent the financial community’s convention of using parentheses for negative amounts, but other uses are possible. For example:

Click here to view code image

–$123.45              //{ sign, symbol, value, none } where negative_sign() returns "–"
*$123.45 silly       //{ sign, symbol, value, none } where negative_sign() returns "* silly"
Each of the values sign, value, and symbol must appear exactly once in a pattern. The remaining value can be either space or none. Where space appears, at least one and possibly more whitespace characters may appear in the representation. Where none appears, except at the end of a pattern, zero or more whitespace characters may appear in the representation.

Note that these strict rules ban some apparently reasonable patterns:

pattern pat = { sign, value, none, none };      // error: no symbol
The frac_digits() function indicates where the decimal_point() is placed. Often, monetary amounts are represented in the smallest currency unit (§39.4.3). This unit is typically one-hundredth of the major unit (for example, a ¢ is one-hundredth of a $), so frac_digits() is often 2.

Here is a simple format defined as a facet:

Click here to view code image

class My_money_io : public moneypunct<char,true> {
public:
     explicit My_money_io(size_t r=0): moneypunct<char,true>(r) { }

     char_type do_decimal_point() const { return '.'; }
     char_type do_thousands_sep() const { return ','; }
     string do_grouping() const { return "\003\003\003"; }

     string_type do_curr_symbol() const { return "USD "; }
     string_type do_positive_sign() const { return ""; }
     string_type do_negative_sign() const { return "()"; }

     int do_frac_digits() const { return 2; }  // two digits after decimal point

     pattern do_pos_format() const { return pat; }
     pattern do_neg_format() const { return pat; }
private:
     static const pattern pat;
};

const pattern My_money_io::pat { sign, symbol, value, none };
39.4.3.2. Money Output
The money_put facet writes monetary amounts according to the format specified by moneypunct. Specifically, money_put provides put() functions that place a suitably formatted character representation into the stream buffer of a stream:

money_put<C,Out = ostreambuf_iterator<C>> facet (§iso.22.4.6.2)

Put value v into buffer position b

Out put(Out b, bool intl, ios_base& s, C fill, long double v) const;

Out put(Out b, bool intl, ios_base& s, C fill, const string_type& v) const;

The intl argument indicates whether a standard four-character “international” currency symbol or a “local” symbol is used (§39.4.3.1).

Given money_put, we can define an output operator for Money (§39.4.3):

Click here to view code image

ostream& operator<<(ostream& s, Money m)
{
     ostream::sentry guard(s);         // see §38.4.1
     if (!guard) return s;

     try {
           const auto& f = use_facet<money_put<char>>(s.getloc());

           auto d = static_cast<long double<(m.amount);
           auto m2 = static_cast<long long>(d);
           if (m2 == m.amount) { // m can be represented as a long long
                if (f.put(s,true,s,s.fill(),d).failed())
                       s.setstate(ios_base::badbit);
           }
           else
                s.setstate(ios_base::badbit);
     }
     catch (...) {
           handle_ioexception(s);      // see §39.4.2.2
     }
     return s;
}
If a long long doesn’t have sufficient precision to represent the monetary value exactly, I set the stream state to badbit and let the guard take over.

39.4.3.3. Money Input
The money_get facet reads monetary amounts according to the format specified by moneypunct. Specifically, money_get provides get() functions that extract a suitably formatted character representation from the stream buffer of a stream:

money_get<C,In = istreambuf_iterator<C>> facet (§iso.22.4.6.1)

Read [b:e) into v, using formatting rules from s, reporting errors by setting r

In get(In b, In e, bool intl, ios_base& s, ios_base::iostate& r, long doubles v) const;

In get(In b, In e, bool intl, ios_base& s, ios_base::iostate& r, string_type& v) const;

A well-defined pair of money_get and money_put facets will provide output in a form that can be read back in without errors or loss of information. For example:

int main()
{
     Money m;
     while (cin>>m)
         cout << m << "\n";
}
The output of this simple program should be acceptable as its input. Furthermore, the output produced by a second run given the output from a first run should be identical to its input.

A plausible input operator for Money would be:

Click here to view code image

istream& operator>>(istream& s, Money& m)
{
     istream::sentry guard(s);   // see _io.sentry_
     if (guard) try {
          ios_base::iostate state = 0;  // good
          string str;
          long double ld;

          const auto& f = use_facet<money_get<char>>(s.getloc());

          f.get(s, istreambuf_iterator<char>{}, true, s, state , str);
          if (state ==0 || state ==ios_base::eofbit) {  // set value only if get() succeeded
                long long i = stoll(str);      //§36.3.5
                if (errno==ERANGE) {
                       state |= ios_base::failbit;
                }
                else {
                     m.amount = i;    // set value only if conversion to long long succeeded
                }
                s.setstate(state);
          }
     }
     catch (...) {
          handle_ioexception(s);      // see §39.4.2.2
     }
     return s;
}
I use the get() that reads into a string because reading into a double and then converting to a long long could lead to loss of precision.

The largest value that can be exactly represented by a long double may be smaller than the largest value that can be represented by a long long.

39.4.4. Date and Time Formatting
Date and time formats are controlled by time_get<C,In> and time_put<C,Out>. The representation of dates and times used is tm (§43.6).

39.4.4.1. time_put
A time_put facet takes a point in time presented as a tm and produces a sequence of characters representing it using strftime() (§43.6) or an equivalent.

time_put<C,Out = ostreambuf_iterator<C>> facet (§iso.22.4.5.3)

Out put(Out s, ios_base& f, C fill, const tm* pt, const C* b, const C* e) const;

Out put(Out s, ios_base& f, C fill, const tm* pt, char format, char mod = 0) const;

Out do_put(Out s, ios_base& ib, C fill, const tm* pt, char format, char mod) const;

A call s=put(s,f,fill,pt,b,e) copies [b:e) onto the output stream s. This formats the values of the date and time stored in *pt. For each strftime() format character x, with optional modifier mod, in [b:e), put() calls do_put(s,ib,pt,x,mod). The possible modifier values are 0 (the default meaning “none”), E, or O. An overriding p=do_put(s,ib,pt,x,mod) is supposed to format the appropriate parts of *pt into s and return a value pointing to the position in s after the last character written.

The obvious use of the time and date facets is to provide locale-sensitive I/O for a Date class.

Consider a variant of the Date from §16.3:

Click here to view code image

class Date {
public:
     explicit Date(int d ={}, Month m ={}, int year ={});
     // ...
};
Using a time_put facet, we can write a Date to a stream using a specific format:

Click here to view code image

ostream& operator<<(ostream& os, Date d)
{
     ostringstream ss;
     tm t;
     t.tm_mday = d.day;
     t.tm_mon = static_cast<int>(d.month-1);
     t.tm_year= d.year-1900;
     char fmt[] = "{%Y-%m-%d}"; // §43.6
     use_facet<time_put<char>>(os.getloc()).put(os,os,' ',&t,begin(fmt),end(fmt));// put from t into os
     return os;
}
In a more complete design, I might store the format string in the Date object.

A _byname version (§39.4, §39.4.1) of time_put is also provided.

39.4.4.2. time_get
The basic idea is that a get_time can read what is produced by a put_time using the same strftime() format (§43.6):

The order of day, month, and year can be obtained by a call to date_order(), which returns a value of type dateorder:

Click here to view code image

class time_base {
public:
     enum dateorder {
         no_order,  // meaning mdy
         dmy,       // meaning "%d%m%y"
         mdy,       // meaning "%m%d%y"
         ymd,       // meaning "%y%m%d"
         ydm        // meaning "%y%d%m"
     };
};
The formatting of the actual date is locale dependent. The classic() locale (§39.2.1) uses / as the separator and the mdy order. For example 10/3/1980.

In addition to reading according to a format, there are operations for reading specific parts of date and time representations:

time_get<C,In> facet (§iso.22.4.5.1)

Read from [b:e) into *pt

dateorder date_order() const;

In get_time(In b, In e, ios_base& ib, ios_base::iostate& err, tm* pt) const;

In get_date(In b, In e, ios_base& ib, ios_base::iostate& err, tm* pt) const;

In get_weekday(In b, In e, ios_base& ib, ios_base::iostate& err, tm* pt) const;

In get_monthname(In b, In e, ios_base& ib, ios_base::iostate& err, tm* pt) const;

In get_year(In b, In e, ios_base& ib, ios_base::iostate& err, tm* pt) const;

In get(In b, In e, ios_base& ib, ios_base::iostate& err, tm* pt, char format, char mod) const;

In get(In b, In e, ios_base& ib, ios_base::iostate& err, tm* pt, char format) const;

In get(In b, In e, ios_base& ib, ios_base::iostate& err, tm* pt, C* fmtb, C* fmte) const;

A get_*() function reads from [b:e) into *pt, getting its locale from b and setting err in case of error. It returns an iterator pointing to the first unread character in [b:e).

A call p=get(b,e,ib,err,pt,format,mod) reads as indicated by the format character format and modifier character mod, as specified by strftime(). If mod is not specified, mod==0 is used.

A call of get(b,e,ib,err,pt,fmtb,fmtb) uses a strftime() format presented as a string [fmtb:fmte). This overload, together with the one with the defaulted modifier, does not have do_get() interfaces. Instead, they are implemented by calls to the do_get() for the first get().

Given a time_get facet we can read Dates:

Click here to view code image

istream& operator>>(istream& is, Date& d)
{
     if (istream::sentry guard{is}) {
           ios_base::iostate err = ios_base::goodbit;
           struct tm t;
           use_facet<time_get<char>>(is.getloc()).get_date(is,0,is,err,&t); // read into t
           if (!err) {
                  Month m = static_cast<Month>(t.tm_mon+1);
                  d = Date(t.tm_mday,m,t.tm_year+1900);
           }
                  is.setstate(err);
           }
           return is;
}
The +1900 is needed because year 1900 is year zero for tm (§43.6).

A simple test looks like this

Click here to view code image

void test()
{
     Date d1(3,10,1980);
     cout << d1 << '\n';   // output Date
     auto order = use_facet<time_get<char>>(cin.getloc()).date_order(); // read date order
     if (order == time_base::mdy)
                cout << "month day year\n";
     else
                cout << "poor guess\n";
     stringstream ss ("10/3/1980");
     ss>>d1;              //input Date
     cout << d1 << '\n';  // output date
}
A _byname version (§39.4, §39.4.1) of time_get is also provided.

39.4.5. Character Classification
When reading characters from input, it is often necessary to classify them to make sense of what is being read. For example, to read a number, an input routine needs to know which letters are digits. Similarly, §10.2.2 showed a use of standard character classification functions for parsing input.

Naturally, classification of characters depends on the alphabet used. Consequently, a facet ctype is provided to represent character classification in a locale.

The character classes are described by an enumeration called mask:

Click here to view code image

class ctype_base {
public:
     enum mask {        // the actual values are implementation-defined
         space = 1,           // whitespace (in "C" locale: ' ', '\n', '\t', ...)
         print = 1<<1,        // printing characters
         cntrl = 1<<2,        // control characters
         upper = 1<<3,        // uppercase characters
         lower = 1<<4,        // lowercase characters
         alpha = 1<<5,        // alphabetic characters
         digit = 1<<6,        // decimal digits
         punct = 1<<7,        // punctuation characters
         xdigit = 1<<8,       // hexadecimal digits
         blank = 1 << 9;      // space and horizontal tab
         alnum=alpha|digit,   // alphanumeric characters
         graph=alnum|punct
     };
};
Click here to view code image

template<typename C>
class ctype : public locale::facet, public ctype_base {
public:
     using char_type = C;
      //...
};
This mask doesn’t depend on a particular character type. Consequently, this enumeration is placed in a (non-template) base class.

Clearly, mask reflects the traditional C and C++ classification (§36.2.1). However, for different character sets, different character values fall into different classes. For example, for the ASCII character set, the integer value 125 represents the character }, which is a punctuation character (punct). However, in the Danish national character set, 125 represents the vowel å, which in a Danish locale must be classified as an alpha.

The classification is called a “mask” because the traditional efficient implementation of character classification for small character sets is a table in which each entry holds bits representing the classification. For example:

table['P'] == upper|alpha
table['a'] == lower|alpha|xdigit
table['1'] == digit|xdigit
table[' '] == space|blank
Given that implementation, table[c]&m is nonzero if the character c is an m and 0 otherwise.

The ctype facet is defined like this:

ctype<C> facet (§iso.22.4.1.1)

bool is(mask m, C c) const;

const C* is(const C* b, const C* e, mask* v) const;

const C* scan_is(mask m, const C* b, const C* e) const;

const C* scan_not(mask m, const C* b, const C* e) const;

C toupper(C c) const;

const C* toupper(C* b, const C* e) const;

C tolower(C c) const;

const C* tolower(C* b, const C* e) const;

C widen(char c) const;

const char* widen(const char* b, const char* e, C* b2) const;

char narrow(C c, char def) const;

const C* narrow(const C* b, const C* e, char def, char* b2) const;

A call is(m,c) tests whether the character c belongs to the classification m. For example:

Click here to view code image

int count_spaces(const string& s, const locale& loc)
{
     const ctype<char>& ct = use_facet<ctype<char>>(loc);
     int i = 0;

     for(auto p = s.begin(); p!=s.end(); ++p)
          if (ct.is(ctype_base::space,*p))          // whitespace as defined by ct
                 ++i;
     return i;
}
Note that it is also possible to use is() to check whether a character belongs to one of a number of classifications. For example:

ct.is(ctype_base::space|ctype_base::punct,c);      // is c whitespace or punctuation in ct?
A call is(b,e,v) determines the classification of each character in [b:e) and places it in the corresponding position in the array v.

A call scan_is(m,b,e) returns a pointer to the first character in [b:e) that is an m. If no character is classified as an m, e is returned. As ever for standard facets, the public member function is implemented by a call to its do_ virtual function. A simple implementation might be:

Click here to view code image

template<typename C>
const C* ctype<C>::do_scan_is(mask m, const C* b, const C* e) const
{
    while (b!=e && !is(m,*b))
         ++b;
    return b;
}
A call scan_not(m,b,e) returns a pointer to the first character in [b:e) that is not an m. If all characters are classified as m, e is returned.

A call toupper(c) returns the uppercase version of c if such a version exists in the character set used and c itself otherwise.

A call toupper(b,e) converts each character in the range [b:e) to uppercase and returns e. A simple implementation might be:

Click here to view code image

template<class C>
const C* ctype<C>::to_upper(C* b, const C* e)
{
    for (; b!=e; ++b)
           *b = toupper(*b);
    return e;
}
The tolower() functions are similar to toupper() except that they convert to lowercase.

A call widen(c) transforms the character c into its corresponding C value. If C’s character set provides several characters corresponding to c, the standard specifies that “the simplest reasonable transformation” be used. For example:

wcout << use_facet<ctype<wchar_t>>(wcout.getloc()).widen('e');
will output a reasonable equivalent to the character e in wcout’s locale.

Translation between unrelated character representations, such as ASCII and EBCDIC, can also be done by using widen(). For example, assume that an ebcdic locale exists:

char EBCDIC_e = use_facet<ctype<char>>(ebcdic).widen('e');
A call widen(b,e,v) takes each character in the range [b:e) and places a widened version in the corresponding position in the array v.

A call narrow(ch,def) produces a char value corresponding to the character ch from the C type. Again, “the simplest reasonable transformation” is to be used. If no such corresponding char exists, def is returned.

A call narrow(b,e,def,v) takes each character in the range [b:e) and places a narrowed version in the corresponding position in the array v.

The general idea is that narrow() converts from a larger character set to a smaller one and that widen() performs the inverse operation. For a character c from the smaller character set, we expect:

c == narrow(widen(c),0)  // not guaranteed
This is true provided that the character represented by c has only one representation in “the smaller character set.” However, that is not guaranteed. If the characters represented by a char are not a subset of those represented by the larger character set (C), we should expect anomalies and potential problems with code treating characters generically.

Similarly, for a character ch from the larger character set, we might expect:

widen(narrow(ch,def)) == ch || widen(narrow(ch,def)) == widen(def)  // not guaranteed
However, even though this is often the case, it cannot be guaranteed for a character that is represented by several values in the larger character set but only once in the smaller character set. For example, a digit, such as 7, often has several separate representations in a large character set. The reason for that is typically that a large character set has several conventional character sets as subsets and that the characters from the smaller sets are replicated for ease of conversion.

For every character in the basic source character set (§6.1.2), it is guaranteed that

widen(narrow(ch_lit,0)) == ch_lit
For example:

widen(narrow('x',0)) == 'x'
The narrow() and widen() functions respect character classifications wherever possible. For example, if is(alpha,c), then is(alpha,narrow(c,'a')) and is(alpha,widen(c)) wherever alpha is a valid mask for the locale used.

A major reason for using a ctype facet in general and for using narrow() and widen() functions in particular is to be able to write code that does I/O and string manipulation for any character set, that is, to make such code generic with respect to character sets. This implies that iostream implementations depend critically on these facilities. By relying on <iostream> and <string>, a user can avoid most direct uses of the ctype facet.

A _byname version (§39.4, §39.4.1) of ctype is provided:

Click here to view code image

template<typename C>
class ctype_byname : public ctype<C> {
      //...
};
39.4.6. Character Code Conversion
Sometimes, the representation of characters stored in a file differs from the desired representation of those same characters in main memory. For example, Japanese characters are often stored in files in which indicators (“shifts”) indicate to which of the four common character sets (kanji, katakana, hiragana, and romaji) a given sequence of characters belongs. This is a bit unwieldy because the meaning of each byte depends on its “shift state,” but it can save memory because only a kanji requires more than 1 byte for its representation. In main memory, these characters are easier to manipulate when represented in a multibyte character set where every character has the same size. Such characters (for example, Unicode characters) are typically placed in wide characters (wchar_t; §6.2.3). Consequently, the codecvt facet provides a mechanism for converting characters from one representation to another as they are read or written. For example:



This code conversion mechanism is general enough to provide arbitrary conversions of character representations. It allows us to write a program to use a suitable internal character representation (stored in char, wchar_t, or whatever) and to then accept a variety of input character stream representations by adjusting the locale used by iostreams. The alternative would be to modify the program itself or to convert input and output files from/to a variety of formats.

The codecvt facet provides conversion between different character sets when a character is moved between a stream buffer and external storage:

Click here to view code image

class codecvt_base {
public:
     enum result {         // result indicators
         ok, partial, error, noconv
     };
};

template<typename In, typename Ex, typename SS>
class codecvt : public locale::facet, public codecvt_base {
public:
     using intern_type = In;
     using extern_type = Ex;
     using state_type = SS;
      //...
};
codecvt<In,Ex,SS> facet (§iso.22.4.1.4)

using CI = const In; using CE = const Ex;

result in(SS& st, CE* b, CE* e, CE*& next, In* b2, In* e2, In*& next2) const;

result out(SS& st, CI* b, CI* e, CI*& next, Ex* b2, Ex* e2, Ex*& next2) const;

result unshift(SS& st, Ex* b, Ex* e, Ex*& next) const;

int encoding() const noexcept;

bool always_noconv() const noexcept;

int length(SS& st, CE* b, CE* e, size_t max) const;

int max_length() const noexcept;

A codecvt facet is used by basic_filebuf (§38.2.1) to read or write characters. A basic_filebuf obtains this facet from the stream’s locale (§38.1).

The State template argument is the type used to hold the shift state of the stream being converted. State can also be used to identify different conversions by specifying a specialization. The latter is useful because characters of a variety of character encodings (character sets) can be stored in objects of the same type. For example:

Click here to view code image

class JISstate { /* .. */ };

p = new codecvt<wchar_t,char,mbstate_t>;        // standard char to wide char
q = new codecvt<wchar_t,char,JISstate>;         // JIS to wide char
Without the different State arguments, there would be no way for the facet to know which encoding to assume for the stream of chars. The mbstate_t type from <cwchar> or <wchar.h> identifies the system’s standard conversion between char and wchar_t.

A new codecvt can also be created as a derived class and identified by name. For example:

Click here to view code image

class JIScvt : public codecvt<wchar_t,char,mbstate_t> {
     //...
};
A call in(st,b,e,next,b2,e2,next2) reads each character in the range [b:e) and tries to convert it. If a character is converted, in() writes its converted form to the corresponding position in the [b2:e2) range; if not, in() stops at that point. Upon return, in() stores the position one beyond the last character read in next (the next character to be read) and the position one beyond the last character written in next2 (the next character to be written). The result value returned by in() indicates how much work was done:

codecvt_base result (§iso.22.4.1.4)

ok

All characters in [b:e) range were converted

partial

Not all characters in [b:e) were converted

error

A character couldn’t be converted

noconv

No conversion was needed

Note that a partial conversion is not necessarily an error. Possibly more characters have to be read before a multibyte character is complete and can be written, or maybe the output buffer has to be emptied to make room for more characters.

The state_type argument st indicates the state of the input character sequence at the start of the call of in(). This is significant when the external character representation uses shift states. Note that st is a (non-const) reference argument: at the end of the call, st holds the shift state of the input sequence. This allows a programmer to deal with partial conversions and to convert a long sequence using several calls to in().

A call out(st,b,e,next,b2,e2,next2) converts [b:e) from the internal to the external representation in the same way the in() converts from the external to the internal representation.

A character stream must start and end in a “neutral” (unshifted) state. Typically, that state is state_type{}.

A call unshift(st,b,e,next) looks at st and places characters in [b:e) as needed to bring a sequence of characters back to that unshifted state. The result of unshift() and the use of next are done just like out().

A call length(st,b,e,max) returns the number of characters that in() could convert from [b:e).

Return values from encoding() mean:

–1 The encoding of the external character set uses state (for example, uses shift and unshift character sequences).

0   The encoding uses varying number of bytes to represent individual characters (for example, a character representation might use a bit in a byte to indicate whether 1 or 2 bytes are used to represent that character).

n   Every character of the external character representation is n bytes.

A call always_noconv() returns true if no conversion is required between the internal and the external character sets and false otherwise. Clearly, always_noconv()==true opens the possibility for the implementation to provide the maximally efficient implementation that simply doesn’t invoke the conversion functions.

A call cvt.max_length() returns the maximum value that cvt.length(ss,p,q,n) can return for a valid set of arguments.

The simplest code conversion that I can think of is one that converts input to uppercase. Thus, this is about as simple as a codecvt can be and still perform a service:

Click here to view code image

class Cvt_to_upper : public codecvt<char,char,mbstate_t> {  // convert to uppercase
public:
     explicit Cvt_to_upper(size_t r = 0) : codecvt(r) { }

protected:
      // read external representation, write internal representation:
     result do_in(State& s,
                    const char* from, const char* from_end, const char*& from_next,
                    char* to, char* to_end, char*& to_next
                ) const override;

      // read internal representation, write external representation:
     result do_out(State& s,
                    const char* from, const char* from_end, const char*& from_next,
                    char* to, char* to_end, char*& to_next
                ) const override;
     result do_unshift(State&, E* to, E* to_end, E*& to_next) const override { return ok; }

     int do_encoding() const noexcept override { return 1; }
     bool do_always_noconv() const noexcept override { return false; }

     int do_length(const State&, const E* from, const E* from_end, size_t max) const override;
     int do_max_length() const noexcept override;           // maximum possible length()
};

codecvt<char,char,mbstate_t>::result
Cvt_to_upper::do_out(State& s,
                  const char* from, const char* from_end, const char*& from_next,
                  char* to, char* to_end, char*& to_next) const
{
     return codecvt<char,char,mbstate_t>::do_out(s,from,from_end,from_next,to,to_end,to_next);
}

codecvt<char,char,mbstate_t>::result
Cvt_to_upper::do_in(State& s,
                  const char* from, const char* from_end, const char*& from_next,
                  char* to, char* to_end, char*& to_next) const
{
      //...
}

int main()  // trivial test
{
     locale ulocale(locale(), new Cvt_to_upper);

     cin.imbue(ulocale);

     for (char ch; cin>>ch;)
           cout << ch;
}
A _byname version (§39.4, §39.4.1) of codecvt is provided:

Click here to view code image

template<typename I, typename E, typename State>
class codecvt_byname : public codecvt<I,E,State> {
      //...
};
39.4.7. Messages
Naturally, most end users prefer to use their native language to interact with a program. However, we cannot provide a standard mechanism for expressing locale-specific general interactions. Instead, the library provides a simple mechanism for keeping a locale-specific set of strings from which a programmer can compose simple messages. In essence, messages implements a trivial read-only database:

Click here to view code image

class messages_base {
public:
     using catalog = /* implementation-defined integer type */;  // catalog identifier type
};

template<typename C>
class messages : public locale::facet, public messages_base {
public:
     using char_type = C;
     using string_type = basic_string<C>;
      //...
};
The messages interface is comparatively simple:

messages<C> facet (§iso.22.4.7.1)

catalog open(const string& s, const locale& loc) const;

string_type get(catalog cat, int set, int id, const basic_string<C>& def) const;

void close(catalog cat) const;

A call open(s,loc) opens a “catalog” of messages called s for the locale loc. A catalog is a set of strings organized in an implementation-specific way and accessed through the messages::get() function. A negative value is returned if no catalog named s can be opened. A catalog must be opened before the first use of get().

A call close(cat) closes the catalog identified by cat and frees all resources associated with that catalog.

A call get(cat,set,id,"foo") looks for a message identified by (set,id) in the catalog cat. If a string is found, get() returns that string; otherwise, get() returns the default string (here, string("foo")).

Here is an example of a messages facet for an implementation in which a message catalog is a vector of sets of “messages” and a “message” is a string:

Click here to view code image

struct Set {
     vector<string> msgs;
};

struct Cat {
     vector<Set> sets;
};

class My_messages : public messages<char> {
     vector<Cat>& catalogs;
public:
     explicit My_messages(size_t = 0) :catalogs{*new vector<Cat>} { }

     catalog do_open(const string& s, const locale& loc) const;      // open catalog s
     string do_get(catalog cat, int s, int m, const string&) const;  // get message (s,m) in cat
     void do_close(catalog cat) const
     {
          if (cat<catalogs.size())
                catalogs.erase(catalogs.begin()+cat);
     }
     ~My_messages() { delete &catalogs; }
};
All messages’ member functions are const, so the catalog data structure (the vector<Set>) is stored outside the facet.

A message is selected by specifying a catalog, a set within that catalog, and a message string within that set. A string is supplied as an argument, to be used as a default result in case no message is found in the catalog:

Click here to view code image

string My_messages::do_get(catalog cat, int set, int id, const string& def) const
{
     if (catalogs.size()<=cat)
           return def;
     Cat& c = catalogs[cat];
     if (c.sets.size()<=set)
           return def;
     Set& s = c.sets[set];
     if (s.msgs.size()<=id)
           return def;
     return s.msgs[id];
}
Opening a catalog involves reading a textual representation from disk into a Cat structure. Here, I chose a representation that is trivial to read. A set is delimited by <<< and >>>, and each message is a line of text:

Click here to view code image

messages<char>::catalog My_messages::do_open(const string& n, const locale& loc) const
{
    string nn = n + locale().name();
    ifstream f(nn.c_str());
    if (!f) return –1;

    catalogs.push_back(Cat{});                // make in-core catalog
    Cat& c = catalogs.back();

    for(string s; f>>s && s=="<<<"; ) {       // read Set
          c.sets.push_back(Set{});
          Set& ss = c.sets.back();
          while (getline(f,s) && s != ">>>")  // read message
               ss.msgs.push_back(s);
    }
    return catalogs.size()–1;
}
Here is a trivial use:

Click here to view code image

int main()
      // a trivial test
{
     if (!has_facet<My_messages>(locale())) {
           cerr << "no messages facet found in" << locale().name() << '\n';
           exit(1);
     }

     const messages<char>& m = use_facet<My_messages>(locale());
     extern string message_directory;   // where I keep my messages

     auto cat = m.open(message_directory,locale());
     if (cat<0) {
           cerr << "no catalog found\n";
           exit(1);
     }
     cout << m.get(cat,0,0,"Missed again!") << endl;
     cout << m.get(cat,1,2,"Missed again!") << endl;
     cout << m.get(cat,1,3,"Missed again!") << endl;
     cout << m.get(cat,3,0,"Missed again!") << endl;
}
If the catalog is:

<<<
hello
goodbye
>>>
<<<
yes
no
maybe
>>>
this program prints

hello
maybe
Missed again!
 Missed again!
39.4.7.1. Using Messages from Other facets
In addition to being a repository for locale-dependent strings used to communicate with users, messages can be used to hold strings for other facets. For example, the Season_io facet (§39.3.2) could have been written like this:

Click here to view code image

class Season_io : public locale::facet {
     const messages<char>& m;            // message directory
     messages_base::catalog cat;         // message catalog
public:
     class Missing_messages { };

     Season_io(size_t i = 0)
           : locale::facet(i),
             m(use_facet<Season_messages>(locale())),
             cat(m.open(message_directory,locale()))
     {
           if (cat<0)
                 throw Missing_messages();
     }

     ~Season_io() { }     // to make it possible to destroy Season_io objects (§39.3)

     const string& to_str(Season x) const;                  // string representation of x

     bool from_str(const string& s, Season& x) const;       // place Season corresponding to s in x

     static locale::id id;  // facet identifier object (§39.2, §39.3, §39.3.1)
};

locale::id Season_io::id;  // define the identifier object

string Season_io::to_str(Season x) const
{
     return m–>get(cat,0,x,"no–such–season");
}

bool Season_io::from_str(const string& s, Season& x) const
{
     for (int i = Season::spring; i<=Season::winter; i++)
           if (m–>get(cat,0,i,"no–such–season") == s) {
                 x = Season(i);
                 return true;
           }
     return false;
}
This messages-based solution differs from the original solution (§39.3.2) in that the implementer of a set of Season strings for a new locale needs to be able to add them to a messages directory. This is easy for someone adding a new locale to an execution environment. However, since messages provides only a read-only interface, adding a new set of season names may be beyond the scope of an application programmer.

A _byname version (§39.4, §39.4.1) of messages is provided:

Click here to view code image

template<typename C>
class messages_byname : public messages<C> {
      //...
};
39.5. Convenience Interfaces
Beyond simply imbuing an iostream, the locale facilities can be complicated to use. Consequently, convenience interfaces are provided to simplify notation and minimize mistakes.

39.5.1. Character Classification
The most common use of the ctype facet is to inquire whether a character belongs to a given classification. Consequently, a set of functions is provided for that:

locale-Sensitive Character Classification (§iso.22.3.3.1)

isspace(c.loc)

Is c a space in loc?

isblank(c,loc)

Is c a blank in loc?

isprint(c,loc)

Is c printable in loc?

iscntrl(c,loc)

Is c a control character in loc?

isupper(c,loc)

Is c an uppercase letter in loc?

islower(c,loc)

Is c a lowercase letter in loc?

isalpha(c,loc)

Is c a letter in loc?

isdigit(c,loc)

Is c a decimal digit in loc?

ispunct(c,loc)

Is c not a letter, digit, whitespace, or invisible control character in loc?

isxdigit(c,loc)

Is c a hexadecimal digit in loc?

isalnum(c,loc)

isalpha(c,loc) or isdigit(c,loc)

isgraph(c,loc)

isalpha(c,loc) or isdigit(c,loc) or ispunct(c) (note: not space)

These functions are trivially implemented using use_facet. For example:

Click here to view code image

template<class C>
inline bool isspace(C c, const locale& loc)
{
     return use_facet<ctype<C>>(loc).is(space,c);
}
The one-argument versions of these functions (§36.2.1) use the current C global locale. Except for the rare cases in which the C global locale and the C++ global locale differ (§39.2.1), we can think of a one-argument version as the two-argument version applied to locale(). For example:

Click here to view code image

inline int isspace(int i)
{
     return isspace(i,locale());     // almost
}
39.5.2. Character Conversions
Case conversions can be locale sensitive:

Character Conversion (§iso.22.3.3.2.1)

c2= toupper(c,loc) use_facet<ctype<C>>(loc).toupper(c)

c2= tolower(c,loc) use_facet<ctype<C>>(loc).tolower(c)

39.5.3. String Conversions
Character code conversions can be locale sensitive. Class template wstring_convert performs conversions between a wide string and a byte string. It lets you specify a code conversion facet (such as codecvt) to perform the conversions, without affecting any streams or locales. For example, you might use a code conversion facet called codecvt_utf8 directly to output a UTF-8 multibyte sequence to cout without altering cout’s locale:

Click here to view code image

wstring_convert<codecvt_utf8<wchar_t>> myconv;
string s = myconv.to_bytes(L"Hello\n");
cout << s;
The definition of wstring_convert is fairly conventional:

Click here to view code image

template<typename Codecvt,
         class Wc = wchar_t,
         class Wa = std::allocator<Wc>,       // wide-character allocator
         class Ba = std::allocator<char>      // byte allocator
       >
class wstring_convert {
public:
     using byte_string = basic_string<char, char_traits<char>, Ba>;
     using wide_string = basic_string<Wc, char_traits<Wc>, Wa>;
     using state_type = typename Codecvt::state_type;
     using int_type = typename wide_string::traits_type::int_type;
      //...
};
The wstring_convert constructors allow us to specify a character conversion facet, an initial conversion state, and values to be used in case of errors:

wstring_convert<Codecvt,Wc,Wa,Ba> (§iso.22.3.3.2.2)

wstring_convert cvt {};

wstring_convert cvt {new Codecvt};

wstring_convert cvt {pcvt,state};

cvt uses the conversion facet *pcvt and conversion state state

wstring_convert cvt {pcvt};

wstring_convert cvt {pcvt,state_type{}};

wstring_convert cvt {b_err,w_err};

wstring_convert cvt{}; use b_err and w_err

wstring_convert cvt {b_err};

wstring_convert cvt{}; use b_err

cvt.~wstring_convert();

Destructor

wstring_convert<Codecvt,Wc,Wa,Ba> (§iso.22.3.3.2.2)

ws=cvt.from_bytes(c)

ws contains the char c converted to Wc

ws=cvt.from_bytes(s)

ws contains the charsof s converted to Wc;

 

s is a C-style string or a string

ws=cvt.from_bytes(b,e)

ws contains the charsof[b:e) converted to Wcs

s=cvt.to_bytes(wc)

s contains wc converted to chars

s=cvt.to_bytes(ws)

s contains the Wcsofws converted to chars;

 

ws is a C-style string or a basic_string<Wc>

s=cvt.to_bytes(b,e)

s contains the Wcsof[b:e) converted to chars

n=cvt.converted()

n is the number of input elements converted by cvt

st=cvt.state()

st is the cvt’s state

If a conversion to a wide_string fails, functions on a cvt constructed with a non-default w_err string return that string (as an error message); otherwise, they throw range_error.

If a conversion to a byte_string fails, functions on a cvt constructed with a non-default b_err string return that string (as an error message); otherwise, they throw range_error.

An example:

Click here to view code image

void test()
{
     wstring_convert<codecvt_utf8_utf16<wchar_t>> converter;

     string s8 = u8"This is a UTF–8 string";
     wstring s16 = converter.from_bytes(s8);
     string s88 = converter.to_bytes(s16);

     if (s8!=s88)
           cerr <<"Insane!\n";
}
39.5.4. Buffer Conversions
We can use a code conversion facet (§39.4.6) to write directly into or to read directly from a stream buffer (§38.6):

Click here to view code image

template<typename Codecvt,
         class C = wchar_t,
         class Tr = std::char_traits<C>
      >
class wbuffer_convert
     : public std::basic_streambuf<C,Tr> {
public:
     using state_type = typename Codecvt::state_type;
      //...
};
wbuffer_convert<Codecvt,C,Tr> (§iso.22.3.3.2.3)

wbuffer_convert wb {psb,pcvt,state};

wb converts from the streambuf *psb,

 

using converter *pcvt and initial conversion state state

wbuffer_convert wb {psb,pcvt};

wbuffer_convert wb {psb,pcvt,state_type{}};

wbuffer_convert wb {psb};

wbuffer_convert wb {psb,new Codecvt{}};

wbuffer_convert wb {};

wbuffer_convert wb {nullptr};

psb=wb.rdbuf()

psb is wb’s stream buffer

psb2=wb.rdbuf(psb)

Set wb’s stream buffer to *psb;

 

*psb2 is wb’s previous stream buffer

t=wb.state()

t is wb’s conversion state

39.6. Advice
[1] Expect that every nontrivial program or system that interacts directly with people will be used in several different countries; §39.1.

[2] Don’t assume that everyone uses the same character set as you do; §39.1, §39.4.1.

[3] Prefer using locales to writing ad hoc code for culture-sensitive I/O; §39.1.

[4] Use locales to meet external (non-C++) standards; §39.1.

[5] Think of a locale as a container of facets; §39.2.

[6] Avoid embedding locale name strings in program text; §39.2.1.

[7] Keep changes of locale to a few places in a program; §39.2.1.

[8] Minimize the use of global format information; §39.2.1.

[9] Prefer locale-sensitive string comparisons and sorts; §39.2.2, §39.4.1.

[10] Make facets immutable; §39.3.

[11] Let locale handle the lifetime of facets; §39.3.

[12] You can make your own facets; §39.3.2.

[13] When writing locale-sensitive I/O functions, remember to handle exceptions from user-supplied (overriding) functions; §39.4.2.2.

[14] Use numput if you need separators in numbers; §39.4.2.1.

[15] Use a simple Money type to hold monetary values; §39.4.3.

[16] Use simple user-defined types to hold values that require locale-sensitive I/O (rather than casting to and from values of built-in types); §39.4.3.

[17] The time_put facet can be used for both <chrono>- and <ctime>-style time; §39.4.4.

[18] Prefer the character classification functions in which the locale is explicit; §39.4.5, §39.5.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


39. Locales
40. Numerics
41. Concurrency
47h 26m remaining
40. Numerics
The purpose of computing is insight, not numbers.

– R. W. Hamming

... but for the student, numbers are often the best road to insight.

– A. Ralston

• Introduction

• Numerical Limits

Limit Macros

• Standard Mathematical Functions

• complex Numbers

• A Numerical Array: valarray

Constructors and Assignments; Subscripting; Operations; Slices; slice_array; Generalized Slices

• Generalized Numerical Algorithms

accumulate(); inner_product(); partial_sum() and adjacent_difference(); iota()

• Random Numbers

Engines; Random Device; Distributions; C-Style Random Numbers

• Advice

40.1. Introduction
C++ was not designed primarily with numeric computation in mind. However, numeric computation typically occurs in the context of other work – such as database access, networking, instrument control, graphics, simulation, and financial analysis – so C++ becomes an attractive vehicle for computations that are part of a larger system. Furthermore, numeric methods have come a long way from being simple loops over vectors of floating-point numbers. Where more complex data structures are needed as part of a computation, C++’s strengths become relevant. The net effect is that C++ is widely used for scientific, engineering, financial, and other computation involving sophisticated numerics. Consequently, facilities and techniques supporting such computation have emerged. This chapter describes the parts of the standard library that support numerics. I make no attempt to teach numeric methods. Numeric computation is a fascinating topic in its own right. To understand it, you need a good course in numerical methods or at least a good textbook – not just a language manual and tutorial.

In addition to the standard-library facilities described here, Chapter 29 is an extended example of numerical programming: an N-dimensional matrix.

40.2. Numerical Limits
To do anything interesting with numbers, we typically need to know something about the general properties of built-in numeric types. To allow the programmer to best take advantage of hardware, these properties are implementation-defined rather than fixed by the rules of the language itself (§6.2.8). For example, what is the largest int? What is the smallest positive float? Is a double rounded or truncated when assigned to a float? How many bits are there in a char?

Answers to such questions are provided by the specializations of the numeric_limits template presented in <limits>. For example:

Click here to view code image

void f(double d, int i)
{
     char classification[numeric_limits<unsigned char>::max()];

     if (numeric_limits<unsigned char>::digits==numeric_limits<char>::digits) {
            // chars are unsigned
     }
     if (i<numeric_limits<short>::min() || numeric_limits<short>::max()<i) {
            // i cannot be stored in a short without loss of digits
     }
     if (0<d && d<numeric_limits<double>::epsilon()) d = 0;

     if (numeric_limits<Quad>::is_specialized) {
           // limits information is available for type Quad
     }
}
Each specialization provides the relevant information for its argument type. Thus, the general numeric_limits template is simply a notational handle for a set of constants and constexpr functions:

Click here to view code image

template<typename T>
class numeric_limits {
public:
     static const bool is_specialized = false;  // is information available for numeric_limits<T>?
      //... uninteresting defaults ...
};
The real information is in the specializations. Each implementation of the standard library provides a specialization of numeric_limits for each fundamental numeric type (the character types, the integer types, the floating-point types, and bool) but not for any other plausible candidates such as void, enumerations, or library types (such as complex<double>).

For an integral type such as char, only a few pieces of information are of interest. Here is numeric_limits<char> for an implementation in which a char has 8 bits and is signed:

Click here to view code image

template<>
class numeric_limits<char> {
public:
     static const bool is_specialized = true;  // yes, we have information

     static const int digits = 7;              // number of bits ("binary digits") excluding sign

     static const bool is_signed = true;       // this implementation has char signed
     static const bool is_integer = true;      // char is an integral type

     static constexpr char min() noexcept { return –128; }      // smallest value
     static constexpr char max() noexcept { return 127; }       // largest value

      // lots of declarations not relevant to a char
};
The functions are constexpr, so that they can be used where a constant expression is required and without run-time overhead.

Most members of numeric_limits are intended to describe floating-point numbers. For example, this describes one possible implementation of float:

Click here to view code image

template<>
class numeric_limits<float> {
public:
     static const bool is_specialized = true;

     static const int radix = 2;         // base of exponent (in this case, binary)
     static const int digits = 24;       // number of radix digits in mantissa
     static const int digits10 = 9;      // number of base 10 digits in mantissa

     static const bool is_signed = true;
     static const bool is_integer = false;
     static const bool is_exact = false;

     static constexpr float min() noexcept { return 1.17549435E–38F; }  // smallest positive
     static constexpr float max() noexcept { return 3.40282347E+38F; }  // largest positive
     static constexpr float lowest() noexcept { return –3.40282347E+38F; }   // smallest value

     static constexpr float epsilon() noexcept { return 1.19209290E–07F; }
     static constexpr float round_error() noexcept { return 0.5F; }    // maximum rounding error

     static constexpr float infinity() noexcept { return /* some value */; }
     static constexpr float quiet_NaN() noexcept { return /* some value */; }
     static constexpr float signaling_NaN() noexcept { return /* some value */; }
     static constexpr float denorm_min() noexcept { return min(); } 

     static const int min_exponent = –125;
     static const int min_exponent10 = –37;
     static const int max_exponent = +128;
     static const int max_exponent10 = +38;

     static const bool has_infinity = true;
     static const bool has_quiet_NaN = true;
     static const bool has_signaling_NaN = true;
     static const float_denorm_style has_denorm = denorm_absent;
     static const bool has_denorm_loss = false;

     static const bool is_iec559 = true;  // conforms to IEC-559
     static const bool is_bounded = true;
     static const bool is_modulo = false;
     static const bool traps = true;
     static const bool tinyness_before = true;

     static const float_round_style round_style = round_to_nearest;
};
Note that min() is the smallest positive normalized number and that epsilon is the smallest positive floating-point number such that 1+epsilon–1 is larger than 0.

When defining a scalar type along the lines of the built-in ones, it is a good idea also to provide a suitable specialization of numeric_limits. For example, if I write a quadruple-precision type Quad, a user could reasonably expect me to provide numeric_limits<Quad>. Conversely, if I use a nonnumeric type, Dumb_ptr, I would expect for numeric_limits<Dumb_ptr<X>> to be the primary template that has is_specialized set to false, indicating that no information is available.

We can imagine specializations of numeric_limits describing properties of user-defined types that have little to do with floating-point numbers. In such cases, it is usually better to use the general technique for describing properties of a type than to specialize numeric_limits with properties not considered in the standard.

40.2.1. Limit Macros
From C, C++ inherited macros that describe properties of integers. They are found in <climits>:

Integer Limit Macros (§iso.18.3.3, abbreviated)

CHAR_BIT

Number of bits in a char (usually 8)

CHAR_MIN

Smallest char value (possibly negative)

CHAR_MAX

Largest char value (usually 127 if char is signed and 255 if char is unsigned)

INT_MIN

Smallest int value

LONG_MAX

Largest long value

Analogously named macros for signed chars, long long, etc., are also provided.

Similarly, <cfloat> and <float.h> define macros describing properties of floating-point numbers:

Floating-Point Limit Macros (§iso.18.3.3, abbreviated)

FLT_MIN

Smallest positive float value (e.g., 1.175494351e-38F)

FLT_MAX

Largest float value (e.g., 3.402823466e+38F)

FLT_DIG

Number of decimal digits of precision of a float (e.g., 6)

FLT_MAX_10_EXP

Largest decimal exponent of a float (e.g., 38)

DBL_MIN

Smallest double value

DBL_MAX

Largest double value (e.g., 1.7976931348623158e+308)

DBL_EPSILON

Smallest double such that 1.0+DBL_EPSILON!=1.0

Analogously named macros for long double are also provided.

40.3. Standard Mathematical Functions
In <cmath> we find what are commonly called the standard mathematical functions:

Standard Mathematical Functions (§iso.26.8, abbreviated)

abs(x)

Absolute value

 

 

ceil(x)

Smallest integer >= x

 

 

floor(x)

Largest integer <= x

 

 

sqrt(x)

Square root; x must be non-negative

 

 

cos(x)

Cosine

cosh(x)

Hyperbolic

sin(x)

Sine

sinh(x)

Hyperbolic

tan(x)

Tangent

tanh(x)

Hyperbolic

acos(x)

Arccosine; the result is non-negative

acosh(x)

Hyperbolic

asin(x)

Arcsine; the result nearest to 0 is returned

asinh(x)

Hyperbolic

atan(x)

Arctangent

atanh(x)

Hyperbolic

atan2(x,y)

atanh(x/y)

 

 

exp(x)

Base e exponential

exp2(x)

base 2

log(x)

Natural logarithm, base e; x must be positive

log2(x)

base 2

log10(x)

Base 10 logarithm

 

 

pow(x,y)

Exponentiation; x to the power of y

 

 

round(x)

4/5 rounding; .5 and -.5 round away from zero

 

 

modf(x,p)

(*p=round(x),x-round(x))

 

 

fmod(x,y)

Floating-point remainder; same sign as x

 

 

There are versions taking float, double, long double, and complex (§40.4) arguments. For each function, the return type is the same as the argument type.

Errors are reported by setting errno from <cerrno> to EDOM for a domain error and to ERANGE for a range error. For example:

Click here to view code image

void f()
{
     errno = 0;  // clear old error state
     sqrt(–1);
     if (errno==EDOM) cerr << "sqrt() not defined for negative argument";
     pow(numeric_limits<double>::max(),2);
     if (errno == ERANGE) cerr << "result of pow() too large to represent as a double";
}
For historical reasons, a few mathematical functions are found in <cstdlib> rather than in <cmath>:

More Mathematical Functions (§iso.26.8)

n2=abs(n)

Absolute value; n is int, long, or long long; n2 has the same type as n

n2=labs(n)

“Long absolute value”; n and n2 are long

n2=llabs(n)

“Long long absolute value”; n and n2 are long long

p=div(n,d)

Divide n by d; p is {quotient,remainder}; n and d can be int, long, or long long

p=ldiv(n,d)

Divide n by d; p is {quotient,remainder}; n and d are long

p=lldiv(n,d)

Divide n by d; p is {quotient,remainder}; n and d are long long

The l*() versions exist because C does not support overloading. The results of a *div() function is div_t, ldiv_t, or lldiv_t. These structs have members quot (quotient) and rem (remainder) of type int, long, or long long. The plain div() returns a struct with sufficient precision to match its arguments.

There is a separate ISO standard for special mathematical functions [C++Math,2010]. An implementation may add these functions to <cmath>:

Mathematical Special Functions (Optional)

assoc_laguerre()

assoc_legendre()

beta()

comp_ellint_1()

comp_ellint_2()

comp_ellint_3()

cyl_bessel_i()

cyl_bessel_j()

cyl_bessel_k()

cyl_neumann()

ellint_1()

ellint_2()

ellint_3()

expint()

hermite()

laguerre()

legendre()

riemann_zeta()

sph_bessel()

sph_legendre()

sph_neumann()

 

 

 

 

If you don’t know these functions, you are unlikely to need them.

40.4. complex Numbers
The standard library provides complex number types complex<float>, complex<double>, and complex<long double>. A complex<Scalar> where Scalar is some other type supporting the usual arithmetic operations usually works but is not guaranteed to be portable.

Click here to view code image

template<typename Scalar> // §iso.26.4.2
class complex {
      // a complex is a pair of scalar values, basically a coordinate pair
     Scalar re, im;
public:
     complex(const Scalar & r = Scalar{}, const Scalar & i = Scalar{}) :re(r), im(i) { }

     Scalar real() const { return re; }       // real part
     void real(Scalar r) { re=r; }
     Scalar imag() const { return im; }       // imaginary part
     void imag(Scalar i) { im = i; }

     template<typename X>
         complex(const complex<X>&);

     complex<T>& operator=(const T&);
     complex& operator=(const complex&);
     template<typename X>
         complex<T>& operator=(const complex<X>&);

     complex<T>& operator+=(const T&);
     template<typename X>
        complex<T>& operator+=(const complex<X>&);

      // similar for operators -=, *=, /=
};
The standard-library complex does not protect against narrowing:

Click here to view code image

complex<float> z1 = 1.33333333333333333;  // narrows
complex<double> z2 = 1.33333333333333333; // narrows
z1=z2;                                    // narrows
To protect against accidental narrowing, use {} initialization:

complex<float> z3 {1.33333333333333333};  // error: narrowing conversion
In addition to the members of complex, <complex> offers a host of useful operations:

complex Operators (§iso.26.4, abbreviated)

z1+z2

Addition

z1-z2

Subtraction

z1*z2

Multiplication

z1/z2

Division

z1==z2

Equality

z1!=z2

Inequality

norm(z)

The square of abs(z)

conj(z)

Conjugate: {z.re,-z.im}

polar(x,y)

Make a complex given polar coordinates (rho,theta)

real(z)

Real part

imag(z)

Imaginary part

abs(z)

Distance from (0,0): sqrt(z.re*z.re+z.im*z.im); also known as rho

arg(z)

Angle from positive real axis: atan2(z.im,z.re); also known as theta

out<<z

Complex output

in>>z

Complex input

The standard mathematical functions (§40.3) are also available for complex numbers. Note that complex does not provide < or %. For more details, see §18.3.

40.5. A Numerical Array: valarray
Much numeric work relies on relatively simple single-dimensional vectors of floating-point values. In particular, such vectors are well supported by high-performance machine architectures, libraries relying on such vectors are in wide use, and very aggressive optimization of code using such vectors is considered essential in many fields. The valarray from <valarray> is a single-dimensional numerical array. It provides the usual numeric vector arithmetic operations for an array type plus support for slices and strides:

Numerical Array Classes (§iso.26.6.1)

valarray<T>

A numerical array of type T

slice

A BLAS-like slice (start, length, and stride); §40.5.4

slice_array<T>

A subarray identified by a slice; §40.5.5

gslice

A slice generalized to describe a matrix

gslice_array<T>

A submatrix identified by a generalized slice; §40.5.6

mask_array<T>

A subset of an array identified by a mask; §40.5.2

indirect_array<T>

A subset of an array identified by a list of indices; §40.5.2

The fundamental idea of valarray was to provide Fortran-like facilities for dense multidimensional arrays with Fortran-like opportunities for optimization. This can only be achieved with the active support of compiler and optimization suppliers and the addition of more library support on top of the very basic facilities provided by valarray. So far, that has not happened for all implementations.

40.5.1. Constructors and Assignments
The valarray constructors allow us to initialize valarrays from the auxiliary numeric array types and from single values:

valarray<T> Constructors (§iso.26.6.2.2)

valarray va {};

valarray with no elements

valarray va {n};

valarray of n elements with value T{}; explicit

valarray va {t,n};

valarray of n elements with value t

valarray va {p,n};

valarray of n elements with values copied from [p:p+n)

valarray va {v2};

Move and copy constructor

valarray va {a};

Construct va with elements from a;

 

a can be a slice_array, gslice_array, mask_array, or indirect_array;

 

the number of elements is the number of elements in a

valarray va {args};

Construct from the initializer_list {args};

 

the number of elements is the number of elements in {args}

va.~valarray()

Destructor

For example:

Click here to view code image

valarray<double> v0;                // placeholder, we can assign to v0 later
valarray<float> v1(1000);           //1000 elements with value float()==0.0F
valarray<int> v2(–1,2000);          //2000 elements with value –1
valarray<double> v3(100,9.8064);    // bad mistake: floating-point valarray size

valarray<double> v4 = v3;           // v4 has v3.size() elements

valarray<int> v5 {–1,2000};         // two elements
In the two-argument constructors, the value comes before the number of elements. This differs from the convention for standard containers (§31.3.2).

The number of elements of an argument valarray to a copy constructor determines the size of the resulting valarray.

Most programs need data from tables or input. In addition to initializer lists, this is supported by a constructor that copies elements from a built-in array. For example:

Click here to view code image

void f(const int* p, int n)
{
     const double vd[] = {0,1,2,3,4};
     const int vi[] = {0,1,2,3,4};

     valarray<double> v1{vd,4};      //4 elements: 0,1,2,3
     valarray<double> v2{vi,4};      // type error: vi is not pointer to double
     valarray<double> v3{vd,8};      // undefined: too few elements in initializer
     valarray<int> v4{p,n};          // p had better point to at least n ints
}
The valarray and its auxiliary facilities were designed for high-speed computing. This is reflected in a few constraints on users and by a few liberties granted to implementers. Basically, an implementer of valarray is allowed to use just about every optimization technique you can think of. The valarray operations are assumed to be free of side effects (except on their explicit arguments, of course), valarrays are assumed to be alias free, and the introduction of auxiliary types and the elimination of temporaries is allowed as long as the basic semantics are maintained. There is no range checking. The elements of a valarray must have the default copy semantics (§8.2.6).

Assignment can be with another valarray, a scalar, or a subset of a valarray:

valarray<T> Assignments (§iso.26.6.2.3)

va2=va

Copy assignment: va2.size() must equal va.size()

va2=move(va)

Move assignment: va becomes empty

va=t

Scalar assignment: each element of va is a copy of t

va={args}

Assignment from the initializer_list {args};

 

the number of elements of va becomes {args}.size()

va=a

Assignment from a; a.size() must equal va.size();

 

a can be a slice_array, gslice_array, mask_array, or indirect_array

va@=va2

va[i]@=va2[i] for each element of va; @ can be *, /, %, +, -, &, ^, |, <<, or >>

va@=t

va[i]@=t for each element of va; @ can be *, /, %, +, -, &, ^, |, <<, or >>

A valarray can be assigned to another of the same size. As one would expect, v1=v2 copies every element of v2 into its corresponding position in v1. If valarrays have different sizes, the result of assignment is undefined.

In addition to this conventional assignment, it is possible to assign a scalar to a valarray. For example, v=7 assigns 7 to every element of the valarray v. This may be surprising to some programmers and is best understood as an occasionally useful degenerate case of the operator assignment operations. For example:

valarray<int> v {1,2,3,4,5,6,7,8};
v *= 2;      // v=={2,4,6,10,12,14,16}
v = 7;       // v=={7,7,7,7,7,7,7,7}
40.5.2. Subscripting
Subscripting can be used to select an element of a valarray or a subset of its elements:

valarray<T> Subscripting (§iso.26.6.2.4, §iso.26.6.2.5)

t=va[i]

Subscripting: t is a reference to the ith element of va; no range checking

a2=va[x]

Subset: x is a slice, a gslice, valarray<bool>, or a valarray<size_t>

Each operator[] returns a subset of the elements from a valarray. The return type (the type of the object representing the subset) depends on the argument type.

For const arguments, the result contains copies of elements. For non-const arguments, the result holds references to elements. Since C++ doesn’t directly support arrays of references (e.g., we can’t say valarray<int&>), the implementation will somehow simulate this. This can be done efficiently. An exhaustive list, with examples (based on §iso.26.6.2.5), is in order. In each case, the subscript describes the elements to be returned, and v1 must be a valarray with an appropriate length and element type:

• A slice of a const valarray:

Click here to view code image

   valarray<T> operator[](slice) const; // copy of elements
    //...
   const valarray<char> v0 {"abcdefghijklmnop",16};
   valarray<char> v1 {v0[slice(2,5,3)]};   //{"cfilo",5}
• A slice of a non-const valarray:

Click here to view code image

   slice_array<T> operator[](slice);   // references to elements
    //...
   valarray<char> v0 {"abcdefghijklmnop",16};
   valarray<char> v1 {"ABCDE",5};
   v0[slice(2,5,3)] = v1;   // v0=={"abAdeBghCjkDmnEp",16}
• A gslice of a const valarray:

Click here to view code image

   valarray<T> operator[](const gslice&) const;    // copies of elements
    //...
   const valarray<char> v0 {"abcdefghijklmnop",16};
   const valarray<size_t> len {2,3};
   const valarray<size_t> str {7,2};
   valarray<char> v1 {v0[gslice(3,len,str)]};      // v1=={"dfhkmo",6}
• A gslice of a non-const valarray:

Click here to view code image

   gslice_array<T> operator[](const gslice&);  // references to elements
    //...
   valarray<char> v0 {"abcdefghijklmnop",16};
   valarray<char> v1 {"ABCDE",5};
   const valarray<size_t> len {2,3};
   const valarray<size_t> str {7,2};
   v0[gslice(3,len,str)] = v1;    // v0=={"abcAeBgCijDlEnFp",16}
• A valarray<bool> (a mask) of a const valarray:

Click here to view code image

   valarray<T> operator[](const valarray<bool>&) const;         // copies of elements
    //...
   const valarray<char> v0 {"abcdefghijklmnop",16};
   const bool vb[] {false, false, true, true, false, true};
   valarray<char> v1 {v0[valarray<bool>(vb, 6)]};               // v1=={"cdf",3}
• A valarray<bool> (a mask) of a non-const valarray:

Click here to view code image

   mask_array<T> operator[](const valarray<bool>&);             // references to elements
    //...
   valarray<char> v0 {"abcdefghijklmnop", 16};
   valarray<char> v1 {"ABC",3};
   const bool vb[] {false, false, true, true, false, true};
   v0[valarray<bool>(vb,6)] = v1;          // v0=={"abABeCghijklmnop",16}
• A valarray<size_t> (a set of indices) of a const valarray:

Click here to view code image

   valarray<T> operator[](const valarray<size_t>&) const;      // references to elements
    //...
   const valarray<char> v0 {"abcdefghijklmnop",16};
   const size_t vi[] {7, 5, 2, 3, 8};
   valarray<char> v1 {v0[valarray<size_t>(vi,5)]};             // v1=={"hfcdi",5}
• A valarray<size_t> (a set of indices) of a non-const valarray:

Click here to view code image

   indirect_array<T> operator[](const valarray<size_t>&);     // references to elements
    //...
   valarray<char> v0 {"abcdefghijklmnop",16};
   valarray<char> v1 {"ABCDE",5};
   const size_t vi[] {7, 5, 2, 3, 8};
   v0[valarray<size_t>(vi,5)] {v1};  // v0=={"abCDeBgAEjklmnop",16}
Note that subscripting with a mask (a valarray<bool>) yields a mask_array, and subscripting with a set of indices (a valarray<size_t>) yields an indirect_array.

40.5.3. Operations
The purpose of valarray is to support computation, so a host of basic numerical operations are directly supported:

valarray<T> Member Operations (§iso.26.6.2.8)

va.swap(va2)

Exchange elements of va and va2; noexcept;

n=va.size()

n is the number of elements of va

t=va.sum()

t is the sum of elements of va computed using +=

t=va.min()

t is the smallest element of va found using <

t=va.max()

t is the largest element of va found using <

va2=va.shift(n)

Linear left shift of elements

va2=va.cshift(n)

Circular left shift of elements

va2=va.apply(f)

Apply f: the value of each element va2[i] is f(va[i])

va.resize(n,t)

Make va a valarray with n elements with the value t

va.resize(n)

va.resize(n,T{})

There is no range checking: the effect of using a function that tries to access an element of an empty valarray is undefined.

Note that resize() does not retain any old values.

valarray<T> Operations (§iso.26.6.2.6, §iso.26.6.2.7, §iso.26.6.3)

v or v2, but not both, can be a scalar; for arithmetic operations, the result is a valarray<T>

swap(va,va2)

va.swap(va2)

va3=va@va2

Perform @ on elements of va and va2, yielding va3;

@ can be +, -, *, /, %, &, |, ^, << ,>>

vb=v@v2

Perform @ on elements of v and v2, yielding a valarray<bool>;

@ can be ==, !=, <, <=, >, >=, &&, ||

v2=@(v)

Perform @() on elements of v, yielding v2;

@ can be abs, acos, asin, atan, cos, cosh, exp, log, log10, sin, sinh, sqrt, tan, tanh

v3=@(v,v2)

Perform @() on elements of v and v2;

@ can be pow() or atan2

p=begin(v)

p is a random-access iterator to the first element of v

p=end(v)

p is a random-access iterator to the one-beyond-the-last element of v

The binary operations are defined for valarrays and for combinations of a valarray and its scalar type. A scalar type is treated as a valarray of the right size with every element having the scalar’s value. For example:

Click here to view code image

void f(valarray<double>& v, valarray<double>& v2, double d)
{
     valarray<double> v3 = v*v2;    // v3[i] = v[i]*v2[i] for all i
     valarray<double> v4 = v*d;            // v4[i] = v[i]*d for all i
     valarray<double> v5 = d*v2;    // v5[i] = d*v2[i] for all i
     valarray<double> v6 = cos(v);  // v6[i] = cos(v[i]) for all i
}
These vector operations all apply their operations to each element of their operand(s) in the way indicated by the * and cos() examples. Naturally, an operation can be used only if the corresponding operation is defined for the scalar type. Otherwise, the compiler will issue an error when trying to specialize the operator or function.

Where the result is a valarray, its length is the same as its valarray operand. If the lengths of the two arrays are not the same, the result of a binary operator on two valarrays is undefined.

These valarray operations return new valarrays rather than modifying their operands. This can be expensive, but it doesn’t have to be when aggressive optimization techniques are applied.

For example, if v is a valarray, it can be scaled like this: v*=0.2, and this: v/=1.3. That is, applying a scalar to a vector means applying the scalar to each element of the vector. As usual, *= is more concise than a combination of * and = (§18.3.1) and easier to optimize.

Note that the non-assignment operations construct a new valarray. For example:

Click here to view code image

double incr(double d) { return d+1; }

void f(valarray<double>& v)
{
     valarray<double> v2 = v.apply(incr);    // produce incremented valarray
      //...
}
This does not change the value of v. Unfortunately, apply() does not accept a function object (§3.4.3, §11.4) as an argument.

The logical and cyclic shift functions, shift() and cshift(), return a new valarray with the elements suitably shifted and leave the original one unchanged. For example, the cyclic shift v2=v.cshift(n) produces a valarray so that v2[i]==v[(i+n)%v.size()]. The logical shift v3=v.shift(n) produces a valarray so that v3[i] is v[i+n] if i+n is a valid index for v. Otherwise, the result is the default element value. This implies that both shift() and cshift() shift left when given a positive argument and right when given a negative argument. For example:

Click here to view code image

void f()
{
     int alpha[] = { 1, 2, 3, 4, 5 ,6, 7, 8 };
     valarray<int> v(alpha,8);                 //1, 2, 3, 4, 5, 6, 7, 8
     valarray<int> v2 = v.shift(2);            //3, 4, 5, 6, 7, 8, 0, 0
     valarray<int> v3 = v<<2;                  //4, 8, 12, 16, 20, 24, 28, 32
     valarray<int> v4 = v.shift(–2);           //0, 0, 1, 2, 3, 4, 5, 6
     valarray<int> v5 = v>>2;                  //0, 0, 0, 1, 1, 1, 1, 2
     valarray<int> v6 = v.cshift(2);           //3, 4, 5, 6, 7, 8, 1, 2
     valarray<int> v7 = v.cshift(–2);          //7, 8, 1, 2, 3, 4, 5, 6
}
For valarrays, >> and << are bit shift operators, rather than element shift operators or I/O operators. Consequently, <<= and >>= can be used to shift bits within elements of an integral type. For example:

Click here to view code image

void f(valarray<int> vi, valarray<double> vd)
{
     vi <<= 2;        // vi[i]<<=2 for all elements of vi
     vd <<= 2;        // error: shift is not defined for floating-point values
}
All of the operators and mathematical functions on valarrays can also be applied to slice_arrays (§40.5.5), gslice_arrays (§40.5.6), mask_arrays (§40.5.2), indirect_arrays (§40.5.2), and combinations of these types. However, an implementation is allowed to convert an operand that is not a valarray to a valarray before performing a required operation.

40.5.4. Slices
A slice is an abstraction that allows us to manipulate a one-dimensional array (e.g., a built-in array, a vector, or a valarray) efficiently as a matrix of arbitrary dimension. It is the key notion of Fortran vectors and of the BLAS (Basic Linear Algebra Subprograms) library, which is the basis for much numeric computation. Basically, a slice is every nth element of some part of an array:

Click here to view code image

class std::slice {
      // starting index, a length, and a stride
public:
     slice();                     // slice{0,0,0}
     slice(size_t start, size_t size, size_t stride);

     size_t start() const;        // index of first element
     size_t size() const;         // number of elements
     size_t stride() const;       // element n is at start()+n*stride()
};
A stride is the distance (in number of elements) between two elements of the slice. Thus, a slice describes a mapping of non-negative integers into indices. The number of elements (the size()) doesn’t affect the mapping (addressing) but allows us to find the end of a sequence. This mapping can be used to simulate two-dimensional arrays within a one-dimensional array (such as valarray) in an efficient, general, and reasonably convenient way. Consider a 3-by-4 matrix (three rows, each with four elements):

valarray<int> v {
     {00,01,02,03},     // row 0
     {10,11,12,13},     // row 1
     {20,21,22,23}      // row 2
};
or graphically:


Following the usual C/C++ conventions, the valarray is laid out in memory with row elements first (row-major order) and contiguous:

for (int x : v) cout << x << ' ' ;
This produces:

0 1 2 3 10 11 12 13 20 21 22 23
or graphically:



Row x is described by slice(x*4,4,1). That is, the first element of row x is the x*4th element of the vector, the next element of the row is the (x*4+1)th, etc., and there are 4 elements in each row. For example, slice{0,4,1} describes the first row of v (row 0): 00, 01, 02, 03, and slice{1,4,1} describes the second row (row 1).

Column y is described by slice(y,3,4). That is, the first element of column y is the yth element of the vector, the next element of the column is the (y+4)th, etc., and there are 3 elements in each column. For example, slice{0,3,4} describes the first column (column 0): 00, 10, 20, and slice{1,3,4} describes the second column (column 1).

In addition to its use for simulating two-dimensional arrays, a slice can describe many other sequences. It is a fairly general way of specifying very simple sequences. This notion is explored further in §40.5.6.

One way of thinking of a slice is as an odd kind of iterator: a slice allows us to describe a sequence of indices for a valarray. We could build an STL-style iterator based on that:

Click here to view code image

template<typename T>
class Slice_iter {
     valarray<T>* v;
     slice s;
     size_t curr;     // index of current element

     T& ref(size_t i) const { return (*v)[s.start()+i*s.stride()]; }
public:
     Slice_iter(valarray<T>*vv, slice ss, size_t pos =0)
          :v{vv}, s{ss}, curr{pos} { }

     Slice_iter end() const { return {v,s,s.size()}; }

     Slice_iter& operator++() { ++curr; return *this; }
     Slice_iter operator++(int) { Slice_iter t = *this; ++curr; return t; }

     T& operator[](size_t i) { return ref(i); }       // C-style subscript
     T& operator()(size_t i) { return ref(i); }       // Fortran-style subscript
     T& operator*() { return ref(curr); }             // current element

     bool operator==(const Slice_iter& q) const
     {
          return curr==q.curr && s.stride()==q.s.stride() && s.start()==q.s.start();
     }

     bool operator!=(const Slice_iter& q) const
     {
          return !(*this==q);
     }

     bool operator<(const Slice_iter& q) const
     {
          return curr<q.curr && s.stride()==q.s.stride() && s.start()==q.s.start(); 
     }
};
Since a slice has a size, we could even provide range checking. Here, I have taken advantage of slice::size() to provide an end() operation to provide an iterator for the one-past-the-end element of the slice.

Since a slice can describe either a row or a column, the Slice_iter allows us to traverse a valarray by row or by column.

40.5.5. slice_array
From a valarray and a slice, we can build something that looks and feels like a valarray but is really simply a way of referring to the subset of the array described by the slice.

slice_array<T> (§iso.26.6.5)

slice_array sa {sa2};

Copy constructor: sa refers to the same elements as sa2 does

sa2=sa

Assign the element referred to by sa[i] to each

corresponding element referred to by sa2[i]

sa=va

Assign va[i] to each corresponsing element referred to by sa[i]; va is a valarray

sa=t

Assign the scalar t to each element referred to by sa

sa@=va

sa[i]@=va[i] for each element of sa; va is a valarray

 

@ can be *, /, %, +, -,&, |, <<, or >>

A user cannot directly create a slice_array. Instead, the user subscripts a valarray to create a slice_array for a given slice. Once the slice_array is initialized, all references to it indirectly go to the valarray for which it is created. For example, we can create something that represents every second element of an array like this:

Click here to view code image

void f(valarray<double>& d)
{
     slice_array<double>& v_even = d[slice(0,d.size()/2+d.size()%2,2)];
     slice_array<double>& v_odd = d[slice(1,d.size()/2,2)];

     v_even *= v_odd;   // multiply element pairs and store results in even elements
     v_odd = 0;         // assign 0 to every odd element of d
}
A slice_array can be copied. For example:

Click here to view code image

slice_array<double> row(valarray<double>& d, int i)
{
     slice_array<double> v = d[slice(0,2,d.size()/2)];
      //...
     return d[slice(i%2,i,d.size()/2)];
}
40.5.6. Generalized Slices
A slice (§29.2.2, §40.5.4) can describe a row or a column of an n-dimensional array. However, sometimes we need to extract a subarray that is not a row or a column. For example, we might want to extract the 3-by-2 matrix from the top-left corner of a 4-by-3 matrix:


Unfortunately, these elements are not allocated in a way that can be described by a single slice:



A gslice is a “generalized slice” that contains (almost) the information from n slices:

Click here to view code image

class std::gslice {
      // instead of 1 stride and one size like slice, gslice holds n strides and n sizes
public:
     gslice();
     gslice(size_t sz, const valarray<size_t>& lengths, const valarray<size_t>& strides);

     size_t start() const;                // index of first element
     valarray<size_t> size() const;       // number of elements in dimension
     valarray<size_t> stride() const;     // stride for index[0], index[1], ...
};
The extra values allow a gslice to specify a mapping between n integers and an index to be used to address elements of an array. For example, we can describe the layout of the 3-by-2 matrix by a pair of (length,stride) pairs:

Click here to view code image

size_t gslice_index(const gslice& s, size_t i, size_t j)    // map (i,j) to their corresponding index
{
     return s.start()+i*s.stride()[0]+j*s.stride()[1];
}
valarray<size_t> lengths {2,3}; //2 elements in the first dimension
                                  //3 elements in the second dimension
valarray<size_t> strides {3,1};   //3 is the stride for the first index
                                  //1 is the stride for the second index

void f()
{
     gslice s(0,lengths,strides);

     for (int i=0; i<3; ++i)        // for each row
           for (int j=0; j<2; ++j)  // for each element in row
                 cout << "(" << i << "," << j << ")–>" << gslice_index(s,i,j) << "; ";  // print mapping
}
This prints:

(0,0)–>0; (0,1)–>1; (1,0)–>3; (1,1)–>4; (2,0)–>6; (2,1)–>7
In this way, a gslice with two (length,stride) pairs describes a subarray of a two-dimensional array, a gslice with three (length,stride) pairs describes a subarray of a three-dimensional array, etc. Using a gslice as the index of a valarray yields a gslice_array consisting of the elements described by the gslice. For example:

Click here to view code image

void f(valarray<float>& v)
{
     gslice m(0,lengths,strides);
     v[m] = 0;                     // assign 0 to v[0],v[1],v[3],v[4],v[6],v[7]
}
The gslice_array offers the same set of members as slice_array (§40.5.5). A gslice_array is the result of using a gslice as the subscript of a valarray (§40.5.2).

40.6. Generalized Numerical Algorithms
In <numeric>, the standard library provides a few generalized numeric algorithms in the style of the non-numeric algorithms from <algorithm> (Chapter 32). These algorithms provide general versions of common operations on sequences of numerical values:

Numerical Algorithms (§iso.26.7) (continues)

These algorithms take input iterators

x=accumulate(b,e,i)

x is the sum of i and the elements of [b:e)

x=accumulate(b,e,i,f)

accumulate using f instead of +

x=inner_product(b,e,b2,i)

x is the inner product of [b:e) and [b2:b2+(e-b)),

that is, the sum of i and (*p1)*(*p2) for each pi in [b:e)

and the corresponding p2 in [b2:b2+(e-b))

x=inner_product(b,e,b2,i,f,f2)

inner_product using f and f2 instead of + and *

Numerical Algorithms (continued) (§iso.26.7)

These algorithms take input iterators

p=partial_sum(b,e,out)

Element i of [out:p) is the sum of elements [b:b+i]

p=partial_sum(b,e,out,f)

partial_sum using f instead of +

p=adjacent_difference(b,e,out)

Element i of [out:p) is *(b+i)-*(b+i-1) for i>0;

 

if e-b>0, then *out is *b

p=adjacent_difference(b,e,out,f)

adjacent_difference using f instead of -

iota(b,e,v)

For each element in [b:e) assign v++;

 

thus the sequence becomes v, v+1 , v+2, ...

These algorithms generalize common operations such as computing a sum by letting them apply to all kinds of sequences and by making the operation applied to elements of those sequences a parameter. For each algorithm, the general version is supplemented by a version applying the most common operator for that algorithm.

40.6.1. accumulate()
The simple version of accumulate() adds elements of a sequence using their + operator:

Click here to view code image

template<typename In, typename T>
T accumulate(In first, In last, T init)
{
     for (; first!=last; ++first)    // for all elements in [first:last)
            init = init + *first;    // plus
     return init;
}
It can be used like this:

Click here to view code image

void f(vector<int>& price, list<float>& incr)
{
     int i = accumulate(price.begin(),price.end(),0);    // accumulate in int
     double d = 0;
     d = accumulate(incr.begin(),incr.end(),d);          // accumulate in double

     int prod = accumulate(price.begin,price.end(),1,[](int a, int b) { return a*b; });
      //...
}
The type of the initial value passed determines the return type.

We can provide an initial value and an operation for “combining elements” as arguments to accumulate(), so accumulate() is not all about addition.

Extracting a value from a data structure is common operation for accumulate(). For example:

Click here to view code image

struct Record {
      //...
     int unit_price;
     int number_of_units;
};

long price(long val, const Record& r)
{
     return val + r.unit_price * r.number_of_units;
}

void f(const vector<Record>& v)
{
     cout << "Total value: " << accumulate(v.begin(),v.end(),0,price) << '\n';
}
Operations similar to accumulate are called reduce, reduction, and fold in some communities.

40.6.2. inner_product()
Accumulating from a sequence is very common, and accumulating from a pair of sequences is not uncommon:

Click here to view code image

template<typename In, typename In2, typename T>
T inner_product(In first, In last, In2 first2, T init)
{
     while (first != last)
          init = init + *first++ **first2++;
     return init;
}

template<typename In, typename In2, typename T, typename BinOp, typename BinOp2>
T inner_product(In first, In last, In2 first2, T init, BinOp op, BinOp2 op2)
{
     while (first != last)
          init = op(init,op2(*first++,*first2++));
     return init;
}
As usual, only the beginning of the second input sequence is passed as an argument. The second input sequence is assumed to be at least as long as the first.

The key operation in multiplying a Matrix by a valarray is an inner_product:

Click here to view code image

valarray<double> operator*(const Matrix& m, valarray<double>& v)
{
     valarray<double> res(m.dim2());

     for (size_t i=0; i<m.dim2(); i++) {
           auto& ri = m.row(i);
           res[i] = inner_product(ri,ri.end(),&v[0],double(0));
     }
     return res;
}

valarray<double> operator*(valarray<double>& v, const Matrix& m)
{
     valarray<double> res(m.dim1());

     for (size_t i=0; i<m.dim1(); i++) {
           auto& ci = m.column(i);
           res[i] = inner_product(ci,ci.end(),&v[0],double(0));
     }
     return res;
}
Some forms of inner_product are referred to as “dot product.”

40.6.3. partial_sum() and adjacent_difference()
The partial_sum() and adjacent_difference() algorithms are inverses of each other and deal with the notion of incremental change.

Given a sequence a, b, c, d, etc., adjacent_difference() produces a, b–a, c–b, d–c, etc.

Consider a vector of temperature readings. We could transform it into a vector of temperature changes like this:

Click here to view code image

vector<double> temps;

void f()
{
     adjacent_difference(temps.begin(),temps.end(),temps.begin());
}
For example, 17, 19, 20, 20, 17 turns into 17, 2, 1, 0, –3.

Conversely, partial_sum() allows us to compute the end result of a set of incremental changes:

Click here to view code image

template<typename In, typename Out, typename BinOp>
Out partial_sum(In first, In last, Out res, BinOp op)
{
     if (first==last) return res;
     *res = *first;
     T val = *first;
     while (++first != last) {
          val = op(val,*first);
          *++res = val;
     }
     return ++res;
}

template<typename In, typename Out>
Out partial_sum(In first, In last, Out res)
{
     return partial_sum(first,last,res,plus);    // use std::plus (§33.4)
}
Given a sequence a, b, c, d, etc., partial_sum() produces a, a+b, a+b+c, a+b+c+d, etc. For example:

Click here to view code image

void f()
{
     partial_sum(temps.begin(),temps.end(),temps.begin());
}
Note the way partial_sum() increments res before assigning a new value through it. This allows res to be the same sequence as the input; adjacent_difference() behaves similarly. Thus,

partial_sum(v.begin(),v.end(),v.begin());
turns the sequence a, b, c, d into a, a+b, a+b+c, a+b+c+d, and

adjacent_difference(v.begin(),v.end(),v.begin());
reproduces the original value. Thus, partial_sum() turns 17, 2, 1, 0, –3 back into 17, 19, 20, 20, 17.

For people who think of temperature differences as a boring detail of meteorology or science lab experiments, I note that analyzing changes in stock prices or sea levels involves exactly the same two operations. These operations are useful for analyzing any series of changes.

40.6.4. iota()
A call iota(b,e,n) assigns n+i to the ith element of [b:e). For example:

Click here to view code image

vector<int> v(5);
iota(v.begin(),v.end(),50);
vector<int> v2 {50,51,52,53,54};

if (v!=v2)
       error("complain to your library vendor");
The name iota is the Latin spelling of the Greek letter , which was used for that function in APL.

Do not confuse iota() with the non-standard, but not uncommon, itoa() (int-to-alpha; §12.2.4).

40.7. Random Numbers
Random numbers are essential to many applications, such as simulations, games, sampling-based algorithms, cryptography, and testing. For example, we might want to choose the TCP/IP address for a router simulation, decide whether a monster should attack or scratch its head, or generate a set of values for testing a square root function. In <random>, the standard library defines facilities for generating (pseudo-)random numbers. These random numbers are sequences of values produced according to mathematical formulas, rather than unguessable (“truly random”) numbers that could be obtained from a physical process, such as radioactive decay or solar radiation. If the implementation has such a truly random device, it will be represented as a random_device (§40.7.1).

Four kinds of entities are provided:

• A uniform random number generator is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability of being returned.

• A random number engine (an engine) is a uniform random number generator that can be created with a default state E{} or with a state determined by a seed E{s}.

• A random number engine adaptor (an adaptor) is a random number engine that takes values produced by some other random number engine and applies an algorithm to those values in order to deliver a sequence of values with different randomness properties.

• A random number distribution (a distribution) is a function object returning values that are distributed according to an associated mathematical probability density function p(z) or according to an associated discrete probability function P(zi).

For details see §iso.26.5.1.

In simpler terms, the users’ terms, a random number generator is an engine plus a distribution. The engine produces a uniformly distributed sequence of values, and the distribution bends those into the desired shape (distribution). That is, if you take lots of numbers from a random number generator and draw them, you should get a reasonably smooth graph of their distribution. For example, binding a normal_distribution to the default_random_engine gives me a random number generator that produces a normal distribution:

Click here to view code image

auto gen = bind(normal_distribution<double>{15,4.0},default_random_engine{});

for (int i=0; i<500; ++i) cout << gen();
The standard-library function bind() makes a function object that will invoke its first argument given its second argument (§33.5.1).

Using ASCII graphics (§5.6.3), I got:

Click here to view code image

3   **
4   *
5   *****
6   ****
7   ****
8   ******
9   ************
10  ***************************
11  ***************************
12  **************************************
13  **********************************************************
14  ***************************************************
15  *******************************************************
16  ********************************
17  **************************************************
18  *************************************
19  **********************************
20  ***************
21  ************
22  ************
23  *******
24  *****
25  ****
26  *
27  *
Most of the time, most programmers just need a simple uniform distribution of integers or floating-point numbers in a given range. For example:

Click here to view code image

void test()
{
     Rand_int ri {10,20};         // uniform distribution of ints in [10:20]
     Rand_double rd {0,0.5};      // uniform distribution of doubles in [0:0.5)

     for (int i=0; i<100; ++i)
           cout << ri() << ' ';
     for (int i=0; i<100; ++i)
           cout << rd() << ' ';
}
Unfortunately, Rand_int and Rand_double are not standard classes, but they are easy to build:

Click here to view code image

class Rand_int {
public:
     Rand_int(int lo, int hi) : p{lo,hi} { }    // store the parameters
     int operator()() const { return r(); }
private:
     uniform_int_distribution<>::param_type p;
     auto r = bind(uniform_int_distribution<>{p},default_random_engine{});
};
I store the parameters using the distribution’s standard param_type alias (§40.7.3) so that I can use auto to avoid having to name the result of the bind().

Just for variation, I use a different technique for Rand_double:

Click here to view code image

class Rand_double {
public:
     Rand_double(double low, double high)
         :r(bind(uniform_real_distribution<>(low,high),default_random_engine())) { }
     double operator()() { return r(); }
private:
     function<double()> r;
};
One important use of random numbers is for sampling algorithms. In such algorithms we need to choose a sample of some size from a much larger population. Here is algorithm R (the simplest algorithm) from a famous old paper [Vitter,1985]:

Click here to view code image

template<typename Iter, typename Size, typename Out, typename Gen>
Out random_sample(Iter first, Iter last, Out result, Size n, Gen&& gen)
{
     using Dist = uniform_int_distribution<Size>;
     using Param = typename Dist::param_type;

      // Fill the reservoir and advance first:
     copy(first,n,result);
     advance(first,n);

      // Sample the remaining values in [first+n:last) by selecting a random
      // number r in the range [0:k], and, if r<n, replace it.
      // k increases with each iteration, making the probability smaller.
      // For random access iterators, k = i-first (assuming we increment i and not first).

     Dist dist;
     for (Size k = n; first!=last; ++first,++k) {
           Size r = dist(gen,Param{0,k});
           if(r < n)
                  *(result + r) = *first;
   }
   return result;
}
40.7.1. Engines
A uniform random number generator is a function object that produces an approximately uniformly distributed sequence of values of its result_type:

Uniform Random Number Generators: G<T> (§iso.26.5.1.3)

G::result_type

The type of an element of the sequence

x=g()

Application operator: x is the next element of the sequence

x=G::min()

x is the smallest element that a g() can return

x=G::max()

x is the largest element that a g() can return

A random number engine is a uniform random number generator with additional properties to make it widely useful:

Random Number Engines: E<T> (§iso.26.5.1.4)

Ee{};

Default constructor

E e {e2};

Copy constructor

E e {s};

e will be in a state determined by the seed s

E e {g};

e will be in a state determined by a call of generate() for the seed sequence g

e.seed()

e will be in the default state

e.seed(s)

e will be in a state determined by the seed s

e.seed(g)

e will be in a state determined by a call of generate() for the seed sequence g

e.discard(n)

Skip the next n elements of the sequence

e==e2

Will e and e2 produce exactly the same sequences?

e!=e2

!(e==e2)

os<<e

Write a representation of e to os

is>>e

Read a representation of an engine previously written by << from is into e

A seed is a value in the range [0:232) that can be used to initialize a particular engine. A seed sequence, g, is an object that provides a function g.generate(b,e) that when called fills [b:e) with newly generated seeds (§iso.26.5.1.2).

Standard Random Number Engines (§iso.26.5.3)

default_random_engine

An alias for an engine with

 

wide applicability and low cost

linear_congruential_engine<Ul,a,c,m>

xi+1 = (axi + c)~mod~m

mersenne_twister_engine<Ul,w,n,m,r,a,u,d,s,b,t,c,l,f> subtract_with_carry_engine<UI,w,s,r>

§iso.26.5.3.2

xi+1 = (axi)~mod~b

 

where b = mr − ms + 1

 

and a = b − (b − 1)/m

The UI parameter for a standard random number engine must be an unsigned integer type. For linear_congruential_engine<UI,a,c,m>, if the modulus m is 0, the value numeric_limits<result_type>::max()+1 is used. For example, this writes out the index of the first repetition of a number:

Click here to view code image

map<int,int> m;
linear_congruential_engine<unsigned int,17,5,0> linc_eng;
for (int i=0; i<1000000; ++i)
      if (1<++m[linc_eng()]) cout << i << '\n';
I was lucky; the parameters were not too bad and I got no duplicate values. Try <unsigned int,16,5,0> instead and see the difference. Use the default_random_engine unless you have a real need and know what you are doing.

A random number engine adaptor takes a random number engine as an argument and produces a new random number engine with different randomness properties.

Standard Random Number Engine Adaptors (§iso.26.5.4)

discard_block_engine<E,p,r>

E is the engine; §iso.26.5.4.2

independent_bits_engine<E,w,UI>

Generate w bits in type UI; §iso.26.5.4.3

shuffle_order_engine<E,k>

§iso.26.5.4.4

For example:

Click here to view code image

independent_bits_engine<default_random_engine,4,unsigned int> ibe;
for (int i=0; i<100; ++i)
      cout << '0'+ibe() << ' ';
This will produce 100 numbers in the range [48:63] ([’0’:’0’+24-1)).

A few aliases are defined for useful engines:

Click here to view code image

using minstd_rand0 = linear_congruential_engine<uint_fast32_t, 16807, 0, 2147483647>;
using minstd_rand = linear_congruential_engine<uint_fast32_t, 48271, 0, 2147483647>;
using mt19937 = mersenne_twister_engine<uint_fast32_t, 32,624,397,
                       31,0x9908b0df,
                       11,0xffffffff,
                       7,0x9d2c5680,
                       15,0xefc60000,
                       18,1812433253>
using mt19937_64 = mersenne_twister_engine<uint_fast64_t, 64,312,156,
                       31,0xb5026f5aa96619e9,
                       29, 0x5555555555555555,
                       17, 0x71d67fffeda60000,
                       37, 0xfff7eee000000000,
                       43, 6364136223846793005>;
using ranlux24_base = subtract_with_carry_engine<uint_fast32_t, 24, 10, 24>;
using ranlux48_base = subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>;
using ranlux24 = discard_block_engine<ranlux24_base, 223, 23>;
using ranlux48 = discard_block_engine<ranlux48_base, 389, 11>;
using knuth_b = shuffle_order_engine<minstd_rand0,256>;
40.7.2. Random Device
If an implementation is able to offer a truly random number generator, that source of random numbers is presented as a uniform random number generator called random_device:

random_device (§iso.26.5.6)

random_device rd {s};

The string s identifies a source of random numbers;

implementation-defined; explicit

d=rd.entropy()

d is a double; d==0.0 for a pseudo-random number generator

Think of s as the name of a random number source, such as a Geiger counter, a Web service, or a file/device containing the record of a truly random source. The entropy() is defined as

�
(
�
0
,
...
,
�
�
−
1
)
=
−
Σ
�
=
0
�
−
1
�
�
 
log
 
�
�
for a device with n states whose respective probabilities are P0,..., Pn–1. The entropy is an estimate of the randomness, the degree of unpredictability, of the generated numbers. In contrast to thermodynamics, high entropy is good for random numbers because that means that it is hard to guess subsequent numbers. The formula reflects the result of repeatedly throwing a perfect n-sided die.

The random_device is intended to be useful for cryptograpic applications, but it would be against all rules of that kind of application to trust an implementation of random_device without first studying it closely.

40.7.3. Distributions
A random number distribution is a function object that, when called with a random number generator argument, produces a sequence of values of its result_type:

Random Number Distribution D (§iso.26.5.1.6) (continues)

D::result_type

The type of an element of D

D::param_type

The type of the set of arguments needed to construct a D

Dd{};

Default constructor

D d {p};

Construct from param_type p

Random Number Distribution D (continued) (§iso.26.5.1.6)

d.reset()

Reset to default state

p=d.param()

p is d’s parameters of param_type

d.param(p)

Reset to the state determined by param_type p

x=d(g)

x is a value produced by d given the generator g

x=d(g,p)

x is a value produced by d given the generator g and the parameters p

x=d.min()

x is the smallest value that d can return

x=d.max()

x is the largest value that d can return

d==d2

Will d and d2 produce identical sequences of elements?

d!=d2

!(d==d2)

os<<d

Write d’s state to os so that it can be read back by >>

is>>d

Read a state previously written by << from is into d

In the following tables, a template argument R means a real is required in the mathematical formula and double is the default. An I means that an integer is required and int is the default.

Uniform Distributions (§iso.26.5.8.2)

Distribution

Precon

dition Defaults

Result

uniform_int_distribution<I>(a,b)

a ≤ b

(0,max)

[a:b]

 

P(i\a, b) = 1/(b − a + 1)

 

uniform_real_distribution<R>(a,b)

a ≤ b

(0.0,1.0)

[a:b)

 

p(x\a,b) = 1/(b − a)

The precondition field specifies requirements on the distribution arguments. For example:

Click here to view code image

uniform_int_distribution<int> uid1 {1,100};   // OK
uniform_int_distribution<int> uid2 {100,1};   // error: a>b
The default field specifies default arguments. For example:

Click here to view code image

uniform_real_distribution<double> urd1 {};        // use a==0.0 and b==1.0
uniform_real_distribution<double> urd2 {10,20};   // use a==10.0 and b==20.0
uniform_real_distribution<> urd3 {};              // use double and a==0.0 and b==1.0
The result field specifies the range of the results. For example:

uniform_int_distribution<> uid3 {0,5};
default_random_engine e;
for (int i=0; i<20; ++i)
      cout << uid3(e) << ' ';
The range for uniform_int_distribution is closed, and we see the six possible values:

2 0 2 5 4 1 5 5 0 1 1 5 0 0 5 0 3 4 1 4
For uniform_real_distribution, as for all other distributions with floating-point results, the range is half-open.

Bernoulli distributions reflect sequences of tosses of coins with varying degrees of loading:

Bernoulli Distributions (§iso.26.5.8.3)

Distribution

Precondition

Defaults

Result

bernoulli_distribution(p)

0 ≤ = p ≤ 1

(0.5)

{true,false}

 

binomial_distribution<I>(t,p)

0 ≤ p ≤ 1 and 0 ≤ t

(1,0.5)

[0:∞)

 

�
(
�
\
�
,
�
)
=
(
�
�
�
�
(
1
−
�
)
�
−
�

geometric_distribution<I>(p)

0 < p < 1

(0.5)

[0:∞)

 

P(i\p) = p(1 − p)i

 

negative_binomial_distribution<I>(k,p)

0 < p ≤ 1 and 0 < k

(1,0.5)

[0:∞)

 

�
(
�
\
�
,
�
)
=
(
�
�
�
�
+
�
−
1
(
1
−
�
)
�

Poisson distributions express the probability of a given number of events occurring in a fixed interval of time and/or space:

Poisson Distributions (§iso.26.5.8.4)

Distribution

Precondition

Defaults

Result

poisson_distribution<I>(m)

0 < m

(1.0)

[0:∞)

 

�
(
�
|
�
)
=
�
−
�
�
�
�
!

exponential_distribution<R>(lambda)

0 < lambda

(1.0)

(0:∞)

 

p(x|λ) = λe−λx

gamma_distribution<R>(alpha,beta)

0 < α and 0 < β

(1.0,1.0)

(0:∞)

 

�
(
�
|
�
,
�
)
=
�
−
�
/
�
�
�
Γ
(
�
)
�
�
−
1

weibull_distribution<R>(a,b)

0 < a and 0 < b

(1.0,1.0)

[0:∞)

 

�
(
�
|
�
,
�
)
=
�
�
(
�
�
)
�
−
1
 exp
(
−
(
�
�
)
�
)

extreme_value_distribution<R>(a,b)

0 < b

(0.0,1.0)

R

 

�
(
�
|
�
,
�
)
=
1
�
exp
(
−
�
−
�
�
−
exp
(
�
−
�
�
)
)

Normal distributions map real values into real values. The simplest is the famous “bell curve” that distributes values symmetrically around a peak (mean) with the distance of elements from the mean being controlled by a standard deviation parameter:

Normal Distributions (§iso.26.5.8.5)

Distribution

Precondition

Defaults

Result

normal_distribution<R>(m,s)

0 < s

(0.0,1.0)

R

 

�
(
�
|
�
,
�
)
=
1
�
2
�
exp
(
−
(
�
−
�
)
2
2
�
2
)

lognormal_distribution<R>(m,s)

0 < s

(0.0,1.0)

>0

 

�
(
�
|
�
,
�
)
=
1
sx
2
�
exp
(
−
(
ln
 
�
−
�
)
2
2
�
2
)

chi_squared_distribution<R>(n)

0 < n

(1)

>0

 

�
(
�
|
�
)
=
�
(
�
/
2
)
−
1
�
−
�
/
2
Γ
(
�
/
2
)
2
�
/
2

cauchy_distribution<R>(a,b)

0 < b

(0.0,1.0)

R

 

�
(
�
|
�
,
�
)
=
(
�
�
∼
(
1
+
(
�
−
�
�
)
2
)
)
−
1

fisher_f_distribution<R>(m,n)

0 < m and 0 < n

(1,1)

>=0

 

�
(
�
|
�
,
�
)
=
Γ
(
(
�
+
�
)
/
2
)
Γ
(
�
/
2
)
Γ
(
�
/
2
)
(
�
�
)
�
/
2
�
(
�
/
2
)
−
1
(
1
+
�
�
�
)
−
(
�
+
�
)
/
2

student_t_distribution<R>(n)

0 < n

(1)

R

 

�
(
�
|
�
)
=
1
nπ
Γ
(
(
�
+
1
)
/
2
)
Γ
(
�
/
2
)
(
1
+
�
2
�
)
−
(
�
+
1
)
/
2

To get a feeling for these distributions, look at graphical representations for a variety of parameters. Such representations are easily generated and even more easily found on the Web.

Sampling distributions map integers into a specific range according to their probability density function P:

Sampling Distributions (§iso.26.5.8.6) (continues)

Distribution

Precondition

Defaults

Result

discrete_distribution<I>{b,e}

0<=b[i]

none

[0:e-b)

 

P(i|p0, ... pn−1) = pi

The sequence [b:e) provides weights wi so

pi = wi/S and 0 < S = w0 + ... + wn−1

where n = e-b

Sampling Distributions (continued) (§iso.26.5.8.6)

Distribution

Precondition

Defaults

Result

discrete_distribution<I>(lst)

discrete_distribution<I>(lst.begin(),lst.end())

 

discrete_distribution<I>(n,min,max,f)

discrete_distribution<I>(b,e)

where the ith element of [b:e) is obtained by

f(min+i*(max-min)/n +(max-min)/(2*n))

piecewise_constant_distribution<R>{b,e,b2}

b[i]<b[i+1]

none

[*b:*(e-1))

 

P(x|b0, ... , bn, ρ0 ... ρn)

=
�
�
�
�
�
(
�
�
+
1
−
�
�
)

[b:e) are the interval boundaries

[b2:b2+(e-b)) are the weights

piecewise_linear_distribution<R>{b,e,b2}

b[i]<b[i+1]

none

[*b:*(e-1))

 

P(x|b0, ... bn, ρ0 ... ρn)

=
�
�
�
�
+
1
−
�
�
�
+
1
−
�
�
+
�
�
+
1
�
−
�
�
�
�
+
1
−
�
�

�
�
=
�
�
/
�
 where
 S
=
1
2
Σ
�
=
0
�
−
1
(
�
�
+
�
�
+
1
)
(
�
�
+
�
−
�
�
)

[b:e) are the interval boundaries

[b2:e2+(e-b)) are the weights

40.7.4. C-Style Random Numbers
In <cstdlib> and <stdlib.h>, the standard library provides a simple basis for the generation of random numbers:

Click here to view code image

#define RAND_MAX implementation_defined /* large positive integer */

int rand();                   // pseudo-random number between 0 and RAND_MAX
void srand(unsigned int i);   // seed random number generator by i
Producing a good random number generator isn’t easy, and unfortunately not all systems deliver a good rand(). In particular, the low-order bits of a random number are often suspect, so rand()%n is not a good portable way of generating a random number between 0 and n–1. Often, int((double(rand())/RAND_MAX)*n) gives acceptable results. However, for serious applications, generators based on uniform_int_distribution (§40.7.3) will give more reliable results.

A call srand(s) starts a new sequence of random numbers from the seed, s, given as argument. For debugging, it is often important that a sequence of random numbers from a given seed be repeatable. However, we often want to start each real run with a new seed. In fact, to make games unpredictable, it is often useful to pick a seed from the environment of a program. For such programs, some bits from a real-time clock often make a good seed.

40.8. Advice
[1] Numerical problems are often subtle. If you are not 100% certain about the mathematical aspects of a numerical problem, either take expert advice, experiment, or do both; §29.1.

[2] Use variants of numeric types that are appropriate for their use; §40.2.

[3] Use numeric_limits to check that the numeric types are adequate for their use; §40.2.

[4] Specialize numeric_limits for a user-defined numeric type; §40.2.

[5] Prefer numeric_limits over limit macros; §40.2.1.

[6] Use std::complex for complex arithmetic; §40.4.

[7] Use {} initialization to protect against narrowing; §40.4.

[8] Use valarray for numeric computation when run-time efficiency is more important than flexibility with respect to operations and element types; §40.5.

[9] Express operations on part of an array in terms of slices rather than loops; §40.5.5.

[10] Slices is a generally useful abstraction for access of compact data; §40.5.4, §40.5.6.

[11] Consider accumulate(), inner_product(), partial_sum(), and adjacent_difference() before you write a loop to compute a value from a sequence; §40.6.

[12] Bind an engine to a distribution to get a random number generator; §40.7.

[13] Be careful that your random numbers are sufficiently random; §40.7.1.

[14] If you need genuinely random numbers (not just a pseudo-random sequence), use random_device; §40.7.2.

[15] Prefer a random number class for a particular distribution over direct use of rand(); §40.7.4.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


40. Numerics
41. Concurrency
42. Threads and Tasks
47h 26m remaining
41. Concurrency
Keep it simple:

as simple as possible,

but no simpler.

– A. Einstein

• Introduction

• Memory Model

Memory Location; Instruction Reordering; Memory Order; Data Races

• Atomics

atomic Types; Flags and Fences

• volatile

• Advice

41.1. Introduction
Concurrency – the execution of several tasks simultaneously – is widely used to improve throughput (by using several processors for a single computation) or to improve responsiveness (by allowing one part of a program to progress while another is waiting for a response).

The C++ standard support for concurrency is introduced in a tutorial manner in §5.3. This chapter and the next provide a more detailed and systematic view.

We call an activity potentially executed concurrently with other activities a task. A thread is the system-level representation of a computer’s facilities for executing a task. A standard-library thread (§42.2) can execute a task. A thread may share an address space with other threads. That is, all threads in a single address space can access the same memory locations. One of the central challenges of the programmer of a concurrent system is to make sure that threads access memory in a sensible manner.

The standard library’s support for concurrency includes:

• A memory model: a set of guarantees for concurrent access to memory (§41.2) that basically ensures that simple and ordinary access works as one would naively expect

• Support for programming without locks: fine-grained low-level mechanisms for avoiding data races (§41.3)

• A thread library: a set of components supporting traditional threads-and-locks-style system-level concurrent programming, such as thread, condition_variable, and mutex (§42.2)

• A task support library: a few facilities supporting task-level concurrent programming: future, promise, packaged_task, and async() (§42.4)

These topics are ordered from the most fundamental and low-level to the highest-level. The memory model is common to all programming. For programmer productivity and error minimization, work at the highest feasible level. For example, prefer a future over a mutex for exchanging information and a mutex over an atomic for anything but simple counters and the like. Leave the complexities to standard-library implementers whenever feasible.

In the context of the C++ standard library, a lock is a mutex (a mutual exclusion variable) and any abstraction built upon a mutex to provide mutually exclusive access to a resource or to synchronize the progress of several concurrent tasks.

The topic of processes, that is, threads of execution in their own address spaces and communicating through inter-process communication mechanisms [Tanenbaum,2007], is not addressed in this book. I suspect that after reading about the problems with and techniques for managing shared data, you may become sympathetic to my view that explicitly shared data is best avoided. Naturally, communication implies some form of sharing, but that sharing most often need not be directly managed by the application programmer.

Please also note that as long as you don’t pass pointers to your local data to other threads, your local data is free of the problems mentioned here. This is yet another reason to avoid global data.

This chapter is not a comprehensive guide to concurrent programming or even a complete explanation of the C++ standard-library facilities for concurrent programming. It provides:

• A basic description of the problems facing a programmer who has to deal with concurrency at the system level

• A fairly detailed overview of the concurrency facilities provided by the standard

• An introduction to the basic uses of the standard-library concurrency features at the threads-and-locks level and above

It does not:

• Go into details of the relaxed memory models or lock-free programming

• Teach advanced concurrent programming and design techniques

Concurrent and parallel programming have been popular topics of research and widely used for more than 40 years, so there is an extensive specialized literature (for example, for C++-based concurrency see [Wilson,1996]). In particular, just about any presentation of POSIX threads can be used as a source of examples that can be easily improved by using the standard-library facilities described here.

In contrast to the C-style POSIX facilities and to many older C++ thread-support libraries, the standard-library thread support is type-safe. There is no longer any reason to mess around with macros or void**s to pass information among threads. Similarly, we can define tasks as function objects (e.g., lambdas) and pass them to threads without using casts or worrying about type violations. Furthermore, there is no reason to invent elaborate conventions for reporting errors from one thread to another; futures (§5.3.5.1, §42.4.4) can transmit exceptions. Given that concurrent software is often complex and that code running in different threads is often separately developed, I consider type safety and a standard (preferably exception-based) error-handling strategy even more important than for single-threaded software. The standard-library thread support also greatly simplifies notation.

41.2. Memory Model
The C++ concurrency mechanisms are mostly supplied as standard-library components. These components rely on a set of language guarantees known as the memory model. A memory model is the result of discussions between machine architects and compiler writers about how best to represent computer hardware. The memory model, as specified in the ISO C++ standard, represents a contract between the implementers and the programmers to ensure that most programmers do not have to think about the details of modern computer hardware.

To understand the problems involved, keep one simple fact in mind: operations on an object in memory are never directly performed on the object in memory. Instead, the object is loaded into a processor register, modified there, and then written back. Worse still, an object is typically first loaded from the main memory into a cache memory and from there to a register. For example, consider incrementing a simple integer x:

 // add one to x:
     load x into cache element Cx
     load Cx into register Rx
     Rx=Rx+1;
     store Rx back into Cx
     store Cx back into x
Memory can be shared by several threads, and cache memory may (depending on the machine architecture) be shared among threads running on the same or different “processing units” (usually called something like processors, cores, or hyper-threads; this is an area of rapid evolution of both system facilities and terminology). This opens a host of opportunities for a simple operation (such as “add one to x”) to get corrupted. It will be obvious to machine architecture experts that I am simplifying. For the few who notice that I have not mentioned store buffers, I recommend Appendix C of [McKenney,2012].

41.2.1. Memory Location
Consider two global variables b and c:

Click here to view code image

 // thread 1:                 // thread 2:
       char c = 0;                 char b = 0;
       void f()                    void g()
       {                           {
            c = 1;                      b = 1;
            int x = c;                int y = b;
       }                           }
Now, x==1 and y==1 as anyone would expect. Why is this even worth saying? Consider what might happen if a linker allocated c and b in the same word in memory and (like most modern hardware) the machine could not load or store anything smaller than a word:


Without a well-defined and reasonable memory model, thread 1 might read the word containing b and c, change c, and write the word back into memory. At the same time, thread 2 could do the same with b. Then, whichever thread managed to read the word first and whichever thread managed to write its result back into memory last would determine the result. We might get 10, 01, or 11 (but not 00). The memory model saves us from such chaos; we get 11. The reason that 00 cannot happen is that the initializations of b and c are done (by the compiler or the linker) before either thread starts.

The C++ memory model guarantees that two threads of execution can update and access separate memory locations without interfering with each other. This is exactly what we would naively expect. It is the compiler’s job to protect us from the sometimes very strange and subtle behaviors of modern hardware. How a compiler and hardware combination achieves that is up to the compiler. We program a “machine” that is provided by a combination of hardware and very low-level (compiler-generated) software.

Bit-fields (§8.2.7) give access to parts of a word. If two threads simultaneously access two fields of the same word, all bets are off. If b and c are two fields of the same word, most hardware has no way of avoiding the problem (the race condition) from the b-and-c example without using some form of (potentially very expensive) locking. Lock and unlock operations are not a cost we could implicitly impose on bit-fields, which are commonly used in critical device drivers. Consequently, the language defines memory location as the unit of memory for which sensible behavior is guaranteed to exclude individual bit-fields.

A memory location is either an object of arithmetic type (§6.2.1), a pointer, or a maximal sequence of adjacent bit-fields all having nonzero width. For example:

Click here to view code image

struct S {
      char a;                   // location #1
      int b:5;                  // location #2
      unsigned c:11;
      unsigned :0;              // note: :0 is "special" (§8.2.7)
      unsigned d:8;             // location #3
      struct { int ee:8; } e;   // location #4
};
Here, S has exactly four separate memory locations. Don’t try to update bit-fields b and c from separate threads without explicit synchronization.

From the explanation above, you might conclude that if x and y are of the same type, x=y is guaranteed to result in x being a copy of y. This is true if and only if you don’t have a data race (§41.2.4) and if x and y are memory locations. However, if x and y are of a multiword struct they are not a single memory location, and if you have a data race, all behavior is undefined, so make sure you have proper synchronization in place if you share data (§41.3, §42.3.1).

41.2.2. Instruction Reordering
To gain performance, compilers, optimizers, and hardware reorder instructions. Consider:

Click here to view code image

 // thread 1:
      int x;
      bool x_init;

      void init()
      {
           x = initialize();  // no use of x_init in initialize()
           x_init = true;
            //...
     }
For this piece of code there is no stated reason to assign to x before assigning to x_init. The optimizer (or the hardware instruction scheduler) may decide to speed up the program by executing x_init=true first.

We probably meant for x_init to indicate whether x had been initialized by initializer() or not. However, we did not say that, so the hardware, the compiler, and the optimizer do not know that.

Add another thread to the program:

Click here to view code image

 // thread 2:
      extern int x;
      extern bool x_init;

      void f2()
      {
         int y;
         while (!x_init)          // if necessary, wait for initialization to complete
               this_thread::sleep_for(milliseconds{10});
         y = x;
          //...
      }
Now we have a problem: thread 2 may never wait and thus will assign an uninitialized x to y.

Even if thread 1 did not set x_init and x in “the wrong order,” we still may have a problem. In thread 2, there are no assignments to x_init, so an optimizer may decide to lift the evaluation of !x_init out of the loop, so that thread 2 either never sleeps or sleeps forever.

41.2.3. Memory Order
The time needed to get the value of a word from memory into a cache, then into a register, can be (on a processor’s time scale) very long. At best, maybe 500 instructions are executed before the value reaches the register, and another 500 instructions are executed before a new value reaches its intended location. The figure 500 is a guess that depends on machine architecture and varies over time, but for the last decades it has steadily increased. When there is no rush to load and store a particular value because the computation is optimized for throughput, the time taken can be much higher. A value can be “away from its location” for tens of thousands of instruction cycles. This is one of the facts that give modern hardware its amazing performance, but it also opens huge opportunities for confusion as different threads look at a value at different times and in different places in the memory hierarchy. For example, my simplified description mentions only a single cache; many popular architectures use a three-level cache. To illustrate, here is a diagram of a possible two-level cache architecture where each core has its own level-2 cache, a pair of cores share a level-1 cache, and all cores share the memory:



Memory ordering is the term used to describe what a programmer can assume about what a thread sees when it looks at a value from memory. The simplest memory order is called sequentially consistent. In a sequentially consistent memory model, every thread sees the effects of every operation done in the same order. The order is as if the instructions were done sequentially in a single thread. A thread can still reorder operations, but at every point where another thread might observe a variable, the set of operations performed before and (therefore) the value of the memory location observed must be well defined and the same for all threads. An operation that “observes” a value and thereby forces a consistent view of a memory location is called an atomic operation (see §41.3). A simple read or write does not impose an order.

There are many possible sequentially consistent orders for a given set of threads. Consider:

Click here to view code image

 // thread 1:                  // thread 2:
      char c = 0;                  char b = 0;
      extern char b;               extern char c;
      void f1()                    void f2()
      {                            {
           c = 1;                       b=1;
           int x = b;                   int y = c;
      }                            }
Assuming that the initialization of c and b is done statically (before any thread starts), there are three possible executions:

Click here to view code image

c = 1;      b = 1;      c = 1;
x = b;      y = c;      b = 1;
b = 1;      c = 1;      x = b;
y = c;      x = b;      y = c;
The results are 01, 10, and 11, respectively. The only result we cannot get is 00. Obviously, to get a predictable result, you need some form of synchronization of the access to the shared variables.

The sequential consistent order is just about all a programmer can effectively reason about, but on some machine architectures it imposes significant synchronization costs that can be eliminated by relaxing the rules. For example, two threads running on separate cores might decide to initiate the reads of x and y before the writes of c and b or at least before the writes had completed. That could give the nonsequentially consistent result 00. More relaxed memory models allow that.

41.2.4. Data Races
From these examples, every sensible person will conclude that we have to be very careful when programming threads. But how? First, we must avoid data races. Two threads have a data race if both can access a memory location (as defined in §41.2.1) simultaneously and at least one of their accesses is a write. Note that defining “simultaneously” precisely is not trivial. If two threads have a data race, no language guarantees hold: the behavior is undefined. This may sound drastic, but the effects of a data race can (as shown in §41.2.2) be drastic. An optimizer (or a hardware instruction scheduler) may reorder code based on assumptions about values and may execute sections of code (affecting apparently unrelated data) or not based on such assumptions.

There are many ways of avoiding data races:

• Use only a single thread. That eliminates the benefits of concurrency (unless you use processes or co-routines).

• Put a lock on every data item that might conceivably be subject to a data race. That can eliminate the benefits of concurrency almost as effectively as single threading because we easily get into a situation where all but one thread waits. Worse still, heavy use of locks increases the chances of deadlock, where a thread waits for another forever, and other locking problems.

• Try to look carefully at the code and avoid data races by selectively adding locks. This may be the currently most popular approach, but it is error-prone.

• Have a program detect all data races and either report them for the programmer to fix or automatically insert locks. Programs that can do that for programs of commercial size and complexity are not common. Programs that can do that and also guarantee the absence of deadlocks are still research projects.

• Design the code so that threads communicate only through simple put-and-get-style interfaces that do not require two threads to directly manipulate a single memory location (§5.3.5.1, §42.4).

• Use a higher-level library or tool that makes data sharing and/or concurrency implicit or sufficiently stylized to make sharing manageable. Examples include parallel implementations of algorithms in a library, directive-based tools (e.g., OpenMP), and transactional memory (often abbreviated to TM).

One way of looking at the rest of this chapter is as a bottom-up approach to arrive at support for one variant of that last style of programming. In the process, we encounter the tools needed to support just about every way of avoiding data races.

Why must programmers suffer all this complexity? An alternative would be to provide only a simple, sequentially consistent model with minimal (or no) opportunities for data races. I can offer two reasons:

[1] That is not the way the world is. The complexities of machine architectures are real, and a systems programming language, such as C++, must provide the tools for programmers to live with them. Maybe someday machine architects will deliver simpler alternatives, but for now someone must deal with a bewildering variety of low-level facilities provided by machine architects to deliver the performance that their customers demand.

[2] We (the C++ standards committee) seriously considered that. We would have liked to provide a memory model that was an improved version of what Java and C# provide. That would have saved a lot of work for the committee and for some programmers. However, this idea was effectively vetoed by the providers of operating systems and virtual machines: they insisted that they needed roughly what was then provided by the various C++ implementations – what is now provided by the C++ standard. The alternative would be for your operating systems and your virtual machines to slow down “by a factor of two or more.” I guess that programming language fanatics might have welcomed an opportunity to simplify C++ at the expense of other languages, but doing so would have been neither practical nor professional.

Fortunately, most programmers never have to work directly at the lowest level of the hardware. Most programmers do not need to understand a memory model at all and can think of reordering problems as amusing curiosities:

Write data-race-free code and don’t mess with memory order (§41.3); then the memory model guarantees that code executes as naively expected. It’s even better than sequential consistency.

I find machine architecture a fascinating topic (e.g., see [Hennesey,2011] [McKenney,2012]), but as sensible and productive programmers, we stay away from the lowest levels of software whenever we can. Leave those for the experts and enjoy the higher levels that those experts provide for you.

41.3. Atomics
Lock-free programming is a set of techniques for writing concurrent programs without using explicit locks. Instead, the programmer relies on primitive operations (directly supported by hardware) to avoid data races (§41.2.4) for small objects (typically a single word or a double word). Primitive operations that do not suffer data races, often called atomic operations, can then be used in the implementation of higher-level concurrency mechanisms, such as locks, threads, and lock-free data structures.

With the notable exception of simple atomic counters, lock-free programming is for specialists. In addition to an understanding of language mechanisms, a detailed understanding of specific machine architectures and a knowledge of somewhat specialized implementation techniques are needed. Do not try lock-free programming with only the information provided here. The primary logical advantage of lock-free techniques over lock-based techniques is that classical locking problems, such as deadlock and starvation, cannot happen. For each atomic operation, it is guaranteed that every thread will eventually (and typically soon) make progress even if other threads compete for access to an atomic object. In addition, lock-free techniques can be significantly faster than lock-based alternatives.

The standard atomic types and operations provide a portable alternative to traditional ways of expressing lock-free code. Those typically either rely on assembly code or system-specific primitives. In this sense, the standard support for atomics is another step in C and C++’s long tradition of increasing portable and relatively comprehensible support for systems programming.

A synchronization operation is something that determines when a thread sees the effects of another thread; it determines what is considered to have happened before something else. Between synchronization operations a compiler and a processor are free to reorder code as long as the semantic rules of the language are maintained. In principle, nobody is looking and all that is affected is performance. A synchronization operation on one or more memory locations is a consume operation, an acquire operation, a release operation, or both an acquire and release operation (§iso.1.10).

• For an acquire operation, other processors will see its effect before any subsequent operation’s effect.

• For a release operation, other processors will see every preceding operation’s effect before the effect of the operation itself.

• A consume operation is a weaker form of an acquire operation. For a consume operation, other processors will see its effect before any subsequent operation’s effect, except that effects that do not depend on the consume operation’s value may happen before the consume operation.

An atomic operation ensures that the state of the memory is as required by the specified memory order (§41.2.2). By default, the memory order is memory_order_seq_cst (sequentially consistent; §41.2.2). The standard memory orders are (§iso.29.3):

enum memory_order {
     memory_order_relaxed,
     memory_order_consume,
     memory_order_acquire,
     memory_order_release,
     memory_order_acq_rel,
     memory_order_seq_cst
};
The enumerations represent:

• memory_order_relaxed: No operation orders memory.

• memory_order_release, memory_order_acq_rel, and memory_order_seq_cst: A store operation performs a release operation on the affected memory location.

• memory_order_consume: A load operation performs a consume operation on the affected memory location

• memory_order_acquire, memory_order_acq_rel, and memory_order_seq_cst: a load operation performs an acquire operation on the affected memory location.

As an example, consider (§iso.29.3) using atomic loads and stores (§41.3.1) to express a relaxed memory order:

Click here to view code image

 // thread 1:
      r1 = y.load(memory_order_relaxed);
      x.store(r1,memory_order_relaxed);

 // thread 2:
      r2 = x.load(memory_order_relaxed);
      y.store(42,memory_order_relaxed);
This is allowed to produce r2==42, making it appear that time went backward in thread 2. That is, memory_order_relaxed allows this execution order:

y.store(42,memory_order_relaxed);
r1 = y.load(memory_order_relaxed);
x.store(r1,memory_order_relaxed);
r2 = x.load(memory_order_relaxed);
For explanations, see the specialist literature, for example, [Boehm,2008] and [Williams,2012].

It is entirely architecture-specific whether a given memory order makes sense. Clearly, a relaxed memory model is not something to be directly used in applications programming. Utilizing a relaxed memory model is an even more specialized task than general lock-free programming. I see it as something done by a small subset of operating system kernel, device driver, and virtual machine implementers. It can also be useful in machine-generated code (as gotos can be). If two threads really do not directly share data, some machine architectures deliver significant performance improvements through the use of a relaxed memory model at the cost of complexity in the implementation of message-passing primitives (e.g., future and promise; §42.4.4).

To allow significant optimizations for architectures with relaxed memory models, the standard provides an attribute [[carries_dependency]] for transmitting memory order dependencies across function calls (§iso.7.6.4). For example:

Click here to view code image

[[carries_dependency]] struct foo* f(int i)
{
       // let the caller use memory_order_consume for the result:
      return foo_head[i].load(memory_order_consume);
}
You can also put [[carries_dependency]] on function arguments, and there is a function kill_dependency() for stopping the propagation of such dependencies.

One of the designers of the C++ memory model, Lawrence Crowl, summarizes:

“Dependency ordering is probably the most complex concurrency feature. It’s really worth using when

• you have a machine for which it matters,

• you have a very high bandwidth read-mostly atomic data structure, and

• you’re willing to spend a couple of weeks in testing and external reviews.

This is real expert territory.”

Consider yourself warned.

41.3.1. atomic Types
An atomic type is a specialization of the atomic template. An operation on an object of an atomic type is atomic. That is, it is performed by a single thread without interference from other threads.

The operations on atomics are very simple: loads and stores, swapping, incrementing, etc., on a simple object (usually a single memory location; §41.2.1). They have to be simple or the hardware can’t handle them directly.

The following tables aim to give a first impression and an overview (only). Unless explicitly stated, the memory order is memory_order_seq_cst (sequentially consistent).

atomic<T> (§iso.29.5)

x.val represents the value of the atomic x; all operations are noexcept

atomic x;

x is uninitialized

atomic x {};

Default constructor: x.val=T{}; constexpr

atomic x {t};

Constructor: x.val=t; constexpr

atomic<T> (continued) (§iso.29.5)

x.val represents the value of the atomic x; all operations are noexcept

x=t

Assignment of T: x.val=t

t=x

Implicit conversion to T: t=x.val

x.is_lock_free()

Are operations on x lock free?

x.store(t)

x.val=t

x.store(t,order)

x.val=t; memory order is order

t=x.load()

t=x.val

t=x.load(order)

t=x.val; memory order is order

t2=x.exchange(t)

Exchange the values of x and t;

t2 is x’s previous value

t2=x.exchange(t,order)

Exchange the values of x and t;

memory order is order; t2 is x’s previous value

b=x.compare_exchange_weak(rt,t)

If b=(x.val==rt), x.val=t, otherwise rt=x.val; rt is a T&

b=x.compare_exchange_weak(rt,t,o1,o2)

b=x.compare_exchange_weak(rt,t);

use o1 as the memory order when b==true;

use o2 as the memory order when b==false

b=x.compare_exchange_weak(rt,t,order)

b=x.compare_exchange_weak(rt,t);

use order as the memory order (see §iso.29.6.1[21])

b=x.compare_exchange_strong(rt,t,o1,o2)

Like b=x.compare_exchange_weak(rt,t,o1,o2)

b=x.compare_exchange_strong(rt,t,order)

Like b=x.compare_exchange_weak(rt,t,order)

b=x.compare_exchange_strong(rt,t)

Like b=x.compare_exchange_weak(rt,t)

There are no copy or move operations for atomics. The assignment operator and constructor take values of the contained type T and access the contained value.

A default atomic (without an explicit {}) is uninitialized to allow the C standard library to be compatible.

The is_lock_free() operation is there so that you can test if these operations are lock free or if they have been implemented using a lock. On all major implementations, is_lock_free() returns true for integral and pointer types.

The atomic facilities are designed for types that map to a simple built-in type. Expect atomic<T> to be implemented using locks if T objects are large. The template argument type T must be trivially copyable (must not have user-defined copy operations).

The initialization of an atomic variable is not an atomic operation, so an initialization may have a data race with an access from another thread (§iso.29.6.5). However, a data race with an initialization is quite hard to achieve. As ever, keep initialization of nonlocal objects simple and prefer to initialize with constant expressions (you can’t have a data race before the program starts).

A simple atomic variable is close to ideal for a shared counter, such as a use count for a shared data structure. For example:

Click here to view code image

template<typename T>
class shared_ptr {
public:
      //...
     ~shared_ptr()
     {
        if (––**puc) delete p;
     }
private:
      T* p;                // pointer to shared object
      atomic<int>*puc;     // pointer to use count
};
Here, *puc is an atomic (allocated somewhere by a shared_ptr constructor), so that the decrement operation (––) is atomic and the new value is correctly reported in the thread destroying a shared_ptr.

The first argument of a compare-and-exchange operation (rt in the table) is a reference so that the object referred to can be updated if the operation fails to update its target (x in the table).

The difference between compare_exchange_strong() and compare_exchange_weak() is that the weak version can fail for “spurious reasons.” That is, some peculiarity of the hardware or the implementation of x.compare_exchange_weak(rt,t) may cause a failure even if x.val==rt. Allowing such failures makes compare_exchange_weak() implementable on architectures where compare_exchange_strong() would be difficult or relatively expensive.

The classic compare-and-swap loop can be written like this:

Click here to view code image

atomic<int> val = 0;
 //...
int expected = val.load();          // read current value
do {
      int next = fct(expected);     // calculate new value
} while (!val.compare_exchange_weak(expected,next));  // write next to val or to expected
The atomic val.compare_exchange_weak(expected,next) reads the current value of val and compares it to expected; if equal, it writes next to val. If some other thread has written to val since we read it in preparation to an update, we have to try again. When we try again, we use the new value of expected obtained from compare_exchange_weak(). Eventually, the expected value will be written. The value of expected is “the current value of val as seen by this thread.” So, since expected is updated to the current value each time the compare_exchange_weak() is executed, we should never get an infinite loop.

Operations like compare_exchange_strong() are widely known as compare-and-swap operations (CAS operations). There is a potentially serious problem with all CAS operations (in any language and on any machine) known as the ABA problem. Consider adding a node at the head of a very simple lock-free singly-linked list if the data value is less than the head’s data:

Click here to view code image

extern atomic<Link*> head;                // the shared head of a linked list

Link* nh = new Link(data,nullptr);        // make a link ready for insertion
Link* h = head.load();                    // read the shared head of the list
do {
     if (h–>data<data) break;             // if so, insert elsewhere
     nh–>next = h;                        // next element is the previous head
} while (!head.compare_exchange_weak(h,nh));    // write nh to head or to h
This is a simplified version of code that would insert data at the right position in an ordered linked list. I read the head, use it as the next of my new Link, and then write the pointer to my new Link to head. I do that repeatedly until no other thread has managed to change the head while I was getting nh ready.

Let us examine this code in some detail. Call the value of head that I read A. If no other thread changed the value of head before I executed my compare_exchange_weak(), it finds A in head and succeeds in replacing it with my nh. If some other thread changed the value of head to B after I read A, my compare_exchange_weak() will fail, and I’ll go around my loop to read head again.

This looks right. What could possibly go wrong? Well, after I read the value A, some other thread changed the value of head to B and recycled the Link. Then, some thread reused the node A and reinserted it at the head of the list. Now my compare_exchange_weak() finds A and does the update. However, the list had changed; the value of head went from A to B and then back to A. That change may be significant in many different ways, but in this simplified example, A–>data may have changed so that the critical data comparison may be wrong. ABA problems can be very subtle and hard to detect. There are a variety of ways of dealing with the ABA problem [Dechev,2010]. I mention it here primarily to warn about the subtleties of lock-free programming.

Integral atomic types offer atomic arithmetic and bit operations:

atomic<T> for Integral T (§iso.29.6.3)

x.val represents the value of the atomic x; all operations are noexcept

z=x.fetch_add(y)

x.val+=y; z is the previous x.val

z=x.fetch_add(y,order)

z=x.fetch_add(y); use order

z=x.fetch_sub(y)

x.val-=y; z is the previous x.val

z=x.fetch_sub(y,order)

z=x.fetch_sub(y); use order

z=x.fetch_and(y)

x.val&=y; z is the previous x.val

z=x.fetch_and(y,order)

z=x.fetch_and(y); use order

z=x.fetch_or(y)

x.vall=y; z is the previous x.val

z=x.fetch_or(y,order)

z=x.fetch_or(y); use order

z=x.fetch_xor(y)

x.val=y; z is the previous x.val

z=x.fetch_xor(y,order)

z=x.fetch_xor(y); use order

++x

++x.val; return x.val

x++

x.val++; return previous x.val

-- x

--x.val; return x.val

x--

x.val-- ; return previous x.val

x+=y

x.val+=y; return x.val

x-=y

x.val-=y; return x.val

x&=y

x.val&=y; return x.val

x|=y

x.val|=y; return x.val

x^=y

x.val^=y; return x.val

Consider the popular double-checked locking idiom. The basic idea is that if initializing some x must be done under a lock, you may not want to incur the cost of acquiring that lock every time you access x to see if the initialization has been done. Instead, you lock and initialize only if a variable x_init is false:


Click here to view code image

X x;                              // we need a lock to initialize an X
mutex lx;                         // the mutex to be used to lock x during initialization
atomic<bool> x_init {false};      // an atomic used to minimize locking

void some_code()
{
    if (!x_init) {             // proceed if x is uninitialized
          lx.lock();
          if (!x_init) {       // proceed if x is still uninitialized
                //... initialize x ...
               x_init = true;
         }
         lx.unlock();
   }
    //... use x ...
}
Had init_x not been atomic, instruction reordering could have moved the initialization of x ahead of the apparently unrelated test of init_x (see §41.2.2). Making init_x atomic prevents that.

The !x_init relies on the implicit conversion from an atomic<T> to a T.

This code can be simplified further by using RAII (§42.3.1.4).

The double-checked locking idiom is represented in the standard library by once_flag and call_once() (§42.3.3), so you don’t have to write such code directly.

The standard library also supports atomic pointers:

atomic<T*> for Pointers (§iso.29.6.4)

x.val represents the value of the atomic x; all operations are noexcept

z=x.fetch_add(y)

x.val+=y; z is the previous x.val

z=x.fetch_add(y,order)

z=x.fetch_add(y); use order

z=x.fetch_sub(y)

x.val-=y; z is the previous x.val

z=x.fetch_sub(y,order)

z=x.fetch_sub(y); use order

++x

++x.val; return x.val

x++

x.val++; return previous x.val

—x

--x.val; return x.val

x—

x.val--; return previous x.val

x+=y

x.val+=y; return x.val

x-=y

x.val-=y; return x.val

To allow the C standard library to be compatible, the atomic member function types have freestanding equivalents:

atomic_* operations (§iso.29.6.5) (continues)

All operations are noexcept

atomic_is_lock_free(p)

Are objects of *p’s type atomic?

atomic_init(p,v)

Initialize *p with v

atomic_* operations (continued) (§iso.29.6.5)

All operations are noexcept

atomic_store(p,v)

Store v in *p

x=atomic_load(p)

Load *p into x

b=atomic_compare_exchange_weak(p,q,v)

Compare and exchange *p and *q; b=(*q==v)

 

 

... about 70 more functions ...

 

41.3.2. Flags and Fences
In addition to the support for atomic types, the standard library offers two lower-level synchronization facilities: atomic flags and fences. The primary use of these is to implement the lowest-level atomic facilities, such as spinlocks and the atomic types. They are the only lock-free mechanisms that are guaranteed to be supported on every implementation (through all major platforms support atomic types).

Essentially no programmers need to use flags or fences. Those who do usually work closely with machine architects.

41.3.2.1. atomic Flags
An atomic_flag is the simplest atomic type and the only one with operations guaranteed to be atomic for every implementation. An atomic_flag represents a single bit of information. If necessary, the other atomic types can be implemented using atomic_flag.

The two possible values of an atomic_flag are called set and clear.

atomic_flag (§iso.29.7)

All operations are noexcept

atomic_flag fl;

The value of fl is undefined

atomic_flag fl {};

Default construct: the value of fl is 0

atomic_flag fl {ATOMIC_FLAG_INIT};

Initialize fl to clear

b=fl.test_and_set()

Set fl and b is fl’s old value

b=fl.test_and_set(order)

Set fl and b is fl’s old value;

use memory order order

fl.clear()

Clear fl

fl.clear(order)

Clear fl; use memory order order

b=atomic_flag_test_and_set(flp)

Set *flp; b is *flp’s old value

b=atomic_flag_test_and_set_explicit(flp,order)

Set *flp; b is *flp’s old value;

use memory order order

atomic_flag_clear(flp)

Clear *flp

atomic_flag_clear_explicit(flp,order)

Clear *flp;

use memory order order

The bool return values are true for set and false for clear.

Using {} to initialize atomic_flag seems to make sense. However, there is no guarantee that 0 represents clear. A machine where clear is 1 is rumored to exist. Clearing using ATOMIC_FLAG_INIT is the only portable and reliable way of initializing an atomic_flag. The ATOMIC_FLAG_INIT is an implementation-supplied macro.

You can think of an atomic_flag as a very simple spin lock:

Click here to view code image

class spin_mutex {
      atomic_flag flag = ATOMIC_FLAG_INIT;
public:
      void lock() { while(flag.test_and_set()); }
      void unlock() { flag.clear(); }
};
Note that spin locks can easily become very expensive.

As usual, I leave the memory orders and their proper use to the specialist literature.

41.3.2.2. Fences
A fence, also known as a memory barrier, is an operation that restricts operation reordering according to some specified memory ordering (§41.2.3). The fence operations do not do anything else. Think of them as simply slowing down a program to a safe speed, allowing the memory hierarchy to reach a reasonably well-defined state.

Fences (§iso.29.8)

All operations are noexcept

atomic_thread_fence(order)

Enforce memory order order

atomic_signal_fence(order)

Enforce memory order order

 

for a thread and a signal handler executed on that thread

Fences are used in combination with atomics (needed to observe the effects of the fences).

41.4. volatile
The volatile specifier is used to indicate that an object can be modified by something external to the thread of control. For example:

volatile const long clock_register;  // updated by the hardware clock
A volatile specifier basically tells the compiler not to optimize away apparently redundant reads and writes. For example:

auto t1 {clock_register};
 //... no use of clock_register here ...
auto t2 {clock_register};
Had clock_register not been volatile, the compiler would have been perfectly entitled to eliminate one of the reads and assume t1==t2.

Do not use volatile except in low-level code that deals directly with hardware.

Do not assume that volatile has special meaning in the memory model. It does not. It is not – as in some later languages – a synchronization mechanism. To get synchronization, use an atomic (§41.3), a mutex (§42.3.1), or a condition_variable (§42.3.4).

41.5. Advice
[1] Use concurrency to improve responsiveness or to improve throughput; §41.1.

[2] Work at the highest level of abstraction that you can afford; §41.1.

[3] Prefer packaged_task and futures over direct use of threads and mutexes; §41.1.

[4] Prefer mutexes and condition_variables over direct use of atomics except for simple counters; §41.1.

[5] Avoid explicitly shared data whenever you can; §41.1.

[6] Consider processes as an alternative to threads; §41.1.

[7] The standard-library concurrency facilities are type safe; §41.1.

[8] The memory model exists to save most programmers from having to think about the machine architecture level of computers; §41.2.

[9] The memory model makes memory appear roughly as naively expected; §41.2.

[10] Separate threads accessing separate bit-fields of a struct may interfere with each other; §41.2.

[11] Avoid data races; §41.2.4.

[12] Atomics allow for lock-free programming; §41.3.

[13] Lock-free programming can be essential for avoiding deadlock and to ensure that every thread makes progress; §41.3.

[14] Leave lock-free programming to experts; §41.3.

[15] Leave relaxed memory models to experts; §41.3.

[16] A volatile tells the compiler that the value of an object can be changed by something that is not part of the program; §41.4.

[17] A C++ volatile is not a synchronization mechanism; §41.4.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


41. Concurrency
42. Threads and Tasks
43. The C Standard Library
47h 26m remaining
42. Threads and Tasks
Keep Calm and Carry On.

– English slogan

• Introduction

• Threads

Identity; Construction; Destruction; join(); detach(); Namespace this_thread; Killing a thread; thread_local Data

• Avoiding Data Races

Mutexes; Multiple Locks; call_once(); Condition Variables

• Task-Based Concurrency

future and promise; promise; packaged_task; future; shared_future; async(); A Parallel find() Example

• Advice

42.1. Introduction
Concurrency – the execution of several tasks simultaneously – is widely used to improve throughput (by using several processors for a single computation) or to improve responsiveness (by allowing one part of a program to progress while another is waiting for a response).

The C++ standard support for concurrency is introduced in a tutorial manner in §5.3. This chapter and the previous one provide a more detailed and systematic view.

We call an activity potentially executed concurrently with other activities a task. A thread is the system-level representation of a computer’s facilities for executing a task. A thread can execute a task. A thread may share an address space with other threads. That is, all threads in a single address space can access the same memory locations. One of the central challenges of the programmer of a concurrent system is to make sure that threads access memory in a sensible manner.

42.2. Threads
A thread is an abstraction of the computer hardware’s notion of a computation. The C++ standard-library threads are intended to map one-to-one with the operating system’s threads. We use threads when several tasks in a program need to progress concurrently. On a system with several processing units (“cores”), threads allows us to use those units. All threads work in the same address space. If you want hardware protection against data races, use some notion of a process. Stacks are not shared between threads, so local variables are not subject to data races, that is, unless you incautiously pass a pointer to a local variable to another thread. In particular, beware of by-reference context bindings in lambdas (§11.4.3). Deliberate and careful sharing of stack memory is useful and common, for example, we might pass sections of a local array to a parallel sort.

If a thread cannot proceed (e.g., because it has encountered a mutex owned by another thread), it is said to be blocked or asleep.

thread (§iso.30.3.1)

id

The type of a thread identifier

native_handle_type

The type of a system’s thread handle;

implementation-defined (§iso.30.2.3)

thread t {};

Default constructor: create a thread that does not

(yet) have a task; noexcept

thread t {t2};

Move constructor; noexcept

thread t {f,args};

Constructor: execute f(args) on a new thread; explicit

t.~thread();

Destructor: if t.joinable(), then terminate();

otherwise no effect

t=move(t2)

Move assignment: if t.joinable(), then terminate(); noexcept

t.swap(t2)

Exchange the values of t and t2; noexcept

t.joinable()

Is there a thread of execution associated with t?

 

t.get_id()!=id{}?; noexcept

tjoin()

Join t with the current thread; that is,

block the current thread until t completes;

throw system_error if a deadlock is detected

(e.g., t.get_id()==this_thread::get_id());

throw system_error if t.id==id{}

t.detach()

Ensure that no system thread is represented by t;

throw system_error if t.id!=id{}

x=t.get_id()

x is the id of t; noexcept

x=t.native_handle()

x is the native handle for t (of native_handle_type)

n=hardware_concurrency()

n is the number of hardware processing

units (0 means “don’t know”); noexcept

swap(t,t2)

t.swap(t2); noexcept

A thread represents a system resource, a system thread, possibly even with dedicated hardware:


Consequently, a thread can be moved but not copied.

After being the source of a move, a thread no longer represents a thread of computation. In particular, it cannot be join()ed.

The thread::hardware_concurrency() operation reports the number of tasks that can simultaneously proceed with hardware support. The exact meaning of that is architecture-dependent, but it is usually less than the number of threads offered by the operating system (e.g., through time multiplexing or time slicing) and sometimes higher than the number of processors or “cores.” For example, my little two-core laptop reports four hardware threads (it is using what is sometimes called hyper-threading).

42.2.1. Identity
Each thread of execution has a unique identifier represented as a value of type thread::id. If a thread does not represent a thread of execution, its id is the default id{}. The id of a thread t can be obtained by a call of t.get_id().

The id of the current thread can be obtained by this_thread::get_id() (§42.2.6).

A thread can have its id be id{} if

• it has not had a task assigned,

• it has terminated,

• it has been moved from, or

• it has been detach()ed.

Every thread has an id, but a system thread may still be running even though it does not have an id (i.e., after a detach()).

A thread::id can be copied, and ids can be compared with the usual comparison operators (==, <, etc.), output using <<, and hashed with a specialization hash<thread::id> (§31.4.3.4). For example:

Click here to view code image

void print_id(thread& t)
{
     if (t.get_id()==id{})
            cout << "t not joinable\n";
     else
            cout << "t's id is " << t.get_id() << '\n';
}
Note that cout is a global shared object so that those output statements are not guaranteed to produce output characters in a recognizable sequence unless you make sure that no two threads are writing to cout at the same time (§iso.27.4.1).

42.2.2. Construction
A thread constructor takes a task to be executed and the arguments required by that task. The number and types of arguments must match what the task requires. For example:

Click here to view code image

void f0();       // no arguments
void f1(int);    // one int argument

thread t1 {f0};
thread t2 {f0,1};                   // error: too many arguments
thread t3 {f1};                     // error: too few arguments
thread t4 {f1,1};
thread t5 {f1,1,2};                 // error: too many arguments
thread t3 {f1,"I'm being silly"};   // error: wrong type of argument
After construction, a thread starts executing its task as soon as the run-time system can acquire resources for it to run. Think of that as “immediately.” There is no separate “start the thread” operation.

If you want to build a set of tasks and link them together (e.g., to communicate through message queues), you first build the tasks as function objects and then – when they are all ready to run – start threads. For example:

Click here to view code image

template<typename T>
class Sync_queue<T> {       // a queue providing put() and get() without data races (§42.3.4)
       //...
};

struct Consumer {
      Sync_queue<Message>& head;
      Consumer(Sync_queue<Message>& q) :head(q) {}
      void operator()();    // get messages from head
};

struct Producer {
      Sync_queue<Message>& tail;
      Consumer(Sync_queue<Message>& q) :tail(q) {}
      void operator()();    // put messages on tail
};

Sync_queue<Message> mq;
Consumer c {mq};                // make tasks and "wire them together"
Producer p {mq};

thread pro {p};                 // finally: start threads
thread con {c};

 //...
Trying to intersperse thread creation with the setup of connections among the tasks to be run by the threads can easily become complicated and error-prone.

The thread constructors are variadic templates (§28.6). This implies that to pass a reference to a thread constructor, we must use a reference wrapper (§33.5.1). For example:

Click here to view code image

void my_task(vector<double>& arg);

void test(vector<double>& v)
{
    thread my_thread1 {my_task,v};             // oops: pass a copy of v
    thread my_thread2 {my_task,ref(v)};        // OK: pass v by reference
    thread my_thread3 {[&v]{ my_task(v); }};   // OK: dodge the ref() problem
     //...
}
The problem is that the variadic template uses bind() or some equivalent mechanism, so that a reference is by default dereferenced and the result copied. So, if v was {1,2,3} and my_task increments elements, thread1 would never have any effect on v. Note that all three threads have a data race on v; this is an example of calling conventions, not of good concurrent programming style.

A default-constructed thread is primarily useful as the target for a move. For example:

Click here to view code image

vector<thread> worker(1000);    //1000 default threads

for (int i=0; i!=worker.size(); ++i) {
       //... compute argument for worker[i] and create worker thread tmp ...
      worker[i] = move(tmp);
}
Moving a task from one thread to another does not affect its execution. A thread move simply changes what the threads refer to.

42.2.3. Destruction
Obviously, the thread destructor destroys the thread object. To prevent a system thread from accidentally outliving its thread, the thread destructor calls terminate() to terminate the program if the thread is joinable() (that is, if get_id()!=id{}). For example:

Click here to view code image

void heartbeat()
{
     while(true){
          output(steady_clock::now());
          this_thread::sleep_for(second{1});  //§42.2.6
     }
}

void run()
{
     thread t {heartbeat};
}     // terminate because heartbeat() is still running at the end of t's scope
If you really need to have a system thread proceed beyond the lifetime of its thread see §42.2.5.

42.2.4. join()
A t.join() tells the current thread not to proceed until t completes. For example:

Click here to view code image

void tick(int n)
{
     for (int i=0; i!=n; ++i) {
           this_thread::sleep_for(second{1});  //§42.2.6
           output("Alive!");
     }
}

int main()
{
     thread timer {tick,10};
     timer.join();
}
This will output Alive! ten times at about 1-second intervals. Had the timer.join() been missing, the program would have terminated before tick() could have printed anything. The join() made the main program wait for the timer to complete.

As mentioned in §42.2.3, trying to have a thread execute past the end of its scope (or more generally, after its destructor is run) without calling detach() is considered a fatal (for the program) error. However, we can forget to join() a thread. When we view a thread as a resource, we see that we should consider RAII (§5.2, §13.3). Consider a simple test example:

Click here to view code image

void run(int i, int n)  // warning: really poor code
{
     thread t1 {f};
     thread t2;
     vector<Foo> v;
      //...
     if (i<n) {
           thread t3 {g};
            //...
           t2 = move(t3);  // move t3 to outer scope
      }
      v[i] = Foo{};     // might throw
       //...
      t1.join();
      t2.join();
}
Here, I have made several bad mistakes. In particular:

• We may never reach the two join()s at the end. In that case, the destructor for t1 will terminate the program.

• We may reach the two join()s at the end without the move t2=move(t3) having executed. In that case, t2.join() will terminate the program.

For this kind of thread use, we need a destructor that implicitly join()s. For example:

Click here to view code image

struct guarded_thread : thread {
    using thread::thread;                             //§20.3.5.1
    ~guarded_thread() { if (joinable()) join(); }
};
Unfortunately, guarded_thread is not a standard-library class, but in the best RAII tradition guarded_thread makes our code shorter and less error-prone. For example:

Click here to view code image

void run2(int i, int n)  // simple use of a guard
{
     guarded_thread t1 {f};
     guarded_thread t2;
     vector<Foo> v;
      //...
     if (i<n) {
           thread t3 {g};
            //...
           t2 = move(t3);  // move t3 to outer scope
     }
     v[i] = Foo{};   // might throw
      //...
}
But why doesn’t the thread’s destructor just join()? There is a long-standing tradition of using system threads that “live forever” or decide for themselves when to terminate. Had it worked, the timer executing tick() (§42.2.2) would have been an example of such a thread. Threads monitoring data structures provide many more examples. Such threads (and processes) are often called daemons. Another use for detached threads is to simply initiate a thread to complete a task and forget about it. Doing so leaves the “housekeeping” to the run-time system.

42.2.5. detach()
Accidentally letting a thread try to execute beyond its destructor is considered a very bad error. If you really want a system thread to outlive its thread (handle), use detach(). For example:

Click here to view code image

void run2()
{
     thread t {heartbeat};
     t.detach();          // let heartbeat run independently
}
I have a philosophical problem with detached threads. Given a choice, I would prefer to

• know exactly which threads are running,

• be able to determine if threads are making progress as expected,

• be able to check if threads that are supposed to delete themselves really do so,

• be able to know whether it is safe to use the results of a thread,

• be sure that all resources associated with a thread are properly released, and

• be sure that a thread does not try to access objects from the scope in which it was created after that scope has been destroyed.

Unless I go beyond the standard library (e.g., using native_handle() and “native” system facilities), I cannot do so for detached threads. Also, how do I debug a system where the behavior of detached threads cannot be directly observed? What happens if a detached thread holds a pointer to something in the scope in which it was created? That could lead to corrupted data, a system crash, or a security violation. Yes, obviously detached threads can be useful and debugged. After all, people have been doing it for decades. But people have been doing self-destructive things for centuries and deemed them useful. Given a choice, I prefer not to detach() threads.

Note that thread provides a move assignment and a move constructor. This allows threads to migrate out of the scope in which they were constructed and often provides an alternative to detach(). We can migrate threads to a “main module” of a program, access them through unique_ptrs or shared_ptrs, or place them in a container (e.g., vector<thread>) to avoid losing track of them. For example:

Click here to view code image

vector<thread> my_threads;     // keep otherwise detached threads here

void run()
{
     thread t {heartbeat};
     my_threads.push_back(move(t));
      //...
     my_threads.emplace_back(tick,1000);
}

void monitor()
{
    for (thread& t : my_threads)
          cout << "thread " << t.get_id() << '\n';
}
For a more realistic example, I would associate some information with each thread in my_threads. Maybe I’d even launch monitor as a task.

If you must detach() a thread, do make sure that it does not refer to variables in its scope. For example:

Click here to view code image

void home()     // don't do this
{
     int var;
     thread disaster{[&]{ this_thread::sleep_for(second{7.3});++var; }}
     disaster.detach();
}
Apart from the warning comment and the evocative name, this code looks quite innocent. It is not: the system thread invoked by disaster() will “forever” keep writing to the address where home()’s var was allocated, corrupting any data that may later be allocated there. This kind of error is extremely hard to find because it is only loosely connected to the code in which it manifests itself, and repeated runs of the program will have different results – many runs may exhibit no symptoms. Such bugs have been called Heisenbugs in honor of the discoverer of the uncertainty principle.

Note that the root problem in that example is a violation of the simple and well known rule “Don’t pass a pointer to a local object out of its scope” (§12.1.4). However, with a lambda, it is easy (and almost invisible) to create a pointer to a local variable: [&]. Fortunately, we have to say detach() to allow a thread to exit its scope; don’t do that without a very good reason, and then only after carefully considering what its task might do.

42.2.6. Namespace this_thread
Operations for the current thread are found in namespace this_thread:

Namespace this_thread (§iso.30.3.2)

x=get_id()

x is the id of the current thread; noexcept

yield()

Give the scheduler the opportunity to run another thread; noexcept

sleep_until(tp)

Put the current thread to sleep until time_point tp

sleep_for(d)

Put the current thread to sleep for duration d

To get the identity of the current thread, call this_thread::get_id(). For example:

void helper(thread& t)
{
     thread::id me {this_thread::get_id()};
      //...
     if (t.get_id()!=me) t.join();
      //...
}
Similarly, we can use this_thread::sleep_until(tp) and this_thread::sleep_for(d) to put the current thread to sleep.

The this_thread::yield() is used to give another thread a chance to proceed. The current thread is not blocked, so it will eventually be run again without any other thread having to do anything specific to wake it. Thus, yield() is primarily useful for waiting for an atomic to change state and for cooperative multi-threading. Usually, it is better to use sleep_for(n) than to just yield(). The argument to sleep_for() gives the scheduler a better chance to make rational choices about which threads to run when. Consider yield() a feature for optimization in very rare and specialized cases.

On all major implementations threads are preemptable; that is, the implementation can switch from one task to another to ensure that all threads progress at a reasonable rate. However, for historical and language technical reasons, preemption is only encouraged rather than required by the standard (§iso.1.10).

Usually, programmers should not mess with system clocks. But if a clock is reset (say, because it has drifted from the true time), a wait_until() would be affected, but not a wait_for(). The same applies to wait_until() and wait_for() for a timed_mutex (§42.3.1.3).

42.2.7. Killing a thread
I find one important operation missing from thread. There is no simple standard way of telling a running thread that I have lost interest in its task, so would it please stop running and release all its resources. For example, if I start a parallel find() (§42.4.7), I would often like to ask remaining tasks to stop once I have an answer. There are various historical and technical reasons for the lack of this operation (called kill, cancel, and interrupt in various languages and systems).

If needed, application programmers can write their own versions of this idea. For example, many tasks involve a request loop. In that case, a “kindly commit suicide” message would allow the receiving thread to release all resources and then terminate. If there is no request loop, a task could periodically examine a “needed” variable to see if results are still wanted.

So, a general cancel operation may be difficult to design and to implement on all systems, but I have never seen an application where a specific cancellation mechanism wasn’t relatively easy to implement.

42.2.8. thread_local Data
As indicated by its name, a thread_local variable is an object owned by a thread and not accessible from other threads unless its owner (incautiously) gives them a pointer to it. In that, a thread_local resembles a local variable, but a local variable has its lifetime and access limited by its scope within a function, whereas a thread_local is shared among all functions of a thread and “lives” for as long as the thread. A thread_local object can be extern.

For most uses, having objects local (on the stack) is preferable to having them shared; thread_local storage shares the logical problems of global variables. As usual, namespaces can be used to limit the problems with nonlocal data. However, on many systems, the amount of stack storage for a thread is rather limited, so thread_local storage becomes important for tasks that require large amounts of nonshared data.

A thread_local is said to have thread storage duration (§iso.3.7.2). Each thread has its own copy of its thread_local variables. A thread_local is initialized before its first use (§iso.3.2). If constructed, it will be destroyed on thread exit.

An important use of thread_local storage is for a thread to explicitly keep a cache of data for exclusive access. That can complicate the program logic, but on machines with shared caches it can sometimes deliver very significant performance advantages. Also, it can simplify and/or lower the cost of locking by transferring data only in larger batches.

In general, nonlocal memory is a problem for concurrent programming because it is often nontrivial to determine if it is shared and thus a possible source of data races. In particular, static class members can be a major problem because they are often hidden from the users of a class, so that potential data races are easily missed. Consider a Map design with a per-type default value:

Click here to view code image

template<typename K, typename V>
class Map {
public:
      Map();
       //...
      static void set_default(const K&,V&);            // set default for all Maps of type Map<K,V>
private:
      static pair<const K,V> default_value;
};
Why would a user suspect a data race on two different Map objects? Obviously, a user who spotted set_default() among the members might suspect, but set_default() is an easily overlooked minor feature (§16.2.12).

One-per-class (static) values used to be popular. They include default values, use counters, caches, free lists, answers to frequently asked questions, and many obscure uses. When used in a concurrent system, we have a classic problem:

Click here to view code image

 // somewhere in thread 1:
      Map<string,int>::set_default("Heraclides",1);

 // somewhere in thread 2:
      Map<string,int>::set_default("Zeno",1);
This is a potential data race: which thread gets to first execute set_default()?

Adding thread_local helps:

Click here to view code image

template<typename K, typename V>
class Map {
      //...
private:
     static thread_local pair<const K,V> default_value;
};
Now, there is no longer a potential data race. However, there is no longer a single default_value shared among all users either. In the example, thread 1 will never see the effect of a set_default() in thread 2. As often as not, that was not what was intended in the original code, so by adding thread_local, we simply exchanged one error for another. Consider static data members suspect (always, because you don’t know if your code might someday be executed as part of a concurrent system), and do not consider thread_local a panacea.

A namespace variable, a local static, and a class static member can be declared thread_local. As for local static variables, the construction of a thread_local local variable is protected by a first-time switch (§42.3.3). The order of construction of thread_locals is undefined, so keep the construction of different thread_locals independent of their order and use compile-time or link-time initialization whenever possible. Like static variables, thread_locals are by default initialized to zero (§6.3.5.1).

42.3. Avoiding Data Races
The best way to avoid data races is not to share data. Keep interesting data in local variables, in free store not shared with other threads, or in thread_local memory (§42.2.8). Do not pass pointers to such data to other threads. When such data needs to be processed by another thread (e.g., by a parallel sort), pass pointers to a specific section of the data and make sure not to touch that section of the data passed until after the termination of the task.

These simple rules are based on the idea of avoiding attempts to simultaneously access data, so they don’t require locking and lead to maximally efficient programs. Where they cannot be used, for example, because lots of data needs to be shared, use some form of locking:

• Mutexes: A mutex (a mutual exclusion variable) is an object used to represent the exclusive right to access some resource. To access the resource, acquire the mutex, access, and then release the mutex (§5.3.4, §42.3.1).

• Condition variables: A condition variable is a variable used by a thread to wait for an event generated by another thread or a timer (§5.3.4.1, §42.3.4).

Strictly speaking, condition variables do not prevent data races. Rather, they save us from having to introduce shared data that might become a source of data races.

42.3.1. Mutexes
A mutex is an object used to represent exclusive access to some resource. Thus, it can be used to protect against data races and to synchronize access to data shared between multiple threads.

Mutex Classes (§iso.30.4)

mutex

A nonrecursive mutex; a thread will block if it tries to acquire

a mutex that has already been acquired

recursive_mutex

A mutex that can be repeatedly acquired by a single thread

timed_mutex

A nonrecursive mutex with operations to try to acquire

the mutex for (only) a specified time

recursive_timed_mutex

A recursive timed mutex

lock_guard<M>

A guard for a mutex M

unique_lock<M>

A lock for a mutex M

The “plain” mutex is the simplest, smallest, and fastest mutex. In exchange for added functionality, recursive and timed mutexes carry a small cost, which may or may not be significant for a given application on a given machine.

Only one thread can own a mutex at any one time:

• To acquire a mutex means to gain exclusive ownership of it; an acquire operation may block the thread executing it.

• To release a mutex means relinquishing exclusive ownership; a release operation will allow another thread to eventually acquire the mutex. That is, a release operation will unblock waiting threads.

If several threads are blocked on a mutex the system scheduler could in principle select the thread to be unblocked in such a way that some unfortunate thread would never get to run. This is called starvation, and a scheduling algorithm that avoids starvation by giving each thread an equal chance to make progress is said to be fair. For example, a scheduler might always choose the thread with the highest thread::id to run next, thereby starving a thread with a low id. The standard does not guarantee fairness, but in reality schedulers are “reasonably fair.” That is, they make it extremely unlikely that a thread starves forever. For example, a scheduler may pick the next thread to run randomly among those blocked.

By itself, a mutex doesn’t do anything. Instead, we use a mutex to represent something else. We use ownership of a mutex to represent the right to manipulate a resource, such as an object, some data, or an I/O device. For example, we could define a cout_mutex to represent the right to use cout from a thread:

Click here to view code image

mutex cout_mutex;  // represent the right to use cout

template<typename Arg1, typename Arg2, typename Arg3>
void write(Arg1 a1, Arg2 a2 = {}, Arg3 a3 = {})
{
     thread::id name = this_thread::get_id();
     cout_mutex.lock();
     cout << "From thread " << name << " : " << a1 << a2 << a3;
     cout_mutex.unlock();
}
If all threads use write() we should get output from different threads properly separated. The snag is that every thread has to use a mutex as intended. The correspondence between a mutex and its resource is implicit. In the cout_mutex example, a thread using cout directly (bypassing cout_mutex) can corrupt output. The standard guarantees that the cout variable is protected against corruption, but there is no protection against output from different threads becoming intermixed.

Note that I locked the mutex only for the one statement that required the lock. To minimize contention and the chances of a thread becoming blocked, we try to minimize the time a lock is held by locking only where it is essential to do so. A section of code protected by a lock is called a critical section. To keep code fast and free of problems related to locking, we minimize the size of critical sections.

The standard-library mutexes provide exclusive ownership semantics. That is, a single thread (at a time) has exclusive access to the resource. There are other kinds of mutexes. For example, multiple-reader-single-writer mutexes are popular, but the standard library does not (yet) offer one. If you need a different kind of mutex, use one offered by a specific system or write it yourself.

42.3.1.1. mutex and recursive_mutex
Class mutex offers a simple set of operations:

mutex (§iso.30.4.1.2.1)

mutex m {};

Default constructor: m is not owned by any thread; constexpr; noexcept

m.~mutex()

Destructor: undefined behavior if owned

m.lock()

Acquire m; block until ownership is acquired

m.try_lock()

Try to acquire m; did acquisition succeed?

m.unlock()

Release m

native_handle_type

An implementation-defined system mutex type

nh=m.native_handle()

nh is the system handle for the mutex m

A mutex cannot be copied or moved. Think of a mutex as a resource, rather than a handle of a resource. In fact, a mutex is typically implemented as a handle to a system resource, but since that system resource cannot be shared, leaked, copied, or moved, it is usually a spurious complication to think of them as separate.

The basic uses of a mutex are very simple. For example:

Click here to view code image

mutex cout_mutex;  // initialized to "not owned by any thread"

void hello()
{
     cout_mutex.lock();
     cout << "Hello, ";
     cout_mutex.unlock();
}
void world()
{
     cout_mutex.lock();
     cout << "World!";
     cout_mutex.unlock();
}

int main()
{
     thread t1 {hello};
     thread t2 {world};

     t1.join();
     t2.join();
}
Given that, we will get the output

Hello, World!
or

World! Hello,
We will not get cout corrupted or some mixed-up output characters.

The try_lock() operation is used when we have some other work we might usefully do if some other thread is using a resource. As an example, consider a work generator that composes work requests for other tasks and places them on a work queue:

Click here to view code image

extern mutex wqm;
extern list<Work> wq;

void composer()
{
     list<Work> requests;

     while (true) {
          for (int i=0; i!=10; ++i) {
                Work w;
                 //... compose work request ...
                requests.push_back(w);
          }
          if (wqm.try_lock()) {
               wq.splice(requests);  // splice() requests into the list (§31.4.2)
               wqm.unlock();
          }
     }
}
When some server thread is examining wq, the composer() simply makes some more work instead of waiting.

When using locks, we have to beware of deadlock. That is, we must not wait for a lock that can never be released. The simplest form of deadlock requires only one lock and one thread. Consider a variant of the thread-safe output operation:

template<typename Arg, typename... Args>
void write(Arg a, Args tail...)
{
     cout_mutex.lock();
     cout << a;
     write(tail...);
     cout_mutex.unlock();
}
Now, if a thread calls write("Hello,","World!"), it will deadlock with itself when it tries the recursive call for the tail.

Recursive and mutually recursive calls are common enough for the standard to provide a solution. A recursive_mutex is just like a plain mutex, except that a single thread can acquire it repeatedly. For example:

Click here to view code image

recursive_mutex cout_mutex;     // changed to recursive_mutex to avoid deadlock

template<typename Arg, typename... Args>
void write(Arg a, Args tail...)
{
     cout_mutex.lock();
     cout << a;
     write(tail...);
     cout_mutex.unlock();
}
Now the recursive call of write() is correctly handled by cout_mutex.

42.3.1.2. mutex Errors
Trying to manipulate a mutex can fail. If so, the mutex operation throws a system_error. Some of the possible errors reflect conditions in the underlying system:

Mutex Error Conditions (§iso.30.4.1.2)

resource_deadlock_would_occur

A deadlock would occur

resource_unavailable_try_again

Some native handle is not available

operation_not_permitted

The thread is not allowed to perform the operation

device_or_resource_busy

Some native handle is already locked

invalid_argument

A constructor native handle argument is bad

For example:

Click here to view code image

mutex mtx;
try {
    mtx.lock();
    mtx.lock();     // try to lock a second time
}
catch (system_error& e) {
    mtx.unlock();
    cout << e.what() << '\n';
    cout << e.code() << '\n';
}
I got the output

device or resource busy
generic: 16
This looks like a good argument for using a lock_guard or a unique_lock (§42.3.1.4).

42.3.1.3. timed_mutex and recursive_timed_mutex
A simple mtx.lock() is unconditional. If we don’t want to block, we can use mtx.try_lock(), but when we fail to acquire mtx, we often want to wait for a while before trying again. The timed_mutex and recursive_timed_mutex offer support for that:

timed_mutex (§iso.30.4.1.3.1)

timed_mutex m {};

Default constructor; m is not owned; constexpr; noexcept

m. ~timed_mutex()

Destructor: undefined behavior if owned

m.lock()

Acquire m; block until ownership is acquired

m.try_lock()

Try to acquire m; did the acquisition succeed?

m.try_lock_for(d)

Try to acquire m for a maximum duration of d;

 

did the acquisition succeed?

m.try_lock_until(tp)

Try to acquire m until time_point tp at the latest;

 

did the acquisition succeed?

m.unlock()

Release m

native_handle_type

Implementation-defined system mutex type

nh=m.native_handle()

nh is the system handle for the mutex

The recursive_timed_mutex interface is identical to the timed_mutex interface (just as the recursive_mutex interface is identical to the mutex interface).

For this_thread, we can sleep_until(tp) a time_point and sleep_for(d) a duration (§42.2.6). More generally, we can m.try_lock_until(tp) or m.try_lock_for(d) for a timed_mutex m. If tp is before the current point in time or d is less than or equal to zero, the operation is equivalent to a “plain” try_lock().

As an example, consider updating an output buffer with a new image (e.g., in a video game or a visualization):

Click here to view code image

extern timed_mutex imtx;
extern Image buf;

void next()
{
    while (true) {
        Image next_image;
         //... compute ...

        if (imtx.try_lock_for(milliseconds{100})) {
              buf = next_image;
              imtx.unlock();
        }
    }
}
The assumption here is that if the image cannot be updated reasonably fast (here, in 100 milliseconds), the user would prefer a newer version of the image. Further, it is assumed that missing an image in a sequence of updated images will rarely be noticed, so that a more complicated solution is not needed.

42.3.1.4. lock_guard and unique_lock
A lock is a resource, so we must not forget to release it. That is, each m.lock() operation must be matched by an m.unlock() operation. The usual opportunities for mistakes exist; for example:

Click here to view code image

void use(mutex& mtx, Vector<string>& vs, int i)
{
     mtx.lock();
     if (i<0) return;
     string s = vs[i];
      //...
     mtx.unlock();
}
The mtx.unlock() is there, but if i<0 or if i is out of vs’s range and vs is range checked, the thread of execution never gets to the mtx.unlock() and mtx may be locked forever.

The standard library provides two RAII classes, lock_guard and unique_lock, to handle such problems.

The “plain” lock_guard is the simplest, smallest, and fastest guard. In exchange for added functionality, unique_lock carries a small cost, which may or may not be significant for a given application on a given machine.

lock_guard<M> (§iso.30.4.2.1)

m is a lockable object

lock guard lck {m};

lck acquires m; explicit

lock_guard lck {m,adopt_lock};

lck holds m; assume that the current thread

 

has already acquired m; noexcept

lck.~lock_guard()

Destructor: calls unlock() for the mutex held

For example:

Click here to view code image

void use(mutex& mtx, vector<string>& vs, int i)
{
     lock_guard<mutex> g {mtx};
     if (i<0) return;
     string s = vs[i];
      //...
}
The lock_guard’s destructor does the necessary unlock() on its argument.

As usual, we should only hold a lock for the minimal amount of time, so a lock_guard should not become an excuse for holding a lock until the end of a large scope if we only need the lock for a small section of the scope. Obviously, the checking of i does not require locking, so we could do that before acquiring the lock:

Click here to view code image

void use(mutex& mtx, vector<string>& vs, int i)
{
     if (i<0) return;
     lock_guard<mutex> g {mtx};
     string s = vs[i];
      //...
}
Furthermore, imagine that we only needed the lock for the read of v[i]. Then, we could put the lock_guard in a small scope:

Click here to view code image

void use(mutex& mtx, vector<string>& vs, int i)
{
     if (i<0) return;
     string s;
     {
          lock_guard<mutex> g {mtx};
          s = vs[i];
     }
      //...
}
Is such complication of the code worthwhile? Without looking at the code “hidden in the ...” we cannot tell, but we should definitely not use a lock_guard just out of unwillingness to consider where locking is needed. Minimizing the size of critical sections is in general a useful thing to do. If nothing else, it forces us to think about exactly where a lock is needed and why.

So, a lock_guard (and also a unique_lock) is a resource handle (“a guard”) for an object that you can lock to acquire ownership and unlock to release.


Such an object is called a lockable object. The obvious lockable object is of a standard-library mutex type, but users can define their own.

A lock_guard is a very simple class with no interesting operations. All it does is RAII for a mutex. To get an object that provides RAII and operations on a contained mutex, we use a unique_lock:

unique_lock<M> (§iso.30.4.2.2)

m is a lockable object

unique_lock lck {};

Default constructor: lck does not hold a mutex;

noexcept

unique_lock lck {m};

lck acquires m; explicit

unique_lock lck {m,defer_lock};

lck holds m but does not acquire it

unique_lock lck {m,try_to_lock};

lck holds m and does a m.try_lock(); if the try succeeds

 

lck owns m; otherwise not

unique_lock lck {m,adopt_lock};

lck holds m; assume that the current thread

has already acquired m

unique_lock lck {m,tp};

lck holds m and calls m.try_lock_until(tp);

if the try succeeds, lck owns m; otherwise not

unique_lock lck {m,d};

lck holds m and calls m.try_lock_for(d);

if the try succeeds, lck owns m; otherwise not

unique_lock lck {lck2};

Move constructor: lck holds the mutex

(if any) held by lck2; lck2 does not hold a mutex

lck.~unique_lock()

Destructor: calls unlock() for the mutex held (if any)

lck2=move(lck)

Move assignment: lck holds the mutex

(if any) held by lck2; lck2 does not hold a mutex

lck.lock()

m.lock()

lck.try_lock()

m.try_lock(); did acquisition succeed?

lck.try_lock_for(d)

m.try_lock_for(d); did acquisition succeed?

lck.try_lock_until(tp)

m.try_lock_until(tp); did acquisition succeed?

lck.unlock()

m.unlock()

lck.swap(lck2)

Exchange the lockable objects of lck and lck2;

noexcept

pm=lck.release()

lck no longer owns *pm; noexcept

lck.owns_lock()

Does lck own a lockable object? noexcept

bool b {lck};

Conversion to bool; b==lck.owns_lock();

explicit; noexcept

pm=lck.mutex()

*pm is the owned lockable object, if any;

 

otherwise pm=nullptr; noexcept

swap(lck,lck2)

lck.swap(lck2); noexcept

Obviously, the timed operations are only allowed if the contained mutex is a timed_mutex or a recursive_timed_mutex.

For example:

Click here to view code image

mutex mtx;
timed_mutex mtx2;

void use()
{
     unique_lock<mutex> lck {mtx,defer_lock}; // defer_lock is an object of type defer_lock_t
     unique_lock<timed_mutex> lck2 {mtx2,defer_lock};
 
     lck.try_lock_for(milliseconds{2});     // error: mutex does not have member try_lock_for()
 
     lck2.try_lock_for(milliseconds{2});    // OK
     lck2.try_lock_until(steady_clock::now()+milliseconds{2});
      //...
}
If you give a duration or a time_point as a second argument to a unique_lock, the constructor will execute the appropriate try operation. The owns_lock() operations allow us to check whether such an acquisition succeeded. For example:

Click here to view code image

timed_mutex mtx2;

void use2()
{
     unique_lock<timed_mutex> lck2 {mtx2,milliseconds{2}};
     if (lck2.owns_lock()) {
            // acquisition succeeded:
            //... do something ...
     }
     else {
            // timeout:
            //... do something else ...
     }
}
42.3.2. Multiple Locks
It is fairly common to want to acquire multiple resources to do some task. Unfortunately, acquiring two locks implies the opportunity of deadlock. For example:

Click here to view code image

mutex mtx1;     // protects one resource
mutex mtx2;     // protects another resource

void task(mutex& m1, mutex& m2)
{
     unique_lock<mutex> lck1 {m1};
     unique_lock<mutex> lck2 {m2};
      //... use resources ...
}
thread t1 {task,ref(mtx1),ref(mtx2)};
thread t2 {task,ref(mtx2),ref(mtx1)};
The ref() is the std::ref() reference wrapper from <functional> (§33.5.1). It is needed to pass a reference through a variadic template (the thread constructor; §42.2.2). A mutex cannot be copied or moved, so I must pass them by reference (or use a pointer).

Change the names from mtx1 and mtx2 to something that does not indicate order and separate the definitions of t1 and t2 from each other in the source text and it will no longer be obvious that there is a good chance that the program will eventually deadlock with t1 owning mtx1, t2 owning mtx2, and each trying to acquire its second mutex forever.

Locking algorithms (§iso.30.4.2)

locks is a sequence of one or more lockable objects lck1, lck2, lck3, ...

x=try_lock(locks)

Try to acquire all members of locks; the locks are acquired in order;

 

x=-1 if all locks were acquired; otherwise x=n,

 

where n is the lock that could not be acquired, and no locks are held

lock(locks)

Acquire all members of locks; do not deadlock

The actual algorithm for try_lock() is unspecified, but one possibility would be:

Click here to view code image

template <typename M1>
int try_lock(M1& mtx)      // try one lock
{
      return (mtx.try_lock()) ? -1 : 0;
}

template <typename M1, typename... Mx>
int try_lock(M1& mtx, Mx&... tail) // try N locks
{
      if (mtx.try_lock()) {
            int n = try_lock(tail...);
            if (n == -1) return -1; // all locks acquired
            mtx.unlock();           //back out
            return n+1;
      }
      return 0;                     // couldn't acquire mtx
}
Given lock(), the buggy task() can be simplified and corrected:

Click here to view code image

void task(mutex& m1, mutex& m2)
{
    unique_lock<mutex> lck1 {m1,defer_lock};
    unique_lock<mutex> lck2 {m2,defer_lock};
    lock(lck1,lck2);
     //... use resources ...
}
Note that applying lock() directly to the mutexes, lock(m1,m2), rather than to the unique_locks would have left the programmer with the obligation to explicitly release m1 and m2.

42.3.3. call_once()
We often want to initialize an object without getting into a race condition. The type once_flag and the function call_once() offer a low-level, efficient, and simple tool for that.

call_once (§iso.30.4.4)

once_flag fl {};

Default constructor: fl has not been used

call_once(fl,f,args)

Call f(args) if fl hasn’t yet been used

For example:

class X {
public:
     X();
      //...
private:
      //...
     static once_flag static_flag;
     static Y static_data_for_class_X;
     static void init();
};

X::X()
{
     call_once(static_flag,init());
}
One way to think about call_once() is as a way to simply modify preconcurrency code that relies on initialized static data.

Run-time initialization of a local static variable is implemented by call_once() or by a mechanism very similar to call_once(). Consider:

Click here to view code image

Color& default_color()     // user code
{
    static Color def { read_from_environment("background color") };
    return def;
}
This may be implemented as

Click here to view code image

Color& default_color()     // generated code
{
    static Color def;
    static_flag __def;
    call_once(__def,read_from_environment,"background color");
    return def;
}
I use the double underscore prefix (§6.3.3) to emphasize that this latter version represents compiler-generated code.

42.3.4. Condition Variables
Condition variables are used to manage communication among threads. A thread can wait (block) on a condition_variable until some event, such as reaching a specific time or another thread completing, occurs.

condition_variable (§iso.30.5)

lck must be a unique_lock<mutex>

condition_variable cv {};

Default constructor: throw a system_error

if some system resource cannot be obtained

cv.~condition_variable()

Destructor: no thread may be waiting and not notified

cv.notify_one()

Unblock one waiting thread (if any); noexcept

cv.notify_all()

Unblock all waiting threads; noexcept

cv.wait(lck)

lck must be owned by the calling thread;

atomically calls lck.unlock() and blocks;

unblocks if notified or if “spuriously” woken up;

when unblocked, calls lck.lock()

cv.wait(lck,pred)

lck must be owned by the calling thread;

 

while (!pred()) wait(lock);

x=cv.wait_until(lck,tp)

lck must be owned by the calling thread;

atomically calls lck.unlock() and blocks;

unblocks if notified or timed out at tp;

when unblocked calls lck.lock();

 

x is timeout if it timed out; otherwise x=no_timeout

b=cv.wait_until(lck,tp,pred)

while OpredO) if (wait_until(lck,tp)==cv_status::timeout) {}; b=pred();

x=cv.wait_for(lck,d)

x=cv.wait_until(lck,steady_clock::nowO+d)

b=cv.wait_for(lck,d,pred)

b=cv.wait_until(lck,steady_clock::now()+d,move(pred))

native_handle_type

See §iso.30.2.3

nh=cv.native_handle()

nh is the system handle for cv

A condition_variable may (or may not) rely on system resources, so a constructor may fail for lack of such a resource. However, like a mutex, a condition_variable cannot be copied or moved, so it is best to think of a condition_variable as a resource in itself, rather than as a handle.

When a condition_variable is destroyed, all waiting threads (if any) must be notified (i.e., told to wake up) or they may wait forever.

The status returned by wait_until() and wait_for() is defined as:

enum class cv_status { no_timeout, timeout };
A condition_variable’s unique_lock is used by the wait functions to prevent wake-ups being lost due to contention on the unique_lock’s list of waiting threads.

The “plain” wait(lck) is a low-level operation that should be used with extra care and usually in the implementation of some higher-level abstraction. It can wake up “spuriously.” That is, the system may decide to resume wait()’s thread even though no other thread has notified it! Apparently, allowing spurious wake-up simplifies implementation of condition_variables on some systems. Always use “plain” wait() in a loop. For example:

while (queue.empty()) wait(queue_lck);
An additional reason for this loop is that some thread may have “snuck up” and invalidated the condition (here, queue.empty()) before the thread calling the unconditional wait() got to run. Such a loop basically is the implementation of a wait with a condition, so prefer those over the unconditional wait().

A thread can wait for an amount of time:

Click here to view code image

void simple_timer(int delay)
{
     condition_variable timer;
     mutex mtx;                                  // mutex protecting timer
     auto t0 = steady_clock::now();
     unique_lock<mutex> lck(mtx);                // acquire mtx
     timer.wait_for(lck,milliseconds{delay});    // release and reacquire mtx
     auto t1 = steady_clock::now();
     cout << duration_cast<milliseconds>(t1–t0).count() << "milliseconds passed\n";
}  // implicitly release mtx
This basically shows the implementation of this_thread::wait_for(). The mutex protects wait_for() against data races. The wait_for() releases its mutex as it goes to sleep and reacquires it as its thread is unblocked. Finally, lck (implicitly) releases the mutex at the end of its scope.

Another simple use of a condition_variable is to control the flow of messages from a producer to a consumer:

template<typename T>
class Sync_queue {
public:
     void put(const T& val);
     void put(T&& val);
     void get(T& val);
private:
     mutex mtx;
     condition_variable cond;
     list<T> q;
};
The idea is that put() and get() will not get in each other’s way. A thread that does a get() will sleep unless there is a value on the queue for it to get.

template<typename T>
void Sync_queue::put(const T& val)
{
     lock_guard<mutex> lck(mtx);
     q.push_back(val);
     cond.notify_one();
}
That is, a producer put() acquires the queue’s mutex, adds a value at the end of the queue, calls notify_one() to wake a possibly blocked consumer, and implicitly releases the mutex. I provided an rvalue version of put() so that we can transmit objects of types that have move, but not copy, operations, such as unique_ptr (§5.2.1, §34.3.1) and packaged_task (§42.4.3).

I used notify_one() rather than notify_all() because I only added one element and wanted to keep put() simple. The possibility of multiple consumers and the possibility of consumers falling behind the producer might make me reconsider.

The get() is a bit more complicated because it should only block its thread if the mutex precludes access or if the queue is empty:

Click here to view code image

template<typename T>
void Sync_queue::get(T& val)
{
     unique_lock<mutex> lck(mtx);
     cond.wait(lck,[this]{ return !q.empty(); });
     val=q.front();
     q.pop_front();
}
A caller of get() will remain blocked until the Sync_queue is nonempty.

I used a unique_lock rather than a plain lock_guard because the lock_guard is optimized for simplicity and does not offer the operations needed to unlock and relock the mutex.

I used [this] to enable the lambda to access the Sync_queue object (§11.4.3.3).

I return the value from get() through a reference argument, rather than as a return value, to be sure that an element type with a copy constructor that can throw will not cause trouble. That is the conventional technique (e.g., the STL stack adaptor provides pop() and the containers provide front()). Writing a general get() that directly returns a value is possible, but surprisingly tricky. For an example, see future<T>::get() (§42.4.4).

A simple producer-consumer pair can be very simple:

Sync_queue<Message> mq;

void producer()
{
     while (true) {
           Message m;
            //... fill m ...
           mq.put(m);
     }
}

void consumer()
{
     while (true) {
           Message m;
           mq.get(m);
            //... use m ...
     }
}
     thread t1 {producer};
     thread t2 {consumer};
Using a condition_variable saves a consumer the bother of explicitly dealing with the case where it runs out of work to do. Had we simply used a mutex to control access to the Sync_queue, the consumer would have had to repeatedly wake up, look for work on the queue, and decide what to do when it found the queue empty.

I copy values into and out of the list I use to hold my queue elements. A copy of an element type may throw an exception, but if it does, the Sync_queue will remain unchanged and the put() or get() simply fails.

A Sync_queue is not itself a shared data structure, so we don’t use a separate mutex for it; only the put() and get() (updating the head and the tail of the queue, which may be the same element) need to be protected against data races.

For some applications, the simple Sync_queue has a fatal flaw: What if a consumer waits forever because a producer stopped adding values? What if a consumer has other things to do so that it cannot wait for a long time? Often there are answers, but one common technique is to add a timeout to get(), that is, to specify a maximum time to wait:

void consumer()
{
     while (true) {
           Message m;
           mq.get(m,milliseconds{200});
            //... use m ...
     }
}
To make this work, we need to add a second get() to Sync_queue:

Click here to view code image

template<typename T>
void Sync_queue::get(T& val, steady_clock::duration d)
{
     unique_lock<mutex> lck(mtx);
     bool not_empty = cond.wait_for(lck,d,[this]{ return !q.empty(); });
     if (not_empty) {
           val=q.front();
           q.pop_front();
     }
     else
           throw system_error{"Sync_queue: get() timeout"};
}
When using a timeout, we need to consider what to do after the wait: did we get data or did we just time out? Actually, we don’t really care about the timeout, but only whether the predicate (expressed in the lambda) is true or not, so that is what wait_for() returns. I chose to report the failure of a get() with a timeout by throwing an exception. Had I thought that timing out would be a common and “nonexceptional” event, I would have returned a bool instead.

The roughly equivalent modification to put() would be to wait for the consumer to make inroads into a long queue, but not for too long a time:

Click here to view code image

template<typename T>
void Sync_queue::put(T val, steady_clock::duration d, int n)
{
     unique_lock<mutex> lck(mtx);
     bool not_full = cond.wait_for(lck,d,[this]{ return q.size()<n; });
     if (not_full) {
           q.push_back(val);
           cond.notify_one();
     }
     else {
           cond.notify_all();
           throw system_error{"Sync_queue: put() timeout"};
     }
}
For put(), the alternative of returning a bool to encourage the producer to always explicitly handle both cases seems more attractive than for get(). However, to avoid getting into a discussion of how best to handle overflow, I again chose to signal a failure by throwing an exception.

I chose to notify_all() if the queue was full. Maybe, some consumer needs a nudge to continue. The choice between notify_all() and notify_one() depends on the behavior of the application and is not always obvious. Notifying just one thread serializes access to the queue and could therefore minimize throughput when there are several potential consumers. On the other hand, notifying all waiting threads may wake up several threads, causing contention on the mutex and possibly having threads repeatedly waking up just to find the queue empty (emptied by other threads). I fall back on the old rule: Don’t trust your intuition; measure.

42.3.4.1. condition_variable_any
A condition_variable is optimized for unique_lock<mutex>. A condition_variable_any is functionally equivalent to a condition_variable but can use any lockable object for its operations:

condition_variable_any (§iso.30.5.2)

lck can be any lockable object with the operations required

... like condition_variable ...

42.4. Task-Based Concurrency
So far, this chapter focused on the mechanisms for running concurrent tasks: the focus was on threads, avoiding race conditions, and synchronizing threads. For many concurrent tasks, I find this focus on mechanisms distracting from the real task (sic!) of specifying concurrent tasks. This section focuses on specifying a simple kind of task: a task that does one thing given arguments and produces one result.

To support this task-based model of concurrency, the standard library offers:

Task Support (§iso.30.6.1)

packaged_task<F>

Package a callable object of type F to be run as a task

promise<T>

A type of object to which to put one result of type T

future<T>

A type of object from which to move one result of type T

shared_future<T>

A future from which to read a result of type T several times

x=async(policy,f,args)

Launch f(args) to be executed according to policy

x=async(f,args)

Launch with the default policy:

 

x=async(launch::async|launch::deferred,f,args)

The presentation of these facilities exposes many details that rarely need to bother an application writer. Please keep in mind the fundamental simplicity of the task model. Most of the more complicated details support rare uses, such as hiding uses of the messier threads-and-locks level.

The standard-library task support is just one example of what can be done to support task-based concurrency. Often, we would like to provide a lot of small tasks and let “the system” worry about how to map their execution onto hardware resources and how to keep them out of problems with data races, spurious wake-ups, excessive waits, etc.

The importance of these facilities is their simplicity to a programmer. In a sequential program, we usually write something like:

res = task(args);     // perform a task given arguments and get the result
The concurrent version becomes:

Click here to view code image

auto handle = async(task,args);     // perform a task given arguments
//    ... do something else ...
res = handle.get()                  // get the result
Sometimes, we lose sight of the value of simplicity as we consider alternatives, details, performance, and tradeoffs. By default, use the simplest technique and reserve the more complex solutions for where you know that they are really worthwhile.

42.4.1. future and promise
As mentioned in §5.3.5, communication between tasks is handled by a future/promise pair. A task puts its result into a promise, and a task that needs the result retrieves the result from the corresponding future:



The “value” in this diagram is technically known as the shared state (§iso.30.6.4). In addition to the return value or exception, it contains the information needed for two threads to safely exchange the information. At a minimum, a shared state must be able to hold:

• A value of the appropriate type or an exception. For a future “returning void” the value is nothing.

• A ready bit to indicate whether a value or exception is ready to be extracted by a future.

• The task to be executed when a get() is called for a future for a task launched by async() with the launch policy deferred (§42.4.6).

• A use count, so that the shared state can be destroyed when and only when its last potential user relinquishes access. In particular, if a stored value is of a class with a destructor, its destructor is called when the use count goes to zero.

• Some mutual exclusion data to enable unblocking of any thread that might be waiting (e.g., a condition_variable).

An implementation can take actions on a shared state:

• Construct: Possibly using a user-supplied allocator.

• Make ready: Set the “ready bit” and unblock any waiting threads.

• Release: Decrease the use count and destroy the shared state if this was the last user.

• Abandon: If it becomes impossible for a value or exception to be put into the shared state by a promise (e.g., because the promise is destroyed), a future_error exception with the error condition broken_promise is stored in the shared state and the shared state is made ready.

42.4.2. promise
A promise is the handle to a shared state (§42.4.1). It is where a task can deposit its result to be retrieved through a future (§42.4.4).

promise<T> (§iso.30.6.5) (continues)

promise pr {};

Default constructor: pr has a shared state

that is not yet ready

promise pr {allocator_arg_t,a};

Construct pr; use allocator a

to construct a shared state that is not yet ready

promise pr {pr2};

Move constructor: pr gets pr2’s state;

pr2 no longer has a shared state; noexcept

pr.~promise()

Destructor: abandon the shared state;

make the result a broken_promise exception.

pr2=move(pr)

Move assignment: pr2 gets pr’s state;

pr no longer has a shared state; noexcept

pr.swap(pr2)

Exchange the values of pr and pr2; noexcept

fu=pr.get_future()

fu is the future corresponding to pr

pr.set_value(x)

The result of the task is the value x

pr.set_value()

Set the result of the task for a void future

pr.set_exception(p)

The result of the task is the exception

pointed to by p; p is an exception_ptr

promise<T> (continued) (§iso.30.6.5)

pr.set_value_at_thread_exit(x)

The result of the task is the value x;

don’t make the result ready until thread exit

pr.set_exception_at_thread_exit(p)

The result of the task is the exception

pointed to by p; p is an exception_ptr;

don’t make the result ready until thread exit

swap(pr,pr2)

pr.swap(pr2); noexcept

There are no copy operations for a promise.

A set function throws future_error if a value or exception is already set.

It is only possible to transmit a single result value through a promise. That may seem restrictive, but remember that the value is moved into and out of the shared state, rather than copied, so that we can cheaply pass a collection of objects. For example:

promise<map<string,int>> pr;
map<string,int>> m;
 //... fill m with a million <string,int> pairs ...
pr.set_value(m);
A task may then extract that map from a corresponding future at essentially zero cost.

42.4.3. packaged_task
A packaged_task holds a task and a future/promise pair.



We pass a task (a function or a function object) that we want executed to a packaged_task. When our task executes a return x, it causes a set_value(x) on the packaged_task’s promise. Similarly, a throw x causes a set_exception(px) where px is an exception_ptr for x. Basically, the packaged_task executes its task, f(args), like this:

Click here to view code image

try {
     pr.set_value(f(args));     // assume that the promise is called pr
}
catch(...) {
     pr.set_exception(current_exception());
}
A packaged_task offers a fairly conventional set of operations:

packaged_task<R(ArgTypes...)> (§iso.30.6.9)

packaged_task pt {};

Default constructor: pt holds no task; noexcept

packaged_task pt {f};

Construct pt holding f; f is moved into pt;

use the default allocator; explicit

packaged_task pt {allocator_arg_t,a,f};

Construct pt holding f; f is moved into pt;

use allocator a; explicit

packaged_task pt {pt2};

Move constructor: pt gets pt2’s state;

after the move pt2 does not have a task; noexcept

pt=move(pt2)

Move assignment: pt gets pt2’s state;

decrease the use count for pt’s former shared state;

after the move pt2 does not have a task; noexcept

pt.~packaged_task();

Destructor: abandon the shared state

pt.swap(pt2)

Exchange the values of pt and pt2; noexcept

pt.valid()

Does pt have a shared state? It does if it has had

a task given to it and not been moved from; noexcept

fu=pt.get_future()

fu is the future for pt’s promise;

throws future_error if called twice

pt()(args)

Execute f(args);

a return x in f() does a set_value(x) to pt’s promise,

a throw x in f() does a set_exception(px)

to pt’s promise; px is an exception_ptr to x

pt.make_ready_at_exit(args)

Call f(args); don’t make

the result available until thread exit

pt.reset()

Reset to initial state; abandon the old state

swap(pt,pt2)

pt.swap(pt2)

uses_allocator<PT,A>

true_type if PT uses allocator type A

A packaged_task can be moved but not copied. A packaged_task may copy its task, and a copy of a task is assumed to yield the same result as the original. This is important because a task may be moved with its packaged_task onto the stack of a new thread.

To abandon a shared state (as is done by the destructor and the move) means making it ready. If there is no value or exception stored, a pointer to a future_error is stored (§42.4.1).

The advantage of make_ready_at_exit() is that the result is not available until destructors for thread_local variables have been executed.

There is no get_promise() operation to match get_future(). The use of the promise is completely handled by the packaged_task.

For a really simple example we don’t even need any threads. First define a simple task:

int ff(int i)
{
      if (i) return i;
      throw runtime_error("ff(0)");
}
We can now package this function into packaged_tasks and call them:

Click here to view code image

packaged_task<int(int)> pt1 {ff};            // store ff in pt1
packaged_task<int(int)> pt2 {ff};            // store ff in pt2

pt1(1);                  // let pt1 call ff(1);
pt2(0);                  // let pt2 call ff(0);
So far, nothing appears to have happened. In particular, we don’t see the exception triggered by ff(0). In fact, pt1(1) did a set_value(1) on the promise attached to pt1, and pt1(0) did a set_exception(px) on the promise attached to pt2; that px is an exception_ptr to a runtime_error("ff(0)").

Later, we can try to retrieve the results. The get_future() operation is used to get hold of the future into which the packaged thread will deposit the result of its task.

Click here to view code image

auto v1 = pt1.get_future();
auto v2 = pt2.get_future();

try {
     cout << v1.get() << '\n';  // will print
     cout << v2.get() << '\n';  // will throw
}
catch (exception& e) {
     cout << "exception: " << e.what() << '\n';
}
The output is:

1
exception: ff(0)
We could have gotten exactly the same effect by simply writing:

Click here to view code image

try {
      cout << ff(1) << '\n';  // will print
      cout << ff(0) << '\n';  // will throw
}
catch (exception& e) {
      cout << "exception: " << e.what() << '\n';
}
The point is that the packaged_task version works exactly like the version using ordinary function calls even when the calls of the task (here ff) and the calls of the get()s are in different threads. We can concentrate on specifying the tasks, rather than thinking about threads and locks.

We can move the future, the packaged_task, or both around. Eventually, the packaged_task is invoked and its task deposits its result in the future without having to know either which thread executed it or which thread will receive the result. This is simple and general.

Consider a thread that processes a series of requests. It could be a GUI thread, a thread owning access to a piece of specialized hardware, or indeed any server that serializes access to a resource through a queue. We can implement such a service as a queue of messages (§42.3.4), or we could pass tasks to be executed:

Click here to view code image

using Res = /* result type for server */;
using Args = /* argument types for server */;
using PTT = Res(Args);

Sync_queue<packaged_task<PTT>> server;

Res f(Args);                                       // function: do something
struct G {
     Res operator()(Args);                         // function object: do something
      //...
};
auto h = [=](Args a) { /* do something */ };       // lambda

packaged_task<PTT> job1(f);
packaged_task<PTT> job2(G{});
packaged_task<PTT> job3(h);

auto f1 = job1.get_future();
auto f2 = job2.get_future();
auto f3 = job3.get_future();

server.put(move(job1));
server.put(move(job2));
server.put(move(job3));

auto r1 = f1.get();
auto r2 = f2.get();
auto r3 = f3.get();
The server thread would take the packaged_tasks from the server queue and execute them in some suitable order. Typically, the tasks would carry data with them from the calling context.

The tasks are written essentially like ordinary functions, function objects, and lambdas. The server calls the tasks essentially like ordinary (callback) functions. The packaged_tasks are actually easier for the server to use than ordinary functions because the handling of their exceptions has been taken care of.

42.4.4. future
A future is a handle to a shared state (§42.4.1). It is where a task can retrieve a result deposited by a promise (§42.4.2).

future<T> (§iso.30.6.6) (continues)

future fu {};

Default constructor: no shared state; noexcept

future fu {fu2};

Move constructor: fu gets

fu2’s shared state, if any; fu2 no longer has a shared state; noexcept

fu.~future()

Destructor: release the shared state, if any

fu=move(fu2)

Move assignment: fu gets fu2’s shared state, if any;

fu2 no longer has a shared state; release fu’s old shared state, if any

future<T> (continued) (§iso.30.6.6)

sf=fu.share()

Move fu’s value into a shared_future sf; fu no longer has a shared state

x=fu.get()

fu’s value is moved into x; if an exception was stored in fu, throw it;

fu no longer has a shared state; don’t try to get() twice

fu.get()

For future<void>: like x=fu.get(), but don’t move any value

fu.valid()

Is fu valid? that is, does fu have a shared state? noexcept

fu.wait()

Block until a value arrives

fs=fu.wait_for(d)

Block until a value arrives or for a duration d;

fs tells if a value is ready, a timeout occurred, or execution was deferred

fs=fu.wait_until(tp)

Block until a value arrives or until a time_point tp;

fs tells if a value is ready, a timeout occurred, or execution was deferred

A future holds a unique value and offers no copy operations.

The value, if any, is moved out of a future. So get() can only be called once. If you potentially need to read a result several times (e.g., by different tasks), use a shared_future (§42.4.5).

It is undefined what happens if you try to get() twice. In fact, it is undefined what happens if you try to do any operation except a first get(), a valid(), or a destructor on a future that is not valid(). The standard “encourages” an implementation to throw a future_error with the error condition future_errc::no_state in such cases.

If a future<T>’s value type, T, is void or a reference, special rules apply for get():

• future<void>::get() doesn’t return a value: it just returns or throws an exception.

• future<T&>::get() returns a T&. A reference isn’t an object, so the library must have transmitted something else, such as a T*, and get() converts that (back) into a T&.

The status of a future can be observed by calling wait_for() and wait_until():

enum class future_status

ready

The future has a value

timeout

The operation timed out

deferred

The execution of the future’s task is deferred until a get()

The possible errors from operations on futures are:

future Errors: future_errc

broken_promise

A promise abandoned the state before supplying a value

future_already_retrieved

A second get() on a future

promise_already_satisfied

A second set_value() or set_exception() on a promise()

no_state

An operation tried to access a promise’s shared state

before that state was created (e.g., get_future() or set_value())

In addition, an operation on the T value of shared_future<T>::get() could possibly throw (e.g., an unusual move operation).

Looking at the future<T> table, I find that I miss two useful functions:

• wait_for_all(args): Wait until every future in args has a value.

• wait_for_any(args): Wait until one future in args has a value.

I can easily implement a version of wait_for_all():

Click here to view code image

template<typename T>
vector<T> wait_for_all(vector<future<T>>& vf)
{
     vector<T> res;
     for (auto& fu : vf)
           res.push_back(fu.get());
     return res;
}
That’s easy enough to use, but it has a flaw: if I wait for ten futures, I risk my thread getting blocked ten times. Ideally, my thread would be blocked and unblocked at most once. However, for many uses, this wait_for_all() implementation is good enough: if some of the tasks are long-running, the extra waits will not be significant. On the other hand, if all tasks are short, they will most likely have finished after the first wait.

An implementation of wait_for_any() is trickier. First we need a way of checking if a future is ready. Surprisingly, that is done by using wait_for(). For example:

future_status s = fu.wait_for(seconds{0});
Using wait_for(seconds{0}) to get the status of a future is not obvious, but wait_for() will tell us why it resumed, and it tests for ready before suspending. It is common, but unfortunately not guaranteed, that wait_for(seconds{0}) returns immediately rather than trying to suspend for zero time.

Given wait_for(), we can write:

Click here to view code image

template<typename T>
int wait_for_any(vector<future<T>>& vf, steady_clock::duration d)
       // return index of ready future
       // if no future is ready, wait for d before trying again
{
      while(true) {
           for (int i=0; i!=vf.size(); ++i) {
                 if (!vf[i].valid()) continue;
                 switch (vf[i].wait_for(seconds{0})) {
                 case future_status::ready:
                      return i;
                 case future_status::timeout:
                      break;
                 case future_status::deferred:
                      throw runtime_error("wait_for_all(): deferred future");
                 }
           }
           this_thread::sleep_for(d);
     }
}
I decided to consider a deferred task (§42.4.6) an error for my uses.

Note the check for valid(). Trying wait_for() on an invalid future (e.g., a future on which you have already done a get()) will cause a hard-to-find error. At best, you can hope for a (probably surprising) exception being thrown.

Like the implementation of wait_for_all(), this implementation has a flaw: ideally, the caller of wait_for_any() should never have to wake up just to find that no tasks had completed and should be unblocked immediately when one does. This simple implementation only approximates that. With a large d a useless wake-up is unlikely but implies the possibility of an unnecessarily long wait.

The wait_for_all() and wait_for_any() functions are useful building blocks for concurrent algorithms. I use them in §42.4.7.

42.4.5. shared_future
The result value of a future can be read only once: it is moved. Thus, if you want to read the value repeatedly or potentially have it read by multiple readers, you must copy it, and then read the copy. That’s what a shared_future does. Every usable shared_future is directly or indirectly initialized by moving the value out of a future with the same result type.

shared_future<T> (§iso.30.6.7)

shared_future sf {};

Default constructor: no shared state; noexcept

shared_future sf {fu};

Constructor: move value from future fu;

fu no longer has a state; noexcept

shared_future sf {sf2};

Copy and move constructor; the move constructor is noexcept

sf.~future()

Destructor: release the shared state, if any

sf=sf2

Copy assignment

sf=move(sf2)

Move assignment; noexcept

x=sf.get()

sf’s value is copied into x; if an exception was stored in fu, throw it

sf.get()

For shared_future<void>: like x=sf.get()

but doesn’t copy any value

sf.valid()

Does sf have a shared state? noexcept

sf.wait()

Block until a value arrives

fs=sf.wait_for(d)

Block until a value arrives or for a duration d;

fs tells if a value is ready, a timeout occurred,

or execution was deferred

fs=sf.wait_until(tp)

Block until a value arrives or until a time_point tp;

fs tells if a value is ready, a timeout occurred,

or execution was deferred

Obviously, shared_future is very similar to future. The key difference is that a shared_future moves its value to a location where it can be repeatedly read and shared. As for future<T>, special rules apply for get() when a shared_future<T>’s value type, T, is void or a reference:

• shared_future<void>::get() doesn’t return a value: it just returns or throws an exception.

• shared_future<T&>::get() returns a T&. A reference isn’t an object, so the library must have transmitted something else, such as a T*, and get() converts that (back) into a T&.

• shared_future<T>::get() returns a const T& when T is not a reference.

Unless the returned object is a reference, it is const, so it can safely be accessed from several threads without synchronization. If the returned object is a non-const reference, you need some form of mutual exclusion to avoid data races on the referred-to object.

42.4.6. async()
Given future and promise (§42.4.1) and packaged_task (§42.4.3), we can write simple tasks without worrying too much about threads. Given those, a thread is just something you give a task to run. However, we still need to consider how many threads to use and whether a task is best run on the current thread or on another. Such decisions can be delegated to a thread launcher, that is, a function that decides whether to create a new thread, to recycle an old thread, or simply run the task on the current thread.

Asynchronous Task Launcher: async<F,Args>() (§iso.30.6.8)

fu=async(policy,f,args)

Execute f(args) according to launch policy policy

fu=async(f,args)

fu=async(launch::async|launch::deferred,f,args)

The async() function is basically a simple interface to a launcher of unknown sophistication. A call of async() returns a future<R> where R is the type of its task’s result. For example:

double square(int i) { return i*i; }

future<double> fd = async(square,2);
double d = fd.get();
If a thread is launched to execute square(2), we may have a record slow way of executing 2*2. The notation can be simplified by the use of auto:

double square(int i) { return i*i; }

auto fd = async(square,2);
auto d = fd.get();
In principle, a caller of async() could provide a huge variety of information to help the implementation of async() decide whether to launch a new thread, rather than simply executing the task on the current thread. For example, we can easily imagine a programmer wanting to give the launcher a hint about how long a task is likely to run. However, only two policies are currently standard:

Launch Policies: launch

async

Execute the task as if a new thread was created to do so

deferred

Execute the task at the point of a get() for the task’s future

Note the as if. The launcher has wide discretionary powers when it comes to launching a new thread or not. For example, since the default policy is async|deferred (async or deferred), it is not too fanciful to imagine an async() that decided to use deferred for async(square,2), so that the execution reduced to fd.get() calling square(2). I could even imagine an optimizer reducing that whole code fragment to

double d = 4;
However, we should not expect an implementation of async() to be optimized for such trivial examples. Implementer efforts are better spent on realistic examples where the task performs a significant amount of computation so that launching on a new or “recycled” thread could be reasonably considered.

By a “recycled thread” I mean a thread from a collection of threads (a thread pool) that async() may create once and use over and over to execute a variety of tasks. Depending on the implementation of system threads, this can drastically lower the cost of executing a task on a thread. If a thread is recycled, the launcher must take care that a task does not see leftover state from a previous task executed on the thread and that a task does not store pointers to its stack or thread_local data (§42.2.8) in nonlocal storage. Such data could conceivably be used for security violations.

A simple and realistic use of async() would be to spawn a task to collect input from a user:

Click here to view code image

void user()
{
     auto handle = async([](){ return input_interaction_manager(); });
      //...
     auto input = handle.get();
      //...
}
Such a task often requires some data from the caller. I used a lambda to make it obvious that I can pass arguments or allow access to local variables. When using a lambda to specify a task, beware of capturing local variables by reference. That could lead to data races or unfortunate cache access patterns by two threads accessing the same stack frame. Also, beware that capturing members of an object using [this] (§11.4.3.3) implies that the members of the object are accessed indirectly (through this), rather than copied, so that the object is subject to data races unless you make certain that it is not. If in doubt, copy (pass or capture by value, [=]).

It is often important that we can select a scheduling policy “late” and change it as needed. For example, I might use launch::deferred for initial debugging. That would eliminate errors related to concurrency until I had eliminated sequential errors. Also, I can often go back to launch::deferred to determine if an error really is related to concurrency.

Over time, more launch policies may become available, and maybe some systems offer better launch policies than others. In such cases, I might be able to improve the performance of my code by a local change of launch policy, rather than by reworking subtle details of the program logic. This, again, is an effect of the fundamental simplicity of the task-based model (§42.4).

Having launch::async|launch::deferred as the default launch policy can be a practical problem. Basically, it is not so much a default as a lacking design decision. An implementation might decide that “no concurrency” is a good idea and always use launch::deferred. If your experiments with concurrency show results surprisingly similar to single-thread execution, try being explicit about the launch policy.

42.4.7. A Parallel find() Example
A find() does a linear search of a sequence. Imagine having millions of items that are not easily sorted so that find() is the right algorithm for finding something. This could be slow, so instead of searching once starting at the beginning and going until the end, we might start 100 find()s each on a hundredth of the data.

First, we represent the data as a vector of Records:

extern vector<Record> goods;  // data to be searched
An individual (sequential) task is simply a use of the standard-library find_if():

Click here to view code image

template<typename Pred>
Record* find_rec(vector<Record>& vr, int first, int last, Pred pr)
{
    vector<Record>::iterator p = std::find_if(vr.begin()+first,vr.begin()+last,pr);
    if (p == vr.begin()+last)
          return nullptr;       // at end: no record found
    return &*p;                 // found: return a pointer to the element
}
Unfortunately, we have to decide on a “grain” of parallelism. That is, we need to specify the number of records to be searched sequentially.

const int grain = 50000;       // number of records for a linear search
Picking a number like that is a very primitive way of choosing a grain size. It is hard to choose well unless a lot is known about the hardware, the library implementation, the data, and the algorithm. Experimentation is essential. Tools and frameworks that save us from having to pick a grain size or help us choose can be most useful. However, for a simple illustration of basic standard-library facilities and the most basic techniques for their use, grain is sufficient.

The pfind() (“parallel find”) function simply does the number of async() calls required by the grain and the number of Records. Then, it get()s the results:

Click here to view code image

template<typename Pred>
Record * pfind(vector<Record>& vr, Pred pr)
{
    assert(vr.size()%grain==0);

    vector<future<Record*>> res;

    for (int i = 0; i!=vr.size(); i+=grain)
          res.push_back(async(find_rec<Pred>,ref(vr),i,i+grain,pr));

    for (int i = 0; i!=res.size(); ++i)          // look for a result in the futures
          if (auto p = res[i].get())             // did the task find a match?
                return p;

    return nullptr;                              // no match found
}
Finally, we can initiate a search:

Click here to view code image

void find_cheap_red()
{
     assert(goods.size()%grain==0);
 
     Record* p = pfind(goods,
                        [](Record& r) { return r.price<200 && r.color==Color::red; });
     cout << "record "<< *p << '\n';
}
This first version of a parallel find() first spawns a lot of tasks and then proceeds to wait for them in order. Like std::find_if(), it reports the first element that matches the predicate; that is, it finds the element with the lowest index that matches. That may be fine, but:

• We could end up waiting for a lot of tasks that don’t find anything (maybe only the last task finds something).

• We may throw away a lot of information that could be useful (maybe a thousand items match our criteria).

The first problem may not be as bad as it sounds. Assume (somewhat recklessly) that launching a thread doesn’t cost anything and that we have as many processing units as there are tasks; then we would still get the result in roughly the time it took to process one task. That is, we would potentially get our result in the time taken to examine 50,000 records rather than millions. If we have N processing units, the results will be delivered in batches of results for N*50000 records. If no record is found until the last segment of the vector, the time will be roughly vr.size()/(N*grain) units.

Instead of waiting for each task in order, we could try to look at the results in the order the tasks completed. That is, we could use wait_for_any() (§42.4.4). For example:

Click here to view code image

template<typename Pred>
Record*pfind_any(vector<Record>& vr, Pred pr)
{
    vector<future<Record*>> res;

    for (int i = 0; i!=vr.size(); i+=grain)
          res.push_back(async(find_rec<Pred>,ref(vr),i,i+grain,pr));

    for (int count = res.size(); count; ––count) {
          int i = wait_for_any(res,microseconds{10});   // find a completed task
          if (auto p = res[i].get())                    // did the task find a match?
                return p;
    }

    return nullptr;                                     // no match found
}
A get() renders its future invalid, so we don’t get to look at a partial result twice.

I use count to make sure I don’t keep looking after all tasks have reported back. Apart from that, pfind_any() is as simple as pfind(). Whether there is a performance advantage to pfind_any() over pfind() depends on lots of things, but the key observation is that to (potentially) gain advantages of concurrency, we had to use a slightly different algorithm. Like find_if(), pfind() returns its first match, whereas pfind_any() returns whichever match it first found. Often, the best parallel algorithm for a problem is a variant of the idea for a sequential solution, rather than a simple repetition of the sequential solution.

In this case, the obvious question is “But do you really only need one match?” Given concurrency, it makes more sense to find all matches. Doing so is easy. All we need to do is to let each task return a vector of matches, rather than just a simple match:

Click here to view code image

template<typename Pred>
vector<Record*> find_all_rec(vector<Record>& vr, int first, int last, Pred pr)
{
    vector<Record*> res;
    for (int i=first; i!=last; ++i)
          if (pr(vr[i]))
                res.push_back(&vr[i]);
    return res;
}
This find_all_rec() is arguably simpler than the original find_rec().

Now we just need to launch find_all_rec() a suitable number of times and wait for the results:

Click here to view code image

template<typename Pred>
vector<Record*> pfind_all(vector<Record>& vr, Pred pr)
{

    vector<future<vector<Record*>>> res;

    for (int i = 0; i!=vr.size(); i+=grain)
          res.push_back(async(find_all_rec<Pred>,ref(vr),i,i+grain,pr));

    vector<vector<Record*>> r2 = wait_for_all(res);

    vector<Record*> r;
    for (auto& x : r2)                // merge results
          for (auto p : x)
                r.push_back(p);
    return r;
}
Had I just returned a vector<vector<Record*>> this pfind_all() would have been the simplest parallelizing function so far. However, by merging the vectors returned into a single one, pfind_all() became an example of a common and popular group of parallel algorithms:

[1] Create a number of tasks to be run.

[2] Run the tasks in parallel.

[3] Merge the results.

This is the basic idea that, when developed into a framework so that the details of concurrent execution have been completely hidden, is commonly referred to as map-reduce [Dean,2004].

The example can be run like this:

Click here to view code image

void find_all_cheap_red()
{
     assert(goods.size()%grain==0);

     auto vp = pfind_all(goods,
          [](Record& r) { return r.price<200 && r.color==Color::red; });
     for (auto p : vp)
           cout << "record "<< *p << '\n';
}
Finally, we must consider if the effort to parallelize was worthwhile. To do so, I added simple sequential versions to my test:

Click here to view code image

void just_find_cheap_red()
{
     auto p = find_if(goods.begin(),goods.end(),
          [](Record& r) { return r.price<200 && r.color==Color::red; });
     if (p!=goods.end())
               cout << "record "<< *p << '\n';
     else
               cout << "not found\n";
}

void just_find_all_cheap_red()
{
     auto vp = find_all_rec(goods,0,goods.size(),
          [](Record& r) { return r.price<200 && r.color==Color::red; });
     for (auto p : vp)
           cout << "record "<< *p << '\n';
}
For my simple test data and my (relatively) simple laptop with only four hardware threads, I did not find any consistent or significant performance differences. In this case, the cost of thread creation in the immature implementation of async() dominates the effects of concurrency. If I needed significant parallel speedup right now, I would implement my own variant of async() based on a pre-created set of threads and a work queue, along the lines of a Sync_queue (§42.3.4) of packaged_tasks (§42.4.3). Note that such a significant optimization can be done without changing my task-based parallel find() program. From the application’s point of view, replacing the standard-library async() with an optimized version is an implementation detail.

42.5. Advice
[1] A thread is a type-safe interface to a system thread; §42.2.

[2] Do not destroy a running thread; §42.2.2.

[3] Use join() to wait for a thread to complete; §42.2.4.

[4] Consider using a guarded_thread to provide RAII for threads; §42.2.4.

[5] Do not detach() a thread unless you absolutely have to; §42.2.4.

[6] Use lock_guard or unique_lock to manage mutexes; §42.3.1.4.

[7] Use lock() to acquire multiple locks; §42.3.2.

[8] Use condition_variables to manage communication among threads; §42.3.4.

[9] Think in terms of tasks that can be executed concurrently, rather than directly in terms of threads; §42.4.

[10] Value simplicity; §42.4.

[11] Return a result using a promise and get a result from a future; §42.4.1.

[12] Don’t set_value() or set_exception() to a promise twice; §42.4.2.

[13] Use packaged_tasks to handle exceptions thrown by tasks and to arrange for value return; §42.4.3.

[14] Use a packaged_task and a future to express a request to an external service and wait for its response; §42.4.3.

[15] Don’t get() twice from a future; §42.4.4.

[16] Use async() to launch simple tasks; §42.4.6.

[17] Picking a good granularity of concurrent tasks is difficult: experiment and measure; §42.4.7.

[18] Whenever possible, hide concurrency behind the interface of a parallel algorithm; §42.4.7.

[19] A parallel algorithm may be semantically different from a sequential solution to the same problem (e.g., pfind_all() vs. find()); §42.4.7.

[20] Sometimes, a sequential solution is simpler and faster than a concurrent solution; §42.4.7.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


42. Threads and Tasks
43. The C Standard Library
44. Compatibility
47h 26m remaining
43. The C Standard Library
C is a strongly typed, weakly checked language.

– D. M. Ritchie

• Introduction

• Files

• The printf() Family

• C-Style Strings

• Memory

• Date and Time

• Etc.

• Advice

43.1. Introduction
The standard library for the C language is with very minor modifications incorporated into the C++ standard library. The C standard library provides quite a few functions that have proven useful over the years in a wide variety of contexts – especially for relatively low-level programming.

There are more C standard-library functions than are presented here; see a good C textbook, such as “Kernighan and Ritchie” [Kernighan,1988] or the ISO C standard [C,2011], if you need to know more.

43.2. Files
The <cstdio> I/O system is based on files. A file (a FILE*) can refer to a file or to one of the standard input and output streams: stdin, stdout, and stderr. The standard streams are available by default; other files need to be opened:

File Open and Close

f=fopen(s,m)

Open a file stream for a file named s with the mode m

f is the FILE* for the opened file if successful or nullptr

x=fclose(f)

Close file stream f; return 0 if successful

A file opened with fopen() must be closed by fclose() or the file will remain open until the operating system closes it. If that is a problem (is considered a leak), use an fstream (§38.2.1).

A mode is a C-style string containing one or more characters specifying how a file is to be opened (and used after opening):

File Modes

"r"

Reading

"w"

Writing (discard previous contents)

"a"

Append (add at end)

"r+"

Reading and writing

"w+"

Reading and writing (discard previous contents)

"b"

Binary; use together with one or more other modes

There may be (and usually are) more options on a specific system. For example, x is sometimes used to mean “the file must not exist before this open operation.” Some options can be combined, for example, fopen("foo","rb") tries to open a file called foo for binary reading. The I/O modes should be the same for stdio and iostreams (§38.2.1).

43.3. The printf() Family
The most popular C standard library functions are the output functions. However, I prefer iostreams because that library is type-safe and extensible. The formatted output function, printf(), is widely used (also in C++ programs) and widely imitated in other programming languages:

printf()

n=printf(fmt,args)

Print the format string fmt to stdout,

inserting the arguments args as appropriate

n=fprintf(f,fmt,args)

Print the format string fmt to file f,

inserting the arguments args as appropriate

n=sprintf(s,fmt,args)

Print the format string fmt to the C-style string s,

inserting the arguments args as appropriate

For each version, n is the number of characters written or a negative number if the output failed. The return value from printf() is essentially always ignored.

The declaration of printf() is:

int printf(const char* format ...);
In other words, it takes a C-style string (typically a string literal) followed by an arbitrary number of arguments of arbitrary type. The meaning of those “extra arguments” is controlled by conversion specifications, such as %c (print as character) and %d (print as decimal integer), in the format string. For example:

Click here to view code image

int x = 5;
const char* p = "Pedersen";
printf("the value of x is '%d' and the value of s is '%s'\n",x,s);
A character following a % controls the handling of an argument. The first % applies to the first “extra argument” (here, %d applies to x), the second % to the second “extra argument” (here, %s applies to s), and so on. In particular, the output of that call to printf() is

the value of x is '5' and the value of s is 'Pedersen'
followed by a newline.

In general, the correspondence between a % conversion directive and the type to which it is applied cannot be checked, and when it can, it usually is not. For example:

printf("the value of x is '%s' and the value of s is '%x'\n",x,s);      // oops
The set of conversion specifications is quite large (and growing over the years) and provides a great degree of flexibility. Various systems support options beyond the ones offered by the C standard. See also the set of options used for strftime() formatting (§43.6). Following the %, there may be:

–

an optional minus sign that specifies left-adjustment of the converted value in the field;

+

an optional plus sign that specifies that a value of a signed type will always begin with a + or – sign;

0

an optional zero that specifies that leading zeros are used for padding of a numeric value. If – or a precision is specified this 0 is ignored;

#

an optional # that specifies that floating-point values will be printed with a decimal point even if no nonzero digits follow, that trailing zeros will be printed, that octal values will be printed with an initial 0, and that hexadecimal values will be printed with an initial 0x or 0X;

d

an optional digit string specifying a field width; if the converted value has fewer characters than the field width, it will be blank-padded on the left (or right, if the left-adjustment indicator has been given) to make up the field width; if the field width begins with a zero, zero-padding will be done instead of blank-padding;

.

an optional period that serves to separate the field width from the next digit string;

d

an optional digit string specifying a precision that specifies the number of digits to appear after the decimal point, for e- and f-conversion, or the maximum number of characters to be printed from a string;

*

a field width or precision may be * instead of a digit string. In this case an integer argument supplies the field width or precision;

h

an optional character h, specifying that a following d, i, o, u, x, or X corresponds to a (signed or unsigned) short integer argument;

hh

an optional pair of characters hh, specifying that a following d, i, o, u, x, or X argument is treated as a (signed or unsigned) char argument;

l

an optional character l (ell), specifying that a following d, i, o, u, x, or X corresponds to a (signed or unsigned) long integer argument;

ll

an optional pair of characters ll (ell ell), specifying that a following d, i, o, u, x, or X corresponds to a (signed or unsigned) long long integer argument;

L

an optional character L, specifying that a following a, A, e, E, f, F, g, or G corresponds to a long double argument;

j

specifying that a following d, i, o, u, x, or X corresponds to a intmax_t or uintmax_t argument;

z

specifying that a following d, i, o, u, x, or X corresponds to a size_t argument;

t

specifying that a following d, i, o, u, x, or X corresponds to a ptrdiff_t argument;

%

indicating that the character % is to be printed; no argument is used;

c

a character that indicates the type of conversion to be applied. The conversion characters and their meanings are:

d

The integer argument is converted to decimal notation;

i

The integer argument is converted to decimal notation;

o

The integer argument is converted to octal notation;

x

The integer argument is converted to hexadecimal notation;

X

The integer argument is converted to hexadecimal notation;

f

The float or double argument is converted to decimal notation in the style [–]ddd.ddd. The number of d’s after the decimal point is equal to the precision for the argument. If necessary, the number is rounded. If the precision is missing, six digits are given; if the precision is explicitly 0 and # isn’t specified, no decimal point is printed;

F

Like %f but uses capital letters for INF, INFINITY, and NAN.

e

The float or double argument is converted to decimal notation in the scientific style [–]d.ddde+dd or [–]d.ddde–dd, where there is one digit before the decimal point and the number of digits after the decimal point is equal to the precision specification for the argument. If necessary, the number is rounded. If the precision is missing, six digits are given; if the precision is explicitly 0 and # isn’t specified, no digits and no decimal point are printed;

E

As e, but with an uppercase E used to identify the exponent;

g

The float or double argument is printed in style d, in style f, or in style e, whichever gives the greatest precision in minimum space;

G

As g, but with an uppercase E used to identify the exponent;

a

The double argument is printed in the hexadecimal format [–]0xh.hhhhp+d or [–]0xh.hhhhp+d;

A

Like %a but using X and P instead or x and p;

c

The character argument is printed. Null characters are ignored;

s

The argument is taken to be a string (character pointer), and characters from the string are printed until a null character or until the number of characters indicated by the precision specification is reached; however, if the precision is 0 or missing, all characters up to a null are printed;

p

The argument is taken to be a pointer. The representation printed is implementation-dependent;

u

The unsigned integer argument is converted to decimal notation;

n

The number of characters written so far by the call of printf(), fprintf(), or sprintf() is written to the int pointed to by the pointer to int argument.

In no case does a nonexistent or small field width cause truncation of a field; padding takes place only if the specified field width exceeds the actual width.

Here is a more elaborate example:

char* line_format = "#line %d \"%s\"\n";
int line = 13;
char* file_name = "C++/main.c";

printf("int a;\n");
printf(line_format,line,file_name);
which produces:

int a;
#line 13 "C++/main.c"
Using printf() is unsafe in the sense that type checking is not done. For example, here is a well-known way of getting unpredictable output, a segmentation fault, or worse:

Click here to view code image

char x = 'q';
printf("bad input char: %s",x);    //%s should have been %c
The printf() function does, however, provide great flexibility in a form that is familiar to C programmers.

Because C does not have user-defined types in the sense that C++ has, there are no provisions for defining output formats for user-defined types, such as complex, vector, or string. The format for strftime() (§43.6) is an example of the contortions you can get into by trying to design yet another set of format specifiers.

The C standard output, stdout, corresponds to cout. The C standard input, stdin, corresponds to cin. The C standard error output, stderr, corresponds to cerr. This correspondence between C standard I/O and C++ I/O streams is so close that C-style I/O and I/O streams can share a buffer. For example, a mix of cout and stdout operations can be used to produce a single output stream (that’s not uncommon in mixed C and C++ code). This flexibility carries a cost. For better performance, don’t mix stdio and iostream operations for a single stream. To ensure that, call ios_base::sync_with_stdio(false) before the first I/O operation (§38.4.4).

The stdio library provides a function, scanf(), that is an input operation with a style that mimics printf(). For example:

Click here to view code image

int x;
char s[buf_size];
int i = scanf("the value of x is '%d' and the value of s is '%s'\n",&x,s);
Here, scanf() tries to read an integer into x and a sequence of non-whitespace characters into s. A non-format character specifies that the input should contain that character. For example:

the value of x is '123' and the value of s is 'string '\n"
will read 123 into x and string followed by a 0 into s. If the call of scanf() succeeds, the resulting value (i in the call above) will be the number of argument pointers assigned to (hopefully 2 in the example); otherwise, EOF. This way of specifying input is error-prone (e.g., what would happen if you forgot the space after string on that input line?). All arguments to scanf() must be pointers. I strongly recommend against the use of scanf().

So what can we do for input if we are obliged to use stdio? One popular answer is “use the standard-library function gets()”:

 // very dangerous code:
char s[buf_size];
char* p = gets(s);    // read a line into s
The call p=gets(s) reads characters into s until a newline or an end-of-file is encountered and a '\0' is placed after the last character written to s. If an end-of-file is encountered or if an error occurred, p is set to the nullptr; otherwise, it is set to s. Never use gets(s) or its rough equivalent (scanf("%s",s))! For years, they were the favorites of virus writers: By providing an input that overflows the input buffer (s in the example), a program can be corrupted and a computer potentially taken over by an attacker. The sprintf() function can suffer similar buffer-overflow problems. The C11 version of the C standard library offers a whole alternate set of stdio input functions that take an extra argument to defend against overflow, such as gets_s(p,n). As for iostream’s unformatted input, that leaves the user with the problem of deciding exactly which termination condition was encountered (§38.4.1.2; e.g., too many characters, a terminator character, or an end-of-file).

The stdio library also provides simple and useful character read and write functions:

Stdio Character Functions

x=getc(st)

Read a character from input stream st;

x is the character’s integer value or EOF if end-of-file or an error occurred

x=putc(c,st)

Write the character c to the output stream st;

x is the integer value of the character written or EOF if an error occurred

x=getchar()

x=getc(stdin)

x=putchar(c)

x=putc(c,stdout)

x=ungetc(c,st)

Put c back onto the input stream st;

x is the integer value of c or EOF if an error occurred

The result of these operations is an int (not a char, or EOF could not be returned). For example, this is a typical C-style input loop:

Click here to view code image

int ch;    // note: not "char ch;"
while ((ch=getchar())!=EOF) { /* do something */ }
Don’t do two consecutive ungetc()s on a stream. The result of that is undefined and non-portable.

There are many more stdio functions; see a good C textbook (e.g., “K&R,”) if you need to know more.

43.4. C-Style Strings
A C-style string is a zero-terminated array of char. This notion of a string is supported by a set of functions defined in <cstring> (or <string.h>; note: not <string>) and <cstdlib>. These functions operate on C-style strings through char* pointers (const char* pointers for memory that is only read, but not unsigned char* pointers):

C-Style String Operations

x=strlen(s)

Count the characters (excluding the terminating 0)

p=strcpy(s,s2)

Copy s2 into s;[s:s+n) and [s2:s2+n) may not overlap; p=s; the terminating 0 is copied

p=strcat(s,s2)

Copy s2 onto the end of s; p=s; the terminating 0 is copied

x=strcmp(s, s2)

Compare lexicographically: if s<s2, then x is negative;

if s==s2, then x==0;if s>s2, then x is positive

p=strncpy(s,s2,n)

strcpy of max n characters; may fail to copy terminating 0

p=strncat(s,s2,n)

strcat of max n characters; may fail to copy terminating 0

x=strncmp(s,s2,n)

strcmp of max n characters

p=strchr(s,c)

p points to the first c in s

p=strrchr(s,c)

p points to the last c in s

p=strstr(s,s2)

p points to the first character of s that starts a substring equal to s2

p=strpbrk(s,s2)

p points to the first character of s also found in s2

Note that in C++, strchr() and strstr() are duplicated to make them type-safe (they can’t turn a const char* into a char* the way the C equivalents can). See also §36.3.2, §36.3.3, and §36.3.7.

C-Style String Numeric Conversions

p points to the first character of s not used for the conversion;

b is the base of the number [2:36] or 0, meaning use C-source-code-style numbers

x=atof(s)

x is a double represented by s

x=atoi(s)

x is an int represented by s

x=atol(s)

x is a long represented by s

x=atoll(s)

x is a long long represented by s

x=strtod(s,p)

x is a double represented by s

x=strtof(s,p)

x is a float represented by s

x=strtold(s,p)

x is a long double represented by s;

x=strtol(s,p,b)

x is a long represented by s

x=strtoll(s,p,b)

x is a long long represented by s

x=strtoul(s,p,b)

x is an unsigned long represented by s

x=strtoull(s,p,b)

x is an unsigned long long represented by s

The conversions to floating-point values set errno to ERANGE (§40.3) if their result doesn’t fit into the target type. See also §36.3.5.

43.5. Memory
The memory manipulation functions operate on “raw memory” (no type known) through void* pointers (const void* pointers for memory that is only read):

C-Style Memory Operations

q=memcpy(p,p2,n)

Copy n bytes from p2 to p (like strcpy);

[p:p+n) and [p2:p2+n) may not overlap; q=p

q=memmove(p,p2,n)

Copy n bytes from p2 to p; q=p

x=memcmp(p,p2,n)

Compare n bytes from p2 to the equivalent n bytes from p;

x<0 means <, x==0 means ==, 0<x means >

q=memchr(p,c,n)

Find c (converted to an unsigned char) in [p:p+n);

q points to that element; q=0 if c is not found

q=memset(p,c,n)

Copy c (converted to an unsigned char) into each of [p:p+n); q=p

p=calloc(n,s)

p points to n*s bytes initialized to 0 on free store; p=nullptr if the bytes could not be allocated

p=malloc(n)

p points to n uninitialized bytes on free store;

p=nullptr if the n bytes could not be allocated

q=realloc(p,n)

q points to n bytes on free store;

p must be a pointer returned by malloc() or calloc(), or nullptr;

if possible, reuse the space pointed to by p;

if not, copy all bytes in the area pointed to by p to a new area;

q=nullptr if n bytes could not be allocated

free(p)

Deallocate the memory pointed to by p; p must be nullptr or

a pointer returned by malloc(), calloc(), or realloc()

Note that malloc(), etc., does not invoke constructors and free() doesn’t invoke destructors. Do not use these functions for types with constructors or destructors. Also, memset() should never be used for any type with a constructor.

Note that realloc(p,n) will reallocate (that is, copy) the data stored, from p onward, when it needs more memory than is avaliable starting from p. For example:

Click here to view code image

int max = 1024;
char* p = static_cast<char*>(malloc(max));
char* current_word = nullptr;
bool in_word = false;
int i=0;
while (cin.get(&p[i])) {
     if (isletter(p[i])) {
          if (!in_word)
                 current_word = p;
          in_word = true;
     }
     else
           in_word = false;
     if (++i==max)
           p = static_cast<char*>(realloc(p,max*=2));    // double allocation
      //...
}
I hope you spotted the nasty bug: if realloc() was called, current_word may (may not) point to a location outside the current allocation pointed to by p.

Most uses of realloc() are better done using a vector (§31.4.1). The mem* functions are found in <cstring> and the allocation functions in <cstdlib>.

43.6. Date and Time
In <ctime>, you can find several types and functions related to date and time:

Date and Time Types

clock_t

An arithmetic type for holding short time intervals (maybe just a few minutes)

time_t

An arithmetic type for holding long time intervals (maybe centuries)

tm

A struct for holding the time of a date (since year 1900)

The struct tm is defined like this:

Click here to view code image

struct tm {
     int tm_sec;     // second of minute [0:61]; 60 and 61 represent leap seconds
     int tm_min;     // minute of hour [0:59]
     int tm_hour;    // hour of day [0:23]
     int tm_mday;    // day of month [1:31]
     int tm_mon;     // month of year [0:11]; 0 means January (note: not [1:12])
     int tm_year;    // year since 1900; 0 means year 1900, and 115 means 2015
     int tm_wday;    // days since Sunday [0:6]; 0 means Sunday
     int tm_yday;    // days since January 1 [0:365]; 0 means January 1
     int tm_isdst;   // hours of daylight savings time
};
A system clock is supported by the function clock() supported by a few functions giving meaning to its return type clock_t:

Date and Time Functions

t=clock()

t is the number of clock ticks since the start of

the program; t is a clock_t

t=time(pt)

t is the current calendar time; pt is a time_t* or nullptr;

t is a time_t; if pt!=nullptr *pt=t

d=difftime(t2,t1)

d is a double representing t2-t1 in seconds

ptm=localtime(pt)

If pt==nullptr, ptm=nullptr; otherwise ptm points

to the local time tm for *pt

ptm=gmtime(pt)

If pt==nullptr, ptm=nullptr; otherwise ptm points to

the Greenwich Mean Time (GMT) tm for *pt

t=mktime(ptm)

time_t for *ptm, or time_t(-1)

p=asctime(ptm)

p is a C-style string representation for *ptm

p=ctime(t)

p=asctime(localtime(t))

n=strftime(p,max,fmt,ptm)

Copy *ptm into [p:p+n+1) controlled by the format

string fmt; characters beyond [p:p+max) are discarded;

n==0 in case of errors; p[n]=0

A example of the result of a call of asctime() is

"Sun Sep 16 01:03:52 1973\n"
Here is an example of how clock() can be used to time a function:

Click here to view code image

int main(int argc, char* argv[])
{
     int n = atoi(argv[1]);

     clock_t t1 = clock();
     if (t1 == clock_t(–1)) {          // clock_t(-1) means "clock() didn't work"
            cerr << "sorry, no clock\n";
            exit(1);
     }

     for (int i = 0; i<n; i++)
           do_something();             // timing loop
     clock_t t2 = clock();
     if (t2 == clock_t(–1)) {
            cerr << "sorry, clock overflow\n";
            exit(2);
     }
     cout << "do_something() " << n << " times took "
          << double(t2–t1)/CLOCKS_PER_SEC <<"seconds"
          << " (measurement granularity: "<< CLOCKS_PER_SEC
          << " of a second)\n";
}
The explicit conversion double(t2–t1) before dividing is necessary because clock_t might be an integer. For values t1 and t2 returned by clock(), double(t2–t1)/CLOCKS_PER_SEC is the system’s best approximation of the time in seconds between the two calls.

Compare <ctime> with the facilities provided in <chrono>; see §35.2.

If clock() isn’t provided for a processor or if a time interval is too long to measure, clock() returns clock_t(–1) .

The strftime() function uses a printf() format string to control the output of a tm. For example:

Click here to view code image

void almost_C()
{
     const int max = 80;
     char str[max];
     time_t t = time(nullptr);
     tm* pt = localtime(&t);
     strftime(str,max,"%D, %H:%M (%I:%M%p)\n",pt);
     printf(str);
}
The output is something like:

06/28/12, 15:38 (03:38PM)
The strftime() formatting characters almost constitute a small programming language:

Date and Time Formatting

%a

Abbreviated weekday name

%A

Full weekday name

%b

Abbreviated month name

%B

Full month name

%c

Date and time representation

%C

The year divided by 100 and truncated to a decimal integer [00:99]

%d

The day of the month as a decimal number [01:31]

%D

Equivalent to %m/%d/%y

%e

The day of the month as a decimal number [1:31];

a single digit is preceded by a space

%F

Equivalent to %Y-%m-%d; the ISO 8601 date format

%g

The last two digits of the week-based year as a decimal number [00:99]

%G

The week-based year as a decimal number (e.g., 2012)

%h

Equivalent to %b

%H

The hour (24-hour clock) as a decimal number [00:23]

%I

The hour (12-hour clock) as a decimal number [01:12]

%j

The day of the year as a decimal number [001:366]

%m

The month as a decimal number [01:12]

%M

The minute as a decimal number [00:59]

%n

A newline character

%p

The locale’s equivalent of AM/PM for a 12-hour clock

%r

12-hour clock time

%R

Equivalent to %H:%M

%S

The second as a decimal number [00:60]

%t

A horizontal-tab character

%T

Equivalent to %H:%M:%S; the ISO 8601 time format

%u

The ISO 8601 weekday as a decimal number [1:7]; Monday is 1

%U

The week number of the year (the first Sunday is the first day of week 1)

as a decimal number [00:53]

%V

The ISO 8601 week number as a decimal number [01:53]

%w

The weekday as a decimal number [0:6]; Sunday is 0

%W

The week number of the year (the first Monday is the first day of week 1)

as a decimal number [00:53]

%x

The locale’s appropriate date representation

%X

The locale’s appropriate time representation

%y

The last 2 digits of the year as a decimal number [00:99]

%Y

The year as a decimal number (e.g., 2012)

%z

The offset from UTC in the ISO 8601 format -0430 (4.5 hours behind UTC, Greenwich); no characters if no time zone is determinable

%Z

The locale’s time zone name or abbreviation; nothing if no time zone is known

%%

The character %

The locale referred to is the program’s global locale.

Some conversion specifiers can be modified by an E or O modifier, indicating alternative implementation-specific and locale-specific formatting. For example:

Date and Time Format Modifier Examples

%Ec

The locale’s alternative date and time representation

%EC

The name of the base year (period) in the locale’s alternative representation

%OH

The hour (24-hour clock), using the locale’s alternative numeric symbols

%Oy

The last two digits of the year, using the locale’s alternative numeric symbols

The strftime() is used by the put_time facet (§39.4.4.1).

For C++-style time facilities, see §35.2.

43.7. Etc.
In <cstdlib> we find:

Etc. <stdlib.h> Functions

abort()

Terminate the program “abnormally”

exit(n)

Terminate the program with value n;

n==0 means successful termination

system(s)

Execute the string as a command (system-dependent)

qsort(b,n,s,cmp)

Sort the array starting at b with n elements

 

of size s using the comparison function cmp

bsearch(k,b,n,s,cmp)

Search for k in the sorted array starting at b

 

with n elements of size s using the comparison function cmp

d=rand()

d is a pseudo-random number in the range [0:RAND_MAX]

srand(d)

Start a sequence of pseudo-random numbers using d as the seed

The comparison function (cmp) used by qsort() and bsort() must have the type

int (*cmp)(const void* p, const void* q);
That is, no type information is known to the sort functions that simply “see” their array arguments as sequences of bytes. The integer returned is

• Negative if *p is considered less than *q

• Zero if *p is considered equal to *q

• Positive if *p is considered greater than *q

This differs from sort(), which uses a conventional <.

Note that exit() and abort() do not invoke destructors. If you want destructors called for constructed objects, throw an exception (§13.5.1).

Similarly, longjmp() from <csetjmp> is a nonlocal goto that unravels the stack until it finds the result of a matching setjmp(). It does not invoke destructors. Its behavior is undefined if a destructor would be invoked by a throw from the same point of a program. Never use setjmp() in a C++ program.

For more C standard library functions see [Kernighan,1988] or some other reputable C language reference.

In <cstdint>, we find int_fast16_t and other standard integer aliases:

Integer Type Aliases

N can be 8,16, 32, or 64

intN_t

Integer type of exactly N bits, e.g. int8_t

uintN_t

Unsigned integer type of exactly N bits, e.g., uint16_t

int_leastN_t

The smallest integer type of at least N bits, e.g., int_least16_t

uint_leastN_t

The smallest unsigned integer type of at least N bits, e.g., uint_least32_t

int_fastN_t

The fastest integer type of at least N bits, e.g., int_fast32_t

uint_fastN_t

The fastest unsigned integer type of at least N bits, e.g., uint_fast64_t

Also in <cstdint>, we find type aliases for the largest signed and unsigned integer types for an implementation. For example:

Click here to view code image

typedef long long intmax_t;            // largest signed integer type
typedef unsigned long long uintmax_t;  // largest unsigned integer type
43.8. Advice
[1] Use fstreams rather than fopen()/fclose() if you worry about resource leaks; §43.2.

[2] Prefer <iostream> to <stdlib> for reasons of type safety and extensibility; §43.3.

[3] Never use gets() or scanf("%s",s); §43.3.

[4] Prefer <string> to <cstring> for reasons of ease of use and simplicity of resource management; §43.4.

[5] Use the C memory management routines, such as memcpy(), only for raw memory; §43.5.

[6] Prefer vector to uses of malloc() and realloc(); §43.5.

[7] Beware that the C standard library does not know about constructors and destructors; §43.5.

[8] Prefer <chrono> to <ctime> for timing; §43.6.

[9] For flexibility, ease of use, and performance, prefer sort() over qsort(); §43.7.

[10] Don’t use exit(); instead, throw an exception; §43.7.

[11] Don’t use longjmp(); instead, throw an exception; §43.7.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


43. The C Standard Library
44. Compatibility
Index
47h 26m remaining
44. Compatibility
You go ahead and follow your customs, and I’ll follow mine.

– C. Napier

• Introduction

• C++11 Extensions

Language Features; Standard-Library Components; Deprecated Features; Coping with Older C++ Implementations

• C/C++ Compatibility

C and C++ Are Siblings; “Silent” Differences; C Code That Is Not C++; C++ Code That Is Not C

• Advice

44.1. Introduction
This chapter discusses the differences between Standard C++ (as defined by ISO/IEC 14882-2011) and earlier versions (such as ISO/IEC 14882-1998), Standard C (as defined by ISO/IEC 9899-2011) and earlier versions (such as Classic C). The purposes are

• To concisely list what is new in C++11

• To document differences that can cause problems for a programmer

• To point to ways of dealing with problems

Most compatibility problems surface when people try to upgrade a C program to a C++ program, try to port a C++ program from an older version of C++ to a newer one (e.g., C++98 to C++11), or try to compile C++ using modern features with an older compiler. The aim here is not to enumerate every possible compatibility problem but rather to list the most frequently occurring problems and present their standard solutions.

When you look at compatibility issues, a key question to consider is the range of implementations under which a program needs to work. For learning C++, it makes sense to use the most complete and helpful implementation. For delivering a product, a more conservative strategy might be in order to maximize the number of systems on which the product can run. In the past, this has been a reason (and more often just an excuse) to avoid C++ features deemed novel. However, implementations are converging, so the need for portability across platforms is less cause for extreme caution than it once was.

44.2. C++11 Extensions
First, I list the language features and standard-library components that have been added to C++ for the C++11 standard. Next, I discuss ways of coping with older versions (notably C++98).

44.2.1. Language Features
Looking at a list of language features can be quite bewildering. Remember that a language feature is not meant to be used in isolation. In particular, most features that are new in C++11 make no sense in isolation from the framework provided by older features. The order is roughly that of first occurrence in this book:

[1] Uniform and general initialization using {}-lists (§2.2.2, §6.3.5)

[2] Type deduction from initializer: auto (§2.2.2, §6.3.6.1)

[3] Prevention of narrowing (§2.2.2, §6.3.5)

[4] Generalized and guaranteed constant expressions: constexpr (§2.2.3, §10.4, §12.1.6)

[5] Range-for-statement (§2.2.5, §9.5.1)

[6] Null pointer keyword: nullptr (§2.2.5, §7.2.2)

[7] Scoped and strongly typed enums: enum class (§2.3.3, §8.4.1)

[8] Compile-time assertions: static_assert (§2.4.3.3, §24.4)

[9] Language mapping of {}-list to std::initializer_list (§3.2.1.3, §17.3.4)

[10] Rvalue references (enabling move semantics; §3.3.2, §7.7.2)

[11] Nested template arguments ending with >> (no space between the >s; §3.4.1)

[12] Lambdas (§3.4.3, §11.4)

[13] Variadic templates (§3.4.4, §28.6)

[14] Type and template aliases (§3.4.5, §6.5, §23.6)

[15] Unicode characters (§6.2.3.2, §7.3.2.2)

[16] long long integer type (§6.2.4)

[17] Alignment controls: alignas and alignof (§6.2.9)

[18] The ability to use the type of an expression as a type in a declaration: decltype (§6.3.6.1)

[19] Raw string literals (§7.3.2.1)

[20] Generalized POD (§8.2.6)

[21] Generalized unions (§8.3.1)

[22] Local classes as template arguments (§11.4.2, §25.2.1)

[23] Suffix return type syntax (§12.1.4)

[24] A syntax for attributes and two standard attributes: [[carries_dependency]] (§41.3) and [[noreturn]] (§12.1.7)

[25] Preventing exception propagation: the noexcept specifier (§13.5.1.1)

[26] Testing for the possibility of a throw in an expression: the noexcept operator (§13.5.1.1)

[27] C99 features: extended integral types (i.e., rules for optional longer integer types; §6.2.4); concatenation of narrow/wide strings; __func__ and __STDC_HOSTED__ (§12.6.2); _Pragma(X) (§12.6.3); vararg macros and empty macro arguments (§12.6)

[28] __func__ (§12.6.2)

[29] inline namespaces (§14.4.6)

[30] Delegating constructors (§17.4.3)

[31] In-class member initializers (§17.4.4)

[32] Control of defaults: default (§17.6) and delete (§17.6.4)

[33] Explicit conversion operators (§18.4.2)

[34] User-defined literals (§19.2.6)

[35] More explicit control of template instantiation: extern templates (§26.2.2)

[36] Default template arguments for function templates (§25.2.5.1)

[37] Inheriting constructors (§20.3.5.1)

[38] Override controls: override and final (§20.3.4)

[39] Simpler and more general SFINAE rule (§23.5.3.2)

[40] Memory model (§41.2)

[41] Thread-local storage: thread_local (§42.2.8)

I have not tried to list every minute change to C++98 in C++11. A historical perspective on these features can be found in §1.4.

44.2.2. Standard_Library Components
The C++11 additions to the standard library come in two forms: new components (such as the regular expression matching library) and improvements to C++98 components (such as move constructors for containers).

[1] initializer_list constructors for containers (§3.2.1.3, §17.3.4, §31.3.2)

[2] Move semantics for containers (§3.3.1, §17.5.2, §31.3.2)

[3] A singly-linked list: forward_list (§4.4.5, §31.4.2)

[4] Hash containers: unordered_map, unordered_multimap, unordered_set, and unordered_multiset (§4.4.5, §31.4.3)

[5] Resource management pointers: unique_ptr, shared_ptr, and weak_ptr (§5.2.1, §34.3)

[6] Concurrency support: thread (§5.3.1, §42.2), mutexes (§5.3.4, §42.3.1), locks (§5.3.4, §42.3.2), and condition variables (§5.3.4.1, §42.3.4)

[7] Higher-level concurrency support: packaged_thread, future, promise, and async() (§5.3.5, §42.4)

[8] tuples (§5.4.3, §28.5, §34.2.4.2)

[9] Regular expressions: regex (§5.5, Chapter 37)

[10] Random numbers: uniform_int_distribution, normal_distribution, random_engine, etc. (§5.6.3, §40.7)

[11] Integer type names, such as int16_t, uint32_t, and int_fast64_t (§6.2.8, §43.7)

[12] A fixed-sized contiguous sequence container: array (§8.2.4, §34.2.1)

[13] Copying and rethrowing exceptions (§30.4.1.2)

[14] Error reporting using error codes: system_error (§30.4.3)

[15] emplace() operations for containers (§31.3.6)

[16] Wide use of constexpr functions

[17] Systematic use of noexcept functions

[18] Improved function adaptors: function and bind() (§33.5)

[19] string to numeric value conversions (§36.3.5)

[20] Scoped allocators (§34.4.4)

[21] Type traits, such as is_integral and is_base_of (§35.4)

[22] Time utilities: duration and time_point (§35.2)

[23] Compile-time rational arithmetic: ratio (§35.3)

[24] Abandoning a process: quick_exit (§15.4.3)

[25] More algorithms, such as move(), copy_if(), and is_sorted() (Chapter 32)

[26] Garbage collection ABI (§34.5)

[27] Low-level concurrency support: atomics (§41.3)

More information about the standard library can be found in

• Chapter 4, Chapter 5, and Part IV

• Implementation technique examples: vector (§13.6), string (§19.3), and tuple (§28.5)

• The emerging specialized C++11 standard-library literature, such as [Williams,2012]

• A brief historical perspective can be found in §1.4.

44.2.3. Deprecated Features
By deprecating a feature, the standards committee expresses the wish that the feature will go away (§iso.D). However, the committee does not have a mandate to immediately remove a heavily used feature – however redundant or dangerous it may be. Thus, a deprecation is a strong hint to avoid the feature. It may disappear in the future. Compilers are likely to issue warnings for uses of deprecated features.

• Generation of the copy constructor and the copy assignment is deprecated for a class with a destructor.

• It is no longer allowed to assign a string literal to a char* (§7.3.2).

• C++98 exception specifications are deprecated:

     void f() throw(X,Y);  // C++98; now deprecated
The support facilities for exception specifications, unexcepted_handler, set_unexpected(), get_unexpected(), and unexpected(), are similarly deprecated. Instead, use noexcept (§13.5.1.1).

• Some C++ standard-library function objects and associated functions are deprecated: unary_function, binary_function, pointer_to_unary_function, pointer_to_binary_function, ptr_fun(), mem_fun_t, mem_fun1_t, mem_fun_ref_t, mem_fun_ref1_t, mem_fun(), const_mem_fun_t, const_mem_fun1_t, const_mem_fun_ref_t, const_mem_fun_ref1_t, binder1st, bind1st(), binder2nd, bind2nd(). Instead, use function and bind() (§33.5).

• The auto_ptr is deprecated. Instead, use unique_ptr (§5.2.1, §34.3.1).

In addition, the committee did remove the essentially unused export feature, because it was complex and not shipped by the major vendors.

C-style casts should have been deprecated when the named casts (§11.5.2) were introduced. Programmers should seriously consider banning C-style casts from their own programs. Where explicit type conversion is necessary, static_cast, reinterpret_cast, const_cast, or a combination of these can do what a C-style cast can. The named casts should be preferred because they are more explicit and more visible.

44.2.4. Coping with Older C++ Implementations
C++ has been in constant use since 1983 (§1.4). Since then, several versions have been defined, and many separately developed implementations have emerged. The fundamental aim of the standards effort was to ensure that implementers and users would have a single definition of C++ to work from. From 1998, programmers could rely on the ISO C++98 standard, and now we have the ISO C++11 standard.

Unfortunately, it is not uncommon for people to take their first serious look at C++ using a five-year-old implementation. The typical reason is that such implementations are widely available and free. Given a choice, no self-respecting professional would touch such an antique. Also, many modern quality implementations are available for free. For a novice, older implementations come with serious hidden costs. The lack of language features and library support means that the novice must struggle with problems that have been eliminated in newer implementations. Using a feature-poor older implementation, especially if guided by an antique tutorial, warps the novice’s programming style and gives a biased view of what C++ is. The best subset of C++ to initially learn is not the set of low-level facilities (and not the common C and C++ subset; see §1.3). In particular, to ease learning and to get a good initial impression of what C++ programming can be, I recommend relying on the standard library, and to heavily use classes, templates, and exceptions.

There are still places, where for political reasons or lack of suitable tool chains, C is preferred over C++. If you must use C, write in the common subset of C and C++. That way, you gain some type safety, increase portability, and will be ready when C++ features become available to you. See also §1.3.3.

Use an implementation that conforms to the standard wherever possible, and minimize the reliance on implementation-defined and undefined aspects of the language. Design as if the full language were available, and only use workarounds when necessary. This leads to better organized and more maintainable programs than designing for a lowest-common-denominator subset of C++. Also, use implementation-specific language extensions only when necessary. See also §1.3.2.

44.3. C/C++ Compatibility
With minor exceptions, C++ is a superset of C (meaning C11, defined by ISO/IEC 9899:2011(E)). Most differences stem from C++’s greater emphasis on type checking. Well-written C programs tend to be C++ programs as well. A compiler can diagnose every difference between C++ and C. The C99/C++11 incompatibilities are listed in §iso.C. At the time of writing, C11 is still very new and most C code is Classic C or C99.

44.3.1. C and C++ Are Siblings
Classic C has two main descendants: ISO C and ISO C++. Over the years, these languages have evolved at different paces and in different directions. One result of this is that each language provides support for traditional C-style programming in slightly different ways. The resulting incompatibilities can make life miserable for people who use both C and C++, for people who write in one language using libraries implemented in the other, and for implementers of libraries and tools for C and C++.

How can I call C and C++ siblings? Clearly, C++ is a descendant of C. However, look at a simplified family tree:



A solid line means a massive inheritance of features, a dashed line a borrowing of major features, and a dotted line a borrowing of minor features. From this, ISO C and ISO C++ emerge as the two major descendants of K&R C, and as siblings. Each carries with it the key aspects of Classic C, and neither is 100% compatible with Classic C. I picked the term “Classic C” from a sticker that used to be affixed to Dennis Ritchie’s terminal. It is K&R C plus enumerations and struct assignment.

Incompatibilities are nasty for programmers in part because they create a combinatorial explosion of alternatives. Consider a simple Venn diagram:



The areas are not to scale. Both C++11 and C11 have most of K&R C as a subset. C++11 has most of C11 as a subset. There are features belonging to most of the distinct areas. For example:

C89 only

Call of undeclared function

C99 only

Variable-length arrays (VLAs)

C++ only

Templates

C89 and C99

Algol-style function definitions

C89 and C++

Use of the C99 keyword restrict as an identifier

C++ and C99

// comments

C89, C++, and C99

structs

C++11 only

Move semantics (using rvalue references; &&)

C11 only

Type-generic expressions using the _Generic keyword

C++11 and C11

Atomics

Note that differences between C and C++ are not necessarily the result of changes to C made in C++. In several cases, the incompatibilities arise from features adopted incompatibly into C long after they were common in C++. Examples are the ability to assign a T* to a void* and the linkage of global consts [Stroustrup,2002]. Sometimes, a feature was even incompatibly adopted into C after it was part of the ISO C++ standard, such as details of the meaning of inline.

44.3.2. “Silent” Differences
With a few exceptions, programs that are both C++ and C have the same meaning in both languages. Fortunately, these exceptions (often referred to as silent differences) are rather obscure:

• In C, the size of a character constant and of an enumeration equals sizeof(int). In C++, sizeof('a') equals sizeof(char).

• In C, an enumerator is an int, whereas a C++ implementation is allowed to choose whatever size is most appropriate for an enumeration (§8.4.2).

• In C++, the name of a struct is entered into the scope in which it is declared; in C, it is not. Thus, the name of a C++ struct declared in an inner scope can hide the name in an outer scope. For example:

Click here to view code image

     int x[99];
     void f()
     {
          struct x { int a; };
          sizeof(x);             /* size of the array in C, size of the struct in C++ */
          sizeof(struct x);      /* size of the struct */
     }
44.3.3. C Code That Is Not C++
The C/C++ incompatibilities that cause most real problems are not subtle. Most are easily caught by compilers. This section gives examples of C code that is not C++. Most are deemed poor style or even obsolete in modern C. A comprehensive list of incompatibilities can be found in §iso.C.

• In C, most functions can be called without a previous declaration. For example:

Click here to view code image

     int main()      // not C++; poor style in C
     {
          double sq2 = sqrt(2);                       /* call undeclared function */
          printf("the square root of 2 is %g\n",sq2); /* call undeclared function */
     }
Complete and consistent use of function declarations (function prototypes) is generally recommended for C. Where that sensible advice is followed, and especially where C compilers provide options to enforce it, C code conforms to the C++ rule. Where undeclared functions are called, you have to know the functions and the rules for C pretty well to know whether you have made a mistake or introduced a portability problem. For example, the previous main() contains at least two errors as a C program.

• In C, a function declared without specifying any argument types can take any number of arguments of any type at all.

Click here to view code image

     void f();   /* argument types not mentioned */

     void g()
     {
          f(2);     /* poor style in C; not C++ */
     }
Such use is deemed obsolete in ISO C.

• In C, functions can be defined using a syntax that optionally specifies argument types after the list of arguments:

     void f(a,p,c) char *p; char c; { /* ... */ }          /* C; not C++ */
Such definitions must be rewritten:

     void f(int a, char* p, char c) { /* ... */ }
• In C, structs can be defined in return type and argument type declarations. For example:

Click here to view code image

     struct S { int x,y; } f();         /* C; not C++ */
     void g(struct S { int x,y; } y);   /* C; not C++ */
The C++ rules for defining types make such declarations useless, and they are not allowed.

• In C, integers can be assigned to variables of enumeration type:

Click here to view code image

     enum Direction { up, down };
     enum Direction d = 1;             /* error: int assigned to Direction; OK in C */
• C++ provides many more keywords than C does. If one of these appears as an identifier in a C program, that program must be modified to make it a C++ program:

C++ Keywords That Are Not C Keywords

alignas

alignof

and

and_eq

asm

bitand

bitor

bool

catch

char16_t

char32_t

class

compi

const_cast

constexpr

decltype

delete

dynamic_cast

explicit

false

friend

inline

mutable

namespace

new

noexcept

not

not_eq

nullptr

operator

or_eq

private

protected

public

reinterpret_cast

static_assert

static_cast

template

this

thread_local

throw

true

try

typeid

typename

using

virtual

wchar_t

xor

xor_eq

In addition, the word export is reserved for future use. C99 adopted inline.

• In C, some of the C++ keywords are macros defined in standard headers:

C++ Keywords That Are C Macros

and

and_eq

bitand

bitor

bool

compl

false

not

not_eq

or

or_eq

true

wchar_t

xor

xor_eq

This implies that in C they can be tested using #ifdef, redefined, etc.

• In C, a global data object may be declared several times in a single translation unit without using the extern specifier. As long as at most one such declaration provides an initializer, the object is considered defined only once. For example:

Click here to view code image

     int i;
     int i; /* just another declaration of a single integer "i"; not C++ */
In C++, an entity must be defined exactly once; §15.2.3.

• In C, a void* may be used as the right-hand operand of an assignment to or initialization of a variable of any pointer type; in C++ it may not (§7.2.1). For example:

Click here to view code image

     void f(int n)
     {
          int* p = malloc(n*sizeof(int)); /* not C++; in C++, allocate using "new" */
     }
This is probably the single most difficult incompatibility to deal with. Note that the implicit conversion of a void* to a different pointer type is not in general harmless:

Click here to view code image

     char ch;
     void* pv = &ch;
     int* pi = pv;          // not C++
     *pi = 666;             // overwrite ch and other bytes near ch
If you use both languages, cast the result of malloc() to the right type. If you use only C++, avoid malloc().

• In C, the type of a string literal is “array of char,” but in C++ it is “array of const char,” so:

Click here to view code image

     char* p = "a string literal is not mutable";       // error in C++; OK in C
     p[7] = 'd';
• C allows transfer of control to a labeled statement (a switch or a goto; §9.6) to bypass an initialization; C++ does not. For example:

     goto foo;                 // OK in C; not C++
      //...
     {
          int x = 1;
     foo:
          if (x!=1) abort();
          /* ... */
     }
• In C, a global const by default has external linkage; in C++ it does not and must be initialized, unless explicitly declared extern (§7.5). For example:

     const int ci;      // OK in C; const not initialized error in C++
• In C, names of nested structures are placed in the same scope as the structure in which they are nested. For example:

Click here to view code image

     struct S {
          struct T { /* ... */ } t;
           //...
     };

     struct T x;       // OK in C, meaning "S::T x;"; not C++
• In C++, the name of a class is entered into the scope in which it is declared; thus it cannot have the same name as another type declared in that scope. For example:

Click here to view code image

     struct X { /* ... */ };
     typedef int X;           // OK in C; not C++
• In C, an array can be initialized by an initializer that has more elements than the array requires. For example:

Click here to view code image

     char v[5] = "Oscar";      // OK in C, the terminating 0 is not used; not C++
     printf("%s",v);           // likely disaster
44.3.3.1. “Classic C” Problems
Should you need to upgrade Classic C programs (“K&R C”) or C89 programs, a few more problems will emerge:

• C89 does not have the // comments (though most C89 compilers added them):

     int x;    // not C89
• In C89, the type specifier defaults to int (known as “implicit int”). For example:

Click here to view code image

     const a = 7;   /* in C89, type int assumed; not C++ or C99 */

     f() /* f()'s return type is int by default; not C++ or C99 */
     {
         /* .. */
     }
44.3.3.2. C Features Not Adopted by C++
A few additions to C99 (compared with C89) were deliberately not adopted in C++:

[1] Variable-length arrays (VLAs); use vector or some form of dynamic array

[2] Designated initializers; use constructors

The C11 features are too new to have been considered for C++, except for features such as the memory model and atomics (§41.3) that came from C++.

44.3.4. C++ Code That Is Not C
This section lists facilities offered by C++ but not by C (or adopted by C years after their introduction in C++, as marked, so that they may be missing in old C compilers). The features are sorted by purpose. However, many classifications are possible, and most features serve multiple purposes, so this classification should not be taken too seriously.

• Features primarily for notational convenience:

[1] // comments (§2.2.1, §9.7); added to C99

[2] Support for restricted character sets (§iso.2.4); partially added to C99

[3] Support for extended character sets (§6.2.3); added to C99

[4] Non-constant initializers for objects in static storage (§15.4.1)

[5] const in constant expressions (§2.2.3, §10.4.2)

[6] Declarations as statements (§9.3); added to C99

[7] Declarations in for-statement initializers (§9.5); added to C99

[8] Declarations in conditions (§9.4.3)

[9] Structure names need not be prefixed by struct (§8.2.2)

[10] Anonymous unions (§8.3.2); added to C11

• Features primarily for strengthening the type system:

[1] Function argument type checking (§12.1); partially added to C (§44.3.3)

[2] Type-safe linkage (§15.2, §15.2.3)

[3] Free-store management using new and delete (§11.2)

[4] const (§7.5, §7.5); partially added to C

[5] The Boolean type bool (§6.2.2); partially added to C99

[6] Named casts (§11.5.2)

• Facilities for user-defined types:

[1] Classes (Chapter 16)

[2] Member functions (§16.2.1) and member classes (§16.2.13)

[3] Constructors and destructors (§16.2.5, Chapter 17)

[4] Derived classes (Chapter 20, Chapter 21)

[5] virtual functions and abstract classes (§20.3.2, §20.4)

[6] Public/protected/private access control (§16.2.3, §20.5)

[7] friends (§19.4)

[8] Pointers to members (§20.6)

[9] static members (§16.2.12)

[10] mutable members (§16.2.9.3)

[11] Operator overloading (Chapter 18)

[12] References (§7.7)

• Features primarily for program organization (in addition to classes):

[1] Templates (Chapter 23)

[2] Inline functions (§12.1.3); added to C99

[3] Default arguments (§12.2.5)

[4] Function overloading (§12.3)

[5] Namespaces (§14.3.1)

[6] Explicit scope qualification (operator ::; §6.3.4)

[7] Exceptions (§2.4.3.1, Chapter 13)

[8] Run-Time Type Identification (Chapter 22)

[9] Generalized constant expressions (constexpr; §2.2.3, §10.4, §12.1.6)

The C++11 features listed in §44.2 are not in C.

The keywords added by C++ (§44.3.3) can be used to spot most C++-specific facilities. However, some facilities, such as function overloading and consts in constant expressions, are not identified by a keyword.

C++’s linking for functions is type-safe, whereas C’s rules do not require type safety when linking functions. This implies that on some (most?) implementations, a C++ function must be declared extern "C" to be compiled as C++ and also conform to C calling conventions (§15.2.5).

For example:

Click here to view code image

double sin(double);               // may not link to C code
extern "C" double cos(double);    // will link to C code
The __cplusplus macro can be used to determine whether a program is being processed by a C or a C++ compiler (§15.2.5).

In addition to the features listed, the C++ library (§30.1.1, §30.2) is mostly C++-specific. The C standard library offers type-generic macros in <tgmath.h> and _Complex number support in <complex.h>, approximating <complex>.

C also offers <stdbool.h>, offering _Bool and the alias bool to approximate C++’s bool.

44.4. Advice
[1] Before using a new feature in production code, try it out by writing small programs to test the standards conformance and performance of the implementations you plan to use; §44.1.

[2] For learning C++, use the most up-to-date and complete implementation of Standard C++ that you can get access to; §44.2.4.

[3] The common subset of C and C++ is not the best initial subset of C++ to learn; §1.2.3, §44.2.4.

[4] Prefer standard facilities to nonstandard ones; §36.1, §44.2.4.

[5] Avoid deprecated features such as throw-specifications; §44.2.3, §13.5.1.3.

[6] Avoid C-style casts; §44.2.3, §11.5.

[7] “Implicit int” has been banned, so explicitly specify the type of every function, variable, const, etc.; §44.3.3.

[8] When converting a C program to C++, first make sure that function declarations (prototypes) and standard headers are used consistently; §44.3.3.

[9] When converting a C program to C++, rename variables that are C++ keywords; §44.3.3.

[10] For portability and type safety, if you must use C, write in the common subset of C and C++; §44.2.4.

[11] When converting a C program to C++, cast the result of malloc() to the proper type or change all uses of malloc() to uses of new; §44.3.3.

[12] When converting from malloc() and free() to new and delete, consider using vector, push_back(), and reserve() instead of realloc(); §3.4.2, §43.5.

[13] When converting a C program to C++, remember that there are no implicit conversions from ints to enumerations; use explicit type conversion where necessary; §44.3.3, §8.4.

[14] A facility defined in namespace std is defined in a header without a suffix (e.g., std::cout is declared in <iostream>); §30.2.

[15] Use <string> to get std::string (<string.h> holds the C-style string functions); §15.2.4.

[16] For each standard C header <X.h> that places names in the global namespace, the header <cX> places the names in namespace std; §15.2.2.

[17] Use extern "C" when declaring C functions; §15.2.5.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


44. Compatibility
Index
The C++ Programming Language, 4th Edition
47h 26m remaining
Index
Knowledge is of two kinds. We know a subject ourselves, or we know where we can find information on it.

– Samuel Johnson

Token
!

logical not operator 274

logical_not 966

not 258

valarray 1170

!=

bitset 980

container 902

duration 1012

error_category 877

error_code 875

iterator 959

match_results 1060

not-equal operator 41

not_eq 258

not_equal_to 966

pair 984

regex_iterator 1067

regex_token_iterator 1068

rel_ops 1029

shared_ptr 992

string 1040

sub_match 1058

time_point 1014

tuple 985

unique_ptr 987

valarray 1170

””

empty string 177

operator 558

″

double quote 176

prefix 147

string literal 39, 176

## 338

# 338

,

and [] 183

no order 531

operator 260

predefined 531

prohibiting 531

$

character 155

regex 1052

$$ the $ character 1061

$& match 1061

$’ suffix 1061

$‘ prefix 1061

$1 first submatch 1061

%

duration 1012

format character 1255

modulus 966

modulus operator 41

remainder operator 41

valarray 1170

%=

duration 1011

operator 42

valarray 1167

&

address-of operator 45, 172

and 258

bit_and 966

bitset 979

bitwise and operator 274

predefined 531

prohibiting 531

reference to 45, 190

valarray 1170

&&

bitand 258

logical and operator 260, 274

logical_and 966

no order 531

rvalue reference 75, 194

valarray 1170

&=

and_eq 258

atomic<T> 1203

bitset 979

valarray 1167

’

character literal 143

prefix 147

single quote 143

(, regex 1052

()

and initializer 162

argument list 307

call operator 80, 550

function call 315

initialization problem 492

Matrix 833, 846

packaged_task 1238

vs. {} initialization 160

(?: lazy match 1056

), regex 1052

*

and [], -> and 553

contents-of operator 45

dereferencing operator 172

duration 1012

for pointer 181

indirection operator 172

iterator 959

Matrix 839

multiplies 966

multiply operator 40

pointer to 44

regex 1052

shared_ptr 992

unary 172

unique_ptr 987

valarray 1170

**, exponentiation 529

*=

duration 1011

scaling operator 42

valarray 1167

+

duration 1011–1012

for pointer 181

iterator

Matrix 836–837

plus 966

plus operator 41

pointer 182

regex 1052

string 1041

time_point 1014

user-defined operator 532, 575

valarray 1170

++

atomic<T> 1203

duration 1011

for pointer 181

increment operator 42, 276

iterator 959

regex_iterator 1067

regex_token_iterator 1068

user-defined operator 531, 554

+=

atomic<T> 1203

duration 1011

iterator 959

Matrix 836

operator 42, 244

string 1041

time_point 1014

user-defined operator 531, 536, 575

valarray 1167

-

duration 1011–1012

for pointer 181

iterator 959

minus 966

minus operator 40

negate 966

pointer 182

time_point 1014

valarray 1170

--


atomic<T> 1203

decrement operator 42, 276

duration 1011

for pointer 181

iterator 959

user-defined operator 554

-=

atomic<T> 1203

duration 1011

iterator

operator 244

time_point 1014

valarray 1167

->

dereference operator 552

iterator 959

member access operator 202

operator 466

regex_iterator 1067

regex_token_iterator 1068

required 758

return type 308

unique_ptr 987

user-defined operator 552

->*

operator 609

pointer to member 607

->~ 487

-1 142

.

floating-point 146

infix 147

member access 48

member access operator 202

operator 466

regex 1052

.*

operator 609

pointer to member 607

...

class 812

ellipsis 321

exception 369

typename 812

/

divide operator 41

divides 966

duration 1012

valarray 1170

/* comment 239, 338

// comment 39, 238

/=

duration 1011

scaling operator 42

valarray 1167

:

arithmetic-if ? 275

bit-field 212

derived class 579

for and 233

label 226

private 605

protected 605

public 66, 605

::

and virtual function, operator 589

namespace and 392

operator 466, 582

scope resolution operator 158, 468

using 403

::*, pointer to member 607

;, semicolon 153, 202, 226

<<=

bitset 979

valarray 1167

<<

bitset 979

error_code 875

example, Season 1121, 1152

exception and 1132

money_put and 1138

num_put and 1131

output operator 39

output ostream 91

resolution 533

shared_ptr 992

string 1042

tuple 817

valarray 1170

<=

container 902

duration 1012

less-than-or-equal operator 41

less_equal 966

pair 984

rel_ops 1029

shared_ptr 992

string 1040

sub_match 1058

time_point 1014

tuple 985

unique_ptr 987

valarray 1170

<

comparison 891

container 902

duration 1012

error_category 877

error_code 875

iterator 959

less 966

less-than operator 41

pair 984

shared_ptr 992

string 1040

sub_match 1058

time_point 1014

tuple 985

unique_ptr 987

valarray 1170

<>

specialization 682

template 731, 737

=

0 65, 598

and == 41

and ==, equivalence 510

atomic<T> 1200

auto 42

container 896

default 518, 524

delete 524

delete vs. missing 525

duration 1010

future 1241

independence 510

initialization problem 492

initializer 41

match_results 1060

Matrix 832

nested_exception 871

packaged_task 1238

pair 983

predefined 531

prohibiting 531

promise 1237

regex 1057

regex_iterator 1067

regex_token_iterator 1068

semantics 510

string 1039

sub_match 1058

time_point 1013

tuple 985

user-defined operator 575

valarray 1167, 1174

weak_ptr 994

=*

regex_iterator 1067

regex_token_iterator 1068

==

= and 41

bitset 980

container 902

duration 1012

equal operator 41

equal_to 966

equality without 892

equivalence = and 510

error_category 877

error_code 875

iterator 959

match_results 1060

pair 984

pointer 177

regex_iterator 1067

regex_token_iterator 1068

shared_ptr 992

string 1040

sub_match 1058

time_point 1014

tuple 985

unique_ptr 987

valarray 1170

>

container 902

duration 1012

greater 966

greater-than operator 41

iterator 959

pair 984

parentheses and 788

rel_ops 1029

shared_ptr 992

string 1040

sub_match 1058

time_point 1014

tuple 985

unique_ptr 987

valarray 1170

>=

container 902

duration 1012

greater-than-or-equal operator 41

greater_equal 966

iterator 959

pair 984

rel_ops 1029

shared_ptr 992

string 1040

sub_match 1058

time_point 1014

tuple 985

valarray 1170

>>

bitset 979

example, Season 1121, 1152

input cin 247

input istream 93

money_get and 1139

num_get and 1133

string 1042

valarray 1170

>>=

bitset 979

valarray 1167

?

:, arithmetic-if 275

regex 1052

?:

conditional expression 264, 275

operator 275

[, regex 1052

[&], lambda 294

[=], lambda 294

[]

, and 183

-> and * and 553

array 976

array of 44

bitset 979

container 900

design of 562

iterator

lambda 294

map 910

match_results 1060

Matrix 833

string 1041

subscript operator 174

subscript operator 50

valarray 1168

\”, double quote 143

\

backslash 39, 143

escape character 143

string literal 177

\’, single quote 143

-> and * and [] 553

, regex 1052

bit_xor 966

bitset 979

bitwise exclusive or operator 274

regex 1052

valarray 1170

xor 258

^=

atomic<T> 1203

bitset 979

valarray 1167

xor_eq 258

_

and suffix 822

underscore character 155

_1, placeholders 967

_2, placeholders 967

{, regex 1052

{}

ambiguity 286

and auto 289

block 157

construction 299

grouping 39

initialization 456, 489, 492

initialization, () vs. 160

initialization, Matrix 843

initializer 41, 175, 202

list 162, 286

list argument 319

Matrix 832

qualified 287

type of 289

unqualified 288

use of 159

|

bit_or 966

bitset 979

bitwise or operator 274

or 258

regex 1052

valarray 1170

|=

atomic<T> 1203

bitset 979

or_eq 258

valarray 1167

||

bitor 258

logical or operator 260, 274

logical_or 966

no order 531

valarray 1170

, regex 1052

bitset 979

bitwise complement operator 274

compl 258

destructor 63, 485

valarray 1170

0

= 65, 598

constant-expression 269

false and 139

null pointer 269

nullptr NULL 46

octal 145

octal digit 144

prefix 147

zero null 174

0X

hexadecimal 145

hexadecimal digit 144

0x prefix 147

1, true and 139

A
\a, alert 143

a, file mode 1254

%a format 1256

%A format 1256

ABA problem 1202

ABI and layout 211

abort() 372, 443

abs() 1163–1164

<cstdlib> 865

valarray 1170

absence of initializer 161

abstract

base class 598

class 598

class 65

class and design 617

class constructor 598

class destructor 598

class, use of 622

type 65

abstraction

data 11

elegant and efficient 9

mechanisms 5

access 571

., member 48

control 453, 600

control and base class 605

control and multiple inheritance 606

control, using-declaration and 606

function 216

Matrix 846

member 466

namespace 403

operator, design of 562

range 964

time, memory 1195

to facet 1119

accessor 541

accumulate() 701, 1177

acos(), valarray 1170

acquire

mutex 1220

operation 1199

acquisition

RAII, resource 112

resource 354

ad hoc concept 708

adaptor

container 887

function 967

iterator 960

adaptors

container 920

sequence 920

add_const 1023

adding

facet to locale 1117

to container 963

to sequence 963

to standard library 866

addition, pointer 182

add_lvalue_reference 1023

Add_reference 816

address 172

constant expression 267

addressing, unit of 172

address-of operator & 45, 172

add_rvalue_reference 1023

add_volatile 1023

adjacent_difference() 1179

adjacent_find() 933

ADL 754

– see argument-dependent lookup

and template 754

overaggressive 754

surprise 397

adopt_lock_t 1225, 1227

advance(), iterator 959

advice 31

aggregate

array 202

struct 202

aggregate() 701

aims

C++ design 12

C++11 27

alert \a 143

algorithm 102, 700

and iterator 927

and string 1044

complexity 931

container 103, 109, 411, 928

container, iterator 953

generalized numeric 1176

lifting and 701

modifying 935

nonmodifying 932

set 947

standard library 109

STL 927

<algorithm> 863, 927

alias

namespace 406

reopen, namespace 398

template 694

template member 676

trait 788

type 167, 784

typedef 168

using 83, 167

alignas, alignment 151

aligned_storage 1025

aligned_union 1025

alignment 151, 203

alignas 151

alignof 151

alignment_of 1022

alignof, alignment 151

all, catch 370

allocate array 281

allocate()

allocator 997

allocator_traits 998

allocateshared(), shared_ptr 992

allocation 63

and deallocation 277, 556

unit of 172

allocator 995

scoped 1000

allocator

allocate() 997

construct() 997

constructor 997

deallocate() 997

destroy() 997

max_size() 997

rebind 997

allocator_arg_t, tuple 985

allocator_traits

allocate() 998

construct() 998

deallocate() 998

destroy() 998

difference_type 998

propagate_on_* 998

allocator_type 896

all_of() 932

almost container 973

alnum, regex 1054

alpha, regex 1054

[[:alpha:]] letter 1054

alternative

implementation 620, 734

to macro 338

alternatives, lambda 291

always_noconv(), codecvt 1148

ambiguity

{} 286

point-of-instantiation 752

resolution, multiple inheritance 627

template 691

ambiguous type conversion 546

amortized complexity 895

analysis, requirements 704

and

& 258

operator &, bitwise 274

operator &&, logical 260, 274

and_eq, &= 258

Annemarie 180

anonymous

union 213, 216

union example 564

ANSI C++ 25

any(), bitset 980

Anya 500

any_of() 932

append(), string 1044

application operator 550

apply()

Matrix 837

valarray 1169

archetype 717

argc, main() argv 253

argument

{} list 319

array 318–319

array function 184

capture and 295

command-line 253

deducing template 685, 687

default 324

dependency on template 746

explicit template 686

formal 315

function 315

function template 686

int template 685

lambda template 727

list () 307

passing, function 315, 482

reference 191, 316

rvalue reference 317

template 722

template literal type 724

template operation as 725

template pointer 724

template string 724

template type 722

template value 724

to main() 253

type check, function 315

type conversion, function 315

type, difference from C 1274

types, virtual function 586

unnamed 308

value, example of default 457

variable number of 321

argument-dependent lookup 395, 754

arguments

constexpr function 266

overload resolution for multiple 329

reference 266

argv argc, main() 253

arithmetic

conversions, usual 258, 271

Matrix 836

mixed-mode 536

operation 966

operator 40

pointer 181, 276

ratio compile-time 1017

type 139

vector 131, 1166

arithmetic-if ? : 275

ARM 25

array 174

aggregate 202

allocate 281

argument 318–319

array of 183

array vs. 976

assignment 180

associative 550

by string, initialization of 176

deallocate 281

fixed-length 174

function argument 184

initializer 175

initializer, difference from C 1276

layout 183, 1172

multidimensional 1172, 1175

numeric 1166

of [] 44

of array 183

of reference 190

passing multidimensional 185

pointer and 179, 318

reference to 318

T[n] built-in 887

unique_ptr 988

valarray and 1166

zero-terminated 175

array 208, 974

[] 976

contiguous 887

data() 976

fill() 974

initialize 975

operation 974

representation 890

size() 976

swap() 974

tuple_element 977

tuple_size 977

vs. array 976

vs. vector 976

<array> 863

arrow operator 552

ASCII 137

character set 143

UTF-8 and 179

asin() 1163

valarray 1170

assembler 14, 23

Assert example 361

assert() 360

<cassert> 873

NDEBUG 873

Assert::dynamic() 361

<assert.h> 864

assertion 360

static_assert 57

assign, regex 1057

assign()

char_traits 1035

container 896

error_code 875

string 1044

Assignable 716

assignment

and exception 381

and slicing 513

and template, copy 679

array 180

copy 73, 381, 482, 508

function call and 192

move 75, 482, 515

must be member 531

of class object 507

operator 244, 536

to self 382, 508

valarray 1167, 1174

Assoc example 550

associative

array 550

array – see map

container 886, 909

container, ordered 909

container, unordered 887, 913

associativity of operator 257

asymptotic complexity 895

async()

launch 122

launch::async 1245

launch::deferred 1245

task launcher 1245

throws system_error 869

asynchronous event 348

at() 97

container 900

map 910

string 1041

atan() 1163

valarray 1170

atan2() 1163

valarray 1170

atexit()

and destructor 444

and exception 352

atomic operation 1196, 1198

atomic type 1200

<atomic> 865

atomic_compare_exchange_weak() 1204

atomic_flag

ATOMIC_FLAG_INIT 1205

clear() 1205

test_and_set() 1205

ATOMIC_FLAG_INIT, atomic_flag 1205

atomic_init() 1204

atomic_is_lock_free( 1204

atomic_load() 1204

atomic_signal_fence(), fence 1206

atomic_store() 1204

atomic<T* > 1204

atomic<T>

+= 1203

++ 1203

-- 1203

-= 1203

&= 1203

= 1200

^= 1203

|= 1203

compare_exchange_strong() 1200

compare_exchange_weak() 1200

constructor 1200

exchange() 1200

fetch_add() 1203

fetch_and() 1203

fetch_or() 1203

fetch_sub() 1203

fetch_xor() 1203

is_lock_free() 1200

load() 1200

store() 1200

atomic_thread_fence(), fence 1206

AT&T Bell Laboratories 25

atto 1018

attribute 314

auto 163

= 42

{} and 289

decltype 163

use of 160, 163

automatic

object 167

storage 167

auto_ptr, deprecated 1270

avoiding data race 1197

awk, regex 1057

axiom 713

B
\b, backspace 143

b, file mode 1254

\B, regex 1055

\b, regex 1055

back()

container 900

of queue 922

string 1041

back_inserter() 103, 963

back_insert_iterator 963

backslash \ 39, 143

backspace \b 143

bad_alloc 283

new throws 868

packaged_task throws 869

bad_cast 1119

dynamic_cast throws 869

bad_typeid, typeid() throws 869

base

and derived class 66

and member destructor 486

class 578–579

class, abstract 598

class, access control and 605

class lookup 756

class, override from virtual 638

class, private member of 581

class, repeated 630

class, template 756

class, virtual 632

conversion, derived to 580

copy of 509

copy of virtual 510

initializer 502

layout, virtual 633

optimization, empty 804

overloading and 693

private 605

protected 605, 618

replicated vs. virtual 636

type 153

Bases... example 813

basic

guarantee 353

guarantee, standard library 868

language facilities 4

basic, regex 1057

basic_regex 1056–1057

basic_string 1036

contiguously 887

generic conversion 1044

basic_string<char>, string 887

basic_string<char16_t>, u16string 887

basic_string<char32_t>, u32string 887

basic_string<wchar_t>, wstring 887

before/after 483

begin() 99, 103, 954

iterator 899

match_results 1060

nonmember 964

string 1044

unordered_map 920

valarray 1170

beginner, book for 37

behavior, undefined 136

Bell Laboratories, AT&T 25

benefits, template 721

Bernoulli distributions 1187

bernoulli_distribution 1187

Bessel 1164

beta() 1164

bibliography 32

bidirectional iterator 955

Bidirectional_iterator 716

bidirectional_iterator_tag 956

big-O notation 894

binary operator, user-defined 530

binary_search() 945

bind() 967

and overloading 968

bind1st() deprecated 967

binder 967

binding

name 746

strength, operator 257

binomial_distribution 1187

bit

field and bitwise logical operators 275

fields and concurrency 1194

order, bitset 978

order, vector<bool> 982

pattern 145

position 978

reference to 978

vector 274

bit_and & 966

bitand,&& 258

bit-field

: 212

bitset and 977

promotion 267

bitor, || 258

bit_or | 966

bits

in char 1161

in float 1161

in int 1161

bitset 887, 977

<< 979

<<= 979

!= 980

== 980

[] 979

>>= 979

&= 979

& 979

^= 979

^ 979

~ 979

| 979

|= 979

>> 979

and bit-field 977

and enum 977

and set 977

and vector<bool> 977

any() 980

bit order 978

constructor 978

count() 980

flip() 979

hash of 915, 980

input 979

none() 980

operation 979

output 979

reset() 979

set() 979

size() 980

test() 980

throws invalid_argument 868

throws out_of_range 868

throws overflow\rror 868

to_string() 980

to_ullong() 980

to_ulong() 980

<bitset> 863

bitwise

and operator & 274

complement operator ~ 274

exclusive or operator ^ 274

logical operators 274

logical operators, bit field and 275

or operator | 274

bit_xor ^ 966

blank, regex 1054

BLAS 1172

Blixen, Karen 2

bllock comment /* 238

block 227, 1210

{} 157

as function body, try 98, 371

try 55, 344

body

function 39, 307

loop 233

book

for beginner 37

organization of 4

structure of 4

_Bool 1278

bool 40, 139

conversion to 269

error_code to 875

hash of 915

nullptr 140

promotion 267

shared_ptr conversion to 992

unique_lock 1227

unique_ptr conversion to 987

bottom-up construction 486

branch, declaration on 229

break 231, 236, 244, 252

case and 230

statement 252

broken_promise 883

bucket

load 919

unordered_map 920

bucket(), unordered_map 920

bucket_count(), unordered_map 920

bucket_size(), unordered_map 920

buffer memory 1005

Buffer example 685, 724

built-in

array, T[n] 887

feature vs. technique 17

type 47, 139

type, constructor for 301, 494

type, move of 516

type, user-defined operator and 532

by value, return 517

_byname facet 1124

byte 150

C
C 23

and C++ 9, 19

and C++ compatibility 1271

and C++ global locale 1154

and C++, learning 18

and exception 350

argument type, difference from 1274

array initializer, difference from 1276

compatibility 14

concepts in 708

const linkage, difference from 1276

declaration and definition, difference from 1275

difference from 1271

enum, difference from 1275

function and exception 352

function call, difference from 1274

function definition, difference from 1274

headers 416

initialization and goto, difference from 1276

int implicit, difference from 1277

jump past initialization, difference from 1276

linkage to 428

locale 1114

macro, difference from 1275

programmer 19

sizeof, difference from 1273

struct name, difference from 1276

struct scope, difference from 1273, 1276

void * assignment, difference from 1275

with Classes 22

with Classes language features 23

with Classes standard library 25

C# programmer 20

.c file 425

.C file 425

%c format 1256

C++

and embedded systems 31

and infrastructure 10, 30

and libraries 31

and operating systems 30

and science 31

and Web 30

ANSI 25

C and 9, 19

compatibility, C and 1271

design aims 12

design of 9

earliest 12

feature summary 1277

general-purpose language 9

history 21

ideals 9

ISO 25, 135

large program and 16

learning 17, 1271

learning C and 18

meaning 23

programmer 19

pronunciation 23

pure 8

standardization 25

teaching and 17

timeline 22

tour of 37

use of 9, 30

C++-style thread support, C-style vs. 1192

C++03 25

C++0x, C++11 23, 27

C++11

aims 27

C++0x 23, 27

C++98 28

facilities, use of 8

language features 28

standard library 29

C++98 25

C++11 28

language features 26

standard library 26

C11 1271

C89 and C99 14, 1271

C99, C89 and 14, 1271

cache memory 1193

cache example 462

calculator example 242, 399–400, 431

call

(), function 315

by reference 191, 316

by value 316

function 315

of constructor 487

of destructor 487

of destructor, explicit 285

operator () 80, 550

callback 290, 615, 971

callC() example 350

call_from_C() example 350

call_once()

once_flag 1230

throws system_error 869

can’t use exception 349

capacity()

container 898

string 1040

capture

and argument 295

lambda 293

list 81

list, lambda 294

carriage return \r 143

[[carries_dependency]] 1200

CAS, compare-and-swap 1202

case, declaration in 232

case and break 230

<cassert> 864

assert() 873

cast

C-style 302

deprecated C-style 1271

function-style 303

named 301

catalog, message 1149

catch all 369

catch 367

all 370

clause 55, 344

every exception 98

throw and 344

catch(...) 98

category, facet 1124–1125

category, facet 1113

cauchy_distribution 1188

cbegin()

iterator 899

match_results 1060

string 1044

unordered_map 920

.cc file 425

<ccomplex> 866

<cctype> 864, 1034

ceil() 1163

cend()

iterator 899

match_results 1060

string 1044

unordered_map 920

centi 1018

cerr 91

<cerrno> 864

POSIX 880

<cfenv> floating-point environment 866

<cfloat> 865, 1163

change, incremental 1179

char 40, 140, 144, 150

bits in 1161

character type 141

range of 141

signed 140, 142

sizeof 150

char*, specialization and 736

char, unsigned 140, 142

char_16t 140

char_32t 140

character

$ 155

\, escape 143

%, format 1255

_ underscore 155

classification 1033, 1142, 1154

code conversion 1146

encoding, multibyte 1146

in name 155

integer value 141

literal’ 143

mask 1142

name U’, universal 144

name \u, universal 179

promotion 267

representation, converting 1146

set 137

set, ASCII 143

set, large 144

set, larger 178

special 143

string 864

thousands_sep() separator 1129

traits 1035

type 140, 1035

type char 141

CHAR_BIT 1162

char_traits 1035

assign() 1035

char_type 1035

compare() 1035

copy() 1035

eof() 1035

eq() 1035

eq_int_type() 1035

find() 1035

get_state() 1035

int_type() 1035

length() 1035

lt() 1035

move() 1035

not_eof() 1035

off_type 1035

pos_type 1035

state_type 1035

to_char_type() 1035

to_int_type() 1035

char_traits<char> 1035

char_type, char_traits 1035

check

sanity 363

template definition 717

checked pointer 555

checking

concept 709

range 174, 543

type 13

unit 818

chi_squared_distribution 1188

choice of default value 495

choosing

default operation 523

name 155

chrono 123

namespace 1009

<chrono> 118, 123, 863, 1009

cin 93

>>, input 247

value of 544

<cinttypes> 866

circular structures, shared_ptr 991

Circular_buffer example 603

clash, name 390

class 60

:, derived 579

abstract 598

and design, abstract 617

base 578–579

concept and 577

concrete 60

constructor, abstract 598

conversion of pointer to 580

derived 578

design questions 523

destructor, abstract 598

forward reference to 571

friend 572

hierarchy 583

hierarchy design 613

invariant 484

layout 580

member, constructor for 500

member of derived 581

member, private 453

member, public 453

member, template argument 748

object, assignment of 507

operations, set of 471

override from virtual base 638

pointer to 580

private member of base 581

repeated base 630

scope 157

storage 167

template 78, 670

template member 675

use of abstract 622

class 31, 48

... 812

abstract 65

abstract base 598

and concept 449

and struct 454

base and derived 66

concrete 470, 478

declaration 454

definition 454

facet 1118

final 592

hierarchy 68

interface 48

invariant 454

lambda and local 291

locale 1112

member 48

nested 469

recursion 794

string 561

struct and 206, 454

typename and 668

union and 215

user-defined type 450

vs. function requirement 706

classes, multiple implementation 624

classic C, locale 1114

classification, character 1033, 1142, 1154

class-oriented programming 11

cleanup, initialization and 354

clear()

atomic_flag 1205

container 898, 901

error_code 875

string 1040

<climits> 865, 1162

<clocale> 864

clock 1015

from_time_t() 1015

is_steady() 1015

now 1015

to_time_t() 1015

Clock example 635

clock timing 118

clone 596

close() 2019

close(), messages 1150

closure 854

lambda 291

type 297

cmatch 1060

<cmath> 128, 865, 1163

cntrl, regex 1054

code

bloat, curbing 732

complexity, function and 306

exception-safe 378

flexible composition of 741

code() system_error 878

codecvt

always_noconv() 1148

encoding() 1148

facet 1146

in() 1147

length() 1148

max_length() 1148

out() 1148

unshift() 1148

<codecvt> 864

codecvt_base result 1146

coercion 535

collate

compare() 1126–1127

do_compare() 1126

do_hash() 1126

do_transform() 1126

facet 1126

hash() 1126

regex 1057

transform() 1126–1127

collate_byname 1128

collating

order 1128

sequence 726

column(), Matrix 833, 846

combine() 1112

comma and subscripting 183

command-line argument 253

comment 238

// 39, 238

/* 338

nesting 240

Common 716

commonality 577

common_type 1025

communication, task 120

compactly stored, vector<bool> 887

compare()

char_traits 1035

collate 1126–1127

string 1048

sub_match 1058

compare-and-swap CAS 1202

compare_exchange_strong(), atomic<T> 1200

compare_exchange_weak(), atomic<T> 1200

comparison

< 891

container 902

criteria 726

default 891

locale used for string 1118

operator 41

requirement 891

string 1126

user-supplied 891

compatibility

C 14

C and C++ 1271

compilation

of template, separate 26

separate 52, 420

unit of 419

compile time, header and 435

compiler 38

compile-time

arithmetic, ratio 1017

computation 124, 781

control structure 789

evaluation 43

IF 794

if 790

iteration 793

programming 780

recursion 793

selection 789

switch 791

type checking 13

type safety 264

vs. run-time 790

compl, ~ 258

complement operator ~, bitwise 274

complete

encapsulation 482

specialization 731

complex 61, 129, 535

_Complex 1278

complex example 542

<complex> 128–129, 865

complexity

algorithm 931

amortized 895

asymptotic 895

function and code 306

guarantee 894

operation 894

composite operator 536

composition

namespace 407, 409

of code, flexible 741

compositor 855

compound statement 227

computation

compile-time 124, 781

conditional 339

numerical 128

concept 704

ad hoc 708

and class 577

and predicate 672

and requirement 672

checking 709

class and 449

constraint 708

constraints check 715

discovering a 704

locale 1109

multi-argument 714

Range 929

semantics and 709

value 715

concepts 708

Enable_if and 799

history 29

in C 708

static_assert and 709

concrete

class 470, 478

class 60

type 60, 470

type, reuse of 478

concurrency 114, 1191, 1209

bit fields and 1194

initialization and 443

task-based 1235

condition 226

declaration in 232

pointer as 228

variable, mutex and 1219

conditional

computation 339

definition 795–796

evaluation 313

expression, ?: 264, 275

Conditional if 790

conditional 1025

condition_variable 119

constructor 1231

destructor 1231

native_handle() 1231

native_handle_type 1231

notify_all() 1231

notify_one() 1231

throws system_error 869

wait() 1231

wait_for() 1231

wait_until() 1231

<condition_variable> 119, 865

condition_variable_any 1235

consistency, sequential 1196

consistent specialization 735

*const 154, 187

const 186

and linkage 422

constexpr 262, 264

C-style string and 176

function 307

function argument 307

immutability 42

in constant expression 264

linkage, difference from C 1276

member 506

member function 461

physical and logical 462

pointer 187

pointer to 187

reference 190

Tuple example 807

variable 461

constant 186

enumerator as in-class 506

expression 43, 262

expression, address 267

expression, const in 264

in-class definition of 506

member 506

symbolic 264

time 894

constant-expression 0 269

const_cast 298, 302

constexpr

and reference 312

const 262, 264

function 43, 264, 307, 311

function arguments 266

immutability 42

type function 786

const_iterator 106, 896

const_local_iterator 896

const_pointer 896

const_pointer_cast(), shared_ptr 992

constraint 708

concept 708

constraints

check 709

check concept 715

const_reference const_value_type& 896

const_reverse_iterator 896

construct()

allocator 997

allocator_traits 998

construction

{} 299

bottom-up 486

explicit 487

order 487

partial 357

constructor 49, 455, 484

abstract class 598

allocator 997

and copy, default 509

and destructor 24, 483, 485, 500, 582

and template, copy 679

and type conversion 538, 543

and virtual base 634

atomic<T> 1200

bitset 978

call of 487

condition_variable 1231

container 896

copy 73, 482, 508

default 61, 493

delegating 502–503

destructor, RAII 486

disambiguation, {}-list 496

duration 1010

exception and 356–357

explicit 457, 499

for built-in type 301, 494

for class member 500

forwarding 503

future 1241

inheriting 594

initialization without 489

initialize by 492

initializer-list 64, 495

invariant and 56

{}-list 495

locale 1116

map 910

match_results 1060

move 75, 482, 515

mutex 1221

packaged_task 1238

pair 983

POD and 212

pointer to 597

promise 1237

protected 1119

regex_iterator 1067

regex_token_iterator 1068

return type 484

shared_ptr 992

simplifies implementation 473

string 1039

thread 1210, 1212

timed_mutex 1224

time_point 1013

tuple 984

unique_lock 1227

unique_ptr 987

unordered_map 915

virtual 597, 623

weak_ptr 994

constructors, initialization using 491

const_value_type&, const_reference 896

consume operation 1199

container 62, 78, 95

!= 902

[] 900

> 902

<= 902

< 902

>= 902

= 896

== 902

adaptor 887

adaptors 920

adding to 963

algorithm 103, 109, 411, 928

almost 973

assign() 896

associative 886, 909

at() 900

back() 900

capacity() 898

clear() 898, 901

comparison 902

constructor 896

destructor 896

emplace() 901

emplace_back() 900

empty() 898

erase() 901

front() 900

hash 887

implementation of 888

insert() 901

iterator algorithm 953

maxsize() 898

member types 896

object in 97

operation 893

operation overview 893

ordered 909

ordered associative 909

overview 101, 885

pop_back() 900

push_back() 900

representation of 888

reserve() 898

resize() 898

return 104

sequence 886

shrinktofit() 898

size() 898

sort() 124

standard library 101

subscripting 900

swap() 902

unordered 909

unordered associative 887, 913

containers

almost 887

list of 863

contents-of operator * 45

context

of template definition 746

of template instantiation 746

contextual

keyword final 593

keyword override 590

contiguous

array 887

vector 886

contiguously, basic_string 887

continue 237, 252

statement 252

contravariance 610

control

override 589

structure, compile-time 789

controlled statement 233

convenience

and orthogonality 862

vs. safety 405

convention

not-found 928

::type 784

::value 786

conversion

ambiguous type 546

basic_string generic 1044

character code 1146

constructor and type 538, 543

delete 524

derived to base 580

explicit 457

explicit type 298

floating-point 269

implicit 457

implicit type 150, 267, 544, 575

integer 268

narrowing 41, 267

of operand 539

of pointer to class 580

operator, explicit 545

operator, type 543

pointer 269

signed unsigned integer 268

string numeric 1042

template and 673

to() 730

to bool 269

to floating-point 270

to integer type 270

to integral 270

type 543

undefined enum 223

undefined enum class 221

user-defined type 535, 575, 678

conversions, usual arithmetic 258, 271

Convertible 716

converting character representation 1146

copy 72, 452, 507

and exception 364

and hierarchy 77

and move 507

and throw 364, 507

assignment 73, 381, 482, 508

assignment and template 679

constructor 73, 482, 508

constructor and template 679

cost of 74

deep 511

default constructor and 509

destructor and 486

elimination of 853

initialization 458

initialization, initializer_list and 498

memberwise 453, 482, 519

move by 516

of base 509

of exception 368

of virtual base 510

on write 512

pointer and 510

requirement 890

semantics 510

shallow 511

shared_ptr and 511

strcpy() string 277

swap() and 514

union 215

_copy suffix 938

copy() 936

char_traits 1035

string 1041

copyable type, trivially 211

Copyable 716

copy_backward() 936

copy_if() 936

copy_n() 936

core language, ISO 38

cos() 1163

valarray 1170

cosh() 1163

valarray 1170

cost

of copy 74

of exception 351

count() 933

bitset 980

count_if() 108, 933

Courtney 500

cout 91

output 39

covariant return 596

Cowboy example 629

__cplusplus 340, 429

.cpp file 425

crbegin()

iterator 899

string 1044

creation, localization of object 623

cref() 968

cregex_iterator 1067

cregex_token_iterator 1068

crend()

iterator 899

string 1044

criteria, standard library 861

critique, design 616, 622

Crowl, Lawrence 1200

<csetjmp> 865, 1264

cshift() 1169

<csignal> 865

<cstdalign> 866

<cstdarg> 865

<cstdbool> 866

<cstddef> 150

<cstdint> 865

<cstdio> 416, 428, 864

<cstdlib> 444, 863–865, 1164

abs() 865

div() 865

c_str(), string 1041

<cstring> 864

C-style

cast 302

cast, deprecated 1271

error handling 1163

string 46, 175

string and const 176

vs. C++-style thread support 1192

<ctgmath>

<ctime> 863, 865

ctype

facet 1143

is() 1143

narrow() 1145

scan_is() 1144

scan_not() 1144

tolower() 1144

toupper() 1144

widen() 1144

ctype_base 1142

<ctype.h> 864

<cuchar> 864

cultural preference, locale 1109

curbing code bloat 732

currency

symbol, international 1136

symbol, local 1136

symbol, standard 1136

current_exception() 374, 870

curr_symbol(), moneypunct 1136

Currying 967

customization point 737

cv_status::notimeout 1231

cv_status::timeout 1231

Cvt_to_upper example 1148

<cwchar> 864, 1124

<cwctype> 864

.cxx file 425

D
%d format 1256

\D, regex 1054

d, regex 1054

\d, regex 1054

daemon 1215

Darwin, Charles 858

data

abstraction 11

member, template 675

race 115, 1197

race, avoiding 1197

race, initialization and 443

race, static variable 314

struct 454

data()

array 976

string 1041

Date example 470

__DATE__ 340

DBL_MINEXP 1162

d.count(), duration 1010

D&E 10, 22

deadlock 118

mutex and 1223

deallocate array 281

deallocate()

allocator 997

allocator_traits 998

deallocation 63

allocation and 277, 556

debugging 454

deca 1018

decay 1023

deci 1018

decimal 145

decimal_point() 1129

moneypunct 1136

declaration 40, 151, 153

and definition, difference from C 1275

and definition, namespace member 400

class 454

enum class 221

function 305, 307

in case 232

in condition 232

in for statement 235

interface 51

on branch 229

point of 158

statement 227

struct name 205

using 393

declarations, keeping consistent 424

declarator operator 46, 154

declare_no_pointers() 1004

declare_reachable() 1004

decltype 165

auto 163

declval 1027

decrement

increment and 554

operator -- 42, 276

deducing template argument 685, 687

deduction

reference 688

rvalue-reference 688

deep copy 511

default

argument 324

argument value, example of 457

comparison 891

constructor 61, 493

constructor and copy 509

initialization 161

initialization union 216

initializer 159

member initialization 501

memberwise 519

operation, choosing 523

operation, generate 517

operation, invariant and 520

operations, using 520

operator, meaning of 519

template argument 728

underlying type 219, 223

value 473–474, 490

value, choice of 495

default 231, 244

= 518, 524

default_error_condition()

error_category 877

error_code 875

default_random_engine 1183

defer_lock_t 1227, 1229

#define 336

defining a template 669

definition 152

check, template 717

class 454

conditional 795–796

context of template 746

difference from C declaration and 1275

function 307

implementation 51

in-class 460

namespace member declaration and 400

of constant, in-class 506

of virtual function 586

point of 204, 748

using directive and 408

degrees of exception safety 375

Delay 785

checking, ::type 784

type checking 784

Delayed 785

delays, shared_ptr 991

delegating constructor 502–503

delegation 554

delete element from sequence 938

delete

= 524

a function 524

an operation 77

and operator delete() 556

conversion 524

destructor and 488

double 279

free-store allocation 525

naked 64

nothrow 285

nullptr 279

operator 63, 277

placement 283

premature 279

stack allocation 525

vs. missing, = 525

delete(), operator 282

delete[] 281

nullptr 282

delete()[], operator 282

deleter 987

denorm_min() 1161

dependency

hardware 136

on template argument 746

dependent

name 746

name, template and 748

name, typename and 747

deprecated

auto_ptr 1270

bind1st() 967

C-style cast 1271

exception specification 1270

feature 1270

mem_fun() 967

mem_fun_ref() 967

deque

double-ended queue 886

operation 893

<deque> 863

dereference operator -> 552

dereferencing operator * 172

derivation, overloading and 693

derived

class 578

class : 579

class, base and 66

class, member of 581

to base conversion 580

design

abstract class and 617

aims, C++ 12

class hierarchy 613

criteria, locale 1111

critique 616, 622

ideals 10

of [] 562

of access operator 562

of C++ 9

questions, class 523

standard library 860–861

destroy()

allocator 997

allocator_traits 998

destruction

explicit 487

order 487

top-down 486

destructive read 194

destructor 63, 482

~ 63, 485

abstract class 598

and copy 486

and delete 488

and join(), thread 1215

and resource 485

and scope 488

and throw 354

atexit() and 444

base and member 486

call of 487

condition_variable 1231

constructor and 24, 483, 485, 500, 582

container 896

exception and 356

explicit call of 285

future 1241

match_results 1060

mutex 1221

packaged_task 1238

pair 983

promise 1237

RAII constructor 486

shared_ptr 992

string 1039

thread 1210, 1213

timed_mutex 1224

tuple 985

unique_lock 1227

unique_ptr 987

virtual 70, 488, 598, 619

weak_ptr 994

detach(), thread 1210, 1215

diagnostics 864

dictionary – see map

difference

from C 1271

from C argument type 1274

from C array initializer 1276

from C const linkage 1276

from C declaration and definition 1275

from C enum 1275

from C function call 1274

from C function definition 1274

from C initialization and goto 1276

from C int implicit 1277

from C jump past initialization 1276

from C macro 1275

from C sizeof 1273

from C struct name 1276

from C struct scope 1273, 1276

from C void * assignment 1275

silent 1273

Difference_Type 788

difference_type 896

allocator_traits 998

iterator_traits 957

of pointer 788

digit

0, octal 144

0X, hexadecimal 144

[[:digit:]] 1054

digit, regex 1054

[[:digit:]] digit 1054

digits 1161

digits10 1161

direct

initialization 458

initialization, initializer_list and 498

directed acyclic graph 583

directive, template instantiation 744

disambiguation

{}-list constructor 496

name 205

discard_block_engine 1184

discovering a concept 704

discrete_distribution 1188

discriminated union 217

disguised pointer 1003

dispatch

double 2018

tag 124, 957

distance(), iterator 959

distribution, random 129

distributions

Bernoulli 1187

normal 1188

Poisson 1187

sampling 1188

uniform 1186

div() 1164

<cstdlib> 865

divide operator / 41

divides / 966

div_t 1164

do statement 236, 250

do_compare(), collate 1126

do_hash(), collate 1126

domain error 1163

dominance 638

dot product 1179

do_transform(), collate 1126

double

delete 279

dispatch 2018

quote \” 143

quote ” 176

double 40, 146

sizeof 150

double-checked locking 1203

double-ended queue, deque 886

doubly-linked, list 886

do/undo 483

duck typing 700

duration 123

= 1010

-- 1011

++ 1011

== 1012

-= 1011

+= 1011

- 1011–1012

< 1012

% 1012

/= 1011

> 1012

<= 1012

* 1012

!= 1012

%= 1011

*= 1011

>= 1012

+ 1011–1012

/ 1012

constructor 1010

d.count() 1010

duration_cast() 1012

hours 1012

max() 1012

microseconds 1012

milliseconds 1012

min() 1012

minutes 1012

nanoseconds 1012

seconds 1012

time_point 1013

zero() 1012

duration_cast 123

duration_cast(), duration 1012

dynamic

memory 277

store 63

dynamic_cast 298

throws bad_cast 869

dynamic_pointer_cast(), shared_ptr 992

E
E infix 147

e, floating-point 146

%e format 1256

e infix 147

earliest C++ 12

ec.category() error_code 875

ECMAScript rules, format_default 1062

ECMAScript, regex 1057

EDOM 1163

efficiency and generality 862

efficient abstraction, elegant and 9

egrep, regex 1057

elegant and efficient abstraction 9

element

access, Tuple 806

from sequence, delete 938

requirements 97, 890

eliminate_duplicates() example 938

elimination

of copy 853

of temporary 853

ellipsis ... 321

elliptic 1164

else 228

embedded systems, C++ and 31

emphasis, examples and 7

emplace()

container 901

map 910

emplace_after(), forward_list 908

emplace_back(), container 900

emplace_front(), list 907

emplace_hint(), map 910

Employee example 578

empty

base optimization 804

sequence 954

statement 227

string ”” 177

empty()

container 898

match_results 1060

string 1040

Enable_if

and concepts 799

and overloading 801

implementation of 799

enable_if 795, 1025

notation 797

use 797

encapsulation, complete 482

encoding(), codecvt 1148

end() 99, 103, 954

iterator 899

match_results 1060

nonmember 964

string 1044

unordered_map 920

valarray 1170

#endif 339

enforcing invariant 359

engine, random 129

entanglement 511

and garbage collection 512

enum 201, 218

and enum class 218

and integer 223

bitset and 977

class 201

class and integer 221

class conversion, undefined 221

class declaration 221

class, enum and 218

class enumeration 50, 219

class, sizeof 222

class underlying type 219

conversion, undefined 223

difference from C 1275

enumeration 50

member 506

plain 222

range of 223

sizeof 223

switch and 231

underlying type 223

unnamed 224

user-defined operator 220

user-defined operator and 532

user-defined type 220

enumeration 218

enum 50

enum class 50, 219

switch on 219

enumerator 218

as in-class constant 506

scope 218

environment, <cfenv> floating-point 866

eof(), char_traits 1035

epsilon() 1161

eq(), char_traits 1035

eq_int_type(), char_traits 1035

equal operator == 41

equal() 934

equality without == 892

Equality_comparable 714, 716

equal_range() 126, 945

equal_to 887

== 966

equation, Matrix linear 849

equivalence

= and == 510

type 210, 673

equivalent() error_category 877

ERANGE 1163

erase() 99

container 901

string 1044

erase_after(), forward_list 908

erasure, type 733

errc

POSIX 880

systemcategory() 880

errno 350, 1163

<errno.h> 864

error

detection, template 674

domain 1163

exception and 345, 348

function size and 306

handling 54, 251

handling, C-style 1163

handling, hierarchical 350

handling, multilevel 350

handling, traditional 345

library and 344

linkage 421

mutex 1223

name lookup 674

range 1163

run-time 55, 344

state 346

syntax 674

type 674

value, return an 346

error_category 877

== 877

!= 877

< 877

default_error_condition() 877

equivalent() 877

message() 877

name() 877

value() 877

error_code 875

!= 875

< 875

== 875

<< 875

assign() 875

clear() 875

default_error_condition() 875

ec.category() 875

hash of 915

mapping 879

message() 875

=n() 875

to bool 875

value() 875

error_condition 878

error-handler function 346

escape character \ 143

essential operations 482, 517, 561

Estd sort() 411

evaluation

compile-time 43

conditional 313

order of 259

partial 967

short-circuit 229, 260

event

asynchronous 348

driven simulation 2018

exa 1018

example

anonymous union 564

Assert 361

Assoc 550

Bases... 813

Buffer 685, 724

cache 462

calculator 242, 399–400, 431

callC() 350

call_from_C() 350

Circular_buffer 603

Clock 635

complex 542

const Tuple 807

Cowboy 629

Cvt_to_upper 1148

Date 470

eliminate_duplicates() 938

Employee 578

Expr 596

File_ptr 357

find_all() 104

find_last() 962

getNth 806

guarded_thread 1214

Has_f 799

Hello, World! 39

Ival_box 614

Matrix 827

Matrix_ref 842

Money 1134

My_messages 1150

My_money_io 1137

My_punct 1129

of default argument value 457

of input 250

of operator overloading 561

of user-defined memory management 561

parallel find() 1246

printf() 809

Rand_int 130

Satellite 625

Season 1120

Season << 1121, 1152

Season >> 1121, 1152

SI units 818

Slice_iter 1173

sort() 333, 684

split() 394

Storable 632

String 668

String I/O 568

String_numput 1131

Sync_queue 1232

Tic_tac_toe 522

Tiny 543

Token 243

Token_stream 247

Tracer 483

Tuple 802

Tuple get() 806

Vec 97

Vector 730

Window 635

examples and emphasis 7

exception 55, 344, 347

... 369

and << 1132

and constructor 356–357

and destructor 356

and error 345, 348

and main() 98

and member 357

and member initialization 371

and new 357

and old code 349

and recursive function 348

and subobject 357

and thread 374

and time critical 349

assignment and 381

atexit() and 352

C and 350

C function and 352

can’t use 349

catch every 98

copy and 364

copy of 368

cost of 351

goto and 238

guarantee 353

packaged_task and 1238

propagation 870

qsort() and 352

runtime_error 1116

safe 353

safety, degrees of 375

safety, techniques for 375

specification 26, 367

specification, deprecated 1270

standard library 868

transparency 378

uncaught 372

exception hierarchy 870

<exception> 372, 864–865

exception_ptr 870

exceptions() 1132

exception-safe code 378

exchange(), atomic<T> 1200

exclusive or operator ^, bitwise 274

exercises – see www.stroustrup.com

exhaustion, free store 283

exit

from function 310

loop 236

exit() 443

exp(), valarray 1170

expired(), weak_ptr 994

explicit

call of destructor 285

construction 487

conversion 457

destruction 487

qualification 588

specialization 693

template argument 686

template instantiation 744

type conversion 298

explicit

constructor 457, 499

conversion operator 545

exponent, size of 1161

exponential_distribution 129, 1187

exponentiation

** 529

vector 1170

export 26, 156

removed 1270

Expr example 596

expr() 1163

expression

?: conditional 264, 275

address constant 267

const in constant 264

constant 43, 262

full 261

lambda 81, 290

statement and 225

extended integer 145

extended, regex 1057

extent 1022

extern 428

extern 421

external linkage 421

externally imposed layout 212

extreme_value_distribution 1187

F
F suffix 147

%f format 1256

%F format 1256

\f, formfeed 143

f suffix 147

fabs() 1163

facet

access to 1119

_byname 1124

category 1113

category 1124–1125

class 1118

codecvt 1146

collate 1126

ctype 1143

identifier id 1119

lifetime of 1119

locale and 1109, 1113

messages 1150

money_get 1138

moneypunct 1135

money_put 1137

numpunct 1129

num_put 1130

put() iterator 1130

Season_io, user-defined 1120

standard 1124

to locale, adding 1117

use of 1119

user-defined 1123

facilities

basic language 4

standard library 88, 860

use of C++11 8

factory 623

failed() 1132

failure

output 1132

precondition 359

false

and 0 139

false_type and 800

falsename() 1130

false_type and false 800

fault tolerance 350

feature

deprecated 1270

summary, C++ 1277

vs. technique, built-in 17

features

C with Classes language 23

C++11 language 28

C++98 language 26

portability and 1267

femto 1018

fence

atomic_signal_fence() 1206

atomic_thread_fence() 1206

fetch_add(), atomic<T> 1203

fetch_and(), atomic<T> 1203

fetch_or(), atomic<T> 1203

fetch_sub(), atomic<T> 1203

fetch_xor(), atomic<T> 1203

file

.c 425

.C 425

.cc 425

.cpp 425

.cxx 425

.h 424

header 52, 424

.hh 425

mode a 1254

mode b 1254

mode r 1254

mode w 1254

mode x 1254

source 419

__FILE__ 340

File_ptr example 357

fill() 941

array 974

fill_n() 941

final 591

and performance 592

class 592

contextual keyword 593

function 307

finally() 358

find() 103, 933

char_traits 1035

example, parallel 1246

map 910

string 1046

find_all() example 104

find_end() 933

find_first_not_of(), string 1047

find_first_of() 933

string 1047

find_if() 108, 933

find_if_not() 933

find_last() example 962

find_last_not_of(), string 1047

find_last_of(), string 1047

firewall 350

first submatch, $1 1061

first, pair member 127, 983

fisher_f_distribution 1188

fixed-length array 174

flags, match 1062

flags(), regex 1057

flexible composition of code 741

flip() bitset 979

float 146

bits in 1161

sizeof 150

float_denorm_style 1161

<float.h> 865

floating-point

. 146

conversion 269

conversion to 270

e 146

environment, <cfenv> 866

hash of 915

literal 146

promotion 267

to int 270

type 139, 146

float_round_style 1161

floor() 1163

FLT_RADIX 1162

fmod() 1163

fold() 701

for

and : 233

<iterator> range 868

loop, lambda and 292

statement 45, 235

statement, declaration in 235

statement, range 45, 233, 965

for(;;) forever 235, 244

for_each() 932

forever, for(;;) 235, 244

formal argument 315

format

%A 1256

%a 1256

%c 1256

character % 1255

%d 1256

%e 1256

%f 1256

%F 1256

%G 1256

%g 1256

%i 1256

%n 1256

number 1129

%o 1256

of monetary amount 1134–1135

%p 1256

%s 1256

string 1255

substitution 1061

%u 1256

%x 1256

%X 1256

format()

options 1062

regex 1061

format_default ECMAScript rules 1062

format_first_only 1062

format_no_copy 1062

format_sed 1062

formfeed \f 143

Fortran 16

forward

iterator 955

reference to class 571

forward() 1028

forward_as_tuple(), tuple 985

forwarding constructor 503

Forward_iterator 716

forward_iterator_tag 956

forward_list 906

emplace_after() 908

erase_after() 908

insert_after() 908

operation 893, 907–908

representation 889

singly-linked list 886

size() 907

splice_after() 908

<forward_list> 863

frac_digits()

monetary 1137

money_punct 1135

free

storage 167

store 63, 167, 277

store exhaustion 283

freestanding implementation 137

free-store allocation, delete 525

frexp() 1163

friend 571

and member 532, 574

class 572

function 572

lookup 573

template and 682

from_time_t(), clock 1015

front()

container 900

of queue 922

string 1041

front_inserter() 963

front_insert_iterator 963

<fstream> 864

full expression 261

__func__ 340

function 39

access 216

adaptor 967

and code complexity 306


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue

