Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


Contents
Preface
Preface to the Third Edition
47h 26m remaining
Preface
All problems in computer science can be solved by another level of indirection, except for the problem of too many layers of indirection.

– David J. Wheeler

C++ feels like a new language. That is, I can express my ideas more clearly, more simply, and more directly in C++11 than I could in C++98. Furthermore, the resulting programs are better checked by the compiler and run faster.

In this book, I aim for completeness. I describe every language feature and standard-library component that a professional programmer is likely to need. For each, I provide:

• Rationale: What kinds of problems is it designed to help solve? What principles underlie the design? What are the fundamental limitations?

• Specification: What is its definition? The level of detail is chosen for the expert programmer; the aspiring language lawyer can follow the many references to the ISO standard.

• Examples: How can it be used well by itself and in combination with other features? What are the key techniques and idioms? What are the implications for maintainability and performance?

The use of C++ has changed dramatically over the years and so has the language itself. From the point of view of a programmer, most of the changes have been improvements. The current ISO standard C++ (ISO/IEC 14882-2011, usually called C++11) is simply a far better tool for writing quality software than were previous versions. How is it a better tool? What kinds of programming styles and techniques does modern C++ support? What language and standard-library features support those techniques? What are the basic building blocks of elegant, correct, maintainable, and efficient C++ code? Those are the key questions answered by this book. Many answers are not the same as you would find with 1985, 1995, or 2005 vintage C++: progress happens.

C++ is a general-purpose programming language emphasizing the design and use of type-rich, lightweight abstractions. It is particularly suited for resource-constrained applications, such as those found in software infrastructures. C++ rewards the programmer who takes the time to master techniques for writing quality code. C++ is a language for someone who takes the task of programming seriously. Our civilization depends critically on software; it had better be quality software.

There are billions of lines of C++ deployed. This puts a premium on stability, so 1985 and 1995 C++ code still works and will continue to work for decades. However, for all applications, you can do better with modern C++; if you stick to older styles, you will be writing lower-quality and worse-performing code. The emphasis on stability also implies that standards-conforming code you write today will still work a couple of decades from now. All code in this book conforms to the 2011 ISO C++ standard.

This book is aimed at three audiences:

• C++ programmers who want to know what the latest ISO C++ standard has to offer,

• C programmers who wonder what C++ provides beyond C, and

• People with a background in application languages, such as Java, C#, Python, and Ruby, looking for something “closer to the machine” – something more flexible, something offering better compile-time checking, or something offering better performance.

Naturally, these three groups are not disjoint – a professional software developer masters more than just one programming language.

This book assumes that its readers are programmers. If you ask, “What’s a for-loop?” or “What’s a compiler?” then this book is not (yet) for you; instead, I recommend my Programming: Principles and Practice Using C++ to get started with programming and C++. Furthermore, I assume that readers have some maturity as software developers. If you ask “Why bother testing?” or say, “All languages are basically the same; just show me the syntax” or are confident that there is a single language that is ideal for every task, this is not the book for you.

What features does C++11 offer over and above C++98? A machine model suitable for modern computers with lots of concurrency. Language and standard-library facilities for doing systems-level concurrent programming (e.g., using multicores). Regular expression handling, resource management pointers, random numbers, improved containers (including, hash tables), and more. General and uniform initialization, a simpler for-statement, move semantics, basic Unicode support, lambdas, general constant expressions, control over class defaults, variadic templates, user-defined literals, and more. Please remember that those libraries and language features exist to support programming techniques for developing quality software. They are meant to be used in combination – as bricks in a building set – rather than to be used individually in relative isolation to solve a specific problem. A computer is a universal machine, and C++ serves it in that capacity. In particular, C++’s design aims to be sufficiently flexible and general to cope with future problems undreamed of by its designers.

Acknowledgments
In addition to the people mentioned in the acknowledgment sections of the previous editions, I would like to thank Pete Becker, Hans-J. Boehm, Marshall Clow, Jonathan Coe, Lawrence Crowl, Walter Daugherity, J. Daniel Garcia, Robert Harle, Greg Hickman, Howard Hinnant, Brian Kernighan, Daniel Krügler, Nevin Liber, Michel Michaud, Gary Powell, Jan Christiaan van Winkel, and Leor Zolman. Without their help this book would have been much poorer.

Thanks to Howard Hinnant for answering many questions about the standard library.

Andrew Sutton is the author of the Origin library, which was the testbed for much of the discussion of emulating concepts in the template chapters, and of the matrix library that is the topic of Chapter 29. The Origin library is open source and can be found by searching the Web for “Origin” and “Andrew Sutton.”

Thanks to my graduate design class for finding more problems with the “tour chapters” than anyone else.

Had I been able to follow every piece of advice of my reviewers, the book would undoubtedly have been much improved, but it would also have been hundreds of pages longer. Every expert reviewer suggested adding technical details, advanced examples, and many useful development conventions; every novice reviewer (or educator) suggested adding examples; and most reviewers observed (correctly) that the book may be too long.

Thanks to Princeton University’s Computer Science Department, and especially Prof. Brian Kernighan, for hosting me for part of the sabbatical that gave me time to write this book.

Thanks to Cambridge University’s Computer Lab, and especially Prof. Andy Hopper, for hosting me for part of the sabbatical that gave me time to write this book.

Thanks to my editor, Peter Gordon, and his production team at Addison-Wesley for their help and patience.

College Station, Texas

Bjarne Stroustrup


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


Preface
Preface to the Third Edition
Preface to the Second Edition
47h 26m remaining
Preface to the Third Edition
Programming is understanding.

– Kristen Nygaard

I find using C++ more enjoyable than ever. C++’s support for design and programming has improved dramatically over the years, and lots of new helpful techniques have been developed for its use. However, C++ is not just fun. Ordinary practical programmers have achieved significant improvements in productivity, maintainability, flexibility, and quality in projects of just about any kind and scale. By now, C++ has fulfilled most of the hopes I originally had for it, and also succeeded at tasks I hadn’t even dreamt of.

This book introduces standard C++† and the key programming and design techniques supported by C++. Standard C++ is a far more powerful and polished language than the version of C++ introduced by the first edition of this book. New language features such as namespaces, exceptions, templates, and run-time type identification allow many techniques to be applied more directly than was possible before, and the standard library allows the programmer to start from a much higher level than the bare language.

† ISO/IEC 14882, Standard for the C++ Programming Language.

About a third of the information in the second edition of this book came from the first. This third edition is the result of a rewrite of even larger magnitude. It offers something to even the most experienced C++ programmer; at the same time, this book is easier for the novice to approach than its predecessors were. The explosion of C++ use and the massive amount of experience accumulated as a result makes this possible.

The definition of an extensive standard library makes a difference to the way C++ concepts can be presented. As before, this book presents C++ independently of any particular implementation, and as before, the tutorial chapters present language constructs and concepts in a “bottom up” order so that a construct is used only after it has been defined. However, it is much easier to use a well-designed library than it is to understand the details of its implementation. Therefore, the standard library can be used to provide realistic and interesting examples well before a reader can be assumed to understand its inner workings. The standard library itself is also a fertile source of programming examples and design techniques.

This book presents every major C++ language feature and the standard library. It is organized around language and library facilities. However, features are presented in the context of their use. That is, the focus is on the language as the tool for design and programming rather than on the language in itself. This book demonstrates key techniques that make C++ effective and teaches the fundamental concepts necessary for mastery. Except where illustrating technicalities, examples are taken from the domain of systems software. A companion, The Annotated C++ Language Standard, presents the complete language definition together with annotations to make it more comprehensible.

The primary aim of this book is to help the reader understand how the facilities offered by C++ support key programming techniques. The aim is to take the reader far beyond the point where he or she gets code running primarily by copying examples and emulating programming styles from other languages. Only a good understanding of the ideas behind the language facilities leads to mastery. Supplemented by implementation documentation, the information provided is sufficient for completing significant real-world projects. The hope is that this book will help the reader gain new insights and become a better programmer and designer.

Acknowledgments
In addition to the people mentioned in the acknowledgement sections of the first and second editions, I would like to thank Matt Austern, Hans Boehm, Don Caldwell, Lawrence Crowl, Alan Feuer, Andrew Forrest, David Gay, Tim Griffin, Peter Juhl, Brian Kernighan, Andrew Koenig, Mike Mowbray, Rob Murray, Lee Nackman, Joseph Newcomer, Alex Stepanov, David Vandevoorde, Peter Weinberger, and Chris Van Wyk for commenting on draft chapters of this third edition. Without their help and suggestions, this book would have been harder to understand, contained more errors, been slightly less complete, and probably been a little bit shorter.

I would also like to thank the volunteers on the C++ standards committees who did an immense amount of constructive work to make C++ what it is today. It is slightly unfair to single out individuals, but it would be even more unfair not to mention anyone, so I’d like to especially mention Mike Ball, Dag Brück, Sean Corfield, Ted Goldstein, Kim Knuttila, Andrew Koenig, Dmitry Lenkov, Nathan Myers, Martin O’Riordan, Tom Plum, Jonathan Shopiro, John Spicer, Jerry Schwarz, Alex Stepanov, and Mike Vilot, as people who each directly cooperated with me over some part of C++ and its standard library.

After the initial printing of this book, many dozens of people have mailed me corrections and suggestions for improvements. I have been able to accommodate many of their suggestions within the framework of the book so that later printings benefitted significantly. Translators of this book into many languages have also provided many clarifications. In response to requests from readers, I have added appendices D and E. Let me take this opportunity to thank a few of those who helped: Dave Abrahams, Matt Austern, Jan Bielawski, Janina Mincer Daszkiewicz, Andrew Koenig, Dietmar Kühl, Nicolai Josuttis, Nathan Myers, Paul E. Sevinç, Andy Tenne-Sens, Shoichi Uchida, Ping-Fai (Mike) Yang, and Dennis Yelle.

Murray Hill, New Jersey

Bjarne Stroustrup


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


Preface to the Third Edition
Preface to the Second Edition
Preface to the First Edition
47h 26m remaining
Preface to the Second Edition
The road goes ever on and on.

– Bilbo Baggins

As promised in the first edition of this book, C++ has been evolving to meet the needs of its users. This evolution has been guided by the experience of users of widely varying backgrounds working in a great range of application areas. The C++ user-community has grown a hundredfold during the six years since the first edition of this book; many lessons have been learned, and many techniques have been discovered and/or validated by experience. Some of these experiences are reflected here.

The primary aim of the language extensions made in the last six years has been to enhance C++ as a language for data abstraction and object-oriented programming in general and to enhance it as a tool for writing high-quality libraries of user-defined types in particular. A “high-quality library,” is a library that provides a concept to a user in the form of one or more classes that are convenient, safe, and efficient to use. In this context, safe means that a class provides a specific type-safe interface between the users of the library and its providers; efficient means that use of the class does not impose significant overheads in run-time or space on the user compared with hand-written C code.

This book presents the complete C++ language. Chapters 1 through 10 give a tutorial introduction; Chapters 11 through 13 provide a discussion of design and software development issues; and, finally, the complete C++ reference manual is included. Naturally, the features added and resolutions made since the original edition are integral parts of the presentation. They include refined overloading resolution, memory management facilities, and access control mechanisms, type-safe linkage, const and static member functions, abstract classes, multiple inheritance, templates, and exception handling.

C++ is a general-purpose programming language; its core application domain is systems programming in the broadest sense. In addition, C++ is successfully used in many application areas that are not covered by this label. Implementations of C++ exist from some of the most modest microcomputers to the largest supercomputers and for almost all operating systems. Consequently, this book describes the C++ language itself without trying to explain a particular implementation, programming environment, or library.

This book presents many examples of classes that, though useful, should be classified as “toys.” This style of exposition allows general principles and useful techniques to stand out more clearly than they would in a fully elaborated program, where they would be buried in details. Most of the useful classes presented here, such as linked lists, arrays, character strings, matrices, graphics classes, associative arrays, etc., are available in “bulletproof” and/or “goldplated” versions from a wide variety of commercial and non-commercial sources. Many of these “industrial strength” classes and libraries are actually direct and indirect descendants of the toy versions found here.

This edition provides a greater emphasis on tutorial aspects than did the first edition of this book. However, the presentation is still aimed squarely at experienced programmers and endeavors not to insult their intelligence or experience. The discussion of design issues has been greatly expanded to reflect the demand for information beyond the description of language features and their immediate use. Technical detail and precision have also been increased. The reference manual, in particular, represents many years of work in this direction. The intent has been to provide a book with a depth sufficient to make more than one reading rewarding to most programmers. In other words, this book presents the C++ language, its fundamental principles, and the key techniques needed to apply it. Enjoy!

Acknowledgments
In addition to the people mentioned in the acknowledgements section in the preface to the first edition, I would like to thank Al Aho, Steve Buroff, Jim Coplien, Ted Goldstein, Tony Hansen, Lorraine Juhl, Peter Juhl, Brian Kernighan, Andrew Koenig, Bill Leggett, Warren Montgomery, Mike Mowbray, Rob Murray, Jonathan Shopiro, Mike Vilot, and Peter Weinberger for commenting on draft chapters of this second edition. Many people influenced the development of C++ from 1985 to 1991. I can mention only a few: Andrew Koenig, Brian Kernighan, Doug McIlroy, and Jonathan Shopiro. Also thanks to the many participants of the “external reviews” of the reference manual drafts and to the people who suffered through the first year of X3J16.

Murray Hill, New Jersey

Bjarne Stroustrup


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


Preface to the Second Edition
Preface to the First Edition
Part I: Introduction
47h 26m remaining
Preface to the First Edition
Language shapes the way we think, and determines what we can think about.

– B.L.Whorf

C++ is a general purpose programming language designed to make programming more enjoyable for the serious programmer. Except for minor details, C++ is a superset of the C programming language. In addition to the facilities provided by C, C++ provides flexible and efficient facilities for defining new types. A programmer can partition an application into manageable pieces by defining new types that closely match the concepts of the application. This technique for program construction is often called data abstraction. Objects of some user-defined types contain type information. Such objects can be used conveniently and safely in contexts in which their type cannot be determined at compile time. Programs using objects of such types are often called object based. When used well, these techniques result in shorter, easier to understand, and easier to maintain programs.

The key concept in C++ is class. A class is a user-defined type. Classes provide data hiding, guaranteed initialization of data, implicit type conversion for user-defined types, dynamic typing, user-controlled memory management, and mechanisms for overloading operators. C++ provides much better facilities for type checking and for expressing modularity than C does. It also contains improvements that are not directly related to classes, including symbolic constants, inline substitution of functions, default function arguments, overloaded function names, free store management operators, and a reference type. C++ retains C’s ability to deal efficiently with the fundamental objects of the hardware (bits, bytes, words, addresses, etc.). This allows the user-defined types to be implemented with a pleasing degree of efficiency.

C++ and its standard libraries are designed for portability. The current implementation will run on most systems that support C. C libraries can be used from a C++ program, and most tools that support programming in C can be used with C++.

This book is primarily intended to help serious programmers learn the language and use it for nontrivial projects. It provides a complete description of C++, many complete examples, and many more program fragments.

Acknowledgments
C++ could never have matured without the constant use, suggestions, and constructive criticism of many friends and colleagues. In particular, Tom Cargill, Jim Coplien, Stu Feldman, Sandy Fraser, Steve Johnson, Brian Kernighan, Bart Locanthi, Doug McIlroy, Dennis Ritchie, Larry Rosler, Jerry Schwarz, and Jon Shopiro provided important ideas for development of the language. Dave Presotto wrote the current implementation of the stream I/O library.

In addition, hundreds of people contributed to the development of C++ and its compiler by sending me suggestions for improvements, descriptions of problems they had encountered, and compiler errors. I can mention only a few: Gary Bishop, Andrew Hume, Tom Karzes, Victor Milenkovic, Rob Murray, Leonie Rose, Brian Schmult, and Gary Walker.

Many people have also helped with the production of this book, in particular, Jon Bentley, Laura Eaves, Brian Kernighan, Ted Kowalski, Steve Mahaney, Jon Shopiro, and the participants in the C++ course held at Bell Labs, Columbus, Ohio, June 26-27, 1985.

Murray Hill, New Jersey
August 1985

Bjarne Stroustrup


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


Preface to the First Edition
Part I: Introduction
1. Notes to the Reader
47h 26m remaining
Part I: Introduction
This introduction gives an overview of the major concepts and features of the C++ programming language and its standard library. It also provides an overview of this book and explains the approach taken to the description of the language facilities and their use. In addition, the introductory chapters present some background information about C++, the design of C++, and the use of C++.

Chapters

1 Notes to the Reader

2 A Tour of C++: The Basics

3 A Tour of C++: Abstraction Mechanisms

4 A Tour of C++: Containers and Algorithms

5 A Tour of C++: Concurrency and Utilities

“... and you, Marcus, you have given me many things; now I shall give you this good advice. Be many people. Give up the game of being always Marcus Cocoza. You have worried too much about Marcus Cocoza, so that you have been really his slave and prisoner. You have not done anything without first considering how it would affect Marcus Cocoza’s happiness and prestige. You were always much afraid that Marcus might do a stupid thing, or be bored. What would it really have mattered? All over the world people are doing stupid things ... I should like you to be easy, your little heart to be light again. You must from now, be more than one, many people, as many as you can think of ...”

– Karen Blixen,
The Dreamers from Seven Gothic Tales (1934)


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


Part I: Introduction
1. Notes to the Reader
2. A Tour of C++: The Basics
47h 26m remaining
1. Notes to the Reader
Hurry Slowly (festina lente).

– Octavius, Caesar Augustus

• The Structure of This Book

Introduction; Basic Facilities; Abstraction Mechanisms; The Standard Library; Examples and References

• The Design of C++

Programming Styles; Type Checking; C Compatibility; Language, Libraries, and Systems

• Learning C++

Programming in C++; Suggestions for C++ Programmers; Suggestions for C Programmers; Suggestions for Java Programmers

• History

Timeline; The Early Years; The 1998 Standard; The 2011 Standard; What is C++ Used for?

• Advice

• References

1.1. The Structure of This Book
A pure tutorial sorts its topics so that no concept is used before it has been introduced; it must be read linearly starting with page one. Conversely, a pure reference manual can be accessed starting at any point; it describes each topic succinctly with references (forward and backward) to related topics. A pure tutorial can in principle be read without prerequisites – it carefully describes all. A pure reference can be used only by someone familiar with all fundamental concepts and techniques. This book combines aspects of both. If you know most concepts and techniques, you can access it on a per-chapter or even on a per-section basis. If not, you can start at the beginning, but try not to get bogged down in details. Use the index and the cross-references.

Making parts of the book relatively self-contained implies some repetition, but repetition also serves as review for people reading the book linearly. The book is heavily cross-referenced both to itself and to the ISO C++ standard. Experienced programmers can read the (relatively) quick “tour” of C++ to gain the overview needed to use the book as a reference. This book consists of four parts:

Part I

Introduction: Chapter 1 (this chapter) is a guide to this book and provides a bit of C++ background. Chapters 2-5 give a quick introduction to the C++ language and its standard library.

Part II

Basic Facilities: Chapters 6-15 describe C++’s built-in types and the basic facilities for constructing programs out of them.

Part III

Abstraction Mechanisms: Chapters 16-29 describe C++’s abstraction mechanisms and their use for object-oriented and generic programming.

Part IV

Chapters 30-44 provide an overview of the standard library and a discussion of compatibility issues.

1.1.1. Introduction
This chapter, Chapter 1, provides an overview of this book, some hints about how to use it, and some background information about C++ and its use. You are encouraged to skim through it, read what appears interesting, and return to it after reading other parts of the book. Please do not feel obliged to read it all carefully before proceeding.

The following chapters provide an overview of the major concepts and features of the C++ programming language and its standard library:

Chapter 2

A Tour of C++: The Basics describes C++’s model of memory, computation, and error handling.

Chapter 3

A Tour of C++: Abstraction Mechanisms presents the language features supporting data abstraction, object-oriented programming, and generic programming.

Chapter 4

A Tour of C++: Containers and Algorithms introduces strings, simple I/O, containers, and algorithms as provided by the standard library.

Chapter 5

A Tour of C++: Concurrency and Utilities outlines the standard-library utilities related to resource management, concurrency, mathematical computation, regular expressions, and more.

This whirlwind tour of C++’s facilities aims to give the reader a taste of what C++ offers. In particular, it should convince readers that C++ has come a long way since the first, second, and third editions of this book.

1.1.2. Basic Facilities
Part II focuses on the subset of C++ that supports the styles of programming traditionally done in C and similar languages. It introduces the notions of type, object, scope, and storage. It presents the fundamentals of computation: expressions, statements, and functions. Modularity – as supported by namespaces, source files, and exception handling – is also discussed:

Chapter 6

Types and Declarations: Fundamental types, naming, scopes, initialization, simple type deduction, object lifetimes, and type aliases

Chapter 7

Pointers, Arrays, and References

Chapter 8

Structures, Unions, and Enumerations

Chapter 9

Statements: Declarations as statements, selection statements (if and switch), iteration statements (for, while, and do), goto, and comments

Chapter 10

Expressions: A desk calculator example, survey of operators, constant expressions, and implicit type conversion.

Chapter 11

Select Operations: Logical operators, the conditional expression, increment and decrement, free store (new and delete), {}-lists, lambda expressions, and explicit type conversion (static_cast and const_cast)

Chapter 12

Functions: Function declarations and definitions, inline functions, constexpr functions, argument passing, overloaded functions, pre- and postconditions, pointers to functions, and macros

Chapter 13

Exception Handling: Styles of error handling, exception guarantees, resource management, enforcing invariants, throw and catch, a vector implementation

Chapter 14

Namespaces: namespace, modularization and interface, composition using namespaces

Chapter 15

Source Files and Programs: Separate compilation, linkage, using header files, and program start and termination

I assume that you are familiar with most of the programming concepts used in Part I. For example, I explain the C++ facilities for expressing recursion and iteration, but I do not go into technical details or spend much time explaining how these concepts are useful.

The exception to this rule is exceptions. Many programmers lack experience with exceptions or got their experience from languages (such as Java) where resource management and exception handling are not integrated. Consequently, the chapter on exception handling (Chapter 13) presents the basic philosophy of C++ exception handling and resource management. It goes into some detail about strategy with a focus on the “Resource Acquisition Is Initialization” technique (RAII).

1.1.3. Abstraction Mechanisms
Part III describes the C++ facilities supporting various forms of abstraction, including object-oriented and generic programming. The chapters fall into three rough categories: classes, class hierarchies, and templates.

The first four chapters concentrate on the classes themselves:

Chapter 16

Classes: The notion of a user-defined type, a class, is the foundation of all C++ abstraction mechanisms.

Chapter 17

Construction, Cleanup, Copy, and Move shows how a programmer can define the meaning of creation and initialization of objects of a class. Further, the meaning of copy, move, and destruction can be specified.

Chapter 18

Operator Overloading presents the rules for giving meaning to operators for user-defined types with an emphasis on conventional arithmetic and logical operators, such as +, *, and &.

Chapter 19

Special Operators discusses the use of user-defined operator for non-arithmetic purposes, such as [] for subscripting, () for function objects, and –> for “smart pointers.”

Classes can be organized into hierarchies:

Chapter 20

Derived Classes presents the basic language facilities for building hierarchies out of classes and the fundamental ways of using them. We can provide complete separation between an interface (an abstract class) and its implementations (derived classes); the connection between them is provided by virtual functions. The C++ model for access control (public, protected, and private) is presented.

Chapter 21

Class Hierarchies discusses ways of using class hierarchies effectively. It also presents the notion of multiple inheritance, that is, a class having more than one direct base class.

Chapter 22

Run-Time Type Information presents ways to navigate class hierarchies using data stored in objects. We can use dynamic_cast to inquire whether an object of a base class was defined as an object of a derived class and use the typeid to gain minimal information from an object (such as the name of its class).

Many of the most flexible, efficient, and useful abstractions involve the parameterization of types (classes) and algorithms (functions) with other types and algorithms:

Chapter 23

Templates presents the basic principles behind templates and their use. Class templates, function templates, and template aliases are presented.

Chapter 24

Generic Programming introduces the basic techniques for designing generic programs. The technique of lifting an abstract algorithm from a number of concrete code examples is central, as is the notion of concepts specifying a generic algorithm’s requirements on its arguments.

Chapter 25

Specialization describes how templates are used to generate classes and functions, specializations, given a set of template arguments.

Chapter 26

Instantiation focuses on the rules for name binding.

Chapter 27

Templates and Hierarchies explains how templates and class hierarchies can be used in combination.

Chapter 28

Metaprogramming explores how templates can be used to generate programs. Templates provide a Turing-complete mechanism for generating code.

Chapter 29

A Matrix Design gives a longish example to show how language features can be used in combination to solve a complex design problem: the design of an N-dimensional matrix with near-arbitrary element types.

The language features supporting abstraction techniques are described in the context of those techniques. The presentation technique in Part III differs from that of Part II in that I don’t assume that the reader knows the techniques described.

1.1.4. The Standard Library
The library chapters are less tutorial than the language chapters. In particular, they are meant to be read in any order and can be used as a user-level manual for the library components:

Chapter 30

Standard-Library Overview gives an overview of the standard library, lists the standard-library headers, and presents language support and diagnostics support, such as exception and system_error.

Chapter 31

STL Containers presents the containers from the iterators, containers, and algorithms framework (called the STL), including vector, map, and unordered_set.

Chapter 32

STL Algorithms presents the algorithms from the STL, including find(), sort(), and merge().

Chapter 33

STL Iterators presents iterators and other utilities from the STL, including reverse_iterator, move_iterator, and function.

Chapter 34

Memory and Resources presents utility components related to memory and resource management, such as array, bitset, pair, tuple, unique_ptr, shared_ptr, allocators, and the garbage collector interface.

Chapter 35

Utilities presents minor utility components, such as time utilities, type traits, and various type functions.

Chapter 36

Strings documents the string library, including the character traits that are the basis for the use of different character sets.

Chapter 37

Regular Expressions describes the regular expression syntax and the various ways of using it for string matching, including regex_match() for matching a complete string, regex_search() for finding a pattern in a string, regex_replace() for simple replacement, and regex_iterator for general traversal of a stream of characters.

Chapter 38

I/O Streams documents the stream I/O library. It describes formatted and unformatted input and output, error handling, and buffering.

Chapter 39

Locales describes class locale and its various facets that provide support for the handling of cultural differences in character sets, formatting of numeric values, formatting of date and time, and more.

Chapter 40

Numerics describes facilities for numerical computation (such as complex, valarray, random numbers, and generalized numerical algorithms).

Chapter 41

Concurrency presents the C++ basic memory model and the facilities offered for concurrent programming without locks.

Chapter 42

Threads and Tasks presents the classes providing threads-and-locks-style concurrent programming (such as thread, timed_mutex, lock_guard, and try_lock()) and the support for task-based concurrency (such as future and async()).

Chapter 43

The C Standard Library documents the C standard library (including printf() and clock()) as incorporated into the C++ standard library.

Chapter 44

Compatibility discusses the relation between C and C++ and between Standard C++ (also called ISO C++) and the versions of C++ that preceded it.

1.1.5. Examples and References
This book emphasizes program organization rather than the design of algorithms. Consequently, I avoid clever or harder-to-understand algorithms. A trivial algorithm is typically better suited to illustrate an aspect of the language definition or a point about program structure. For example, I use a Shell sort where, in real code, a quicksort would be better. Often, reimplementation with a more suitable algorithm is an exercise. In real code, a call of a library function is typically more appropriate than the code used here to illustrate language features.

Textbook examples necessarily give a warped view of software development. By clarifying and simplifying the examples, the complexities that arise from scale disappear. I see no substitute for writing realistically sized programs in order to get an impression of what programming and a programming language are really like. This book concentrates on the language features and the standard-library facilities. These are the basic techniques from which every program is composed. The rules and techniques for such composition are emphasized.

The selection of examples reflects my background in compilers, foundation libraries, and simulations. The emphasis reflects my interest in systems programming. Examples are simplified versions of what is found in real code. The simplification is necessary to keep programming language and design points from getting lost in details. My ideal is the shortest and clearest example that illustrates a design principle, a programming technique, a language construct, or a library feature. There are no “cute” examples without counterparts in real code. For purely language-technical examples, I use variables named x and y, types called A and B, and functions called f() and g().

Where possible, the C++ language and library features are presented in the context of their use rather than in the dry manner of a manual. The language features presented and the detail in which they are described roughly reflect my view of what is needed for effective use of C++. The purpose is to give you an idea of how a feature can be used, often in combination with other features. An understanding of every language-technical detail of a language feature or library component is neither necessary nor sufficient for writing good programs. In fact, an obsession with understanding every little detail is a prescription for awful – overelaborate and overly clever – code. What is needed is an understanding of design and programming techniques together with an appreciation of application domains.

I assume that you have access to online information sources. The final arbiter of language and standard-library rules is the ISO C++ standard [C++,2011].

References to parts of this book are of the form §2.3.4 (Chapter 2, section 3, subsection 4) and §iso.5.3.1 (ISO C++ standard, §5.3.1). Italics are used sparingly for emphasis (e.g., “a string literal is not acceptable”), for first occurrences of important concepts (e.g., polymorphism), and for comments in code examples.

To save a few trees and to simplify additions, the hundreds of exercises for this book have been moved to the Web. Look for them at www.stroustrup.com.

The language and library used in this book are “pure C++” as defined by the C++ standard [C++,2011]. Therefore, the examples should run on every up-to-date C++ implementation. The major program fragments in this book were tried using several C++ implementations. Examples using features only recently adopted into C++ didn’t compile on every implementation. However, I see no point in mentioning which implementations failed to compile which examples. Such information would soon be out of date because implementers are working hard to ensure that their implementations correctly accept every C++ feature. See Chapter 44 for suggestions on how to cope with older C++ compilers and with code written for C compilers.

I use C++11 features freely wherever I find them most appropriate. For example, I prefer {}-style initializers and using for type aliases. In places, that usage may startle “old timers.” However, being startled is often a good way to start reviewing material. On the other hand, I don’t use new features just because they are new; my ideal is the most elegant expression of the fundamental ideas – and that may very well be using something that has been in C++ or even in C for ages.

Obviously, if you have to use a pre-C++11 compiler (say, because some of your customers have not yet upgraded to the current standard), you have to refrain from using novel features. However, please don’t assume that “the old ways” are better or simpler just because they are old and familiar. §44.2 summarizes the differences between C++98 and C++11.

1.2. The Design of C++
The purpose of a programming language is to help express ideas in code. In that, a programming language performs two related tasks: it provides a vehicle for the programmer to specify actions to be executed by the machine, and it provides a set of concepts for the programmer to use when thinking about what can be done. The first purpose ideally requires a language that is “close to the machine” so that all important aspects of a machine are handled simply and efficiently in a way that is reasonably obvious to the programmer. The C language was primarily designed with this in mind. The second purpose ideally requires a language that is “close to the problem to be solved” so that the concepts of a solution can be expressed directly and concisely. The facilities added to C to create C++, such as function argument checking, const, classes, constructors and destructors, exceptions, and templates, were primarily designed with this in mind. Thus, C++ is based on the idea of providing both

• direct mappings of built-in operations and types to hardware to provide efficient memory use and efficient low-level operations, and

• affordable and flexible abstraction mechanisms to provide user-defined types with the same notational support, range of uses, and performance as built-in types.

This was initially achieved by applying ideas from Simula to C. Over the years, further application of these simple ideals resulted in a far more general, efficient, and flexible set of facilities. The result supports a synthesis of programming styles that can be simultaneously efficient and elegant.

The design of C++ has focused on programming techniques dealing with fundamental notions such as memory, mutability, abstraction, resource management, expression of algorithms, error handling, and modularity. Those are the most important concerns of a systems programmer and more generally of programmers of resource-constrained and high-performance systems.

By defining libraries of classes, class hierarchies, and templates, you can write C++ programs at a much higher level than the one presented in this book. For example, C++ is widely used in financial systems, for game development, and for scientific computation (§1.4.5). For high-level applications programming to be effective and convenient, we need libraries. Using just the bare language features makes almost all programming quite painful. That’s true for every general-purpose language. Conversely, given suitable libraries just about any programming task can be pleasant.

My standard introduction of C++ used to start:

• C++ is a general-purpose programming language with a bias toward systems programming.

This is still true. What has changed over the years is an increase in the importance, power, and flexibility of C++’s abstraction mechanisms:

• C++ is a general-purpose programming language providing a direct and efficient model of hardware combined with facilities for defining lightweight abstractions.

Or terser:

• C++ is a language for developing and using elegant and efficient abstractions.

By general-purpose programming language I mean a language designed to support a wide variety of uses. C++ has indeed been used for an incredible variety of uses (from microcontrollers to huge distributed commercial applications), but the key point is that C++ is not deliberately specialized for any given application area. No language is ideal for every application and every programmer, but the ideal for C++ is to support the widest possible range of application areas well.

By systems programming I mean writing code that directly uses hardware resources, has serious resource constraints, or closely interacts with code that does. In particular, the implementation of software infrastructure (e.g., device drivers, communications stacks, virtual machines, operating systems, operations systems, programming environments, and foundation libraries) is mostly systems programming. The importance of the “bias toward systems programming” qualification in my long-standing characterization of C++ is that C++ has not been simplified (compromised) by ejecting the facilities aimed at the expert-level use of hardware and systems resources in the hope of making it more suitable for other application areas.

Of course, you can also program in ways that completely hide hardware, use expensive abstractions (e.g., every object on the free store and every operation a virtual function), use inelegant styles (e.g., overabstraction), or use essentially no abstractions (“glorified assembly code”). However, many languages can do that, so those are not distinguishing characteristics of C++.

The Design and Evolution of C++ book [Stroustrup,1994] (known as D&E) outlines the ideas and design aims of C++ in greater detail, but two principles should be noted:

• Leave no room for a lower-level language below C++ (except for assembly code in rare cases). If you can write more efficient code in a lower-level language then that language will most likely become the systems programming language of choice.

• What you don’t use you don’t pay for. If programmers can hand-write reasonable code to simulate a language feature or a fundamental abstraction and provide even slightly better performance, someone will do so, and many will imitate. Therefore, a language feature and a fundamental abstraction must be designed not to waste a single byte or a single processor cycle compared to equivalent alternatives. This is known as the zero-overhead principle.

These are Draconian principles, but essential in some (but obviously not all) contexts. In particular, the zero-overhead principle repeatedly led C++ to simpler, more elegant, and more powerful facilities than were first envisioned. The STL is an example (§4.1.1, §4.4, §4.5, Chapter 31, Chapter 32, Chapter 33). These principles have been essential in the effort to raise the level of programming.

1.2.1. Programming Style
Languages features exist to provide support for programming styles. Please don’t look at an individual language feature as a solution, but as one building brick from a varied set which can be combined to express solutions.

The general ideals for design and programming can be expressed simply:

• Express ideas directly in code.

• Express independent ideas independently in code.

• Represent relationships among ideas directly in code.

• Combine ideas expressed in code freely – where and only where combinations make sense.

• Express simple ideas simply.

These are ideals shared by many people, but languages designed to support them can differ dramatically. A fundamental reason for that is that a language embodies a set of engineering tradeoffs reflecting differing needs, tastes, and histories of various individuals and communities. C++’s answers to the general design challenges were shaped by its origins in systems programming (going back to C and BCPL [Richards,1980]), its aim to address issues of program complexity through abstraction (going back to Simula), and its history.

The C++ language features most directly support four programming styles:

• Procedural programming

• Data abstraction

• Object-oriented programming

• Generic programming

However, the emphasis is on the support of effective combinations of those. The best (most maintainable, most readable, smallest, fastest, etc.) solution to most nontrivial problems tends to be one that combines aspects of these styles.

As is usual with important terms in the computing world, a wide variety of definitions of these terms are popular in various parts of the computing industry and academia. For example, what I refer to as a “programming style,” others call a “programming technique” or a “paradigm.” I prefer to use “programming technique” for something more limited and language-specific. I feel uncomfortable with the word “paradigm” as pretentious and (from Kuhn’s original definition) having implied claims of exclusivity.

My ideal is language facilities that can be used elegantly in combination to support a continuum of programming styles and a wide variety of programming techniques.

• Procedural programming: This is programming focused on processing and the design of suitable data structures. It is what C was designed to support (and Algol, and Fortran, as well as many other languages). C++’s support comes in the form of the built-in types, operators, statements, functions, structs, unions, etc. With minor exceptions, C is a subset of C++. Compared to C, C++ provides further support for procedural programming in the form of many additional language constructs and a stricter, more flexible, and more supportive type system.

• Data abstraction: This is programming focused on the design of interfaces, hiding implementation details in general and representations in particular. C++ supports concrete and abstract classes. The facilities for defining classes with private implementation details, constructors and destructors, and associated operations directly support this. The notion of an abstract class provides direct support for complete data hiding.

• Object-oriented programming: This is programming focused on the design, implementation, and use of class hierarchies. In addition to allowing the definition of lattices of classes, C++ provides a variety of features for navigating class lattices and for simplifying the definition of a class out of existing ones. Class hierarchies provide run-time polymorphism (§20.3.2, §21.2) and encapsulation (§20.4, §20.5).

• Generic programming: This is programming focused on the design, implementation, and use of general algorithms. Here, “general” means that an algorithm can be designed to accept a wide variety of types as long as they meet the algorithm’s requirements on its arguments. The template is C++’s main support for generic programming. Templates provide (compile-time) parametric polymorphism.

Just about anything that increases the flexibility or efficiency of classes improves the support of all of those styles. Thus, C++ could be (and has been) called class oriented.

Each of these styles of design and programming has contributed to the synthesis that is C++. Focusing exclusively on one of these styles is a mistake: except for toy examples, doing so leads to wasted development effort and suboptimal (inflexible, verbose, poorly performing, unmaintainable, etc.) code.

I wince when someone characterizes C++ exclusively through one of these styles (e.g., “C++ is an object-oriented language”) or uses a term (e.g., “hybrid” or “mixed paradigm”) to imply that a more restrictive language would be preferable. The former misses the fact that all the styles mentioned have contributed something significant to the synthesis; the latter denies the validity of the synthesis. The styles mentioned are not distinct alternatives: each contributes techniques to a more expressive and effective style of programming, and C++ provides direct language support for their use in combination.

From its inception, the design of C++ aimed at a synthesis of programming and design styles. Even the earliest published account of C++ [Stroustrup,1982] presents examples that use these different styles in combination and presents language features aimed at supporting such combinations:

• Classes support all of the mentioned styles; all rely on the user representing ideas as user-defined types or objects of user-defined types.

• Public/private access control supports data abstraction and object-oriented programming by making a clear distinction between interface and implementation.

• Member functions, constructors, destructors, and user-defined assignment provide a clean functional interface to objects as needed by data abstraction and object-oriented programming. They also provide a uniform notation as needed for generic programming. More general overloading had to wait until 1984 and uniform initialization until 2010.

• Function declarations provide specific statically checked interfaces to member functions as well as freestanding functions, so they support all of the mentioned styles. They are necessary for overloading. At the time, C lacked “function prototypes” but Simula had function declarations as well as member functions.

• Generic functions and parameterized types (generated from functions and classes using macros) support generic programming. Templates had to wait until 1988.

• Base and derived classes provide the foundation for object-oriented programming and some forms of data abstraction. Virtual functions had to wait until 1983.

• Inlining made the use of these facilities affordable in systems programming and for building run-time and space efficient libraries.

These early features are general abstraction mechanisms, rather than support for disjoint programming styles. Today’s C++ provides much better support for design and programming based on lightweight abstraction, but the aim of elegant and efficient code was there from the very beginning. The developments since 1981 provide much better support for the synthesis of the programming styles (“paradigms”) originally considered and significantly improve their integration.

The fundamental object in C++ has identity; that is, it is located in a specific location in memory and can be distinguished from other objects with (potentially) the same value by comparing addresses. Expressions denoting such objects are called lvalues (§6.4). However, even from the earliest days of C++’s ancestors [Barron,1963] there have also been objects without identity (objects for which an address cannot be safely stored for later use). In C++11, this notion of rvalue has been developed into a notion of a value that can be moved around cheaply (§3.3.2, §6.4.1, §7.7.2). Such objects are the basis of techniques that resemble what is found in functional programming (where the notion of objects with identity is viewed with horror). This nicely complements the techniques and language features (e.g., lambda expressions) developed primarily for generic programming. It also solves classical problems related to “simple abstract data types,” such as how to elegantly and efficiently return a large matrix from an operation (e.g., a matrix +).

From the very earliest days, C++ programs and the design of C++ itself have been concerned about resource management. The ideal was (and is) for resource management to be

• simple (for implementers and especially for users),

• general (a resource is anything that has to be acquired from somewhere and later released),

• efficient (obey the zero-overhead principle; §1.2),

• perfect (no leaks are acceptable), and

• statically type-safe.

Many important C++ classes, such as the standard library’s vector, string, thread, mutex, unique_ptr, fstream, and regex, are resource handles. Foundation and application libraries beyond the standard provided many more examples, such as Matrix and Widget. The initial step in supporting the notion of resource handles was taken with the provision of constructors and destructors in the very first “C with Classes” draft. This was soon backed with the ability to control copy by defining assignment as well as copy constructors. The introduction of move constructors and move assignments (§3.3) in C++11 completes this line of thinking by allowing cheap movement of potentially large objects from scope to scope (§3.3.2) and to simply control the lifetime of polymorphic or shared objects (§5.2.1).

The facilities supporting resource management also benefit abstractions that are not resource handles. Any class that establishes and maintains an invariant relies on a subset of those features.

1.2.2. Type Checking
The connection between the language in which we think/program and the problems and solutions we can imagine is very close. For this reason, restricting language features with the intent of eliminating programmer errors is, at best, dangerous. A language provides a programmer with a set of conceptual tools; if these are inadequate for a task, they will be ignored. Good design and the absence of errors cannot be guaranteed merely by the presence or absence of specific language features. However, the language features and the type system are provided for the programmer to precisely and concisely represent a design in code.

The notion of static types and compile-time type checking is central to effective use of C++. The use of static types is key to expressiveness, maintainability, and performance. Following Simula, the design of user-defined types with interfaces that are checked at compile time is key to the expressiveness of C++. The C++ type system is extensible in nontrivial ways (Chapter 3, Chapter 16, Chapter 18, Chapter 19, Chapter 21, Chapter 23, Chapter 28, Chapter 29), aiming for equal support for built-in types and user-defined types.

C++ type-checking and data-hiding features rely on compile-time analysis of programs to prevent accidental corruption of data. They do not provide secrecy or protection against someone who is deliberately breaking the rules: C++ protects against accident, not against fraud. They can, however, be used freely without incurring run-time or space overheads. The idea is that to be useful, a language feature must not only be elegant, it must also be affordable in the context of a real-world program.

C++’s static type system is flexible, and the use of simple user-defined types implies little, if any overhead. The aim is to support a style of programming that represents distinct ideas as distinct types, rather than just using generalizations - such as integer, floating-point number, string, “raw memory,” and “object” - everywhere. A type-rich style of programming makes code more readable, maintainable, and analyzable. A trivial type system allows only trivial analysis, whereas a type-rich style of programming opens opportunities for nontrivial error detection and optimization. C++ compilers and development tools support such type-based analysis [Stroustrup,2012].

Maintaining most of C as a subset and preserving the direct mapping to hardware needed for the most demanding low-level systems programming tasks implies the ability to break the static type system. However, my ideal is (and always was) complete type safety. In this, I agree with Dennis Ritchie, who said, “C is a strongly typed, weakly checked language.” Note that Simula was both type-safe and flexible. In fact, my ideal when I started on C++ was “Algol68 with Classes” rather than “C with Classes.” However, the list of solid reasons against basing my work on type-safe Algol68 [Woodward,1974] was long and painful. So, perfect type safety is an ideal that C++ as a language can only approximate. But it is an ideal that C++ programmers (especially library builders) can strive for. Over the years, the set of language features, standard-library components, and techniques supporting that ideal has grown. Outside of low-level sections of code (hopefully isolated by type-safe interfaces), code that interfaces to code obeying different language conventions (e.g., an operating system call interface), and the implementations of fundamental abstractions (e.g., string and vector), there is now little need for type-unsafe code.

1.2.3. C Compatibility
C++ was developed from the C programming language and, with few exceptions, retains C as a subset. The main reasons for relying on C were to build on a proven set of low-level language facilities and to be part of a technical community. Great importance was attached to retaining a high degree of compatibility with C [Koenig,1989] [Stroustrup,1994] (Chapter 44); this (unfortunately) precluded cleaning up the C syntax. The continuing, more or less parallel evolution of C and C++ has been a constant source of concern and requires constant attention [Stroustrup,2002]. Having two committees devoted to keeping two widely used languages “as compatible as possible” is not a particularly good way of organizing work. In particular, there are differences in opinion as to the value of compatibility, differences in opinion on what constitutes good programming, and differences in opinion on what support is needed for good programming. Just keeping up communication between the committees is a large amount of work.

One hundred percent C/C++ compatibility was never a goal for C++ because that would compromise type safety and the smooth integration of user-defined and built-in types. However, the definition of C++ has been repeatedly reviewed to remove gratuitous incompatibilities; C++ is now more compatible with C than it was originally. C++98 adopted many details from C89 (§44.3.1). When C then evolved from C89 [C,1990] to C99 [C,1999], C++ adopted almost all of the new features, leaving out VLAs (variable-length arrays) as a misfeature and designated initializers as redundant. C’s facilities for low-level systems programming tasks are retained and enhanced; for example, see inlining (§3.2.1.1, §12.1.5, §16.2.8) and constexpr (§2.2.3, §10.4, §12.1.6).

Conversely, modern C has adopted (with varying degrees of faithfulness and effectiveness) many features from C++ (e.g., const, function prototypes, and inlining; see [Stroustrup,2002]).

The definition of C++ has been revised to ensure that a construct that is both legal C and legal C++ has the same meaning in both languages (§44.3).

One of the original aims for C was to replace assembly coding for the most demanding systems programming tasks. When C++ was designed, care was taken not to compromise the gains in this area. The difference between C and C++ is primarily in the degree of emphasis on types and structure. C is expressive and permissive. Through extensive use of the type system, C++ is even more expressive without loss of performance.

Knowing C is not a prerequisite for learning C++. Programming in C encourages many techniques and tricks that are rendered unnecessary by C++ language features. For example, explicit type conversion (casting) is less frequently needed in C++ than it is in C (§1.3.3). However, good C programs tend to be C++ programs. For example, every program in Kernighan and Ritchie, The C Programming Language, Second Edition [Kernighan,1988], is a C++ program. Experience with any statically typed language will be a help when learning C++.

1.2.4. Language, Libraries, and Systems
The C++ fundamental (built-in) types, operators, and statements are those that computer hardware deals with directly: numbers, characters, and addresses. C++ has no built-in high-level data types and no high-level primitive operations. For example, the C++ language does not provide a matrix type with an inversion operator or a string type with a concatenation operator. If a user wants such a type, it can be defined in the language itself. In fact, defining a new general-purpose or application-specific type is the most fundamental programming activity in C++. A well-designed user-defined type differs from a built-in type only in the way it is defined, not in the way it is used. The C++ standard library (Chapter 4, Chapter 5, Chapter 30, Chapter 31, etc.) provides many examples of such types and their uses. From a user’s point of view, there is little difference between a built-in type and a type provided by the standard library. Except for a few unfortunate and unimportant historical accidents, the C++ standard library is written in C++. Writing the C++ standard library in C++ is a crucial test of the C++ type system and abstraction mechanisms: they must be (and are) sufficiently powerful (expressive) and efficient (affordable) for the most demanding systems programming tasks. This ensures that they can be used in large systems that typically consist of layer upon layer of abstraction.

Features that would incur run-time or memory overhead even when not used were avoided. For example, constructs that would make it necessary to store “housekeeping information” in every object were rejected, so if a user declares a structure consisting of two 16-bit quantities, that structure will fit into a 32-bit register. Except for the new, delete, typeid, dynamic_cast, and throw operators, and the try-block, individual C++ expressions and statements need no run-time support. This can be essential for embedded and high-performance applications. In particular, this implies that the C++ abstraction mechanisms are usable for embedded, high-performance, high-reliability, and real-time applications. So, programmers of such applications don’t have to work with a low-level (error-prone, impoverished, and unproductive) set of language features.

C++ was designed to be used in a traditional compilation and run-time environment: the C programming environment on the UNIX system [UNIX,1985]. Fortunately, C++ was never restricted to UNIX; it simply used UNIX and C as a model for the relationships among language, libraries, compilers, linkers, execution environments, etc. That minimal model helped C++ to be successful on essentially every computing platform. There are, however, good reasons for using C++ in environments that provide significantly more run-time support. Facilities such as dynamic loading, incremental compilation, and a database of type definitions can be put to good use without affecting the language.

Not every piece of code can be well structured, hardware-independent, easy to read, etc. C++ possesses features that are intended for manipulating hardware facilities in a direct and efficient way without concerns for safety or ease of comprehension. It also possesses facilities for hiding such code behind elegant and safe interfaces.

Naturally, the use of C++ for larger programs leads to the use of C++ by groups of programmers. C++’s emphasis on modularity, strongly typed interfaces, and flexibility pays off here. However, as programs get larger, the problems associated with their development and maintenance shift from being language problems to being more global problems of tools and management.

This book emphasizes techniques for providing general-purpose facilities, generally useful types, libraries, etc. These techniques will serve programmers of small programs as well as programmers of large ones. Furthermore, because all nontrivial programs consist of many semi-independent parts, the techniques for writing such parts serve programmers of all applications.

I use the implementation and use of standard-library components, such as vector, as examples. This introduces library components and their underlying design concepts and implementation techniques. Such examples show how programmers might design and implement their own libraries. However, if the standard library provides a component that addresses a problem, it is almost always better to use that component than to build your own. Even if the standard component is arguably slightly inferior to a home-built component for a particular problem, the standard component is likely to be more widely applicable, more widely available, and more widely known. Over the longer term, the standard component (possibly accessed through a convenient custom interface) is likely to lower long-term maintenance, porting, tuning, and education costs.

You might suspect that specifying a program by using a more detailed type structure would increase the size of the program source text (or even the size of the generated code). With C++, this is not so. A C++ program declaring function argument types, using classes, etc., is typically a bit shorter than the equivalent C program not using these facilities. Where libraries are used, a C++ program will appear much shorter than its C equivalent, assuming, of course, that a functioning C equivalent could have been built.

C++ supports systems programming. This implies that C++ code is able to effectively interoperate with software written in other languages on a system. The idea of writing all software in a single language is a fantasy. From the beginning, C++ was designed to interoperate simply and efficiently with C, assembler, and Fortran. By that, I meant that a C++, C, assembler, or Fortran function could call functions in the other languages without extra overhead or conversion of data structures passed among them.

C++ was designed to operate within a single address space. The use of multiple processes and multiple address spaces relied on (extralinguistic) operating system support. In particular, I assumed that a C++ programmer would have the operating systems command language available for composing processes into a system. Initially, I relied on the UNIX Shell for that, but just about any “scripting language” will do. Thus, C++ provided no support for multiple address spaces and no support for multiple processes, but it was used for systems relying on those features from the earliest days. C++ was designed to be part of large, concurrent, multilanguage systems.

1.3. Learning C++
No programming language is perfect. Fortunately, a programming language does not have to be perfect to be a good tool for building great systems. In fact, a general-purpose programming language cannot be perfect for all of the many tasks to which it is put. What is perfect for one task is often seriously flawed for another because perfection in one area implies specialization. Thus, C++ was designed to be a good tool for building a wide variety of systems and to allow a wide variety of ideas to be expressed directly.

Not everything can be expressed directly using the built-in features of a language. In fact, that isn’t even the ideal. Language features exist to support a variety of programming styles and techniques. Consequently, the task of learning a language should focus on mastering the native and natural styles for that language – not on understanding every little detail of every language feature. Writing programs is essential; understanding a programming language is not just an intellectual exercise. Practical application of ideas is necessary.

In practical programming, there is little advantage in knowing the most obscure language features or using the largest number of features. A single language feature in isolation is of little interest. Only in the context provided by techniques and by other features does the feature acquire meaning and interest. Thus, when reading the following chapters, please remember that the real purpose of examining the details of C++ is to be able to use language features and library facilities in concert to support good programming styles in the context of sound designs.

No significant system is built exclusively in terms of the language features themselves. We build and use libraries to simplify the task of programming and to increase the quality of our systems. We use libraries to improve maintainability, portability, and performance. Fundamental application concepts are represented as abstractions (e.g., classes, templates, and class hierarchies) in libraries. Many of the most fundamental programming concepts are represented in the standard library. Thus, learning the standard library is an integral part of learning C++. The standard library is the repository of much hard-earned knowledge of how to use C++ well.

C++ is widely used for teaching and research. This has surprised some who – correctly – point out that C++ isn’t the smallest or cleanest language ever designed. It is, however:

• Sufficiently clean for successfully teaching basic design and programming concepts

• Sufficiently comprehensive to be a vehicle for teaching advanced concepts and techniques

• Sufficiently realistic, efficient, and flexible for demanding projects

• Sufficiently commercial to be a vehicle for putting what is learned into nonacademic use

• Sufficiently available for organizations and collaborations relying on diverse development and execution environments

C++ is a language that you can grow with.

The most important thing to do when learning C++ is to focus on fundamental concepts (such as type safety, resource management, and invariants) and programming techniques (such as resource management using scoped objects and the use of iterators in algorithms) and not get lost in language-technical details. The purpose of learning a programming language is to become a better programmer, that is, to become more effective at designing and implementing new systems and at maintaining old ones. For this, an appreciation of programming and design techniques is far more important than understanding all the details. The understanding of technical details comes with time and practice.

C++ programming is based on strong static type checking, and most techniques aim at achieving a high level of abstraction and a direct representation of the programmer’s ideas. This can usually be done without compromising run-time and space efficiency compared to lower-level techniques. To gain the benefits of C++, programmers coming to it from a different language must learn and internalize idiomatic C++ programming style and technique. The same applies to programmers used to earlier and less expressive versions of C++.

Thoughtlessly applying techniques effective in one language to another typically leads to awkward, poorly performing, and hard-to-maintain code. Such code is also most frustrating to write because every line of code and every compiler error message reminds the programmer that the language used differs from “the old language.” You can write in the style of Fortran, C, Lisp, Java, etc., in any language, but doing so is neither pleasant nor economical in a language with a different philosophy. Every language can be a fertile source of ideas about how to write C++ programs. However, ideas must be transformed into something that fits with the general structure and type system of C++ in order to be effective in C++. Over the basic type system of a language, only Pyrrhic victories are possible.

In the continuing debate on whether one needs to learn C before C++, I am firmly convinced that it is best to go directly to C++. C++ is safer and more expressive, and it reduces the need to focus on low-level techniques. It is easier for you to learn the trickier parts of C that are needed to compensate for its lack of higher-level facilities after you have been exposed to the common subset of C and C++ and to some of the higher-level techniques supported directly in C++. Chapter 44 is a guide for programmers going from C++ to C, say, to deal with legacy code. My opinion on how to teach C++ to novices is represented by [Stroustrup,2008].

There are several independently developed implementations of C++. They are supported by a wealth of tools, libraries, and software development environments. To help master all of this you can find textbooks, manuals, and a bewildering variety of online resources. If you plan to use C++ seriously, I strongly suggest that you obtain access to several such sources. Each has its own emphasis and bias, so use at least two.

1.3.1. Programming in C++
The question “How does one write good programs in C++?” is very similar to the question “How does one write good English prose?” There are two answers: “Know what you want to say” and “Practice. Imitate good writing.” Both appear to be as appropriate for C++ as they are for English – and as hard to follow.

The main ideal for C++ programming – as for programming in most higher-level languages – is to express concepts (ideas, notions, etc.) from a design directly in code. We try to ensure that the concepts we talk about, represent with boxes and arrows on our whiteboard, and find in our (non-programming) textbooks have direct and obvious counterparts in our programs:

[1] Represent ideas directly in code.

[2] Represent relationships among ideas directly in code (e.g., hierarchical, parametric, and ownership relationships).

[3] Represent independent ideas independently in code.

[4] Keep simple things simple (without making complex things impossible).

More specifically:

[5] Prefer statically type-checked solutions (when applicable).

[6] Keep information local (e.g., avoid global variables, minimize the use of pointers).

[7] Don’t overabstract (i.e., don’t generalize, introduce class hierarchies, or parameterize beyond obvious needs and experience).

More specific suggestions are listed in §1.3.2.

1.3.2. Suggestions for C++ Programmers
By now, many people have been using C++ for a decade or two. Many more are using C++ in a single environment and have learned to live with the restrictions imposed by early compilers and first-generation libraries. Often, what an experienced C++ programmer has failed to notice over the years is not the introduction of new features as such, but rather the changes in relationships between features that make fundamental new programming techniques feasible. In other words, what you didn’t think of when first learning C++ or found impractical just might be a superior approach today. You find out only by reexamining the basics.

Read through the chapters in order. If you already know the contents of a chapter, you can be done in minutes. If you don’t already know the contents, you’ll have learned something unexpected. I learned a fair bit writing this book, and I suspect that hardly any C++ programmer knows every feature and technique presented. Furthermore, to use the language well, you need a perspective that brings order to the set of features and techniques. Through its organization and examples, this book offers such a perspective.

Take the opportunity offered by the new C++11 facilities to modernize your design and programming techniques:

[1] Use constructors to establish invariants (§2.4.3.2, §13.4, §17.2.1).

[2] Use constructor/destructor pairs to simplify resource management (RAII; §5.2, §13.3).

[3] Avoid “naked” new and delete (§3.2.1.2, §11.2.1).

[4] Use containers and algorithms rather than built-in arrays and ad hoc code (§4.4, §4.5, §7.4, Chapter 32).

[5] Prefer standard-library facilities to locally developed code (§1.2.4).

[6] Use exceptions, rather than error codes, to report errors that cannot be handled locally (§2.4.3, §13.1).

[7] Use move semantics to avoid copying large objects (§3.3.2, §17.5.2).

[8] Use unique_ptr to reference objects of polymorphic type (§5.2.1).

[9] Use shared_ptr to reference shared objects, that is, objects without a single owner that is responsible for their destruction (§5.2.1).

[10] Use templates to maintain static type safety (eliminate casts) and avoid unnecessary use of class hierarchies (§27.2).

It might also be a good idea to review the advice for C and Java programmers (§1.3.3, §1.3.4).

1.3.3. Suggestions for C Programmers
The better one knows C, the harder it seems to be to avoid writing C++ in C style, thereby losing many of the potential benefits of C++. Please take a look at Chapter 44, which describes the differences between C and C++.

[1] Don’t think of C++ as C with a few features added. C++ can be used that way, but only suboptimally. To get really major advantages from C++ as compared to C, you need to apply different design and implementation styles.

[2] Don’t write C in C++; that is often seriously suboptimal for both maintenance and performance.

[3] Use the C++ standard library as a teacher of new techniques and programming styles. Note the difference from the C standard library (e.g., = rather than strcpy() for copying and == rather than strcmp() for comparing).

[4] Macro substitution is almost never necessary in C++. Use const (§7.5), constexpr (§2.2.3, §10.4), enum or enum class (§8.4) to define manifest constants, inline (§12.1.5) to avoid function-calling overhead, templates (§3.4, Chapter 23) to specify families of functions and types, and namespaces (§2.4.2, §14.3.1) to avoid name clashes.

[5] Don’t declare a variable before you need it, and initialize it immediately. A declaration can occur anywhere a statement can (§9.3), in for-statement initializers (§9.5), and in conditions (§9.4.3).

[6] Don’t use malloc(). The new operator (§11.2) does the same job better, and instead of realloc(), try a vector (§3.4.2). Don’t just replace malloc() and free() with “naked” new and delete (§3.2.1.2, §11.2.1).

[7] Avoid void*, unions, and casts, except deep within the implementation of some function or class. Their use limits the support you can get from the type system and can harm performance. In most cases, a cast is an indication of a design error. If you must use an explicit type conversion, try using one of the named casts (e.g., static_cast; §11.5.2) for a more precise statement of what you are trying to do.

[8] Minimize the use of arrays and C-style strings. C++ standard-library strings (§4.2), arrays (§8.2.4), and vectors (§4.4.1) can often be used to write simpler and more maintainable code compared to the traditional C style. In general, try not to build yourself what has already been provided by the standard library.

[9] Avoid pointer arithmetic except in very specialized code (such as a memory manager) and for simple array traversal (e.g., ++p).

[10] Do not assume that something laboriously written in C style (avoiding C++ features such as classes, templates, and exceptions) is more efficient than a shorter alternative (e.g., using standard-library facilities). Often (but of course not always), the opposite is true.

To obey C linkage conventions, a C++ function must be declared to have C linkage (§15.2.5).

1.3.4. Suggestions for Java Programmers
C++ and Java are rather different languages with similar syntaxes. Their aims are significantly different and so are many of their application domains. Java is not a direct successor to C++ in the sense of a language that can do the same as its predecessor, but better and also more. To use C++ well, you need to adopt programming and design techniques appropriate to C++, rather than trying to write Java in C++. It is not just an issue of remembering to delete objects that you create with new because you can’t rely on the presence of a garbage collector:

[1] Don’t simply mimic Java style in C++; that is often seriously suboptimal for both maintainability and performance.

[2] Use the C++ abstraction mechanisms (e.g., classes and templates): don’t fall back to a C style of programming out of a false feeling of familiarity.

[3] Use the C++ standard library as a teacher of new techniques and programming styles.

[4] Don’t immediately invent a unique base for all of your classes (an Object class). Typically, you can do better without it for many/most classes.

[5] Minimize the use of reference and pointer variables: use local and member variables (§3.2.1.2, §5.2, §16.3.4, §17.1).

[6] Remember: a variable is never implicitly a reference.

[7] Think of pointers as C++’s equivalent to Java references (C++ references are more limited; there is no reseating of C++ references).

[8] A function is not virtual by default. Not every class is meant for inheritance.

[9] Use abstract classes as interfaces to class hierarchies; avoid “brittle base classes,” that is, base classes with data members.

[10] Use scoped resource management (“Resource Acquisition Is Initialization”; RAII) whenever possible.

[11] Use a constructor to establish a class invariant (and throw an exception if it can’t).

[12] If a cleanup action is needed when an object is deleted (e.g., goes out of scope), use a destructor for that. Don’t imitate finally (doing so is more ad hoc and in the longer run far more work than relying on destructors).

[13] Avoid “naked” new and delete; instead, use containers (e.g., vector, string, and map) and handle classes (e.g., lock and unique_ptr).

[14] Use freestanding functions (nonmember functions) to minimize coupling (e.g., see the standard algorithms), and use namespaces (§2.4.2, Chapter 14) to limit the scope of freestanding functions.

[15] Don’t use exception specifications (except noexcept; §13.5.1.1).

[16] A C++ nested class does not have access to an object of the enclosing class.

[17] C++ offers only the most minimal run-time reflection: dynamic_cast and typeid (Chapter 22). Rely more on compile-time facilities (e.g., compile-time polymorphism; Chapter 27, Chapter 28).

Most of this advice applies equally to C# programmers.

1.4. History
I invented C++, wrote its early definitions, and produced its first implementation. I chose and formulated the design criteria for C++, designed its major language features, developed or helped to develop many of the early libraries, and was responsible for the processing of extension proposals in the C++ standards committee.

C++ was designed to provide Simula’s facilities for program organization [Dahl,1970] [Dahl,1972] together with C’s efficiency and flexibility for systems programming [Kernighan,1978] [Kernighan,1988]. Simula is the initial source of C++’s abstraction mechanisms. The class concept (with derived classes and virtual functions) was borrowed from it. However, templates and exceptions came to C++ later with different sources of inspiration.

The evolution of C++ was always in the context of its use. I spent a lot of time listening to users and seeking out the opinions of experienced programmers. In particular, my colleagues at AT&T Bell Laboratories were essential for the growth of C++ during its first decade.

This section is a brief overview; it does not try to mention every language feature and library component. Furthermore, it does not go into details. For more information, and in particular for more names of people who contributed, see [Stroustrup,1993], [Stroustrup,2007], and [Stroustrup,1994]. My two papers from the ACM History of Programming Languages conference and my Design and Evolution of C++ book (known as “D&E”) describe the design and evolution of C++ in detail and document influences from other programming languages.

Most of the documents produced as part of the ISO C++ standards effort are available online [WG21]. In my FAQ, I try to maintain a connection between the standard facilities and the people who proposed and refined those facilities [Stroustrup,2010]. C++ is not the work of a faceless, anonymous committee or of a supposedly omnipotent “dictator for life”; it is the work of many dedicated, experienced, hard-working individuals.

1.4.1. Timeline
The work that led to C++ started in the fall of 1979 under the name “C with Classes.” Here is a simplified timeline:

1979

Work on “C with Classes” started. The initial feature set included classes and derived classes, public/private access control, constructors and destructors, and function declarations with argument checking. The first library supported non-preemptive concurrent tasks and random number generators.

1984

“C with Classes” was renamed to C++. By then, C++ had acquired virtual functions, function and operator overloading, references, and the I/O stream and complex number libraries.

1985

First commercial release of C++ (October 14). The library included I/O streams, complex numbers, and tasks (non-preemptive scheduling).

1985

The C++ Programming Language (“TC++PL,” October 14) [Stroustrup,1986].

1989

The Annotated C++ Reference Manual (“the ARM”).

1991

The C++ Programming Language, Second Edition [Stroustrup,1991], presenting generic programming using templates and error handling based on exceptions (including the “Resource Acquisition Is Initialization” general resource management idiom).

1997

The C++ Programming Language, Third Edition [Stroustrup,1997] introduced ISO C++, including namespaces, dynamic_cast, and many refinements of templates. The standard library added the STL framework of generic containers and algorithms.

1998

ISO C++ standard.

2002

Work on a revised standard, colloquially named C++0x, started.

2003

A “bug fix” revision of the ISO C++ standard was issued. A C++ Technical Report introduced new standard-library components, such as regular expressions, unordered containers (hash tables), and resource management pointers, which later became part of C++0x.

2006

An ISO C++ Technical Report on Performance was issued to answer questions of cost, predictability, and techniques, mostly related to embedded systems programming.

2009

C++0x was feature complete. It provided uniform initialization, move semantics, variadic template arguments, lambda expressions, type aliases, a memory model suitable for concurrency, and much more. The standard library added several components, including threads, locks, and most of the components from the 2003 Technical Report.

2011

ISO C++11 standard was formally approved.

2012

The first complete C++11 implementations emerged.

2012

Work on future ISO C++ standards (referred to as C++14 and C++17) started.

2013

The C++ Programming Language, Fourth Edition introduced C++11.

During development, C++11 was known as C++0x. As is not uncommon in large projects, we were overly optimistic about the completion date.

1.4.2. The Early Years
I originally designed and implemented the language because I wanted to distribute the services of a UNIX kernel across multiprocessors and local-area networks (what are now known as multicores and clusters). For that, I needed some event-driven simulations for which Simula would have been ideal, except for performance considerations. I also needed to deal directly with hardware and provide high-performance concurrent programming mechanisms for which C would have been ideal, except for its weak support for modularity and type checking. The result of adding Simula-style classes to C, “C with Classes,” was used for major projects in which its facilities for writing programs that use minimal time and space were severely tested. It lacked operator overloading, references, virtual functions, templates, exceptions, and many, many details [Stroustrup,1982]. The first use of C++ outside a research organization started in July 1983.

The name C++ (pronounced “see plus plus”) was coined by Rick Mascitti in the summer of 1983 and chosen as the replacement for “C with Classes” by me. The name signifies the evolutionary nature of the changes from C; “++” is the C increment operator. The slightly shorter name “C+” is a syntax error; it had also been used as the name of an unrelated language. Connoisseurs of C semantics find C++ inferior to ++C. The language was not called D, because it was an extension of C, because it did not attempt to remedy problems by removing features, and because there already existed several would-be C successors named D. For yet another interpretation of the name C++, see the appendix of [Orwell,1949].

C++ was designed primarily so that my friends and I would not have to program in assembler, C, or various then-fashionable high-level languages. Its main purpose was to make writing good programs easier and more pleasant for the individual programmer. In the early years, there was no C++ paper design; design, documentation, and implementation went on simultaneously. There was no “C++ project” either, or a “C++ design committee.” Throughout, C++ evolved to cope with problems encountered by users and as a result of discussions among my friends, my colleagues, and me.

1.4.2.1. Language Features and Library Facilities
The very first design of C++ (then called “C with Classes”) included function declarations with argument type checking and implicit conversions, classes with the public/private distinction between the interface and the implementation, derived classes, and constructors and destructors. I used macros to provide primitive parameterization. This was in use by mid-1980. Late that year, I was able to present a set of language facilities supporting a coherent set of programming styles; see §1.2.1. In retrospect, I consider the introduction of constructors and destructors most significant. In the terminology of the time, “a constructor creates the execution environment for the member functions and the destructor reverses that.” Here is the root of C++’s strategies for resource management (causing a demand for exceptions) and the key to many techniques for making user code short and clear. If there were other languages at the time that supported multiple constructors capable of executing general code, I didn’t (and don’t) know of them. Destructors were new in C++.

C++ was released commercially in October 1985. By then, I had added inlining (§12.1.5, §16.2.8), consts (§2.2.3, §7.5, §16.2.9), function overloading (§12.3), references (§7.7), operator overloading (§3.2.1.1, Chapter 18, Chapter 19), and virtual functions (§3.2.3, §20.3.2). Of these features, support for run-time polymorphism in the form of virtual functions was by far the most controversial. I knew its worth from Simula but found it impossible to convince most people in the systems programming world of its value. Systems programmers tended to view indirect function calls with suspicion, and people acquainted with other languages supporting object-oriented programming had a hard time believing that virtual functions could be fast enough to be useful in systems code. Conversely, many programmers with an object-oriented background had (and many still have) a hard time getting used to the idea that you use virtual function calls only to express a choice that must be made at run time. The resistance to virtual functions may be related to a resistance to the idea that you can get better systems through more regular structure of code supported by a programming language. Many C programmers seem convinced that what really matters is complete flexibility and careful individual crafting of every detail of a program. My view was (and is) that we need every bit of help we can get from languages and tools: the inherent complexity of the systems we are trying to build is always at the edge of what we can express.

Much of the design of C++ was done on the blackboards of my colleagues. In the early years, the feedback from Stu Feldman, Alexander Fraser, Steve Johnson, Brian Kernighan, Doug McIlroy, and Dennis Ritchie was invaluable.

In the second half of the 1980s, I continued to add language features in response to user comments. The most important of those were templates [Stroustrup,1988] and exception handling [Koenig,1990], which were considered experimental at the time the standards effort started. In the design of templates, I was forced to decide among flexibility, efficiency, and early type checking. At the time, nobody knew how to simultaneously get all three, and to compete with C-style code for demanding systems applications, I felt that I had to choose the first two properties. In retrospect, I think the choice was the correct one, and the search for better type checking of templates continues [Gregor,2006] [Sutton,2011] [Stroustrup,2012a]. The design of exceptions focused on multilevel propagation of exceptions, the passing of arbitrary information to an error handler, and the integrations between exceptions and resource management by using local objects with destructors to represent and release resources (what I clumsily called “Resource Acquisition Is Initialization”; §13.3).

I generalized C++’s inheritance mechanisms to support multiple base classes [Stroustrup,1987a]. This was called multiple inheritance and was considered difficult and controversial. I considered it far less important than templates or exceptions. Multiple inheritance of abstract classes (often called interfaces) is now universal in languages supporting static type checking and object-oriented programming.

The C++ language evolved hand in hand with some of the key library facilities presented in this book. For example, I designed the complex [Stroustrup,1984], vector, stack, and (I/O) stream [Stroustrup,1985] classes together with the operator overloading mechanisms. The first string and list classes were developed by Jonathan Shopiro and me as part of the same effort. Jonathan’s string and list classes were the first to see extensive use as part of a library. The string class from the standard C++ library has its roots in these early efforts. The task library described in [Stroustrup,1987b] was part of the first “C with Classes” program ever written in 1980. I wrote it and its associated classes to support Simula-style simulations. Unfortunately, we had to wait until 2011 (30 years!) to get concurrency support standardized and universally available (§1.4.4.2, §5.3, Chapter 41). The development of the template facility was influenced by a variety of vector, map, list, and sort templates devised by Andrew Koenig, Alex Stepanov, me, and others.

C++ grew up in an environment with a multitude of established and experimental programming languages (e.g., Ada [Ichbiah,1979], Algol 68 [Woodward,1974], and ML [Paulson,1996]). At the time, I was comfortable in about 25 languages, and their influences on C++ are documented in [Stroustrup,1994] and [Stroustrup,2007]. However, the determining influences always came from the applications I encountered. That was a deliberate policy to have the development of C++ “problem driven” rather than imitative.

1.4.3. The 1998 Standard
The explosive growth of C++ use caused some changes. Sometime during 1987, it became clear that formal standardization of C++ was inevitable and that we needed to start preparing the ground for a standardization effort [Stroustrup,1994]. The result was a conscious effort to maintain contact between implementers of C++ compilers and major users. This was done through paper and electronic mail and through face-to-face meetings at C++ conferences and elsewhere.

AT&T Bell Labs made a major contribution to C++ and its wider community by allowing me to share drafts of revised versions of the C++ reference manual with implementers and users. Because many of those people worked for companies that could be seen as competing with AT&T, the significance of this contribution should not be underestimated. A less enlightened company could have caused major problems of language fragmentation simply by doing nothing. As it happened, about a hundred individuals from dozens of organizations read and commented on what became the generally accepted reference manual and the base document for the ANSI C++ standardization effort. Their names can be found in The Annotated C++ Reference Manual (“the ARM”) [Ellis,1989]. The X3J16 committee of ANSI was convened in December 1989 at the initiative of Hewlett-Packard. In June 1991, this ANSI (American national) standardization of C++ became part of an ISO (international) standardization effort for C++ and named WG21. From 1990, these joint C++ standards committees have been the main forum for the evolution of C++ and the refinement of its definition. I served on these committees throughout. In particular, as the chairman of the working group for extensions (later called the evolution group), I was directly responsible for handling proposals for major changes to C++ and the addition of new language features. An initial draft standard for public review was produced in April 1995. The first ISO C++ standard (ISO/IEC 14882-1998) [C++,1998] was ratified by a 22-0 national vote in 1998. A “bug fix release” of this standard was issued in 2003, so you sometimes hear people refer to C++03, but that is essentially the same language as C++98.

1.4.3.1. Language Features
By the time the ANSI and ISO standards efforts started, most major language features were in place and documented in the ARM [Ellis,1989]. Consequently, most of the work involved refinement of features and their specification. The template mechanisms, in particular, benefited from much detailed work. Namespaces were introduced to cope with the increased size of C++ programs and the increased number of libraries. At the initiative of Dmitry Lenkov from Hewett-Packard, minimal facilities to use run-time type information (RTTI; Chapter 22) were introduced. I had left such facilities out of C++ because I had found them seriously overused in Simula. I tried to get a facility for optional conservative garbage collection accepted, but failed. We had to wait until the 2011 standard for that.

Clearly, the 1998 language was far superior in features and in particular in the detail of specification to the 1989 language. However, not all changes were improvements. In addition to the inevitable minor mistakes, two major features were added that in retrospect should not have been:

• Exception specifications provide run-time enforcement of which exceptions a function is allowed to throw. They were added at the energetic initiative of people from Sun Microsystems. Exception specifications turned out to be worse than useless for improving readability, reliability, and performance. They are deprecated (scheduled for future removal) in the 2011 standard. The 2011 standard introduced noexcept (§13.5.1.1) as a simpler solution to many of the problems that exception specifications were supposed to address.

• It was always obvious that separate compilation of templates and their uses would be ideal [Stroustrup,1994]. How to achieve that under the constraints from real-world uses of templates was not at all obvious. After a long debate in the committee, a compromise was reached and something called export templates were specified as part of the 1998 standard. It was not an elegant solution to the problem, only one vendor implemented export (the Edison Design Group), and the feature was removed from the 2011 standard. We are still looking for a solution. My opinion is that the fundamental problem is not separate compilation in itself, but that the distinction between interface and implementation of a template is not well specified. Thus, export solved the wrong problem. In the future, language support for “concepts” (§24.3) may help by providing precise specification of template requirements. This is an area of active research and design [Sutton,2011] [Stroustrup,2012a].

1.4.3.2. The Standard Library
The greatest and most important innovation in the 1998 standard was the inclusion of the STL, a framework of algorithms and containers, in the standard library (§4.4, §4.5, Chapter 31, Chapter 32, Chapter 33). It was the work of Alex Stepanov (with Dave Musser, Meng Lee, and others) based on more than a decade’s work on generic programming. Andrew Koenig, Beman Dawes, and I did much to help get the STL accepted [Stroustrup,2007]. The STL has been massively influential within the C++ community and beyond.

Except for the STL, the standard library was a bit of a hodgepodge of components, rather than a unified design. I had failed to ship a sufficiently large foundation library with Release 1.0 of C++ [Stroustrup,1993], and an unhelpful (non-research) AT&T manager had prevented my colleagues and me from rectifying that mistake for Release 2.0. That meant that every major organization (such as Borland, IBM, Microsoft, and Texas Instruments) had its own foundation library by the time the standards work started. Thus, the committee was limited to a patchwork of components based on what had always been available (e.g., the complex library), what could be added without interfering with the major vendor’s libraries, and what was needed to ensure cooperation among different nonstandard libraries.

The standard-library string (§4.2, Chapter 36) had its origins in early work by Jonathan Shopiro and me at Bell Labs but was revised and extended by several different individuals and groups during standardization. The valarray library for numerical computation (§40.5) is primarily the work of Kent Budge. Jerry Schwarz transformed my streams library (§1.4.2.1) into the iostreams library (§4.3, Chapter 38) using Andrew Koenig’s manipulator technique (§38.4.5.2) and other ideas. The iostreams library was further refined during standardization, where the bulk of the work was done by Jerry Schwarz, Nathan Myers, and Norihiro Kumagai.

By commercial standards the C++98 standard library is tiny. For example, there is no standard GUI, database access library, or Web application library. Such libraries are widely available but are not part of the ISO standard. The reasons for that are practical and commercial, rather than technical. However, the C standard library was (and is) many influential people’s measure of a standard library, and compared to that, the C++ standard library is huge.

1.4.4. The 2011 Standard
The current C++, C++11, known for years as C++0x, is the work of the members of WG21. The committee worked under increasingly onerous self-imposed processes and procedures. These processes probably led to a better (and more rigorous) specification, but they also limited innovation [Stroustrup,2007]. An initial draft standard for public review was produced in 2009. The second ISO C++ standard (ISO/IEC 14882-2011) [C++,2011] was ratified by a 21-0 national vote in August 2011.

One reason for the long gap between the two standards is that most members of the committee (including me) were under the mistaken impression that the ISO rules required a “waiting period” after a standard was issued before starting work on new features. Consequently, serious work on new language features did not start until 2002. Other reasons included the increased size of modern languages and their foundation libraries. In terms of pages of standards text, the language grew by about 30% and the standard library by about 100%. Much of the increase was due to more detailed specification, rather than new functionality. Also, the work on a new C++ standard obviously had to take great care not to compromise older code through incompatible changes. There are billions of lines of C++ code in use that the committee must not break.

The overall aims for the C++11 effort were:

• Make C++ a better language for systems programming and library building.

• Make C++ easier to teach and learn.

The aims are documented and detailed in [Stroustrup,2007].

A major effort was made to make concurrent systems programming type-safe and portable. This involved a memory model (§41.2) and a set of facilities for lock-free programming (§41.3), which is primarily the work of Hans Boehm, Brian McKnight, and others. On top of that, we added the threads library. Pete Becker, Peter Dimov, Howard Hinnant, William Kempf, Anthony Williams, and others did massive amounts of work on that. To provide an example of what can be achieved on top of the basic concurrency facilities, I proposed work on “a way to exchange information between tasks without explicit use of a lock,” which became futures and async() (§5.3.5); Lawrence Crowl and Detlef Vollmann did most of the work on that. Concurrency is an area where a complete and detailed listing of who did what and why would require a very long paper. Here, I can’t even try.

1.4.4.1. Language Features
The list of language features and standard-library facilities added to C++98 to get C++11 is presented in §44.2. With the exception of concurrency support, every addition to the language could be deemed “minor,” but doing so would miss the point: language features are meant to be used in combination to write better programs. By “better” I mean easier to read, easier to write, more elegant, less error-prone, more maintainable, faster-running, consuming fewer resources, etc.

Here are what I consider the most widely useful new “building bricks” affecting the style of C++11 code with references to the text and their primary authors:

• Control of defaults: =delete and =default: §3.3.4, §17.6.1, §17.6.4; Lawrence Crowl and Bjarne Stroustrup.

• Deducing the type of an object from its initializer, auto: §2.2.2, §6.3.6.1; Bjarne Stroustrup. I first designed and implemented auto in 1983 but had to remove it because of C compatibility problems.

• Generalized constant expression evaluation (including literal types), constexpr: §2.2.3, §10.4, §12.1.6; Gabriel Dos Reis and Bjarne Stroustrup [DosReis,2010].

• In-class member initializers: §17.4.4; Michael Spertus and Bill Seymour.

• Inheriting constructors: §20.3.5.1; Bjarne Stroustrup, Michael Wong, and Michel Michaud.

• Lambda expressions, a way of implicitly defining function objects at the point of their use in an expression: §3.4.3, §11.4; Jaakko Jarvi.

• Move semantics, a way of transmitting information without copying: §3.3.2, §17.5.2; Howard Hinnant.

• A way of stating that a function may not throw exceptions noexcept: §13.5.1.1; David Abrahams, Rani Sharoni, and Doug Gregor.

• A proper name for the null pointer, §7.2.2; Herb Sutter and Bjarne Stroustrup.

• The range-for statement: §2.2.5, §9.5.1; Thorsten Ottosen and Bjarne Stroustrup.

• Override controls: final and override: §20.3.4. Alisdair Meredith, Chris Uzdavinis, and Ville Voutilainen.

• Type aliases, a mechanism for providing an alias for a type or a template. In particular, a way of defining a template by binding some arguments of another template: §3.4.5, §23.6; Bjarne Stroustrup and Gabriel Dos Reis.

• Typed and scoped enumerations: enum class: §8.4.1; David E. Miller, Herb Sutter, and Bjarne Stroustrup.

• Universal and uniform initialization (including arbitrary-length initializer lists and protection against narrowing): §2.2.2, §3.2.1.3, §6.3.5, §17.3.1, §17.3.4; Bjarne Stroustrup and Gabriel Dos Reis.

• Variadic templates, a mechanism for passing an arbitrary number of arguments of arbitrary types to a template: §3.4.4, §28.6; Doug Gregor and Jaakko Jarvi.

Many more people than can be listed here deserve to be mentioned. The technical reports to the committee [WG21] and my C++11 FAQ [Stroustrup,2010a] give many of the names. The minutes of the committee’s working groups mention more still. The reason my name appears so often is (I hope) not vanity, but simply that I chose to work on what I consider important. These are features that will be pervasive in good code. Their major role is to flesh out the C++ feature set to better support programming styles (§1.2.1). They are the foundation of the synthesis that is C++11.

Much work went into a proposal that did not make it into the standard. “Concepts” was a facility for specifying and checking requirements for template arguments [Gregor,2006] based on previous research (e.g., [Stroustrup,1994] [Siek,2000] [DosReis,2006]) and extensive work in the committee. It was designed, specified, implemented, and tested, but by a large majority the committee decided that the proposal was not yet ready. Had we been able to refine “concepts,” it would have been the most important single feature in C++11 (its only competitor for that title is concurrency support). However, the committee decided against “concepts” on the grounds of complexity, difficulty of use, and compile-time performance [Stroustrup,2010b]. I think we (the committee) did the right thing with “concepts” for C++11, but this feature really was “the one that got away.” This is currently a field of active research and design [Sutton,2011] [Stroustrup,2012a].

1.4.4.2. Standard Library
The work on what became the C++11 standard library started with a standards committee technical report ("TR1"). Initially, Matt Austern was the head of the Library Working Group, and later Howard Hinnant took over until we shipped the final draft standard in 2011.

As for language features, I’ll only list a few standard-library components with references to the text and the names of the individuals most closely associated with them. For a more detailed list, see §44.2.2. Some components, such as unordered_map (hash tables), were ones we simply didn’t manage to finish in time for the C++98 standard. Many others, such as unique_ptr and function were part of a technical report (TR1) based on Boost libraries. Boost is a volunteer organization created to provide useful library components based on the STL [Boost].

• Hashed containers, such as unordered_map: §31.4.3; Matt Austern.

• The basic concurrency library components, such as thread, mutex, and lock: §5.3, §42.2; Pete Becker, Peter Dimov, Howard Hinnant, William Kempf, Anthony Williams, and more.

• Launching asynchronous computation and returning results, future, promise, and async(): §5.3.5, §42.4.6; Detlef Vollmann, Lawrence Crowl, Bjarne Stroustrup, and Herb Sutter.

• The garbage collection interface: §34.5; Michael Spertus and Hans Boehm.

• A regular expression library, regexp: §5.5, Chapter 37; John Maddock.

• A random number library: §5.6.3, §40.7; Jens Maurer and Walter Brown. It was about time. I shipped the first random number library with “C with Classes” in 1980.

Several utility components were tried out in Boost:

• A pointer for simply and efficiently passing resources, unique_ptr: §5.2.1, §34.3.1; Howard E. Hinnant. This was originally called move_ptr and is what auto_ptr should have been had we known how to do so for C++98.

• A pointer for representing shared ownership, shared_ptr: §5.2.1, §34.3.2; Peter Dimov. A successor to the C++98 counted_ptr proposal from Greg Colvin.

• The tuple library: §5.4.3, §28.5, §34.2.4.2; Jaakko Jarvi and Gary Powell. They credit a long list of contributors, including Doug Gregor, David Abrahams, and Jeremy Siek.

• The general bind(): §33.5.1; Peter Dimov. His acknowledgments list a veritable who’s who of Boost (including Doug Gregor, John Maddock, Dave Abrahams, and Jaakko Jarvi).

• The function type for holding callable objects: §33.5.3; Doug Gregor. He credits William Kempf and others with contributions.

1.4.5. What is C++ used for?
By now (2013), C++ is used just about everywhere: it is in your computer, your phone, your car, probably even in your camera. You don’t usually see it. C++ is a systems programming language, and its most pervasive uses are deep in the infrastructure where we, as users, never look.

C++ is used by millions of programmers in essentially every application domain. Billions (thousands of millions) of lines of C++ are currently deployed. This massive use is supported by half a dozen independent implementations, many thousands of libraries, hundreds of textbooks, and dozens of websites. Training and education at a variety of levels are widely available.

Early applications tended to have a strong systems programming flavor. For example, several early operating systems have been written in C++: [Campbell,1987] (academic), [Rozier,1988] (real time), [Berg,1995] (high-throughput I/O). Many current ones (e.g., Windows, Apple’s OS, Linux, and most portable-device OSs) have key parts done in C++. Your cellphone and Internet routers are most likely written in C++. I consider uncompromising low-level efficiency essential for C++. This allows us to use C++ to write device drivers and other software that rely on direct manipulation of hardware under real-time constraints. In such code, predictability of performance is at least as important as raw speed. Often, so is the compactness of the resulting system. C++ was designed so that every language feature is usable in code under severe time and space constraints (§1.2.4) [Stroustrup,1994,§4.5].

Some of today’s most visible and widely used systems have their critical parts written in C++. Examples are Amadeus (airline ticketing), Amazon (Web commerce), Bloomberg (financial information), Google (Web search), and Facebook (social media). Many other programming languages and technologies depend critically on C++’s performance and reliability in their implementation. Examples include the most widely used Java Virtual Machines (e.g., Oracle’s HotSpot), JavaScript interpreters (e.g., Google’s V8), browsers (e.g., Microsoft’s Internet Explorer, Mozilla’s Firefox, Apple’s Safari, and Google’s Chrome), and application frameworks (e.g., Microsoft’s .NET Web services framework). I consider C++ to have unique strengths in the area of infrastructure software [Stroustrup,2012b].

Most applications have sections of code that are critical for acceptable performance. However, the largest amount of code is not in such sections. For most code, maintainability, ease of extension, and ease of testing are key. C++’s support for these concerns has led to its widespread use in areas where reliability is a must and where requirements change significantly over time. Examples are financial systems, telecommunications, device control, and military applications. For decades, the central control of the U.S. long-distance telephone system has relied on C++, and every 800 call (i.e., a call paid for by the called party) has been routed by a C++ program [Kamath,1993]. Many such applications are large and long-lived. As a result, stability, compatibility, and scalability have been constant concerns in the development of C++. Multimillion-line C++ programs are common.

Games is another area where a multiplicity of languages and tools need to coexist with a language providing uncompromising efficiency (often on “unusual” hardware). Thus, games has been another major applications area for C++.

What used to be called systems programming is widely found in embedded systems, so it is not surprising to find massive use of C++ in demanding embedded systems projects, including computer tomography (CAT scanners), flight control software (e.g., Lockheed-Martin), rocket control, ship’s engines (e.g., the control of the world’s largest marine diesel engines from MAN), automobile software (e.g., BMW), and wind turbine control (e.g., Vesta).

C++ wasn’t specifically designed with numerical computation in mind. However, much numerical, scientific, and engineering computation is done in C++. A major reason for this is that traditional numerical work must often be combined with graphics and with computations relying on data structures that don’t fit into the traditional Fortran mold (e.g., [Root,1995]). I am particularly pleased to see C++ used in major scientific endeavors, such as the Human Genome Project, NASA’s Mars Rovers, CERN’s search for the fundamentals of the universe, and many others.

C++’s ability to be used effectively for applications that require work in a variety of application areas is an important strength. Applications that involve local- and wide-area networking, numerics, graphics, user interaction, and database access are common. Traditionally, such application areas were considered distinct and were served by distinct technical communities using a variety of programming languages. However, C++ is widely used in all of those areas, and more. It is designed so that C++ code can coexist with code written in other languages. Here, again, C++’s stability over decades is important. Furthermore, no really major system is written 100% in a single language. Thus, C++’s original design aim of interoperability becomes significant.

Major applications are not written in just the raw language. C++ is supported by a variety of libraries (beyond the ISO C++ standard library) and tool sets, such as Boost [Boost] (portable foundation libraries), POCO (Web development), Qt (cross-platform application development), wxWidgets (a cross-platform GUI library), WebKit (a layout engine library for Web browsers), CGAL (computational geometry), QuickFix (Financial Information eXchange), OpenCV (real-time image processing), and Root [Root,1995] (High-Energy Physics). There are many thousands of C++ libraries, so keeping up with them all is impossible.

1.5. Advice
Each chapter contains an “Advice” section with a set of concrete recommendations related to its contents. Such advice consists of rough rules of thumb, not immutable laws. A piece of advice should be applied only where reasonable. There is no substitute for intelligence, experience, common sense, and good taste.

I find rules of the form “never do this” unhelpful. Consequently, most advice is phrased as suggestions for what to do. Negative suggestions tend not to be phrased as absolute prohibitions and I try to suggest alternatives. I know of no major feature of C++ that I have not seen put to good use. The “Advice” sections do not contain explanations. Instead, each piece of advice is accompanied by a reference to an appropriate section of the book.

For starters, here are a few high-level recommendations derived from the sections on design, learning, and history of C++:

[1] Represent ideas (concepts) directly in code, for example, as a function, a class, or an enumeration; §1.2.

[2] Aim for your code to be both elegant and efficient; §1.2.

[3] Don’t overabstract; §1.2.

[4] Focus design on the provision of elegant and efficient abstractions, possibly presented as libraries; §1.2.

[5] Represent relationships among ideas directly in code, for example, through parameterization or a class hierarchy; §1.2.1.

[6] Represent independent ideas separately in code, for example, avoid mutual dependencies among classes; §1.2.1.

[7] C++ is not just object-oriented; §1.2.1.

[8] C++ is not just for generic programming; §1.2.1.

[9] Prefer solutions that can be statically checked; §1.2.1.

[10] Make resources explicit (represent them as class objects); §1.2.1, §1.4.2.1.

[11] Express simple ideas simply; §1.2.1.

[12] Use libraries, especially the standard library, rather than trying to build everything from scratch; §1.2.1.

[13] Use a type-rich style of programming; §1.2.2.

[14] Low-level code is not necessarily efficient; don’t avoid classes, templates, and standard-library components out of fear of performance problems; §1.2.4, §1.3.3.

[15] If data has an invariant, encapsulate it; §1.3.2.

[16] C++ is not just C with a few extensions; §1.3.3.

In general: To write a good program takes intelligence, taste, and patience. You are not going to get it right the first time. Experiment!

1.6. References
[Austern,2003]

Matt Austern et al.: Untangling the Balancing and Searching of Balanced Binary Search Trees. Software – Practice & Experience. Vol 33, Issue 13. November 2003.

[Barron,1963]

D. W. Barron et al.: The main features of CPL. The Computer Journal. 6 (2): 134. (1963). comjnl.oxfordjournals.org/content/6/2/134.full.pdf+html.

[Barton,1994]

J. J. Barton and L. R. Nackman: Scientific and Engineering C++: An Introduction with Advanced Techniques and Examples. Addison-Wesley. Reading, Massachusetts. 1994. ISBN 0-201-53393-6.

[Berg,1995]

William Berg, Marshall Cline, and Mike Girou: Lessons Learned from the OS/400 OO Project. CACM. Vol. 38, No. 10. October 1995.

[Boehm,2008]

Hans-J. Boehm and Sarita V. Adve: Foundations of the C++ concurrency memory model. ACM PLDI’08.

[Boost]

The Boost library collection. www.boost.org.

[Budge,1992]

Kent Budge, J. S. Perry, and A. C. Robinson: High-Performance Scientific Computation Using C++. Proc. USENIX C++ Conference. Portland, Oregon. August 1992.

[C,1990]

X3 Secretariat: Standard – The C Language. X3J11/90-013. ISO Standard ISO/IEC 9899-1990. Computer and Business Equipment Manufacturers Association. Washington, DC.

[C,1999]

ISO/IEC 9899. Standard – The C Language. X3J11/90-013-1999.

[C,2011]

ISO/IEC 9899. Standard – The C Language. X3J11/90-013-2011.

[C++,1998]

ISO/IEC JTC1/SC22/WG21: International Standard – The C++ Language. ISO/IEC 14882:1998.

[C++Math,2010]

International Standard – Extensions to the C++ Library to Support Mathematical Special Functions. ISO/IEC 29124:2010.

[C++,2011]

ISO/IEC JTC1/SC22/WG21: International Standard – The C++ Language. ISO/IEC 14882:2011.

[Campbell,1987]

Roy Campbell et al.: The Design of a Multiprocessor Operating System. Proc. USENIX C++ Conference. Santa Fe, New Mexico. November 1987.

[Coplien,1995]

James O. Coplien: Curiously Recurring Template Patterns. The C++ Report. February 1995.

[Cox,2007]

Russ Cox: Regular Expression Matching Can Be Simple And Fast. January 2007. swtch.com/~rsc/regexp/regexp1.html.

[Czarnecki,2000]

K. Czarnecki and U. Eisenecker: Generative Programming: Methods, Tools, and Applications. Addison-Wesley. Reading, Massachusetts. 2000. ISBN 0-201-30977-7.

[Dahl,1970]

O-J. Dahl, B. Myrhaug, and K. Nygaard: SIMULA Common Base Language. Norwegian Computing Center S-22. Oslo, Norway. 1970.

[Dahl,1972]

O-J. Dahl and C. A. R. Hoare: Hierarchical Program Construction in Structured Programming. Academic Press. New York. 1972.

[Dean,2004]

J. Dean and S. Ghemawat: MapReduce: Simplified Data Processing on Large Clusters. OSDI’04: Sixth Symposium on Operating System Design and Implementation. 2004.

[Dechev,2010]

D. Dechev, P. Pirkelbauer, and B. Stroustrup: Understanding and Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs. 13th IEEE Computer Society ISORC 2010 Symposium. May 2010.

[DosReis,2006]

Gabriel Dos Reis and Bjarne Stroustrup: Specifying C++ Concepts. POPL06. January 2006.

[DosReis,2010]

Gabriel Dos Reis and Bjarne Stroustrup: General Constant Expressions for System Programming Languages. SAC-2010. The 25th ACM Symposium On Applied Computing. March 2010.

[DosReis,2011]

Gabriel Dos Reis and Bjarne Stroustrup: A Principled, Complete, and Efficient Representation of C++. Journal of Mathematics in Computer Science. Vol. 5, Issue 3. 2011.

[Ellis,1989]

Margaret A. Ellis and Bjarne Stroustrup: The Annotated C++ Reference Manual. Addison-Wesley. Reading, Mass. 1990. ISBN 0-201-51459-1.

[Freeman,1992]

Len Freeman and Chris Phillips: Parallel Numerical Algorithms. Prentice Hall. Englewood Cliffs, New Jersey. 1992. ISBN 0-13-651597-5.

[Friedl,1997]:

Jeffrey E. F. Friedl: Mastering Regular Expressions. O’Reilly Media. Sebastopol, California. 1997. ISBN 978-1565922570.

[Gamma,1995]

Erich Gamma et al.: Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley. Reading, Massachusetts. 1994. ISBN 0-201-63361-2.

[Gregor,2006]

Douglas Gregor et al.: Concepts: Linguistic Support for Generic Programming in C++. OOPSLA’06.

[Hennessy,2011]

John L. Hennessy and David A. Patterson: Computer Architecture, Fifth Edition: A Quantitative Approach. Morgan Kaufmann. San Francisco, California. 2011. ISBN 978-0123838728.

[Ichbiah,1979]

Jean D. Ichbiah et al.: Rationale for the Design of the ADA Programming Language. SIGPLAN Notices. Vol. 14, No. 6. June 1979.

[Kamath,1993]

Yogeesh H. Kamath, Ruth E. Smilan, and Jean G. Smith: Reaping Benefits with Object-Oriented Technology. AT&T Technical Journal. Vol. 72, No. 5. September/October 1993.

[Kernighan,1978]

Brian W. Kernighan and Dennis M. Ritchie: The C Programming Language. Prentice Hall. Englewood Cliffs, New Jersey. 1978.

[Kernighan,1988]

Brian W. Kernighan and Dennis M. Ritchie: The C Programming Language, Second Edition. Prentice-Hall. Englewood Cliffs, New Jersey. 1988. ISBN 0-13-110362-8.

[Knuth,1968]

Donald E. Knuth: The Art of Computer Programming. Addison-Wesley. Reading, Massachusetts. 1968.

[Koenig,1989]

Andrew Koenig and Bjarne Stroustrup: C++: As close to C as possible – but no closer. The C++ Report. Vol. 1, No. 7. July 1989.

[Koenig,1990]

A. R. Koenig and B. Stroustrup: Exception Handling for C++ (revised). Proc USENIX C++ Conference. April 1990.

[Kolecki,2002]

Joseph C. Kolecki: An Introduction to Tensors for Students of Physics and Engineering. NASA/TM-2002-211716.

[Langer,2000]

Angelika Langer and Klaus Kreft: Standard C++ IOStreams and Locales: Advanced Programmer’s Guide and Reference. Addison-Wesley. 2000. ISBN 978-0201183955.

[McKenney]

Paul E. McKenney: Is Parallel Programming Hard, And, If So, What Can You Do About It? kernel.org. Corvallis, Oregon. 2012. http://kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html.

[Maddock,2009]

John Maddock: Boost.Regex. www.boost.org. 2009.

[Orwell,1949]

George Orwell: 1984. Secker and Warburg. London. 1949.

[Paulson,1996]

Larry C. Paulson: ML for the Working Programmer. Cambridge University Press. Cambridge. 1996. ISBN 0-521-56543-X.

[Pirkelbauer,2009]

P. Pirkelbauer, Y. Solodkyy, and B. Stroustrup: Design and Evaluation of C++ Open Multi-Methods. Science of Computer Programming. Elsevier Journal. June 2009. doi:10.1016/j.scico.2009.06.002.

[Richards,1980]

Martin Richards and Colin Whitby-Strevens: BCPL – The Language and Its Compiler. Cambridge University Press. Cambridge. 1980. ISBN 0-521-21965-5.

[Root,1995]

ROOT: A Data Analysis Framework. root.cern.ch. It seems appropriate to represent a tool from CERN, the birthplace of the World Wide Web, by a Web address.

[Rozier,1988]

M. Rozier et al.: CHORUS Distributed Operating Systems. Computing Systems. Vol. 1, No. 4. Fall 1988.

[Siek,2000]

Jeremy G. Siek and Andrew Lumsdaine: Concept checking: Binding parametric polymorphism in C++. Proc. First Workshop on C++ Template Programming. Erfurt, Germany. 2000.

[Solodkyy,2012]

Y. Solodkyy, G. Dos Reis, and B. Stroustrup: Open and Efficient Type Switch for C++. Proc. OOPSLA’12.

[Stepanov,1994]

Alexander Stepanov and Meng Lee: The Standard Template Library. HP Labs Technical Report HPL-94-34 (R. 1). 1994.

[Stewart,1998]

G. W. Stewart: Matrix Algorithms, Volume I. Basic Decompositions. SIAM. Philadelphia, Pennsylvania. 1998.

[Stroustrup,1982]

B. Stroustrup: Classes: An Abstract Data Type Facility for the C Language. Sigplan Notices. January 1982. The first public description of “C with Classes.”

[Stroustrup,1984]

B. Stroustrup: Operator Overloading in C++. Proc. IFIP WG2.4 Conference on System Implementation Languages: Experience & Assessment. September 1984.

[Stroustrup,1985]

B. Stroustrup: An Extensible I/O Facility for C++. Proc. Summer 1985 USENIX Conference.

[Stroustrup,1986]

B. Stroustrup: The C++ Programming Language. Addison-Wesley. Reading, Massachusetts. 1986. ISBN 0-201-12078-X.

[Stroustrup,1987]

B. Stroustrup: Multiple Inheritance for C++. Proc. EUUG Spring Conference. May 1987.

[Stroustrup,1987b]

B. Stroustrup and J. Shopiro: A Set of C Classes for Co-Routine Style Programming. Proc. USENIX C++ Conference. Santa Fe, New Mexico. November 1987.

[Stroustrup,1988]

B. Stroustrup: Parameterized Types for C++. Proc. USENIX C++ Conference, Denver. 1988.

[Stroustrup,1991]

B. Stroustrup: The C++ Programming Language (Second Edition). Addison-Wesley. Reading, Massachusetts. 1991. ISBN 0-201-53992-6.

[Stroustrup,1993]

B. Stroustrup: A History of C++: 1979-1991. Proc. ACM History of Programming Languages conference (HOPL-2). ACM Sigplan Notices. Vol 28, No 3. 1993.

[Stroustrup,1994]

B. Stroustrup: The Design and Evolution of C++. Addison-Wesley. Reading, Mass. 1994. ISBN 0-201-54330-3.

[Stroustrup,1997]

B. Stroustrup: The C++ Programming Language, Third Edition. Addison-Wesley. Reading, Massachusetts. 1997. ISBN 0-201-88954-4. Hardcover (“Special”) Edition. 2000. ISBN 0-201-70073-5.

[Stroustrup,2002]

B. Stroustrup: C and C++: Siblings, C and C++: A Case for Compatibility, and C and C++: Case Studies in Compatibility. The C/C++ Users Journal. July-September 2002. www.stroustrup.com/papers.html.

[Stroustrup,2007]

B. Stroustrup: Evolving a language in and for the real world: C++ 1991-2006. ACM HOPL-III. June 2007.

[Stroustrup,2008]

B. Stroustrup: Programming – Principles and Practice Using C++. Addison-Wesley. 2009. ISBN 0-321-54372-6.

[Stroustrup,2010a]

B. Stroustrup: The C++11 FAQ. www.stroustrup.com/C++11FAQ.html.

[Stroustrup,2010b]

B. Stroustrup: The C++0x “Remove Concepts” Decision. Dr. Dobb’s Journal. July 2009.

[Stroustrup,2012a]

B. Stroustrup and A. Sutton: A Concept Design for the STL. WG21 Technical Report N3351==12-0041. January 2012.

[Stroustrup,2012b]

B. Stroustrup: Software Development for Infrastructure. Computer. January 2012. doi:10.1109/MC.2011.353.

[Sutton,2011]

A. Sutton and B. Stroustrup: Design of Concept Libraries for C++. Proc. SLE 2011 (International Conference on Software Language Engineering). July 2011.

[Tanenbaum,2007]

Andrew S. Tanenbaum: Modern Operating Systems, Third Edition. Prentice Hall. Upper Saddle River, New Jersey. 2007. ISBN 0-13-600663-9.

[Tsafrir,2009]

Dan Tsafrir et al.: Minimizing Dependencies within Generic Classes for Faster and Smaller Programs. ACM OOPSLA’09. October 2009.

[Unicode,1996]

The Unicode Consortium: The Unicode Standard, Version 2.0. Addison-Wesley. Reading, Massachusetts. 1996. ISBN 0-201-48345-9.

[UNIX,1985]

UNIX Time-Sharing System: Programmer’s Manual. Research Version, Tenth Edition. AT&T Bell Laboratories, Murray Hill, New Jersey. February 1985.

[Vandevoorde,2002]

David Vandevoorde and Nicolai M. Josuttis: C++ Templates: The Complete Guide. Addison-Wesley. 2002. ISBN 0-201-73484-2.

[Veldhuizen,1995]

Todd Veldhuizen: Expression Templates. The C++ Report. June 1995.

[Veldhuizen,2003]

Todd L. Veldhuizen: C++ Templates are Turing Complete. Indiana University Computer Science Technical Report. 2003.

[Vitter,1985]

Jefferey Scott Vitter: Random Sampling with a Reservoir. ACM Transactions on Mathematical Software, Vol. 11, No. 1. 1985.

[WG21]

ISO SC22/WG21 The C++ Programming Language Standards Committee: Document Archive. www.open-std.org/jtc1/sc22/wg21.

[Williams,2012]

Anthony Williams: C++ Concurrency in Action – Practical Multithreading. Manning Publications Co. ISBN 978-1933988771.

[Wilson,1996]

Gregory V. Wilson and Paul Lu (editors): Parallel Programming Using C++. The MIT Press. Cambridge, Mass. 1996. ISBN 0-262-73118-5.

[Wood,1999]

Alistair Wood: Introduction to Numerical Analysis. Addison-Wesley. Reading, Massachusetts. 1999. ISBN 0-201-34291-X.

[Woodward,1974]

P. M. Woodward and S. G. Bond: Algol 68-R Users Guide. Her Majesty’s Stationery Office. London. 1974.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


1. Notes to the Reader
2. A Tour of C++: The Basics
3. A Tour of C++: Abstraction Mechanisms
47h 26m remaining
2. A Tour of C++: The Basics
The first thing we do, let’s kill all the language lawyers.

– Henry VI, Part II

• Introduction

• The Basics

Hello, World!; Types, Variables, and Arithmetic; Constants; Tests and Loops; Pointers, Arrays, and Loops

• User-Defined Types

Structures; Classes; Enumerations

• Modularity

Separate Compilation; Namespaces; Error Handling

• Postscript

• Advice

2.1. Introduction
The aim of this chapter and the next three is to give you an idea of what C++ is, without going into a lot of details. This chapter informally presents the notation of C++, C++’s model of memory and computation, and the basic mechanisms for organizing code into a program. These are the language facilities supporting the styles most often seen in C and sometimes called procedural programming. Chapter 3 follows up by presenting C++’s abstraction mechanisms. Chapter 4 and Chapter 5 give examples of standard-library facilities.

The assumption is that you have programmed before. If not, please consider reading a textbook, such as Programming: Principles and Practice Using C++ [Stroustrup,2009], before continuing here. Even if you have programmed before, the language you used or the applications you wrote may be very different from the style of C++ presented here. If you find this “lightning tour” confusing, skip to the more systematic presentation starting in Chapter 6.

This tour of C++ saves us from a strictly bottom-up presentation of language and library facilities by enabling the use of a rich set of facilities even in early chapters. For example, loops are not discussed in detail until Chapter 10, but they will be used in obvious ways long before that. Similarly, the detailed description of classes, templates, free-store use, and the standard library are spread over many chapters, but standard-library types, such as vector, string, complex, map, unique_ptr, and ostream, are used freely where needed to improve code examples.

As an analogy, think of a short sightseeing tour of a city, such as Copenhagen or New York. In just a few hours, you are given a quick peek at the major attractions, told a few background stories, and usually given some suggestions about what to see next. You do not know the city after such a tour. You do not understand all you have seen and heard. To really know a city, you have to live in it, often for years. However, with a bit of luck, you will have gained a bit of an overview, a notion of what is special about the city, and ideas of what might be of interest to you. After the tour, the real exploration can begin.

This tour presents C++ as an integrated whole, rather than as a layer cake. Consequently, it does not identify language features as present in C, part of C++98, or new in C++11. Such historical information can be found in §1.4 and Chapter 44.

2.2. The Basics
C++ is a compiled language. For a program to run, its source text has to be processed by a compiler, producing object files, which are combined by a linker yielding an executable program. A C++ program typically consists of many source code files (usually simply called source files).



An executable program is created for a specific hardware/system combination; it is not portable, say, from a Mac to a Windows PC. When we talk about portability of C++ programs, we usually mean portability of source code; that is, the source code can be successfully compiled and run on a variety of systems.

The ISO C++ standard defines two kinds of entities:

• Core language features, such as built-in types (e.g., char and int) and loops (e.g., for-statements and while-statements)

• Standard-library components, such as containers (e.g., vector and map) and I/O operations (e.g., << and getline())

The standard-library components are perfectly ordinary C++ code provided by every C++ implementation. That is, the C++ standard library can be implemented in C++ itself (and is with very minor uses of machine code for things such as thread context switching). This implies that C++ is sufficiently expressive and efficient for the most demanding systems programming tasks.

C++ is a statically typed language. That is, the type of every entity (e.g., object, value, name, and expression) must be known to the compiler at its point of use. The type of an object determines the set of operations applicable to it.

2.2.1. Hello, World!
The minimal C++ program is

int main() { }     // the minimal C++ program
This defines a function called main, which takes no arguments and does nothing (§15.4).

Curly braces, { }, express grouping in C++. Here, they indicate the start and end of the function body. The double slash, //, begins a comment that extends to the end of the line. A comment is for the human reader; the compiler ignores comments.

Every C++ program must have exactly one global function named main(). The program starts by executing that function. The int value returned by main(), if any, is the program’s return value to “the system.” If no value is returned, the system will receive a value indicating successful completion. A nonzero value from main() indicates failure. Not every operating system and execution environment make use of that return value: Linux/Unix-based environments often do, but Windows-based environments rarely do.

Typically, a program produces some output. Here is a program that writes Hello, World!:

Click here to view code image

#include <iostream>

int main()
{
     std::cout << "Hello, World!\n";
}
The line #include <iostream> instructs the compiler to include the declarations of the standard stream I/O facilities as found in iostream. Without these declarations, the expression

std::cout << "Hello, World!\n"
would make no sense. The operator << (“put to”) writes its second argument onto its first. In this case, the string literal "Hello, World!\n" is written onto the standard output stream std::cout. A string literal is a sequence of characters surrounded by double quotes. In a string literal, the backslash character \ followed by another character denotes a single “special character.” In this case, \n is the newline character, so that the characters written are Hello, World! followed by a newline.

The std:: specifies that the name cout is to be found in the standard-library namespace (§2.4.2, Chapter 14). I usually leave out the std:: when discussing standard features; §2.4.2 shows how to make names from a namespace visible without explicit qualification.

Essentially all executable code is placed in functions and called directly or indirectly from main(). For example:

Click here to view code image

#include <iostream>
using namespace std;       // make names from std visible without std:: (§2.4.2)

double square(double x)    // square a double precision floating-point number
{
    return x*x;
}
void print_square(double x)
{
     cout << "the square of " << x << " is " << square(x) << "\n";
}

int main()
{
     print_square(1.234);      // print: the square of 1.234 is 1.52276
}
A “return type” void indicates that a function does not return a value.

2.2.2. Types, Variables, and Arithmetic
Every name and every expression has a type that determines the operations that may be performed on it. For example, the declaration

int inch;
specifies that inch is of type int; that is, inch is an integer variable.

A declaration is a statement that introduces a name into the program. It specifies a type for the named entity:

• A type defines a set of possible values and a set of operations (for an object).

• An object is some memory that holds a value of some type.

• A value is a set of bits interpreted according to a type.

• A variable is a named object.

C++ offers a variety of fundamental types. For example:

Click here to view code image

bool     // Boolean, possible values are true and false
char     // character, for example, 'a', ' z', and '9'
int      // integer, for example, -213, 42, and 1066
double   // double-precision floating-point number, for example, 3.14 and 299793.0
Each fundamental type corresponds directly to hardware facilities and has a fixed size that determines the range of values that can be stored in it:



A char variable is of the natural size to hold a character on a given machine (typically an 8-bit byte), and the sizes of other types are quoted in multiples of the size of a char. The size of a type is implementation-defined (i.e., it can vary among different machines) and can be obtained by the sizeof operator; for example, sizeof(char) equals 1 and sizeof(int) is often 4.

The arithmetic operators can be used for appropriate combinations of these types:

Click here to view code image

x+y      // plus
+x       // unary plus
x–y      // minus
–x       // unary minus
x*y      // multiply
x/y      // divide
x%y      // remainder (modulus) for integers
So can the comparison operators:

Click here to view code image

x==y     // equal
x!=y     // not equal
x<y      // less than
x>y      // greater than
x<=y     // less than or equal
x>=y     // greater than or equal
In assignments and in arithmetic operations, C++ performs all meaningful conversions (§10.5.3) between the basic types so that they can be mixed freely:

Click here to view code image

void some_function()       // function that doesn't return a value
{
     double d = 2.2;       // initialize floating-point number
     int i = 7;            // initialize integer
     d = d+i;              // assign sum to d
     i = d*i;              // assign product to i (truncating the double d*i to an int)
}
Note that = is the assignment operator and == tests equality.

C++ offers a variety of notations for expressing initialization, such as the = used above, and a universal form based on curly-brace-delimited initializer lists:

Click here to view code image

double d1 = 2.3;       // initialize d1 with 2.3
double d2 {2.3};       // initialize d2 with 2.3

complex<double> z = 1;           // a complex number with double-precision floating-point scalars
complex<double> z2 {d1,d2};
complex<double> z3 = {1,2};      // the = is optional with { ... }

vector<int> v {1,2,3,4,5,6};     // a vector of ints
The = form is traditional and dates back to C, but if in doubt, use the general {}-list form (§6.3.5.2). If nothing else, it saves you from conversions that lose information (narrowing conversions; §10.5):

Click here to view code image

int i1 = 7.2;       // i1 becomes 7 (surprise?)
int i2 {7.2};       // error: floating-point to integer conversion
int i3 = {7.2};     // error: floating-point to integer conversion (the = is redundant)
A constant (§2.2.3) cannot be left uninitialized and a variable should only be left uninitialized in extremely rare circumstances. Don’t introduce a name until you have a suitable value for it. User-defined types (such as string, vector, Matrix, Motor_controller, and Orc_warrior) can be defined to be implicitly initialized (§3.2.1.1).

When defining a variable, you don’t actually need to state its type explicitly when it can be deduced from the initializer:

Click here to view code image

auto b = true;     // a bool
auto ch = 'x';     // a char
auto i = 123;      // an int
auto d = 1.2;      // a double
auto z = sqrt(y);  // z has the type of whatever sqrt(y) returns
With auto, we use the = syntax because there is no type conversion involved that might cause problems (§6.3.6.2).

We use auto where we don’t have a specific reason to mention the type explicitly. “Specific reasons” include:

• The definition is in a large scope where we want to make the type clearly visible to readers of our code.

• We want to be explicit about a variable’s range or precision (e.g., double rather than float).

Using auto, we avoid redundancy and writing long type names. This is especially important in generic programming where the exact type of an object can be hard for the programmer to know and the type names can be quite long (§4.5.1).

In addition to the conventional arithmetic and logical operators (§10.3), C++ offers more specific operations for modifying a variable:

Click here to view code image

x+=y    // x = x+y
++x     // increment: x = x+1
x–=y    // x = x-y
––x     // decrement: x = x-1
x*=y    // scaling: x = x*y
x/=y    // scaling: x = x/y
x%=y    // x = x%y
These operators are concise, convenient, and very frequently used.

2.2.3. Constants
C++ supports two notions of immutability (§7.5):

• const: meaning roughly “I promise not to change this value” (§7.5). This is used primarily to specify interfaces, so that data can be passed to functions without fear of it being modified. The compiler enforces the promise made by const.

• constexpr: meaning roughly “to be evaluated at compile time” (§10.4). This is used primarily to specify constants, to allow placement of data in read-only memory (where it is unlikely to be corrupted), and for performance.

For example:

Click here to view code image

const int dmv = 17;                         // dmv is a named constant
int var = 17;                               // var is not a constant
constexpr double max1 = 1.4*square(dmv);    // OK if square(17) is a constant expression
constexpr double max2 = 1.4*square(var);    // error: var is not a constant expression
const double max3 = 1.4*square(var);        // OK, may be evaluated at run time
double sum(const vector<double>&);          // sum will not modify its argument (§2.2.5)
vector<double> v {1.2, 3.4, 4.5};           // v is not a constant
const double s1 = sum(v);                   // OK: evaluated at run time
constexpr double s2 = sum(v);               // error: sum(v) not constant expression
For a function to be usable in a constant expression, that is, in an expression that will be evaluated by the compiler, it must be defined constexpr. For example:

constexpr double square(double x) { return x*x; }
To be constexpr, a function must be rather simple: just a return-statement computing a value. A constexpr function can be used for non-constant arguments, but when that is done the result is not a constant expression. We allow a constexpr function to be called with non-constant-expression arguments in contexts that do not require constant expressions, so that we don’t have to define essentially the same function twice: once for constant expressions and once for variables.

In a few places, constant expressions are required by language rules (e.g., array bounds (§2.2.5, §7.3), case labels (§2.2.4, §9.4.2), some template arguments (§25.2), and constants declared using constexpr). In other cases, compile-time evaluation is important for performance. Independently of performance issues, the notion of immutability (of an object with an unchangeable state) is an important design concern (§10.4).

2.2.4. Tests and Loops
C++ provides a conventional set of statements for expressing selection and looping. For example, here is a simple function that prompts the user and returns a Boolean indicating the response:

Click here to view code image

bool accept()
{
     cout << "Do you want to proceed (y or n)?\n";    // write question

     char answer = 0;
     cin >> answer;                                   // read answer

     if (answer == 'y') return true;
     return false;
}
To match the << output operator (“put to”), the >> operator (“get from”) is used for input; cin is the standard input stream. The right-hand operand of >>> is the target of the input operation and that operand’s type determines what input the >> accepts. The \n character at the end of the output string represents a newline (§2.2.1).

The example could be improved by taking an n (for “no”) answer into account:

Click here to view code image

bool accept2()
{
     cout << "Do you want to proceed (y or n)?\n"; // write question

     char answer = 0;
     cin >> answer;                                // read answer
     switch (answer) {
     case 'y':
          return true;
     case 'n':
          return false;
     default:
          cout << "I'll take that for a no.\n";
          return false;
     }
}
A switch-statement tests a value against a set of constants. The case constants must be distinct, and if the value tested does not match any of them, the default is chosen. If no default is provided, no action is taken if the value doesn’t match any case constant.

Few programs are written without loops. For example, we might like to give the user a few tries to produce acceptable input:

Click here to view code image

bool accept3()
{
     int tries = 1;
     while (tries<4) {
         cout << "Do you want to proceed (y or n)?\n";  // write question
         char answer = 0;
         cin >> answer;                                 // read answer

         switch (answer) {
         case 'y':
              return true;
         case 'n':
              return false;
         default:
              cout << "Sorry, I don't understand that.\n";
              ++tries; // increment
         }
     }
     cout << "I'll take that for a no.\n";
     return false;
}
The while-statement executes until its condition becomes false.

2.2.5. Pointers, Arrays, and Loops
An array of elements of type char can be declared like this:

char v[6];       // array of 6 characters
Similarly, a pointer can be declared like this:

char* p;         // pointer to character
In declarations, [] means “array of” and * means “pointer to.” All arrays have 0 as their lower bound, so v has six elements, v[0] to v[5]. The size of an array must be a constant expression (§2.2.3). A pointer variable can hold the address of an object of the appropriate type:

Click here to view code image

char* p = &v[3];          // p points to v's fourth element
char x = *p;              // *p is the object that p points to
In an expression, prefix unary * means “contents of” and prefix unary & means “address of.” We can represent the result of that initialized definition graphically:



Consider copying ten elements from one array to another:

Click here to view code image

void copy_fct()
{
     int v1[10] = {0,1,2,3,4,5,6,7,8,9};
     int v2[10];                // to become a copy of v1

     for (auto i=0; i!=10; ++i) // copy elements
          v2[i]=v1[i];
     // ...
}
This for-statement can be read as “set i to zero; while i is not 10, copy the ith element and increment i.” When applied to an integer variable, the increment operator, ++, simply adds 1. C++ also offers a simpler for-statement, called a range-for-statement, for loops that traverse a sequence in the simplest way:

Click here to view code image

void print()
{
     int v[] = {0,1,2,3,4,5,6,7,8,9};

     for (auto x : v)            // for each x in v
           cout << x << '\n';

     for (auto x : {10,21,32,43,54,65})
           cout << x << '\n';
     // ...
}
The first range-for-statement can be read as “for every element of v, from the first to the last, place a copy in x and print it.” Note that we don’t have to specify an array bound when we initialize it with a list. The range-for-statement can be used for any sequence of elements (§3.4.1).

If we didn’t want to copy the values from v into the variable x, but rather just have x refer to an element, we could write:

Click here to view code image

void increment()
{
     int v[] = {0,1,2,3,4,5,6,7,8,9};

     for (auto& x : v)
           ++x;
     // ...
}
In a declaration, the unary suffix & means “reference to.” A reference is similar to a pointer, except that you don’t need to use a prefix * to access the value referred to by the reference. Also, a reference cannot be made to refer to a different object after its initialization. When used in declarations, operators (such as &, *, and []) are called declarator operators:

Click here to view code image

T a[n];   // T[n]: array of n Ts (§7.3)
T* p;     // T*: pointer to T (§7.2)
T& r;     // T&: reference to T (§7.7)
T f(A);   // T(A): function taking an argument of type A returning a result of type T (§2.2.1)
We try to ensure that a pointer always points to an object, so that dereferencing it is valid. When we don’t have an object to point to or if we need to represent the notion of “no object available” (e.g., for an end of a list), we give the pointer the value nullptr (“the null pointer”). There is only one nullptr shared by all pointer types:

Click here to view code image

double* pd = nullptr;
Link<Record>* lst = nullptr; // pointer to a Link to a Record
int x = nullptr;             // error: nullptr is a pointer not an integer
It is often wise to check that a pointer argument that is supposed to point to something, actually points to something:

Click here to view code image

int count_x(char* p, char x)
     // count the number of occurrences of x in p[]
     // p is assumed to point to a zero-terminated array of char (or to nothing)
{
     if (p==nullptr) return 0;
     int count = 0;
     for (; *p!=0; ++p)
           if (*p==x)
                 ++count;
     return count;
}
Note how we can move a pointer to point to the next element of an array using ++ and that we can leave out the initializer in a for-statement if we don’t need it.

The definition of count_x() assumes that the char* is a C-style string, that is, that the pointer points to a zero-terminated array of char.

In older code, 0 or NULL is typically used instead of nullptr (§7.2.2). However, using nullptr eliminates potential confusion between integers (such as 0 or NULL) and pointers (such as nullptr).

2.3. User-Defined Types
We call the types that can be built from the fundamental types (§2.2.2), the const modifier (§2.2.3), and the declarator operators (§2.2.5) built-in types. C++’s set of built-in types and operations is rich, but deliberately low-level. They directly and efficiently reflect the capabilities of conventional computer hardware. However, they don’t provide the programmer with high-level facilities to conveniently write advanced applications. Instead, C++ augments the built-in types and operations with a sophisticated set of abstraction mechanisms out of which programmers can build such high-level facilities. The C++ abstraction mechanisms are primarily designed to let programmers design and implement their own types, with suitable representations and operations, and for programmers to simply and elegantly use such types. Types built out of the built-in types using C++’s abstraction mechanisms are called user-defined types. They are referred to as classes and enumerations. Most of this book is devoted to the design, implementation, and use of user-defined types. The rest of this chapter presents the simplest and most fundamental facilities for that. Chapter 3 is a more complete description of the abstraction mechanisms and the programming styles they support. Chapter 4 and Chapter 5 present an overview of the standard library, and since the standard library mainly consists of user-defined types, they provide examples of what can be built using the language facilities and programming techniques presented in Chapter 2 and Chapter 3.

2.3.1. Structures
The first step in building a new type is often to organize the elements it needs into a data structure, a struct:

Click here to view code image

struct Vector {
     int sz;       // number of elements
     double* elem; // pointer to elements
};
This first version of Vector consists of an int and a double*.

A variable of type Vector can be defined like this:

Vector v;
However, by itself that is not of much use because v’s elem pointer doesn’t point to anything. To be useful, we must give v some elements to point to. For example, we can construct a Vector like this:

Click here to view code image

void vector_init(Vector& v, int s)
{
     v.elem = new double[s]; // allocate an array of s doubles
     v.sz = s;
}
That is, v’s elem member gets a pointer produced by the new operator and v’s sz member gets the number of elements. The & in Vector& indicates that we pass v by non-const reference (§2.2.5, §7.7); that way, vector_init() can modify the vector passed to it.

The new operator allocates memory from an area called the free store (also known as dynamic memory and heap; §11.2).

A simple use of Vector looks like this:

Click here to view code image

double read_and_sum(int s)
    // read s integers from cin and return their sum; s is assumed to be positive
{
    Vector v;
    vector_init(v,s);           // allocate s elements for v
    for (int i=0; i!=s; ++i)
          cin>>v.elem[i];       // read into elements

    double sum = 0;
    for (int i=0; i!=s; ++i)
          sum+=v.elem[i];       // take the sum of the elements
    return sum;
}
There is a long way to go before our Vector is as elegant and flexible as the standard-library vector. In particular, a user of Vector has to know every detail of Vector’s representation. The rest of this chapter and the next gradually improve Vector as an example of language features and techniques. Chapter 4 presents the standard-library vector, which contains many nice improvements, and Chapter 31 presents the complete vector in the context of other standard-library facilities.

I use vector and other standard-library components as examples

• to illustrate language features and design techniques, and

• to help you learn and use the standard-library components.

Don’t reinvent standard-library components, such as vector and string; use them.

We use . (dot) to access struct members through a name (and through a reference) and –> to access struct members through a pointer. For example:

Click here to view code image

void f(Vector v, Vector& rv, Vector* pv)
{
     int i1 = v.sz;     // access through name
     int i2 = rv.sz;    // access through reference
     int i4 = pv–>sz;   // access through pointer
}
2.3.2. Classes
Having the data specified separately from the operations on it has advantages, such as the ability to use the data in arbitrary ways. However, a tighter connection between the representation and the operations is needed for a user-defined type to have all the properties expected of a “real type.” In particular, we often want to keep the representation inaccessible to users, so as to ease use, guarantee consistent use of the data, and allow us to later improve the representation. To do that we have to distinguish between the interface to a type (to be used by all) and its implementation (which has access to the otherwise inaccessible data). The language mechanism for that is called a class. A class is defined to have a set of members, which can be data, function, or type members. The interface is defined by the public members of a class, and private members are accessible only through that interface. For example:

Click here to view code image

class Vector {
public:
     Vector(int s) :elem{new double[s]}, sz{s} { } // construct a Vector
     double& operator[](int i) { return elem[i]; } // element access: subscripting
     int size() { return sz; }
private:
     double* elem; // pointer to the elements
     int sz;       // the number of elements
};
Given that, we can define a variable of our new type Vector:

Vector v(6);      // a Vector with 6 elements
We can illustrate a Vector object graphically:



Basically, the Vector object is a “handle” containing a pointer to the elements (elem) plus the number of elements (sz). The number of elements (6 in the example) can vary from Vector object to Vector object, and a Vector object can have a different number of elements at different times (§3.2.1.3). However, the Vector object itself is always the same size. This is the basic technique for handling varying amounts of information in C++: a fixed-size handle referring to a variable amount of data “elsewhere” (e.g., on the free store allocated by new; §11.2). How to design and use such objects is the main topic of Chapter 3.

Here, the representation of a Vector (the members elem and sz) is accessible only through the interface provided by the public members: Vector(), operator[](), and size(). The read_and_sum() example from §2.3.1 simplifies to:

Click here to view code image

double read_and_sum(int s)
{
    Vector v(s);                     // make a vector of s elements
    for (int i=0; i!=v.size(); ++i)
          cin>>v[i];                 // read into elements

    double sum = 0;
    for (int i=0; i!=v.size(); ++i)
          sum+=v[i];                 // take the sum of the elements
    return sum;
}
A “function” with the same name as its class is called a constructor, that is, a function used to construct objects of a class. So, the constructor, Vector(), replaces vector_init() from §2.3.1. Unlike an ordinary function, a constructor is guaranteed to be used to initialize objects of its class. Thus, defining a constructor eliminates the problem of uninitialized variables for a class.

Vector(int) defines how objects of type Vector are constructed. In particular, it states that it needs an integer to do that. That integer is used as the number of elements. The constructor initializes the Vector members using a member initializer list:

:elem{new double[s]}, sz{s}
That is, we first initialize elem with a pointer to s elements of type double obtained from the free store. Then, we initialize sz to s.

Access to elements is provided by a subscript function, called operator[]. It returns a reference to the appropriate element (a double&).

The size() function is supplied to give users the number of elements.

Obviously, error handling is completely missing, but we’ll return to that in §2.4.3. Similarly, we did not provide a mechanism to “give back” the array of doubles acquired by new; §3.2.1.2 shows how to use a destructor to elegantly do that.

2.3.3. Enumerations
In addition to classes, C++ supports a simple form of user-defined type for which we can enumerate the values:

Click here to view code image

enum class Color { red, blue, green };
enum class Traffic_light { green, yellow, red };

Color col = Color::red;
Traffic_light light = Traffic_light::red;
Note that enumerators (e.g., red) are in the scope of their enum class, so that they can be used repeatedly in different enum classes without confusion. For example, Color::red is Color’s red which is different from Traffic_light::red.

Enumerations are used to represent small sets of integer values. They are used to make code more readable and less error-prone than it would have been had the symbolic (and mnemonic) enumerator names not been used.

The class after the enum specifies that an enumeration is strongly typed and that its enumerators are scoped. Being separate types, enum classes help prevent accidental misuses of constants. In particular, we cannot mix Traffic_light and Color values:

Click here to view code image

Color x = red;                 // error: which red?
Color y = Traffic_light::red;  // error: that red is not a Color
Color z = Color::red;          // OK
Similarly, we cannot implicitly mix Color and integer values:

Click here to view code image

int i = Color::red;        // error: Color::red is not an int
Color c = 2;               // error: 2 is not a Color
If you don’t want to explicitly qualify enumerator names and want enumerator values to be ints (without the need for an explicit conversion), you can remove the class from enum class to get a “plain” enum (§8.4.2).

By default, an enum class has only assignment, initialization, and comparisons (e.g., == and <; §2.2.2) defined. However, an enumeration is a user-defined type so we can define operators for it:

Click here to view code image

Traffic_light& operator++(Traffic_light& t)
      // prefix increment: ++
{
      switch (t) {
      case Traffic_light::green:    return t=Traffic_light::yellow;
      case Traffic_light::yellow:   return t=Traffic_light::red;
      case Traffic_light::red:      return t=Traffic_light::green;
      }
}

Traffic_light next = ++light;       // next becomes Traffic_light::green
2.4. Modularity
A C++ program consists of many separately developed parts, such as functions (§2.2.1, Chapter 12), user-defined types (§2.3, §3.2, Chapter 16), class hierarchies (§3.2.4, Chapter 20), and templates (§3.4, Chapter 23). The key to managing this is to clearly define the interactions among those parts. The first and most important step is to distinguish between the interface to a part and its implementation. At the language level, C++ represents interfaces by declarations. A declaration specifies all that’s needed to use a function or a type. For example:

Click here to view code image

double sqrt(double);    // the square root function takes a double and returns a double

class Vector {
public:
     Vector(int s);
     double& operator[](int i);
     int size();
private:
     double* elem; // elem points to an array of sz doubles
     int sz;
};
The key point here is that the function bodies, the function definitions, are “elsewhere.” For this example, we might like for the representation of Vector to be “elsewhere” also, but we will deal with that later (abstract types; §3.2.2). The definition of sqrt() will look like this:

Click here to view code image

double sqrt(double d)     // definition of sqrt()
{
    // ... algorithm as found in math textbook ...
}
For Vector, we need to define all three member functions:

Click here to view code image

Vector::Vector(int s)               // definition of the constructor
    :elem{new double[s]}, sz{s}     // initialize members
{
}

double& Vector::operator[](int i)   // definition of subscripting
{
    return elem[i];
}

int Vector::size()                  // definition of size()
{
    return sz;
}
We must define Vector’s functions, but not sqrt() because it is part of the standard library. However, that makes no real difference: a library is simply some “other code we happen to use” written with the same language facilities as we use.

2.4.1. Separate Compilation
C++ supports a notion of separate compilation where user code sees only declarations of the types and functions used. The definitions of those types and functions are in separate source files and compiled separately. This can be used to organize a program into a set of semi-independent code fragments. Such separation can be used to minimize compilation times and to strictly enforce separation of logically distinct parts of a program (thus minimizing the chance of errors). A library is often a collection of separately compiled code fragments (e.g., functions).

Typically, we place the declarations that specify the interface to a module in a file with a name indicating its intended use. For example:

Click here to view code image

// Vector.h:

class Vector {
public:
     Vector(int s);
     double& operator[](int i);
     int size();
private:
     double* elem;    // elem points to an array of sz doubles
     int sz;
};
This declaration would be placed in a file Vector.h, and users will include that file, called a header file, to access that interface. For example:

Click here to view code image

// user.cpp:

#include "Vector.h"       // get Vector's interface
#include <cmath>          // get the the standard-library math function interface including sqrt()
using namespace std;      // make std members visible (§2.4.2)
double sqrt_sum(Vector& v)
{
    double sum = 0;
    for (int i=0; i!=v.size(); ++i)
          sum+=sqrt(v[i]);             // sum of square roots
    return sum;
}
To help the compiler ensure consistency, the .cpp file providing the implementation of Vector will also include the .h file providing its interface:

Click here to view code image

// Vector.cpp:

#include "Vector.h" // get the interface

Vector::Vector(int s)
    :elem{new double[s]}, sz{s}
{
}

double& Vector::operator[](int i)
{
    return elem[i];
}

int Vector::size()
{
    return sz;
}
The code in user.cpp and Vector.cpp shares the Vector interface information presented in Vector.h, but the two files are otherwise independent and can be separately compiled. Graphically, the program fragments can be represented like this:



Strictly speaking, using separate compilation isn’t a language issue; it is an issue of how best to take advantage of a particular language implementation. However, it is of great practical importance. The best approach is to maximize modularity, represent that modularity logically through language features, and then exploit the modularity physically through files for effective separate compilation (Chapter 14, Chapter 15).

2.4.2. Namespaces
In addition to functions (§2.2.1, Chapter 12), classes (Chapter 16), and enumerations (§2.3.3, §8.4), C++ offers namespaces (Chapter 14) as a mechanism for expressing that some declarations belong together and that their names shouldn’t clash with other names. For example, I might want to experiment with my own complex number type (§3.2.1.1, §18.3, §40.4):

Click here to view code image

namespace My_code {
   class complex { /* ... */ };
   complex sqrt(complex);
   // ...
   int main();
}

int My_code::main()
{
   complex z {1,2};
   auto z2 = sqrt(z);
   std::cout << '{' << z2.real() << ',' << z2.imag() << "}\n";
   // ...
};

int main()
{
   return My_code::main();
}
By putting my code into the namespace My_code, I make sure that my names do not conflict with the standard-library names in namespace std (§4.1.2). The precaution is wise, because the standard library does provide support for complex arithmetic (§3.2.1.1, §40.4).

The simplest way to access a name in another namespace is to qualify it with the namespace name (e.g., std::cout and My_code::main). The “real main()” is defined in the global namespace, that is, not local to a defined namespace, class, or function. To gain access to names in the standard-library namespace, we can use a using-directive (§14.2.3):

using namespace std;
Namespaces are primarily used to organize larger program components, such as libraries. They simplify the composition of a program out of separately developed parts.

2.4.3. Error Handling
Error handling is a large and complex topic with concerns and ramifications that go far beyond language facilities into programming techniques and tools. However, C++ provides a few features to help. The major tool is the type system itself. Instead of painstakingly building up our applications from the built-in types (e.g., char, int, and double) and statements (e.g., if, while, and for), we build more types that are appropriate for our applications (e.g., string, map, and regex) and algorithms (e.g., sort(), find_if(), and draw_all()). Such higher-level constructs simplify our programming, limit our opportunities for mistakes (e.g., you are unlikely to try to apply a tree traversal to a dialog box), and increase the compiler’s chances of catching such errors. The majority of C++ constructs are dedicated to the design and implementation of elegant and efficient abstractions (e.g., user-defined types and algorithms using them). One effect of this modularity and abstraction (in particular, the use of libraries) is that the point where a run-time error can be detected is separated from the point where it can be handled. As programs grow, and especially when libraries are used extensively, standards for handling errors become important.

2.4.3.1. Exceptions
Consider again the Vector example. What ought to be done when we try to access an element that is out of range for the vector from §2.3.2?

• The writer of Vector doesn’t know what the user would like to have done in this case (the writer of Vector typically doesn’t even know in which program the vector will be running).

• The user of Vector cannot consistently detect the problem (if the user could, the out-of-range access wouldn’t happen in the first place).

The solution is for the Vector implementer to detect the attempted out-of-range access and then tell the user about it. The user can then take appropriate action. For example, Vector::operator[]() can detect an attempted out-of-range access and throw an out_of_range exception:

Click here to view code image

double& Vector::operator[](int i)
{
    if (i<0 || size()<=i) throw out_of_range{"Vector::operator[]"};
    return elem[i];
}
The throw transfers control to a handler for exceptions of type out_of_range in some function that directly or indirectly called Vector::operator[](). To do that, the implementation will unwind the function call stack as needed to get back to the context of that caller (§13.5.1). For example:

Click here to view code image

void f(Vector& v)
{
     // ...
     try { // exceptions here are handled by the handler defined below

         v[v.size()] = 7; // try to access beyond the end of v
     }
     catch (out_of_range) { // oops: out_of_range error
         // ... handle range error ...
     }
     // ...
}
We put code for which we are interested in handling exceptions into a try-block. That attempted assignment to v[v.size()] will fail. Therefore, the catch-clause providing a handler for out_of_range will be entered. The out_of_range type is defined in the standard library (in <stdexcept>) and is in fact used by some standard-library container access functions.

Use of the exception-handling mechanisms can make error handling simpler, more systematic, and more readable. See Chapter 13 for further discussion, details, and examples.

2.4.3.2. Invariants
The use of exceptions to signal out-of-range access is an example of a function checking its argument and refusing to act because a basic assumption, a precondition, didn’t hold. Had we formally specified Vector’s subscript operator, we would have said something like "the index must be in the [0:size()) range," and that was in fact what we tested in our operator[](). The [a:b) notation specifies a half-open range, meaning that a is part of the range, but b is not. Whenever we define a function, we should consider what its preconditions are and if feasible test them (see §12.4, §13.4).

However, operator[]() operates on objects of type Vector and nothing it does makes any sense unless the members of Vector have “reasonable” values. In particular, we did say “elem points to an array of sz doubles” but we only said that in a comment. Such a statement of what is assumed to be true for a class is called a class invariant, or simply an invariant. It is the job of a constructor to establish the invariant for its class (so that the member functions can rely on it) and for the member functions to make sure that the invariant holds when they exit. Unfortunately, our Vector constructor only partially did its job. It properly initialized the Vector members, but it failed to check that the arguments passed to it made sense. Consider:

Vector v(–27);
This is likely to cause chaos.

Here is a more appropriate definition:

Click here to view code image

Vector::Vector(int s)
{
    if (s<0) throw length_error{};
    elem = new double[s];
    sz = s;
}
I use the standard-library exception length_error to report a non-positive number of elements because some standard-library operations use that exception to report problems of this kind. If operator new can’t find memory to allocate, it throws a std::bad_alloc. We can now write:

Click here to view code image

void test()
{
     try {
         Vector v(–27);
     }
     catch (std::length_error) {
         // handle negative size
     }
     catch (std::bad_alloc) {
         // handle memory exhaustion
     }
}
You can define your own classes to be used as exceptions and have them carry arbitrary information from a point where an error is detected to a point where it can be handled (§13.5).

Often, a function has no way of completing its assigned task after an exception is thrown. Then, “handling” an exception simply means doing some minimal local cleanup and rethrowing the exception. To throw (rethrow) the exception caught in an exception handler, we simply write throw; (§13.5.2.1).

The notion of invariants is central to the design of classes, and preconditions serve a similar role in the design of functions. Invariants

• help us to understand precisely what we want

• force us to be specific; that gives us a better chance of getting our code correct (after debugging and testing).

The notion of invariants underlies C++’s notions of resource management supported by constructors (§2.3.2) and destructors (§3.2.1.2, §5.2). See also §13.4, §16.3.1, and §17.2.

2.4.3.3. Static Assertions
Exceptions report errors found at run time. If an error can be found at compile time, it is usually preferable to do so. That’s what much of the type system and the facilities for specifying the interfaces to user-defined types are for. However, we can also perform simple checks on other properties that are known at compile time and report failures as compiler error messages. For example:

static_assert(4<=sizeof(int), "integers are too small"); // check integer size
This will write integers are too small if 4<=sizeof(int) does not hold, that is, if an int on this system does not have at least 4 bytes. We call such statements of expectations assertions.

The static_assert mechanism can be used for anything that can be expressed in terms of constant expressions (§2.2.3, §10.4). For example:

Click here to view code image

constexpr double C = 299792.458;                        // km/s

void f(double speed)
{
     const double local_max = 160.0/(60*60);            // 160 km/h == 160.0/(60*60) km/s

     static_assert(speed<C,"can't go that fast");       // error: speed must be a constant
     static_assert(local_max<C,"can't go that fast");   // OK

     // ...
}
In general, static_assert(A,S) prints S as a compiler error message if A is not true.

The most important uses of static_assert come when we make assertions about types used as parameters in generic programming (§5.4.2, §24.3).

For runtime-checked assertions, see §13.4.

2.5. Postscript
The topics covered in this chapter roughly correspond to the contents of Part II (Chapters 6–15). Those are the parts of C++ that underlie all programming techniques and styles supported by C++. Experienced C and C++ programmers, please note that this foundation does not closely correspond to the C or C++98 subsets of C++ (that is, of C++11).

2.6. Advice
[1] Don’t panic! All will become clear in time; §2.1.

[2] You don’t have to know every detail of C++ to write good programs; §1.3.1.

[3] Focus on programming techniques, not on language features; §2.1.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


2. A Tour of C++: The Basics
3. A Tour of C++: Abstraction Mechanisms
4. A Tour of C++: Containers and Algorithms
47h 26m remaining
3. A Tour of C++: Abstraction Mechanisms
Don’t Panic!

– Douglas Adams

• Introduction

• Classes

Concrete Types; Abstract Types; Virtual Functions; Class Hierarchies

• Copy and Move

Copying Containers; Moving Containers; Resource Management; Suppressing Operations

• Templates

Parameterized Types; Function Templates; Function Objects; Variadic Templates; Aliases

• Advice

3.1. Introduction
This chapter aims to give you an idea of C++’s support for abstraction and resource management without going into a lot of detail. It informally presents ways of defining and using new types (user-defined types). In particular, it presents the basic properties, implementation techniques, and language facilities used for concrete classes, abstract classes, and class hierarchies. Templates are introduced as a mechanism for parameterizing types and algorithms with (other) types and algorithms. Computations on user-defined and built-in types are represented as functions, sometimes generalized to template functions and function objects. These are the language facilities supporting the programming styles known as object-oriented programming and generic programming. The next two chapters follow up by presenting examples of standard-library facilities and their use.

The assumption is that you have programmed before. If not, please consider reading a textbook, such as Programming: Principles and Practice Using C++ [Stroustrup,2009], before continuing here. Even if you have programmed before, the language you used or the applications you wrote may be very different from the style of C++ presented here. If you find this “lightning tour” confusing, skip to the more systematic presentation starting in Chapter 6.

As in Chapter 2, this tour presents C++ as an integrated whole, rather than as a layer cake. Consequently, it does not identify language features as present in C, part of C++98, or new in C++11. Such historical information can be found in §1.4 and Chapter 44.

3.2. Classes
The central language feature of C++ is the class. A class is a user-defined type provided to represent a concept in the code of a program. Whenever our design for a program has a useful concept, idea, entity, etc., we try to represent it as a class in the program so that the idea is there in the code, rather than just in our head, in a design document, or in some comments. A program built out of a well chosen set of classes is far easier to understand and get right than one that builds everything directly in terms of the built-in types. In particular, classes are often what libraries offer.

Essentially all language facilities beyond the fundamental types, operators, and statements exist to help define better classes or to use them more conveniently. By “better,” I mean more correct, easier to maintain, more efficient, more elegant, easier to use, easier to read, and easier to reason about. Most programming techniques rely on the design and implementation of specific kinds of classes. The needs and tastes of programmers vary immensely. Consequently, the support for classes is extensive. Here, we will just consider the basic support for three important kinds of classes:

• Concrete classes (§3.2.1)

• Abstract classes (§3.2.2)

• Classes in class hierarchies (§3.2.4)

An astounding number of useful classes turn out to be of these three kinds. Even more classes can be seen as simple variants of these kinds or are implemented using combinations of the techniques used for these.

3.2.1. Concrete Types
The basic idea of concrete classes is that they behave “just like built-in types.” For example, a complex number type and an infinite-precision integer are much like built-in int, except of course that they have their own semantics and sets of operations. Similarly, a vector and a string are much like built-in arrays, except that they are better behaved (§4.2, §4.3.2, §4.4.1).

The defining characteristic of a concrete type is that its representation is part of its definition. In many important cases, such as a vector, that representation is only one or more pointers to more data stored elsewhere, but it is present in each object of a concrete class. That allows implementations to be optimally efficient in time and space. In particular, it allows us to

• place objects of concrete types on the stack, in statically allocated memory, and in other objects (§6.4.2);

• refer to objects directly (and not just through pointers or references);

• initialize objects immediately and completely (e.g., using constructors; §2.3.2); and

• copy objects (§3.3).

The representation can be private (as it is for Vector; §2.3.2) and accessible only through the member functions, but it is present. Therefore, if the representation changes in any significant way, a user must recompile. This is the price to pay for having concrete types behave exactly like built-in types. For types that don’t change often, and where local variables provide much-needed clarity and efficiency, this is acceptable and often ideal. To increase flexibility, a concrete type can keep major parts of its representation on the free store (dynamic memory, heap) and access them through the part stored in the class object itself. That’s the way vector and string are implemented; they can be considered resource handles with carefully crafted interfaces.

3.2.1.1. An Arithmetic Type
The “classical user-defined arithmetic type” is complex:

Click here to view code image

class complex {
     double re, im;  // representation: two doubles
public:
     complex(double r, double i) :re{r}, im{i} {}   // construct complex from two scalars
     complex(double r) :re{r}, im{0} {}             // construct complex from one scalar
     complex() :re{0}, im{0} {}                     // default complex: {0,0}

     double real() const { return re; }
     void real(double d) { re=d; }
     double imag() const { return im; }
     void imag(double d) { im=d; }

     complex& operator+=(complex z) { re+=z.re; im+=z.im; return *this; }  // add to re and im
                                                                           // and return the result
     complex& operator–=(complex z) { re–=z.re; im–=z.im; return *this; }

     complex& operator*=(complex);     // defined out-of-class somewhere
     complex& operator/=(complex);     // defined out-of-class somewhere
 };
This is a slightly simplified version of the standard-library complex (§40.4). The class definition itself contains only the operations requiring access to the representation. The representation is simple and conventional. For practical reasons, it has to be compatible with what Fortran provided 50 years ago, and we need a conventional set of operators. In addition to the logical demands, complex must be efficient or it will remain unused. This implies that simple operations must be inlined. That is, simple operations (such as constructors, +=, and imag()) must be implemented without function calls in the generated machine code. Functions defined in a class are inlined by default. An industrial-strength complex (like the standard-library one) is carefully implemented to do appropriate inlining.

A constructor that can be invoked without an argument is called a default constructor. Thus, complex() is complex’s default constructor. By defining a default constructor you eliminate the possibility of uninitialized variables of that type.

The const specifiers on the functions returning the real and imaginary parts indicate that these functions do not modify the object for which they are called.

Many useful operations do not require direct access to the representation of complex, so they can be defined separately from the class definition:

Click here to view code image

complex operator+(complex a, complex b) { return a+=b; }
complex operator–(complex a, complex b) { return a–=b; }
complex operator–(complex a) { return {–a.real(), –a.imag()}; }     // unary minus
complex operator*(complex a, complex b) { return a*=b; }
complex operator/(complex a, complex b) { return a/=b; }
Here, I use the fact that an argument passed by value is copied, so that I can modify an argument without affecting the caller’s copy, and use the result as the return value.

The definitions of == and != are straightforward:

Click here to view code image

bool operator==(complex a, complex b)           // equal
{
     return a.real()==b.real() && a.imag()==b.imag();
}

bool operator!=(complex a, complex b)           // not equal
{
     return !(a==b);
}

complex sqrt(complex);

 //...
Class complex can be used like this:

Click here to view code image

void f(complex z)
{
     complex a {2.3};        // construct {2.3,0.0} from 2.3
     complex b {1/a};
     complex c {a+z*complex{1,2.3}};
      //...
     if (c != b)
            c = –(b/a)+2*b;
}
The compiler converts operators involving complex numbers into appropriate function calls. For example, c!=b means operator!=(c,b) and 1/a means operator/(complex{1},a).

User-defined operators (“overloaded operators”) should be used cautiously and conventionally. The syntax is fixed by the language, so you can’t define a unary /. Also, it is not possible to change the meaning of an operator for built-in types, so you can’t redefine + to subtract ints.

3.2.1.2. A Container
A container is an object holding a collection of elements, so we call Vector a container because it is the type of objects that are containers. As defined in §2.3.2, Vector isn’t an unreasonable container of doubles: it is simple to understand, establishes a useful invariant (§2.4.3.2), provides range-checked access (§2.4.3.1), and provides size() to allow us to iterate over its elements. However, it does have a fatal flaw: it allocates elements using new but never deallocates them. That’s not a good idea because although C++ defines an interface for a garbage collector (§34.5), it is not guaranteed that one is available to make unused memory available for new objects. In some environments you can’t use a collector, and sometimes you prefer more precise control of destruction (§13.6.4) for logical or performance reasons. We need a mechanism to ensure that the memory allocated by the constructor is deallocated; that mechanism is a destructor:

Click here to view code image

class Vector {
private:
     double* elem;         // elem points to an array of sz doubles
     int sz;
public:
     Vector(int s) :elem{new double[s]}, sz{s}          // constructor: acquire resources
     {
         for (int i=0; i!=s; ++i) elem[i]=0;            // initialize elements
     }

     ~Vector() { delete[] elem; }                       // destructor: release resources

     double& operator[](int i);
     int size() const;
};
The name of a destructor is the complement operator, ~, followed by the name of the class; it is the complement of a constructor. Vector’s constructor allocates some memory on the free store (also called the heap or dynamic store) using the new operator. The destructor cleans up by freeing that memory using the delete operator. This is all done without intervention by users of Vector. The users simply create and use Vectors much as they would variables of built-in types. For example:

void fct(int n)
{
     Vector v(n);

      //... use v ...

     {
           Vector v2(2*n);
            //... use v and v2 ...
     }  // v2 is destroyed here

      //... use v ..

}  // v is destroyed here
Vector obeys the same rules for naming, scope, allocation, lifetime, etc., as does a built-in type, such as int and char. For details on how to control the lifetime of an object, see §6.4. This Vector has been simplified by leaving out error handling; see §2.4.3.

The constructor/destructor combination is the basis of many elegant techniques. In particular, it is the basis for most C++ general resource management techniques (§5.2, §13.3). Consider a graphical illustration of a Vector:



The constructor allocates the elements and initializes the Vector members appropriately. The destructor deallocates the elements. This handle-to-data model is very commonly used to manage data that can vary in size during the lifetime of an object. The technique of acquiring resources in a constructor and releasing them in a destructor, known as Resource Acquisition Is Initialization or RAII, allows us to eliminate “naked new operations,” that is, to avoid allocations in general code and keep them buried inside the implementation of well-behaved abstractions. Similarly, “naked delete operations” should be avoided. Avoiding naked new and naked delete makes code far less error-prone and far easier to keep free of resource leaks (§5.2).

3.2.1.3. Initializing Containers
A container exists to hold elements, so obviously we need convenient ways of getting elements into a container. We can handle that by creating a Vector with an appropriate number of elements and then assigning to them, but typically other ways are more elegant. Here, I just mention two favorites:

• Initializer-list constructor: Initialize with a list of elements.

• push_back(): Add a new element at the end (at the back of) the sequence.

These can be declared like this:

Click here to view code image

class Vector {
public:
     Vector(std::initializer_list<double>);      // initialize with a list
      //...
     void push_back(double);                     // add element at end increasing the size by one
      //...
};
The push_back() is useful for input of arbitrary numbers of elements. For example:

Click here to view code image

Vector read(istream& is)
{
    Vector v;
    for (double d; is>>d;)      // read floating-point values into d
          v.push_back(d);       // add d to v
    return v;
}
The input loop is terminated by an end-of-file or a formatting error. Until that happens, each number read is added to the Vector so that at the end, v’s size is the number of elements read. I used a for-statement rather than the more conventional while-statement to keep the scope of d limited to the loop. The implementation of push_back() is discussed in §13.6.4.3. The way to provide Vector with a move constructor, so that returning a potentially huge amount of data from read() is cheap, is explained in §3.3.2.

The std::initializer_list used to define the initializer-list constructor is a standard-library type known to the compiler: when we use a {}-list, such as {1,2,3,4}, the compiler will create an object of type initializer_list to give to the program. So, we can write:

Click here to view code image

Vector v1 = {1,2,3,4,5};             // v1 has 5 elements
Vector v2 = {1.23, 3.45, 6.7, 8};    // v2 has 4 elements
Vector’s initializer-list constructor might be defined like this:

Click here to view code image

Vector::Vector(std::initializer_list<double> lst)     // initialize with a list
    :elem{new double[lst.size()]}, sz{static_cast<int>(lst.siz e())}
{
    copy(lst.begin(),lst.end(),elem);           // copy from lst into elem
}
3.2.2. Abstract Types
Types such as complex and Vector are called concrete types because their representation is part of their definition. In that, they resemble built-in types. In contrast, an abstract type is a type that completely insulates a user from implementation details. To do that, we decouple the interface from the representation and give up genuine local variables. Since we don’t know anything about the representation of an abstract type (not even its size), we must allocate objects on the free store (§3.2.1.2, §11.2) and access them through references or pointers (§2.2.5, §7.2, §7.7).

First, we define the interface of a class Container which we will design as a more abstract version of our Vector:

Click here to view code image

class Container {
public:
     virtual double& operator[](int) = 0;      // pure virtual function
     virtual int size() const = 0;             // const member function (§3.2.1.1)
     virtual ~Container() {}                   // destructor (§3.2.1.2)
};
This class is a pure interface to specific containers defined later. The word virtual means “may be redefined later in a class derived from this one.” Unsurprisingly, a function declared virtual is called a virtual function. A class derived from Container provides an implementation for the Container interface. The curious =0 syntax says the function is pure virtual; that is, some class derived from Container must define the function. Thus, it is not possible to define an object that is just a Container; a Container can only serve as the interface to a class that implements its operator[]() and size() functions. A class with a pure virtual function is called an abstract class.

This Container can be used like this:

void use(Container& c)
{
     const int sz = c.size();

     for (int i=0; i!=sz; ++i)
           cout << c[i] << '\n';
}
Note how use() uses the Container interface in complete ignorance of implementation details. It uses size() and [] without any idea of exactly which type provides their implementation. A class that provides the interface to a variety of other classes is often called a polymorphic type (§20.3.2).

As is common for abstract classes, Container does not have a constructor. After all, it does not have any data to initialize. On the other hand, Container does have a destructor and that destructor is virtual. Again, that is common for abstract classes because they tend to be manipulated through references or pointers, and someone destroying a Container through a pointer has no idea what resources are owned by its implementation; see also §3.2.4.

A container that implements the functions required by the interface defined by the abstract class Container could use the concrete class Vector:

Click here to view code image

class Vector_container : public Container {    // Vector_container implements Container
     Vector v;
public:
     Vector_container(int s) : v(s) { }  // Vector of s elements
     ~Vector_container() {}

     double& operator[](int i) { return v[i]; }
     int size() const { return v.size(); }
};
The :public can be read as “is derived from” or “is a subtype of.” Class Vector_container is said to be derived from class Container, and class Container is said to be a base of class Vector_container. An alternative terminology calls Vector_container and Container subclass and superclass, respectively. The derived class is said to inherit members from its base class, so the use of base and derived classes is commonly referred to as inheritance.

The members operator[]() and size() are said to override the corresponding members in the base class Container (§20.3.2). The destructor (~Vector_container()) overrides the base class destructor (~Container()). Note that the member destructor (~Vector()) is implicitly invoked by its class’s destructor (~Vector_container()).

For a function like use(Container&) to use a Container in complete ignorance of implementation details, some other function will have to make an object on which it can operate. For example:

Click here to view code image

void g()
{
     Vector_container vc // ten elements
     use(vc);
}
Since use() doesn’t know about Vector_containers but only knows the Container interface, it will work just as well for a different implementation of a Container. For example:

Click here to view code image

class List_container : public Container {  // List_container implements Container
     std::list<double> ld;      //(standard-library) list of doubles (§4.4.2)
public:
     List_container() { }       // empty List
     List_container(initializer_list<double> il) : ld{il} { }
     ~List_container() {}
     double& operator[](int i);
     int size() const { return ld.size(); }
};

double& List_container::operator[](int i)
{
     for (auto& x : ld) {
           if (i==0) return x;
           ––i;
     }
     throw out_of_range("List container");
}
Here, the representation is a standard-library list<double>. Usually, I would not implement a container with a subscript operation using a list, because performance of list subscripting is atrocious compared to vector subscripting. However, here I just wanted to show an implementation that is radically different from the usual one.

A function can create a List_container and have use() use it:

Click here to view code image

void h()
{
     List_container lc = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
     use(lc);
}
The point is that use(Container&) has no idea if its argument is a Vector_container, a List_container, or some other kind of container; it doesn’t need to know. It can use any kind of Container. It knows only the interface defined by Container. Consequently, use(Container&) needn’t be recompiled if the implementation of List_container changes or a brand-new class derived from Container is used.

The flip side of this flexibility is that objects must be manipulated through pointers or references (§3.3, §20.4).

3.2.3. Virtual Functions
Consider again the use of Container:

void use(Container& c)
{
     const int sz = c.size();

     for (int i=0; i!=sz; ++i)
           cout << c[i] << '\n';
}
How is the call c[i] in use() resolved to the right operator[]()? When h() calls use(), List_container’s operator[]() must be called. When g() calls use(), Vector_container’s operator[]() must be called. To achieve this resolution, a Container object must contain information to allow it to select the right function to call at run time. The usual implementation technique is for the compiler to convert the name of a virtual function into an index into a table of pointers to functions. That table is usually called the virtual function table or simply the vtbl. Each class with virtual functions has its own vtbl identifying its virtual functions. This can be represented graphically like this:



The functions in the vtbl allow the object to be used correctly even when the size of the object and the layout of its data are unknown to the caller. The implementation of the caller needs only to know the location of the pointer to the vtbl in a Container and the index used for each virtual function. This virtual call mechanism can be made almost as efficient as the “normal function call” mechanism (within 25%). Its space overhead is one pointer in each object of a class with virtual functions plus one vtbl for each such class.

3.2.4. Class Hierarchies
The Container example is a very simple example of a class hierarchy. A class hierarchy is a set of classes ordered in a lattice created by derivation (e.g., : public). We use class hierarchies to represent concepts that have hierarchical relationships, such as “A fire engine is a kind of a truck which is a kind of a vehicle” and “A smiley face is a kind of a circle which is a kind of a shape.” Huge hierarchies, with hundreds of classes, that are both deep and wide are common. As a semi-realistic classic example, let’s consider shapes on a screen:


The arrows represent inheritance relationships. For example, class Circle is derived from class Shape. To represent that simple diagram in code, we must first specify a class that defines the general properties of all shapes:

Click here to view code image

class Shape {
public:
     virtual Point center() const =0;      // pure virtual
     virtual void move(Point to) =0;

     virtual void draw() const = 0;        // draw on current "Canvas"
     virtual void rotate(int angle) = 0;

     virtual ~Shape() {}                   // destructor
      //...
};
Naturally, this interface is an abstract class: as far as representation is concerned, nothing (except the location of the pointer to the vtbl) is common for every Shape. Given this definition, we can write general functions manipulating vectors of pointers to shapes:

Click here to view code image

void rotate_all(vector<Shape*>& v, int angle)  // rotate v's elements by angle degrees
{
     for (auto p : v)
           p–>rotate(angle);
}
To define a particular shape, we must say that it is a Shape and specify its particular properties (including its virtual functions):

Click here to view code image

class Circle : public Shape {
public:
     Circle(Point p, int rr);          // constructor

     Point center() const { return x; }
     void move(Point to) { x=to; }

     void draw() const;
     void rotate(int) {}               // nice simple algorithm
private:
     Point x;   // center
     int r;     // radius
};
So far, the Shape and Circle example provides nothing new compared to the Container and Vector_container example, but we can build further:

Click here to view code image

class Smiley : public Circle {  // use the circle as the base for a face
public:
     Smiley(Point p, int r) : Circle{p,r}, mouth{nullptr} { }

     ~Smiley()
     {
          delete mouth;
          for (auto p : eyes) delete p;
     }
     void move(Point to);

     void draw() const;
     void rotate(int);

     void add_eye(Shape* s) { eyes.push_back(s); }
     void set_mouth(Shape* s);
     virtual void wink(int i);     // wink eye number i

      //...

private:
     vector<Shape*> eyes;          // usually two eyes
     Shape* mouth;
};
The push_back() member function adds its argument to the vector (here, eyes), increasing that vector’s size by one.

We can now define Smiley::draw() using calls to Smiley’s base and member draw()s:

void Smiley::draw()
{
     Circle::draw();
     for (auto p : eyes)
           p–>draw();
     mouth–>draw();
}
Note the way that Smiley keeps its eyes in a standard-library vector and deletes them in its destructor. Shape’s destructor is virtual and Smiley’s destructor overrides it. A virtual destructor is essential for an abstract class because an object of a derived class is usually manipulated through the interface provided by its abstract base class. In particular, it may be deleted through a pointer to a base class. Then, the virtual function call mechanism ensures that the proper destructor is called. That destructor then implicitly invokes the destructors of its bases and members.

In this simplified example, it is the programmer’s task to place the eyes and mouth appropriately within the circle representing the face.

We can add data members, operations, or both as we define a new class by derivation. This gives great flexibility with corresponding opportunities for confusion and poor design. See Chapter 21. A class hierarchy offers two kinds of benefits:

• Interface inheritance: An object of a derived class can be used wherever an object of a base class is required. That is, the base class acts as an interface for the derived class. The Container and Shape classes are examples. Such classes are often abstract classes.

• Implementation inheritance: A base class provides functions or data that simplifies the implementation of derived classes. Smiley’s uses of Circle’s constructor and of Circle::draw() are examples. Such base classes often have data members and constructors.

Concrete classes – especially classes with small representations – are much like built-in types: we define them as local variables, access them using their names, copy them around, etc. Classes in class hierarchies are different: we tend to allocate them on the free store using new, and we access them through pointers or references. For example, consider a function that reads data describing shapes from an input stream and constructs the appropriate Shape objects:

Click here to view code image

enum class Kind { circle, triangle, smiley };

Shape* read_shape(istream& is)        // read shape descriptions from input stream is
{
     //... read shape header from is and find its Kind k ...

    switch (k) {
    case Kind::circle:
          // read circle data {Point,int} into p and r
         return new Circle{p,r};
    case Kind::triangle:
          // read triangle data {Point,Point,Point} into p1, p2, and p3
         return new Triangle{p1,p2,p3};
    case Kind::smiley:
          // read smiley data {Point,int,Shape,Shape,Shape} into p, r, e1 ,e2, and m
         Smiley* ps = new Smiley{p,r};
         ps–>add_eye(e1);
         ps–>add_eye(e2);
         ps–>set_mouth(m);
         return ps;
    }
}
A program may use that shape reader like this:

Click here to view code image

void user()
{
     std::vector<Shape*>v;
     while (cin)
          v.push_back(read_shape(cin));
     draw_all(v);                 // call draw() for each element
     rotate_all(v,45);            // call rotate(45) for each element
     for (auto p : v) delete p;   // remember to delete elements
}
Obviously, the example is simplified – especially with respect to error handling – but it vividly illustrates that user() has absolutely no idea of which kinds of shapes it manipulates. The user() code can be compiled once and later used for new Shapes added to the program. Note that there are no pointers to the shapes outside user(), so user() is responsible for deallocating them. This is done with the delete operator and relies critically on Shape’s virtual destructor. Because that destructor is virtual, delete invokes the destructor for the most derived class. This is crucial because a derived class may have acquired all kinds of resources (such as file handles, locks, and output streams) that need to be released. In this case, a Smiley deletes its eyes and mouth objects.

Experienced programmers will notice that I left open two obvious opportunities for mistakes:

• A user might fail to delete the pointer returned by read_shape().

• The owner of a container of Shape pointers might not delete the objects pointed to.

In that sense, functions returning a pointer to an object allocated on the free store are dangerous. One solution to both problems is to return a standard-library unique_ptr (§5.2.1) rather than a “naked pointer” and store unique_ptrs in the container:

Click here to view code image

unique_ptr<Shape> read_shape(istream& is)  // read shape descriptions from input stream is
{
      // read shape header from is and find its Kind k

     switch (k) {
     case Kind::circle:
           // read circle data {Point,int} into p and r
          return unique_ptr<Shape>{new Circle{p,r}};       //§5.2.1
      //...
}

void user()
{
     vector<unique_ptr<Shape>> v;
     while (cin)
           v.push_back(read_shape(cin));
     draw_all(v);             // call draw() for each element
     rotate_all(v,45);                // call rotate(45) for each element
}  // all Shapes implicitly destroyed
Now the object is owned by the unique_ptr which will delete the object when it is no longer needed, that is, when its unique_ptr goes out of scope.

For the unique_ptr version of user() to work, we need versions of draw_all() and rotate_all() that accept vector<unique_ptr<Shape>>s. Writing many such _all() functions could become tedious, so §3.4.3 shows an alternative.

3.3. Copy and Move
By default, objects can be copied. This is true for objects of user-defined types as well as for builtin types. The default meaning of copy is memberwise copy: copy each member. For example, using complex from §3.2.1.1:

Click here to view code image

void test(complex z1)
{
     complex z2 {z1};    // copy initialization
     complex z3;
     z3 = z2;            // copy assignment
      //...
}
$$$
Now z1, z2, and z3 have the same value because both the assignment and the initialization copied both members.

When we design a class, we must always consider if and how an object might be copied. For simple concrete types, memberwise copy is often exactly the right semantics for copy. For some sophisticated concrete types, such as Vector, memberwise copy is not the right semantics for copy, and for abstract types it almost never is.

3.3.1. Copying Containers
When a class is a resource handle – that is, when the class is responsible for an object accessed through a pointer – the default memberwise copy is typically a disaster. Memberwise copy would violate the resource handle’s inv ariant (§2.4.3.2). For example, the default copy would leave a copy of a Vector referring to the same elements as the original:

Click here to view code image

void bad_copy(Vector& v1)
{
     Vector v2 = v1;     // copy v1's representation into v2
     v1[0] = 2;          // v2[0] is now also 2!
     v2[1] = 3;          // v1[1] is now also 3!
}
Assuming that v1 has four elements, the result can be represented graphically like this:



Fortunately, the fact that Vector has a destructor is a strong hint that the default (memberwise) copy semantics is wrong and the compiler should at least warn against this example (§17.6). We need to define better copy semantics.

Copying of an object of a class is defined by two members: a copy constructor and a copy assignment:

Click here to view code image

class Vector {
private:
     double* elem;  // elem points to an array of sz doubles
     int sz;
public:
     Vector(int s);                             // constructor: establish invariant, acquire resources
     ~Vector() { delete[] elem; }              // destructor: release resources

     Vector(const Vector& a);                  // copy constructor
     Vector& operator=(const Vector& a);      // copy assignment

     double& operator[](int i);               // subscript variable
     const double& operator[](int i) const;  // subscr ipt constant (§3.2.1.1)

     int size() const;
};
A suitable definition of a copy constructor for Vector allocates the space for the required number of elements and then copies the elements into it, so that after a copy each Vector has its own copy of the elements:

Click here to view code image

Vector::Vector(const Vector& a)       // copy constructor
    :elem{new double[a.sz]},     // allocate space for elements
    sz{a.sz}
{
    for (int i=0; i!=sz; ++i)         // copy elements
          elem[i] = a.elem[i];
}
The result of the v2=v1 example can now be presented as:



Of course, we need a copy assignment in addition to the copy constructor:

Click here to view code image

Vector& Vector::operator=(const Vector& a)    // copy assignment
{
    double* p = new double[a.sz];
    for (int i=0; i!=a.sz; ++i)
          p[i] = a.elem[i];
    delete[] elem;          // delete old elements
    elem = p;
    sz = a.sz;
    return *this;
}
The name this is predefined in a member function and points to the object for which the member function is called.

A copy constructor and a copy assignment for a class X are typically declared to take an argument of type const X& (§2.2.3).

3.3.2. Moving Containers
We can control copying by defining a copy constructor and a copy assignment, but copying can be costly for large containers. Consider:

Click here to view code image

Vector operator+(const Vector& a, const Vector& b)
{
    if (a.size()!=b.size())
          throw Vector_size_mismatch{};

    Vector res(a.size());
    for (int i=0; i!=a.size(); ++i)
          res[i]=a[i]+b[i];
    return res;
}
Returning from a + involves copying the result out of the local variable res and into some place where the caller can access it. We might use this + like this:

Click here to view code image

void f(const Vector& x, const Vector& y, const Vector& z)
{
     Vector r;
      //...
     r = x+y+z;
      //...
}
That would be copying a Vector at least twice (one for each use of the + operator). If a Vector is large, say, 10,000 doubles, that could be embarrassing. The most embarrassing part is that res in operator+() is never used again after the copy. We didn’t really want a copy; we just wanted to get the result out of a function: we wanted to move a Vector rather than to copy it. Fortunately, we can state that intent:

Click here to view code image

class Vector {
      //...

     Vector(const Vector& a);           // copy constructor
     Vector& operator=(const Vector& a);      // copy assignment

     Vector(Vector&& a);                // move constructor
     Vector& operator=(Vector&& a);           // move assignment
};
Given that definition, the compiler will choose the move constructor to implement the transfer of the return value out of the function. This means that r=x+y+z will involve no copying of Vectors. Instead, Vectors are just moved.

As is typical, Vector’s move constructor is trivial to define:

Click here to view code image

Vector::Vector(Vector&& a)
    :elem{a.elem},       //"grab the elements" from a
    sz{a.sz}
{
    a.elem = nullptr;          // now a has no elements
    a.sz = 0;
}
The && means “rvalue reference” and is a reference to which we can bind an rvalue (§6.4.1). The word “rvalue” is intended to complement “lvalue,” which roughly means “something that can appear on the left-hand side of an assignment.” So an rvalue is - to a first approximation - a value that you can’t assign to, such as an integer returned by a function call. Thus, an rvalue reference is a reference to something that nobody else can assign to, so that we can safely “steal” its value. The res local variable in operator+() for Vectors is an example.

A move constructor does not take a const argument: after all, a move constructor is supposed to remove the value from its argument. A move assignment is defined similarly.

A move operation is applied when an rvalue reference is used as an initializer or as the right-hand side of an assignment.

After a move, a moved-from object should be in a state that allows a destructor to be run. Typically, we should also allow assignment to a moved-from object (§17.5, §17.6.2).

Where the programmer knows that a value will not be used again, but the compiler can’t be expected to be smart enough to figure that out, the programmer can be specific:

Click here to view code image

Vector f()
{
    Vector x(1000);
    Vector y(1000);
    Vector z(1000);
     //...
    z = x;              // we get a copy
    y = std::move(x);   // we get a move
     //...
    return z;           // we get a move
};
The standard-library function move() returns an rvalue reference to its argument.

Just before the return we have:



When z is destroyed, it too has been moved from (by the return) so that, like x, it is empty (it holds no elements).

3.3.3. Resource Management
By defining constructors, copy operations, move operations, and a destructor, a programmer can provide complete control of the lifetime of a contained resource (such as the elements of a container). Furthermore, a move constructor allows an object to move simply and cheaply from one scope to another. That way, objects that we cannot or would not want to copy out of a scope can be simply and cheaply moved out instead. Consider a standard-library thread representing a concurrent activity (§5.3.1) and a Vector of a million doubles. We can’t copy the former and don’t want to copy the latter.

Click here to view code image

std::vector<thread> my_threads;

Vector init(int n)
{
    thread t {heartbeat};                // run heartbeat concurrently (on its own thread)
    my_threads.push_back(move(t));       // move t into my_threads
     //... more initialization ...
    Vector vec(n);
    for (int i=0; i<vec.size(); ++i) vec[i] = 777;
    return vec;                          // move vec out of init()
}

auto v = init(1000000);  // start heartbeat and initialize v
Resource handles, such as Vector and thread, are superior alternatives to the use of pointers in many cases. In fact, the standard-library “smart pointers,” such as unique_ptr, are themselves resource handles (§5.2.1).

I used the standard-library vector to hold the threads because we don’t get to parameterize Vector with an element type until §3.4.1.

In very much the same way as new and delete disappear from application code, we can make pointers disappear into resource handles. In both cases, the result is simpler and more maintainable code, without added overhead. In particular, we can achieve strong resource safety; that is, we can eliminate resource leaks for a general notion of a resource. Examples are vectors holding memory, threads holding system threads, and fstreams holding file handles.

3.3.4. Suppressing Operations
Using the default copy or move for a class in a hierarchy is typically a disaster: given only a pointer to a base, we simply don’t know what members the derived class has (§3.2.2), so we can’t know how to copy them. So, the best thing to do is usually to delete the default copy and move operations, that is, to eliminate the default definitions of those two operations:

Click here to view code image

class Shape {
public:
     Shape(const Shape&) =delete;              // no copy operations
     Shape& operator=(const Shape&) =delete;

     Shape(Shape&&) =delete;                   // no move operations
     Shape& operator=(Shape&&) =delete;

     ~Shape();
      //...
};
Now an attempt to copy a Shape will be caught by the compiler. If you need to copy an object in a class hierarchy, write some kind of clone function (§22.2.4).

In this particular case, if you forgot to delete a copy or move operation, no harm is done. A move operation is not implicitly generated for a class where the user has explicitly declared a destructor. Furthermore, the generation of copy operations is deprecated in this case (§44.2.3). This can be a good reason to explicitly define a destructor even where the compiler would have implicitly provided one (§17.2.2).

A base class in a class hierarchy is just one example of an object we wouldn’t want to copy. A resource handle generally cannot be copied just by copying its members (§5.2, §17.2.2).

The =delete mechanism is general, that is, it can be used to suppress any operation (§17.6.4).

3.4. Templates
Someone who wants a vector is unlikely always to want a vector of doubles. A vector is a general concept, independent of the notion of a floating-point number. Consequently, the element type of a vector ought to be represented independently. A template is a class or a function that we parameterize with a set of types or values. We use templates to represent concepts that are best understood as something very general from which we can generate specific types and functions by specifying arguments, such as the element type double.

3.4.1. Parameterized Types
We can generalize our vector-of-doubles type to a vector-of-anything type by making it a template and replacing the specific type double with a parameter. For example:

Click here to view code image

template<typename T>
class Vector {
private:
     T* elem;  // elem points to an array of sz elements of type T
     int sz;
public:
     Vector(int s);                   // constructor: establish invariant, acquire resources
     ~Vector() { delete[] elem; }     // destructor: release resources

      //... copy and move operations ...

     T& operator[](int i);
     const T& operator[](int i) const;
     int size() const { return sz; }
};
The template<typename T> prefix makes T a parameter of the declaration it prefixes. It is C++’s version of the mathematical “for all T” or more precisely “for all types T.”

The member functions might be defined similarly:

Click here to view code image

template<typename T>
Vector<T>::Vector(int s)
{
    if (s<0) throw Negative_size{};
    elem = new T[s];
    sz = s;
}

template<typename T>
const T& Vector<T>::operator[](int i) const
{
    if (i<0 || size()<=i)
          throw out_of_range{"Vector::operator[]"};
    return elem[i];
}
Given these definitions, we can define Vectors like this:

Click here to view code image

Vector<char> vc(200);       // vector of 200 characters
Vector<string> vs(17);      // vector of 17 strings
Vector<list<int>> vli(45);  // vector of 45 lists of integers
The >> in Vector<list<int>> terminates the nested template arguments; it is not a misplaced input operator. It is not (as in C++98) necessary to place a space between the two >s.

We can use Vectors like this:

Click here to view code image

void write(const Vector<string>& vs)       // Vector of some strings
{
     for (int i = 0; i!=vs.size(); ++i)
            cout << vs[i] << '\n';
}
To support the range-for loop for our Vector, we must define suitable begin() and end() functions:

Click here to view code image

template<typename T>
T* begin(Vector<T>& x)
{
    return x.size() ? &x[0] : nullptr;           // pointer to first element or nullptr
}

template<typename T>
T* end(Vector<T>& x)
{
    return begin()+x.size();                   // pointer to one-past-last element
}
Given those, we can write:

Click here to view code image

void f2(Vector<string>& vs)     // Vector of some strings
{
     for (auto& s : vs)
           cout << s << '\n';
}
Similarly, we can define lists, vectors, maps (that is, associative arrays), etc., as templates (§4.4, §23.2, Chapter 31).

Templates are a compile-time mechanism, so their use incurs no run-time overhead compared to hand-crafted code (§23.2.2).

3.4.2. Function Templates
Templates have many more uses than simply parameterizing a container with an element type. In particular, they are extensively used for parameterization of both types and algorithms in the standard library (§4.4.5, §4.5.5). For example, we can write a function that calculates the sum of the element values of any container like this:

Click here to view code image

template<typename Container, typename Value>
Value sum(const Container& c, Value v)
{
    for (auto x : c)
          v+=x;
    return v;
}
The Value template argument and the function argument v are there to allow the caller to specify the type and initial value of the accumulator (the variable in which to accumulate the sum):

Click here to view code image

void user(Vector<int>& vi, std::list<double>& ld, std::vector<complex<double>>& vc)
{
     int x = sum(vi,0);                   // the sum of a vector of ints (add ints)
     double d = sum(vi,0.0);              // the sum of a vector of ints (add doubles)
     double dd = sum(ld,0.0);             // the sum of a list of doubles
     auto z = sum(vc,complex<double>{});  // the sum of a vector of complex<double>
                                          // the initial value is {0.0,0.0}
}
The point of adding ints in a double would be to gracefully handle a number larger than the largest int. Note how the types of the template arguments for sum<T,V> are deduced from the function arguments. Fortunately, we do not need to explicitly specify those types.

This sum() is a simplified version of the standard-library accumulate() (§40.6).

3.4.3. Function Objects
One particularly useful kind of template is the function object (sometimes called a functor), which is used to define objects that can be called like functions. For example:

Click here to view code image

template<typename T>
class Less_than {
     const T val;      // value to compare against
public:
     Less_than(const T& v) :val(v) { }
     bool operator()(const T& x) const { return x<val; }  // call operator
};
The function called operator() implements the “function call,” “call,” or “application” operator ().

We can define named variables of type Less_than for some argument type:

Click here to view code image

Less_than<int> lti {42};           // lti(i) will compare i to 42 using < (i<42)
Less_than<string> lts {"Backus"};  // lts(s) will compare s to "Backus" using < (s<"Backus")
We can call such an object, just as we call a function:

Click here to view code image

void fct(int n, const string & s)
{
     bool b1 = lti(n);     // true if n<42
     bool b2 = lts(s);     // true if s<"Backus"
      //...
}
Such function objects are widely used as arguments to algorithms. For example, we can count the occurrences of values for which a predicate returns true:

Click here to view code image

template<typename C, typename P>
int count(const C& c, P pred)
{
     int cnt = 0;
     for (const auto& x : c)
           if (pred(x))
                 ++cnt;
     return cnt;
}
A predicate is something that we can invoke to return true or false. For example:

Click here to view code image

void f(const Vector<int>& vec, const list<string>& lst, int x, const string& s)
{
     cout << "number of values less than " << x
          << ": " << count(vec,Less_than<int>{x})
          << '\n';
     cout << "number of values less than " << s
          << ": " << count(lst,Less_than<string>{s})
          << '\n';
}
Here, Less_than<int>{x} constructs an object for which the call operator compares to the int called x; Less_than<string>{s} constructs an object that compares to the string called s. The beauty of these function objects is that they carry the value to be compared against with them. We don’t have to write a separate function for each value (and each type), and we don’t have to introduce nasty global variables to hold values. Also, for a simple function object like Less_than inlining is simple, so that a call of Less_than is far more efficient than an indirect function call. The ability to carry data plus their efficiency make function objects particularly useful as arguments to algorithms.

Function objects used to specify the meaning of key operations of a general algorithm (such as Less_than for count()) are often referred to as policy objects.

We have to define Less_than separately from its use. That could be seen as inconvenient. Consequently, there is a notation for implicitly generating function objects:

Click here to view code image

void f(const Vector<int>& vec, const list<string>& lst, int x, const string& s)
{
     cout << "number of values less than " << x
          << ": " << count(vec,[&](int a){ return a<x; })
          << '\n';
     cout << "number of values less than " << s
          << ": " << count(lst,[&](const string& a){ return a<s; })
          << '\n';
}
The notation [&](int a){ return a<x; } is called a lambda expression (§11.4). It generates a function object exactly like Less_than<int>{x}. The [&] is a capture list specifying that local names used (such as x) will be accessed through references. Had we wanted to “capture” only x, we could have said so: [&x]. Had we wanted to give the generated object a copy of x, we could have said so: [x]. Capture nothing is [], capture all local names used by reference is [&], and capture all local names used by value is [=].

Using lambdas can be convenient and terse, but also obscure. For nontrivial actions (say, more than a simple expression), I prefer to name the operation so as to more clearly state its purpose and to make it available for use in several places in a program.

In §3.2.4, we noticed the annoyance of having to write many functions to perform operations on elements of vectors of pointers and unique_ptrs, such as draw_all() and rotate_all(). Function objects (in particular, lambdas) can help by allowing us to separate the traversal of the container from the specification of what is to be done with each element.

First, we need a function that applies an operation to each object pointed to by the elements of a container of pointers:

Click here to view code image

template<typename C, typename Oper>
void for_all(C& c, Oper op)        // assume that C is a container of pointers
{
     for (auto& x : c)
           op(*x);      // pass op() a reference to each element pointed to
}
Now, we can write a version of user() from §3.2.4 without writing a set of _all functions:

Click here to view code image

void user()
{
     vector<unique_ptr<Shape>> v;
     while (cin)
           v.push_back(read_shape(cin));
     for_all(v,[](Shape& s){ s.draw(); });       // draw_all()
     for_all(v,[](Shape& s){ s.rotate(45); });   // rotate_all(45)
}
I pass a reference to Shape to a lambda so that the lambda doesn’t have to care exactly how the objects are stored in the container. In particular, those for_all() calls would still work if I changed v to a vector<Shape*>.

3.4.4. Variadic Templates
A template can be defined to accept an arbitrary number of arguments of arbitrary types. Such a template is called a variadic template. For example:

Click here to view code image

void f() { } // do nothing

template<typename T, typename... Tail>
void f(T head, Tail... tail)
{
     g(head);    // do something to head
     f(tail...); // try again with tail
}
The key to implementing a variadic template is to note that when you pass a list of arguments to it, you can separate the first argument from the rest. Here, we do something to the first argument (the head) and then recursively call f() with the rest of the arguments (the tail). The ellipsis, ..., is used to indicate “the rest” of a list. Eventually, of course, tail will become empty and we need a separate function to deal with that.

We can call this f() like this:

int main()
{
     cout << "first: ";
     f(1,2.2,"hello");

     cout << "\nsecond: ";
     f(0.2,'c',"yuck!",0,1,2);
     cout << "\n";
}
This would call f(1,2.2,"hello"), which will call f(2.2,"hello"), which will call f("hello"), which will call f(). What might the call g(head) do? Obviously, in a real program it will do whatever we wanted done to each argument. For example, we could make it write its argument (here, head) to output:

template<typename T>
void g(T x)
{
     cout << x << " ";
}
Given that, the output will be:

first: 1 2.2 hello
second: 0.2 c yuck! 0 1 2
It seems that f() is a simple variant of printf() printing arbitrary lists or values – implemented in three lines of code plus their surrounding declarations.

The strength of variadic templates (sometimes just called variadics) is that they can accept any arguments you care to give them. The weakness is that the type checking of the interface is a possibly elaborate template program. For details, see §28.6. For examples, see §34.2.4.2 (N-tuples) and Chapter 29 (N-dimensional matrices).

3.4.5. Aliases
Surprisingly often, it is useful to introduce a synonym for a type or a template (§6.5). For example, the standard header <cstddef> contains a definition of the alias size_t, maybe:

using size_t = unsigned int;
The actual type named size_t is implementation-dependent, so in another implementation size_t may be an unsigned long. Having the alias size_t allows the programmer to write portable code.

It is very common for a parameterized type to provide an alias for types related to their template arguments. For example:

template<typename T>
class Vector {
public:
     using value_type = T;
     //...
};
In fact, every standard-library container provides value_type as the name of its value type (§31.3.1). This allows us to write code that will work for every container that follows this convention. For example:

Click here to view code image

template<typename C>
using Value_type = typename C::value_type;  // the type of C's elements

template<typename Container>
void algo(Container& c)
{
     Vector<Value_type<Container>> vec;     // keep results here
      // ... use vec ...
}
The aliasing mechanism can be used to define a new template by binding some or all template arguments. For example:

Click here to view code image

template<typename Key, typename Value>
class Map {
      //...
};

template<typename Value>
using String_map = Map<string,Value>;

String_map<int> m;  // m is a Map<string,int>
See §23.6.

3.5. Advice
[1] Express ideas directly in code; §3.2.

[2] Define classes to represent application concepts directly in code; §3.2.

[3] Use concrete classes to represent simple concepts and performance-critical components; §3.2.1.

[4] Avoid “naked” new and delete operations; §3.2.1.2.

[5] Use resource handles and RAII to manage resources; §3.2.1.2.

[6] Use abstract classes as interfaces when complete separation of interface and implementation is needed; §3.2.2.

[7] Use class hierarchies to represent concepts with inherent hierarchical structure; §3.2.4.

[8] When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance; §3.2.4.

[9] Control construction, copy, move, and destruction of objects; §3.3.

[10] Return containers by value (relying on move for efficiency); §3.3.2.

[11] Provide strong resource safety; that is, never leak anything that you think of as a resource; §3.3.3.

[12] Use containers, defined as resource-handle templates, to hold collections of values of the same type; §3.4.1.

[13] Use function templates to represent general algorithms; §3.4.2.

[14] Use function objects, including lambdas, to represent policies and actions; §3.4.3.

[15] Use type and template aliases to provide a uniform notation for types that may vary among similar types or among implementations; §3.4.5.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


3. A Tour of C++: Abstraction Mechanisms
4. A Tour of C++: Containers and Algorithms
5. A Tour of C++: Concurrency and Utilities
47h 26m remaining
4. A Tour of C++: Containers and Algorithms
Why waste time learning when ignorance is instantaneous?

– Hobbes

• Libraries

Standard-Library Overview; The Standard-Library Headers and Namespace

• Strings

• Stream I/O

Output; Input; I/O of User-Defined Types

• Containers

vector; list; map; unordered_map; Container Overview

• Algorithms

Use of Iterators; Iterator Types; Stream Iterators; Predicates; Algorithm Overview; Container Algorithms

• Advice

4.1. Libraries
No significant program is written in just a bare programming language. First, a set of libraries is developed. These then form the basis for further work. Most programs are tedious to write in the bare language, whereas just about any task can be rendered simple by the use of good libraries.

Continuing from Chapters 2 and 3, this chapter and the next give a quick tour of key standard-library facilities. I assume that you have programmed before. If not, please consider reading a textbook, such as Programming: Principles and Practice Using C++ [Stroustrup,2009], before continuing. Even if you have programmed before, the libraries you used or the applications you wrote may be very different from the style of C++ presented here. If you find this “lightning tour” confusing, you might skip to the more systematic and bottom-up language presentation starting in Chapter 6. Similarly, a more systematic description of the standard library starts in Chapter 30.

I very briefly present useful standard-library types, such as string, ostream, vector, map (this chapter), unique_ptr, thread, regex, and complex (Chapter 5), as well as the most common ways of using them. Doing this allows me to give better examples in the following chapters. As in Chapter 2 and Chapter 3, you are strongly encouraged not to be distracted or discouraged by an incomplete understanding of details. The purpose of this chapter is to give you a taste of what is to come and to convey a basic understanding of the most useful library facilities.

The specification of the standard library is almost two thirds of the ISO C++ standard. Explore it, and prefer it to home-made alternatives. Much thought has gone into its design, more still into its implementations, and much effort will go into its maintenance and extension.

The standard-library facilities described in this book are part of every complete C++ implementation. In addition to the standard-library components, most implementations offer “graphical user interface” systems (GUIs), Web interfaces, database interfaces, etc. Similarly, most application development environments provide “foundation libraries” for corporate or industrial “standard” development and/or execution environments. Here, I do not describe such systems and libraries. The intent is to provide a self-contained description of C++ as defined by the standard and to keep the examples portable, except where specifically noted. Naturally, a programmer is encouraged to explore the more extensive facilities available on most systems.

4.1.1. Standard-Library Overview
The facilities provided by the standard library can be classified like this:

• Run-time language support (e.g., for allocation and run-time type information); see §30.3.

• The C standard library (with very minor modifications to minimize violations of the type system); see Chapter 43.

• Strings and I/O streams (with support for international character sets and localization); see Chapter 36, Chapter 38, and Chapter 39. I/O streams is an extensible framework to which users can add their own streams, buffering strategies, and character sets.

• A framework of containers (such as vector and map) and algorithms (such as find(), sort(), and merge()); see §4.4, §4.5, Chapters 31-33. This framework, conventionally called the STL [Stepanov,1994], is extensible so users can add their own containers and algorithms.

• Support for numerical computation (such as standard mathematical functions, complex numbers, vectors with arithmetic operations, and random number generators); see §3.2.1.1 and Chapter 40.

• Support for regular expression matching; see §5.5 and Chapter 37.

• Support for concurrent programming, including threads and locks; see §5.3 and Chapter 41. The concurrency support is foundational so that users can add support for new models of concurrency as libraries.

• Utilities to support template metaprogramming (e.g., type traits; §5.4.2, §28.2.4, §35.4), STL-style generic programming (e.g., pair; §5.4.3, §34.2.4.1), and general programming (e.g., clock; §5.4.1, §35.2).

• “Smart pointers” for resource management (e.g., unique_ptr and shared_ptr; §5.2.1, §34.3) and an interface to garbage collectors (§34.5).

• Special-purpose containers, such as array (§34.2.1), bitset (§34.2.2), and tuple (§34.2.4.2).

The main criteria for including a class in the library were that:

• it could be helpful to almost every C++ programmer (both novices and experts),

• it could be provided in a general form that did not add significant overhead compared to a simpler version of the same facility, and

• that simple uses should be easy to learn (relative to the inherent complexity of their task).

Essentially, the C++ standard library provides the most common fundamental data structures together with the fundamental algorithms used on them.

4.1.2. The Standard-Library Headers and Namespace
Every standard-library facility is provided through some standard header. For example:

#include<string>
#include<list>
This makes the standard string and list available.

The standard library is defined in a namespace (§2.4.2, §14.3.1) called std. To use standard library facilities, the std:: prefix can be used:

Click here to view code image

std::string s {"Four legs Good; two legs Baaad!"};
std::list<std::string> slogans {"War is Peace", "Freedom is Slavery", "Ignorance is Strength"};
For simplicity, I will rarely use the std:: prefix explicitly in examples. Neither will I always #include the necessary headers explicitly. To compile and run the program fragments here, you must #include the appropriate headers (as listed in §4.4.5, §4.5.5, and §30.2) and make the names they declare accessible. For example:

Click here to view code image

#include<string>           // make the standard string facilities accessible
using namespace std;       // make std names available without std:: prefix

string s {"C++ is a general–purpose programming language"};   // OK: string is std::string
It is generally in poor taste to dump every name from a namespace into the global namespace. However, in this book, I use the standard library almost exclusively and it is good to know what it offers. So, I don’t prefix every use of a standard library name with std::. Nor do I #include the appropriate headers in every example. Assume that done.

Here is a selection of standard-library headers, all supplying declarations in namespace std:

Selected Standard Library Headers (continues)

<algorithm>

copy(), find(), sort()

§32.2

§iso.25

<array>

array

§34.2.1

§iso.23.3.2

<chrono>

duration, time_point

§35.2

§iso.20.11.2

<cmath>

sqrt(), pow()

§40.3

§iso.26.8

<complex>

complex, sqrt(), pow()

§40.4

§iso.26.8

<fstream>

fstream, ifstream, ofstream

§38.2.1

§iso.27.9.1

<future>

future, promise

§5.3.5

§iso.30.6

<iostream>

istream, ostream, cin, cout

§38.1

§iso.27.4

<map>

map, multimap

§31.4.3

§iso.23.4.4

<memory>

unique_ptr, shared_ptr, allocator

§5.2.1

§iso.20.6

<random>

default_random_engine, normal_distribution

§40.7

§iso.26.5

<regex>

regex, smatch

Chapter 37

§iso.28.8

<string>

string, basic_string

Chapter 36

§iso.21.3

<set>

set, multiset

§31.4.3

§iso.23.4.6

<sstream>

istrstream, ostrstream

§38.2.2

§iso.27.8

<thread>

thread

§5.3.1

§iso.30.3

<unordered_map>

unordered_map, unordered_multimap

§31.4.3.2

§iso.23.5.4

<utility>

move(), swap(), pair

§35.5

§iso.20.1

<vector>

vector

§31.4

§iso.23.3.6

This listing is far from complete; see §30.2 for more information.

4.2. Strings
The standard library provides a string type to complement the string literals. The string type provides a variety of useful string operations, such as concatenation. For example:

Click here to view code image

string compose(const string& name, const string& domain)
{
     return name + '@' + domain;
}

auto addr = compose("dmr","bell–labs.com");
Here, addr is initialized to the character sequence dmr@bell–labs.com. “Addition” of strings means concatenation. You can concatenate a string, a string literal, a C-style string, or a character to a string. The standard string has a move constructor so returning even long strings by value is efficient (§3.3.2).

In many applications, the most common form of concatenation is adding something to the end of a string. This is directly supported by the += operation. For example:

Click here to view code image

void m2(string& s1, string& s2)
{
     s1 = s1 + '\n';    // append newline
     s2 += '\n';        // append newline
}
The two ways of adding to the end of a string are semantically equivalent, but I prefer the latter because it is more explicit about what it does, more concise, and possibly more efficient.

A string is mutable. In addition to = and +=, subscripting (using []) and substring operations are supported. The standard-library string is described in Chapter 36. Among other useful features, it provides the ability to manipulate substrings. For example:

Click here to view code image

string name = "Niels Stroustrup";

void m3()
{
     string s = name.substr(6,10);     // s = "Stroustrup"
     name.replace(0,5,"nicholas");     // name becomes "nicholas Stroustrup"
     name[0] = toupper(name[0]);       // name becomes "Nicholas Stroustrup"
}
The substr() operation returns a string that is a copy of the substring indicated by its arguments. The first argument is an index into the string (a position), and the second is the length of the desired substring. Since indexing starts from 0, s gets the value Stroustrup.

The replace() operation replaces a substring with a value. In this case, the substring starting at 0 with length 5 is Niels; it is replaced by nicholas. Finally, I replace the initial character with its uppercase equivalent. Thus, the final value of name is Nicholas Stroustrup. Note that the replacement string need not be the same size as the substring that it is replacing.

Naturally, strings can be compared against each other and against string literals. For example:

Click here to view code image

string incantation;

void respond(const string& answer)
{
     if (answer == incantation) {
            // perform magic
     }
     else if (answer == "yes") {
            //...
     }
      //...
}
The string library is described in Chapter 36. The most common techniques for implementing string are presented in the String example (§19.3).

4.3. Stream I/O
The standard library provides formatted character input and output through the iostream library. The input operations are typed and extensible to handle user-defined types. This section is a very brief introduction to the use of iostreams; Chapter 38 is a reasonably complete description of the iostream library facilities.

Other forms of user interaction, such as graphical I/O, are handled through libraries that are not part of the ISO standard and therefore not described here.

4.3.1. Output
The I/O stream library defines output for every built-in type. Further, it is easy to define output of a user-defined type (§4.3.3). The operator << (“put to”) is used as an output operator on objects of type ostream; cout is the standard output stream and cerr is the standard stream for reporting errors. By default, values written to cout are converted to a sequence of characters. For example, to output the decimal number 10, we can write:

void f()
{
     cout << 10;
}
This places the character 1 followed by the character 0 on the standard output stream.

Equivalently, we could write:

void g()
{
     int i {10};
     cout << i;
}
Output of different types can be combined in the obvious way:

void h(int i)
{
     cout << "the value of i is ";
     cout << i;
     cout << '\n';
}
For h(10), the output will be:

the value of i is 10
People soon tire of repeating the name of the output stream when outputting several related items. Fortunately, the result of an output expression can itself be used for further output. For example:

Click here to view code image

void h2(int i)
{
     cout << "the value of i is " << i << '\n';
}
This h2() produces the same output as h().

A character constant is a character enclosed in single quotes. Note that a character is output as a character rather than as a numerical value. For example:

Click here to view code image

void k()
{
     int b = 'b';    // note: char implicitly converted to int
     char c = 'c';
     cout << 'a' << b << c;
}
The integer value of the character 'b' is 98 (in the ASCII encoding used on the C++ implementation that I used), so this will output a98c.

4.3.2. Input
The standard library offers istreams for input. Like ostreams, istreams deal with character string representations of built-in types and can easily be extended to cope with user-defined types.

The operator >> (“get from”) is used as an input operator; cin is the standard input stream. The type of the right-hand operand of >> determines what input is accepted and what is the target of the input operation. For example:

Click here to view code image

void f()
{
     int i;
     cin >> i;       // read an integer into i

     double d;
     cin >> d;       // read a double-precision floating-point number into d
}
This reads a number, such as 1234, from the standard input into the integer variable i and a floating-point number, such as 12.34e5, into the double-precision floating-point variable d.

Often, we want to read a sequence of characters. A convenient way of doing that is to read into a string. For example:

Click here to view code image

void hello()
{
     cout << "Please enter your name\n";
     string str;
     cin >> str;
     cout << "Hello, " << str << "!\n";
}
If you type in Eric the response is:

Hello, Eric!
By default, a whitespace character (§7.3.2), such as a space, terminates the read, so if you enter Eric Bloodaxe pretending to be the ill-fated king of York, the response is still:

Hello, Eric!
You can read a whole line (including the terminating newline character) using the getline() function. For example:

Click here to view code image

void hello_line()
{
     cout << "Please enter your name\n";
     string str;
     getline(cin,str);
     cout << "Hello, " << str << "!\n";
}
With this program, the input Eric Bloodaxe yields the desired output:

Hello, Eric Bloodaxe!
The newline that terminated the line is discarded, so cin is ready for the next input line.

The standard strings have the nice property of expanding to hold what you put in them; you don’t have to precalculate a maximum size. So, if you enter a couple of megabytes of semicolons, the program will echo pages of semicolons back at you.

4.3.3. I/O of User-Defined Types
In addition to the I/O of built-in types and standard strings, the iostream library allows programmers to define I/O for their own types. For example, consider a simple type Entry that we might use to represent entries in a telephone book:

struct Entry {
     string name;
     int number;
};
We can define a simple output operator to write an Entry using a {”name”,number} format similar to the one we use for initialization in code:

Click here to view code image

ostream& operator<<(ostream& os, const Entry& e)
{
     return os << "{\"" << e.name << "\", " << e.number << "}";
}
A user-defined output operator takes its output stream (by reference) as its first argument and returns it as its result. See §38.4.2 for details.

The corresponding input operator is more complicated because it has to check for correct formatting and deal with errors:

Click here to view code image

istream& operator>>(istream& is, Entry& e)
      // read { "name" , number } pair. Note: formatted with { " " , and }
{
     char c, c2;
     if (is>>c && c=='{' && is>>c2 && c2=="") {  // start with a { "
            string name;                    // the default value of a string is the empty string: ""
            while (is.get(c) && c!='"')     // anything before a " is part of the name
                  name+=c;

            if (is>>c && c==',') {
                  int number = 0;
                  if (is>>number>>c && c=='}') {  // read the number and a }
                         e = {name,number};       // assign to the entry
                         return is;
                  }
             }
     }
     is.setstate(ios_base::failbit);      // register the failure in the stream
     return is;
}
An input operation returns a reference to its istream which can be used to test if the operation succeeded. For example, when used as a condition, is>>c means “Did we succeed at reading from is into c?”

The is>>c skips whitespace by default, but is.get(c) does not, so that this Entry-input operator ignores (skips) whitespace outside the name string, but not within it. For example:

Click here to view code image

{ "John Marwood Cleese" , 123456   }
{"Michael Edward Palin",987654}
We can read such a pair of values from input into an Entry like this:

Click here to view code image

for (Entry ee; cin>>ee;)   // read from cin into ee
     cout << ee << '\n';    // write ee to cout
The output is:

{"John Marwood Cleese", 123456}
{"Michael Edward Palin", 987654}
See §38.4.1 for more technical details and techniques for writing input operators for user-defined types. See §5.5 and Chapter 37 for a more systematic technique for recognizing patterns in streams of characters (regular expression matching).

4.4. Containers
Most computing involves creating collections of values and then manipulating such collections. Reading characters into a string and printing out the string is a simple example. A class with the main purpose of holding objects is commonly called a container. Providing suitable containers for a given task and supporting them with useful fundamental operations are important steps in the construction of any program.

To illustrate the standard-library containers, consider a simple program for keeping names and telephone numbers. This is the kind of program for which different approaches appear “simple and obvious” to people of different backgrounds. The Entry class from §4.3.3 can be used to hold a simple phone book entry. Here, we deliberately ignore many real-world complexities, such as the fact that many phone numbers do not have a simple representation as a 32-bit int.

4.4.1. vector
The most useful standard-library container is vector. A vector is a sequence of elements of a given type. The elements are stored contiguously in memory:



The Vector examples in §3.2.2 and §3.4 give an idea of the implementation of vector and §13.6 and §31.4 provide an exhaustive discussion.

We can initialize a vector with a set of values of its element type:

Click here to view code image

vector<Entry> phone_book = {
     {"David Hume",123456},
     {"Karl Popper",234567},
     {"Bertrand Arthur William Russell",345678}
};
Elements can be accessed through subscripting:

Click here to view code image

void print_book(const vector<Entry>& book)
{
     for (int i = 0; i!=book.size(); ++i)
           cout << book[i] << '\n';
}
As usual, indexing starts at 0 so that book[0] holds the entry for David Hume. The vector member function size() gives the number of elements.

The elements of a vector constitute a range, so we can use a range-for loop (§2.2.5):

Click here to view code image

void print_book(const vector<Entry>& book)
{
     for (const auto& x : book)    // for "auto" see §2.2.2
           cout << x << '\n';
}
When we define a vector, we give it an initial size (initial number of elements):

Click here to view code image

vector<int> v1 = {1, 2, 3, 4};      // sizeis4
vector<string> v2;                  // sizeis0
vector<Shape*> v3(23);              // size is 23; initial element value: nullptr
vector<double> v4(32,9.9);          // size is 32; initial element value: 9.9
An explicit size is enclosed in ordinary parentheses, for example, (23), and by default the elements are initialized to the element type’s default value (e.g., nullptr for pointers and 0 for numbers). If you don’t want the default value, you can specify one as a second argument (e.g., 9.9 for the 32 elements of v4).

The initial size can be changed. One of the most useful operations on a vector is push_back(), which adds a new element at the end of a vector, increasing its size by one. For example:

void input()
{
     for (Entry e; cin>>e;)
           phone_book.push_back(e);
}
This reads Entrys from the standard input into phone_book until either the end-of-input (e.g., the end of a file) is reached or the input operation encounters a format error. The standard-library vector is implemented so that growing a vector by repeated push_back()s is efficient.

A vector can be copied in assignments and initializations. For example:

vector<Entry> book2 = phone_book;
Copying and moving of vectors are implemented by constructors and assignment operators as described in §3.3. Assigning a vector involves copying its elements. Thus, after the initialization of book2, book2 and phone_book hold separate copies of every Entry in the phone book. When a vector holds many elements, such innocent-looking assignments and initializations can be expensive. Where copying is undesirable, references or pointers (§7.2, §7.7) or move operations (§3.3.2, §17.5.2) should be used.

4.4.1.1. Elements
Like all standard-library containers, vector is a container of elements of some type T, that is, a vector<T>. Just about any type qualifies as an element type: built-in numeric types (such as char, int, and double), user-defined types (such as string, Entry, list<int>, and Matrix<double,2>), and pointers (such as const char*, Shape*, and double*). When you insert a new element, its value is copied into the container. For example, when you put an integer with the value 7 into a container, the resulting element really has the value 7. The element is not a reference or a pointer to some object containing 7. This makes for nice, compact containers with fast access. For people who care about memory sizes and run-time performance this is critical.

4.4.1.2. Range Checking
The standard-library vector does not guarantee range checking (§31.2.2). For example:

Click here to view code image

void silly(vector<Entry>& book)
{
     int i = book[book.size()].number;     // book.size() is out of range
     // ...
}
That initialization is likely to place some random value in i rather than giving an error. This is undesirable, and out-of-range errors are a common problem. Consequently, I often use a simple range-checking adaptation of vector:

Click here to view code image

template<typename T>
class Vec : public std::vector<T> {
public:
     using vector<T>::vector;  // use the constructors from vector (under the name Vec); see §20.3.5.1

     T& operator[](int i)                 // range check
         { return vector<T>::at(i); }

     const T& operator[](int i) const     // range check const objects; §3.2.1.1
         { return vector<T>::at(i); }
};
Vec inherits everything from vector except for the subscript operations that it redefines to do range checking. The at() operation is a vector subscript operation that throws an exception of type out_of_range if its argument is out of the vector’s range (§2.4.3.1, §31.2.2).

For Vec, an out-of-range access will throw an exception that the user can catch. For example:

Click here to view code image

void checked(Vec<Entry>& book)
{
     try {
           book[book.size()] = {"Joe",999999};   // will throw an exception
            //...
     }
     catch (out_of_range) {
           cout << "range error\n";
     }
}
The exception will be thrown, and then caught (§2.4.3.1, Chapter 13). If the user doesn’t catch an exception, the program will terminate in a well-defined manner rather than proceeding or failing in an undefined manner. One way to minimize surprises from uncaught exceptions is to use a main() with a try-block as its body. For example:

Click here to view code image

int main()
try {
      // your code
}
catch (out_of_range) {
     cerr << "range error\n";
}
catch (...) {
     cerr << "unknown exception thrown\n";
}
This provides default exception handlers so that if we fail to catch some exception, an error message is printed on the standard error-diagnostic output stream cerr (§38.1).

Some implementations save you the bother of defining Vec (or equivalent) by providing a range-checked version of vector (e.g., as a compiler option).

4.4.2. list
The standard library offers a doubly-linked list called list:



We use a list for sequences where we want to insert and delete elements without moving other elements. Insertion and deletion of phone book entries could be common, so a list could be appropriate for representing a simple phone book. For example:

Click here to view code image

list<Entry> phone_book = {
     {"David Hume",123456},
     {"Karl Popper",234567},
     {"Bertrand Arthur William Russell",345678}
};
When we use a linked list, we tend not to access elements using subscripting the way we commonly do for vectors. Instead, we might search the list looking for an element with a given value. To do this, we take advantage of the fact that a list is a sequence as described in §4.5:

Click here to view code image

int get_number(const string& s)
{
     for (const auto& x : phone_book)
            if (x.name==s)
                  return x.number;
     return 0;  // use 0 to represent "number not found"
}
The search for s starts at the beginning of the list and proceeds until s is found or the end of phone_book is reached.

Sometimes, we need to identify an element in a list. For example, we may want to delete it or insert a new entry before it. To do that we use an iterator: a list iterator identifies an element of a list and can be used to iterate through a list (hence its name). Every standard-library container provides the functions begin() and end(), which return an iterator to the first and to one-past-the-last element, respectively (§4.5, §33.1.1). Using iterators explicitly, we can – less elegantly – write the get_number() function like this:

Click here to view code image

int get_number(const string& s)
{
     for (auto p = phone_book.begin(); p!=phone_book.end(); ++p)
           if (p–>name==s)
                 return p–>number;
     return 0;  // use 0 to represent "number not found"
}
In fact, this is roughly the way the terser and less error-prone range-for loop is implemented by the compiler. Given an iterator p, *p is the element to which it refers, ++p advances p to refer to the next element, and when p refers to a class with a member m, then p–>m is equivalent to (*p).m.

Adding elements to a list and removing elements from a list is easy:

Click here to view code image

void f(const Entry& ee, list<Entry>::iterator p, list<Entry>::iterator q)
{
     phone_book.insert(p,ee);        // add ee before the element referred to by p
     phone_book.erase(q);            // remove the element referred to by q
}
For a more complete description of insert() and erase(), see §31.3.7.

These list examples could be written identically using vector and (surprisingly, unless you understand machine architecture) perform better with a small vector than with a small list. When all we want is a sequence of elements, we have a choice between using a vector and a list. Unless you have a reason not to, use a vector. A vector performs better for traversal (e.g., find() and count()) and for sorting and searching (e.g., sort() and binary_search()).

4.4.3. map
Writing code to look up a name in a list of (name,number) pairs is quite tedious. In addition, a linear search is inefficient for all but the shortest lists. The standard library offers a search tree (a red-black tree) called map:



In other contexts, a map is known as an associative array or a dictionary. It is implemented as a balanced binary tree.

The standard-library map (§31.4.3) is a container of pairs of values optimized for lookup. We can use the same initializer as for vector and list (§4.4.1, §4.4.2):

Click here to view code image

map<string,int> phone_book {
    {"David Hume",123456},
    {"Karl Popper",234567},
    {"Bertrand Arthur William Russell",345678}
};
When indexed by a value of its first type (called the key), a map returns the corresponding value of the second type (called the value or the mapped type). For example:

Click here to view code image

int get_number(const string& s)
{
     return phone_book[s];
}
In other words, subscripting a map is essentially the lookup we called get_number(). If a key isn’t found, it is entered into the map with a default value for its value. The default value for an integer type is 0; the value I just happened to choose represents an invalid telephone number.

If we wanted to avoid entering invalid numbers into our phone book, we could use find() and insert() instead of [] (§31.4.3.1).

4.4.4. unordered_map
The cost of a map lookup is O(log(n)) where n is the number of elements in the map. That’s pretty good. For example, for a map with 1,000,000 elements, we perform only about 20 comparisons and indirections to find an element. However, in many cases, we can do better by using a hashed lookup rather than comparison using an ordering function, such as <. The standard-library hashed containers are referred to as “unordered” because they don’t require an ordering function:



For example, we can use an unordered_map from <unordered_map> for our phone book:

Click here to view code image

unordered_map<string,int> phone_book {
    {"David Hume",123456},
    {"Karl Popper",234567},
    {"Bertrand Arthur William Russell",345678}
};
As for a map, we can subscript an unordered_map:

int get_number(const string& s)
{
     return phone_book[s];
}
The standard-library unordered_map provides a default hash function for strings. If necessary, you can provide your own (§31.4.3.4).

4.4.5. Container Overview
The standard library provides some of the most general and useful container types to allow the programmer to select a container that best serves the needs of an application:

Standard Container Summary

vector<T>

A variable-size vector (§31.4)

list<T>

A doubly-linked list (§31.4.2)

forward_list<T>

A singly-linked list (§31.4.2)

deque<T>

A double-ended queue (§31.2)

set<T>

A set (§31.4.3)

multiset<T>

A set in which a value can occur many times (§31.4.3)

map<K,V>

An associative array (§31.4.3)

multimap<K,V>

A map in which a key can occur many times (§31.4.3)

unordered_map<K,V>

A map using a hashed lookup (§31.4.3.2)

unordered_multimap<K,V>

A multimap using a hashed lookup (§31.4.3.2)

unordered_set<T>

A set using a hashed lookup (§31.4.3.2)

unordered_multiset<T>

A multiset using a hashed lookup (§31.4.3.2)

The unordered containers are optimized for lookup with a key (often a string); in other words, they are implemented using hash tables.

The standard containers are described in §31.4. The containers are defined in namespace std and presented in headers <vector>, <list>, <map>, etc. (§4.1.2, §30.2). In addition, the standard library provides container adaptors queue<T> (§31.5.2), stack<T> (§31.5.1), and priority_queue<T> (§31.5.3). The standard library also provides more specialized container-like types, such as a fixed-size array array<T,N> (§34.2.1) and bitset<N> (§34.2.2).

The standard containers and their basic operations are designed to be similar from a notational point of view. Furthermore, the meanings of the operations are equivalent for the various containers. Basic operations apply to every kind of container for which they make sense and can be efficiently implemented. For example:

• begin() and end() give iterators to the first and one-beyond-the-last elements, respectively.

• push_back() can be used (efficiently) to add elements to the end of a vector, list, and other containers.

• size() returns the number of elements.

This notational and semantic uniformity enables programmers to provide new container types that can be used in a very similar manner to the standard ones. The range-checked vector, Vector (§2.3.2, §2.4.3.1), is an example of that. The uniformity of container interfaces also allows us to specify algorithms independently of individual container types. However, each has strengths and weaknesses. For example, subscripting and traversing a vector is cheap and easy. On the other hand, vector elements are moved when we insert or remove elements; list has exactly the opposite properties. Please note that a vector is usually more efficient than a list for short sequences of small elements (even for insert() and erase()). I recommend the standard-library vector as the default type for sequences of elements: you need a reason to choose another.

4.5. Algorithms
A data structure, such as a list or a vector, is not very useful on its own. To use one, we need operations for basic access such as adding and removing elements (as is provided for list and vector). Furthermore, we rarely just store objects in a container. We sort them, print them, extract subsets, remove elements, search for objects, etc. Consequently, the standard library provides the most common algorithms for containers in addition to providing the most common container types. For example, the following sorts a vector and places a copy of each unique vector element on a list:

Click here to view code image

bool operator<(const Entry& x, const Entry& y)   // less than
{
     return x.name<y.name;         // order Entrys by their names
}
void f(vector<Entry>& vec, list<Entry>& lst)
{
     sort(vec.begin(),vec.end());                       // use < for order
     unique_copy(vec.begin(),vec.end(),lst.begin());    // don't copy adjacent equal elements
}
The standard algorithms are described in Chapter 32. They are expressed in terms of sequences of elements. A sequence is represented by a pair of iterators specifying the first element and the one-beyond-the-last element:



In the example, sort() sorts the sequence defined by the pair of iterators vec.begin() and vec.end() – which just happens to be all the elements of a vector. For writing (output), you need only to specify the first element to be written. If more than one element is written, the elements following that initial element will be overwritten. Thus, to avoid errors, lst must have at least as many elements as there are unique values in vec.

If we wanted to place the unique elements in a new container, we could have written:

Click here to view code image

list<Entry> f(vector<Entry>& vec)
{
     list<Entry> res;
     sort(vec.begin(),vec.end());
     unique_copy(vec.begin(),vec.end(),back_inserter(res));  // append to res
     return res;
}
A back_inserter() adds elements at the end of a container, extending the container to make room for them (§33.2.2). Thus, the standard containers plus back_inserter()s eliminate the need to use error-prone, explicit C-style memory management using realloc() (§31.5.1). The standard-library list has a move constructor (§3.3.2, §17.5.2) that makes returning res by value efficient (even for lists of thousands of elements).

If you find the pair-of-iterators style of code, such as sort(vec.begin(),vec.end()), tedious, you can define container versions of the algorithms and write sort(vec) (§4.5.6).

4.5.1. Use of Iterators
When you first encounter a container, a few iterators referring to useful elements can be obtained; begin() and end() are the best examples of this. In addition, many algorithms return iterators. For example, the standard algorithm find looks for a value in a sequence and returns an iterator to the element found:

Click here to view code image

bool has_c(const string& s, char c)     // does s contain the character c?
{
     auto p = find(s.begin(),s.end(),c);
     if (p!=s.end())
           return true;
     else
           return false;
}
Like many standard-library search algorithms, find returns end() to indicate “not found.” An equivalent, shorter, definition of has_c() is:

Click here to view code image

bool has_c(const string& s, char c)      // does s contain the character c?
{
     return find(s.begin(),s.end(),c)!=s.end();
}
A more interesting exercise would be to find the location of all occurrences of a character in a string. We can return the set of occurrences as a vector of string iterators. Returning a vector is efficient because vector provides move semantics (§3.3.1). Assuming that we would like to modify the locations found, we pass a non-const string:

Click here to view code image

vector<string::iterator> find_all(string& s, char c)    // find all occurrences of c in s
{
     vector<string::iterator> res;
     for (auto p = s.begin(); p!=s.end(); ++p)
           if (*p==c)
                 res.push_back(p);
     return res;
}
We iterate through the string using a conventional loop, moving the iterator p forward one element at a time using ++ and looking at the elements using the dereference operator *. We could test find_all() like this:

Click here to view code image

void test()
{
     string m {"Mary had a little lamb"};
     for (auto p : find_all(m,'a'))
           if (*p!='a')
                 cerr << "a bug!\n";
}
That call of find_all() could be graphically represented like this:



Iterators and standard algorithms work equivalently on every standard container for which their use makes sense. Consequently, we could generalize find_all():

Click here to view code image

template<typename C, typename V>
vector<typename C::iterator> find_all(C& c, V v)      // find all occurrences of v in c
{
     vector<typename C::iterator> res;
     for (auto p = c.begin(); p!=c.end(); ++p)
           if (*p==v)
                 res.push_back(p);
     return res;
}
The typename is needed to inform the compiler that C’s iterator is supposed to be a type and not a value of some type, say, the integer 7. We can hide this implementation detail by introducing a type alias (§3.4.5) for Iterator:

Click here to view code image

template<typename T>
using Iterator = typename T::iterator;      // T's iterator


template<typename C, typename V>
vector<Iterator<C>> find_all(C& c, V v)     // find all occurrences of v in c
{
     vector<Iterator<C>> res;
     for (auto p = c.begin(); p!=c.end(); ++p)
           if (*p==v)
                 res.push_back(p);
     return res;
}
We can now write:

Click here to view code image

void test()
{
     string m {"Mary had a little lamb"};
     for (auto p : find_all(m,'a'))              // p is a string::iterator
           if (*p!='a')
                 cerr << "string bug!\n";

     list<double> ld {1.1, 2.2, 3.3, 1.1};
     for (auto p : find_all(ld,1.1))
           if (*p!=1.1)
                 cerr << "list bug!\n";

     vector<string> vs { "red", "blue", "green", "green", "orange", "green" };
     for (auto p : find_all(vs,"red"))
           if (*p!="red")
                 cerr << "vector bug!\n";

     for (auto p : find_all(vs,"green"))
           *p = "vert";
}
Iterators are used to separate algorithms and containers. An algorithm operates on its data through iterators and knows nothing about the container in which the elements are stored. Conversely, a container knows nothing about the algorithms operating on its elements; all it does is to supply iterators upon request (e.g., begin() and end()). This model of separation between data storage and algorithm delivers very general and flexible software.

4.5.2. Iterator Types
What are iterators really? Any particular iterator is an object of some type. There are, however, many different iterator types, because an iterator needs to hold the information necessary for doing its job for a particular container type. These iterator types can be as different as the containers and the specialized needs they serve. For example, a vector’s iterator could be an ordinary pointer, because a pointer is quite a reasonable way of referring to an element of a vector:



Alternatively, a vector iterator could be implemented as a pointer to the vector plus an index:



Using such an iterator would allow range checking.

A list iterator must be something more complicated than a simple pointer to an element because an element of a list in general does not know where the next element of that list is. Thus, a list iterator might be a pointer to a link:



What is common for all iterators is their semantics and the naming of their operations. For example, applying ++ to any iterator yields an iterator that refers to the next element. Similarly, * yields the element to which the iterator refers. In fact, any object that obeys a few simple rules like these is an iterator (§33.1.4). Furthermore, users rarely need to know the type of a specific iterator; each container “knows” its iterator types and makes them available under the conventional names iterator and const_iterator. For example, list<Entry>::iterator is the general iterator type for list<Entry>. We rarely have to worry about the details of how that type is defined.

4.5.3. Stream Iterators
Iterators are a general and useful concept for dealing with sequences of elements in containers. However, containers are not the only place where we find sequences of elements. For example, an input stream produces a sequence of values, and we write a sequence of values to an output stream. Consequently, the notion of iterators can be usefully applied to input and output.

To make an ostream_iterator, we need to specify which stream will be used and the type of objects written to it. For example:

ostream_iterator<string> oo {cout};      // write strings to cout
The effect of assigning to *oo is to write the assigned value to cout. For example:

Click here to view code image

int main()
{
     *oo = "Hello, ";     // meaning cout<<"Hello, "
     ++oo;
     *oo = "world!\n";    // meaning cout<<"world!\n" 
}
This is yet another way of writing the canonical message to standard output. The ++oo is done to mimic writing into an array through a pointer.

Similarly, an istream_iterator is something that allows us to treat an input stream as a read-only container. Again, we must specify the stream to be used and the type of values expected:

istream_iterator<string> ii {cin};
Input iterators are used in pairs representing a sequence, so we must provide an istream_iterator to indicate the end of input. This is the default istream_iterator:

istream_iterator<string> eos {};
Typically, istream_iterators and ostream_iterators are not used directly. Instead, they are provided as arguments to algorithms. For example, we can write a simple program to read a file, sort the words read, eliminate duplicates, and write the result to another file:

Click here to view code image

int main()
{
     string from, to;
     cin >> from >> to;                      // get source and target file names


     ifstream is {from};                     // input stream for file "from"
     istream_iterator<string> ii {is};       // input iterator for stream
     istream_iterator<string> eos {};        // input sentinel


     ofstream os {to};                        // output stream for file "to"
     ostream_iterator<string> oo {os,"\n"};  // output iterator for stream

     vector<string> b {ii,eos};              // b is a vector initialized from input
     sort(b.begin(),b.end());                // sort the buffer


     unique_copy(b.begin(),b.end(),oo);      // copy buffer to output, discard replicated values
     return !is.eof() || !os;                // return error state (§2.2.1, §38.3)
}
An ifstream is an istream that can be attached to a file, and an ofstream is an ostream that can be attached to a file. The ostream_iterator’s second argument is used to delimit output values.

Actually, this program is longer than it needs to be. We read the strings into a vector, then we sort() them, and then we write them out, eliminating duplicates. A more elegant solution is not to store duplicates at all. This can be done by keeping the strings in a set, which does not keep duplicates and keeps its elements in order (§31.4.3). That way, we could replace the two lines using a vector with one using a set and replace unique_copy() with the simpler copy():

Click here to view code image

     set<string> b {ii,eos};          // collect strings from input
     copy(b.begin(),b.end(),oo);      // copy buffer to output
We used the names ii, eos, and oo only once, so we could further reduce the size of the program:

Click here to view code image

int main()
{
     string from, to;
     cin >> from >> to;         // get source and target file names

     ifstream is {from};        // input stream for file "from"
     ofstream os {to};          // output stream for file "to"

     set<string> b {istream_iterator<string>{is},istream_iterator<string>{}};  // read input
     copy(b.begin(),b.end(),ostream_iterator<string>{os,"\n"});                // copy to output

     return !is.eof() || !os;          // return error state (§2.2.1, §38.3)
}
It is a matter of taste and experience whether or not this last simplification improves readability.

4.5.4. Predicates
In the examples above, the algorithms have simply “built in” the action to be done for each element of a sequence. However, we often want to make that action a parameter to the algorithm. For example, the find algorithm (§32.4) provides a convenient way of looking for a specific value. A more general variant looks for an element that fulfills a specified requirement, a predicate (§3.4.2). For example, we might want to search a map for the first value larger than 42. A map allows us to access its elements as a sequence of (key,value) pairs, so we can search a map<string,int>’s sequence for a pair<const string,int> where the int is greater than 42:

Click here to view code image

void f(map<string,int>& m)
{
     auto p = find_if(m.begin(),m.end(),Greater_than{42});
      //...
}
Here, Greater_than is a function object (§3.4.3) holding the value (42) to be compared against:

Click here to view code image

struct Greater_than {
     int val;
     Greater_than(int v) : val{v} { }
     bool operator()(const pair<string,int>& r) { return r.second>val; }
};
Alternatively, we could use a lambda expression (§3.4.3):

auto p = find_if(m.begin(), m.end(), [](const pair<string,int>& r) { return r.second>42; });
4.5.5. Algorithm Overview
A general definition of an algorithm is “a finite set of rules which gives a sequence of operations for solving a specific set of problems [and] has five important features: Finiteness ... Definiteness ... Input ... Output ... Effectiveness” [Knuth,1968,§1.1]. In the context of the C++ standard library, an algorithm is a function template operating on sequences of elements.

The standard library provides dozens of algorithms. The algorithms are defined in namespace std and presented in the <algorithm> header. These standard-library algorithms all take sequences as inputs (§4.5). A half-open sequence from b to e is referred to as [b:e). Here are a few I have found particularly useful:

Selected Standard Algorithms

p=find(b,e,x)

p is the first p in [b:e) so that *p==x

p=find_if(b,e,f)

p is the first p in [b:e) so that f(*p)==true

n=count(b,e,x)

n is the number of elements *q in [b:e) so that *q==x

n=count_if(b,e,f)

n is the number of elements *q in [b:e) so that f(*q)

replace(b,e,v,v2)

Replace elements *q in [b:e) so that *q==v by v2

replace_if(b,e,f,v2)

Replace elements *q in [b:e) so that f(*q) by v2

p=copy(b,e,out)

Copy [b:e) to [out:p)

p=copy_if(b,e,out,f)

Copy elements *q from [b:e) so that f(*q) to [out:p)

p=unique_copy(b,e,out)

Copy [b:e) to [out:p); don’t copy adjacent duplicates

sort(b,e)

Sort elements of [b:e) using < as the sorting criterion

sort(b,e,f)

Sort elements of [b:e) using f as the sorting criterion

(p1,p2)=equal_range(b,e,v)

[p1:p2) is the subsequence of the sorted sequence [b:e) with the value v; basically a binary search for v

p=merge(b,e,b2,e2,out)

Merge two sorted sequences [b:e) and [b2:e2) into [out:p)

These algorithms, and many more (see Chapter 32), can be applied to elements of containers, strings, and built-in arrays.

4.5.6. Container Algorithms
A sequence is defined by a pair of iterators [begin:end). This is general and flexible, but most often, we apply an algorithm to a sequence that is the contents of a container. For example:

sort(v.begin(),v.end());
Why don’t we just say sort(v)? We can easily provide that shorthand:

Click here to view code image

namespace Estd {
   using namespace std;

   template<typename C>
   void sort(C& c)
   {
        sort(c.begin(),c.end());
   }
   template<typename C, typename Pred>
   void sort(C& c, Pred p)
   {
        sort(c.begin(),c.end(),p);
   }

    //...
}
I put the container versions of sort() (and other algorithms) into their own namespace Estd (“extended std”) to avoid interfering with other programmers’ uses of namespace std.

4.6. Advice
[1] Don’t reinvent the wheel; use libraries; §4.1.

[2] When you have a choice, prefer the standard library over other libraries; §4.1.

[3] Do not think that the standard library is ideal for everything; §4.1.

[4] Remember to #include the headers for the facilities you use; §4.1.2.

[5] Remember that standard-library facilities are defined in namespace std; §4.1.2.

[6] Prefer strings over C-style strings (a char*; §2.2.5); §4.2, §4.3.2.

[7] iostreams are type-sensitive, type-safe, and extensible; §4.3.

[8] Prefer vector<T>, map<K,T>, and unordered_map<K,T> over T[]; §4.4.

[9] Know your standard containers and their tradeoffs; §4.4.

[10] Use vector as your default container; §4.4.1.

[11] Prefer compact data structures; §4.4.1.1.

[12] If in doubt, use a range-checked vector (such as Vec); §4.4.1.2.

[13] Use push_back() or back_inserter() to add elements to a container; §4.4.1, §4.5.

[14] Use push_back() on a vector rather than realloc() on an array; §4.5.

[15] Catch common exceptions in main(); §4.4.1.2.

[16] Know your standard algorithms and prefer them over handwritten loops; §4.5.5.

[17] If iterator use gets tedious, define container algorithms; §4.5.6.

[18] You can use the range-for loop for a complete container.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


4. A Tour of C++: Containers and Algorithms
5. A Tour of C++: Concurrency and Utilities
Part II: Basic Facilities
47h 26m remaining
5. A Tour of C++: Concurrency and Utilities
When you wish to instruct, be brief.

– Cicero

• Introduction

• Resource Management

unique_ptr and shared_ptr

• Concurrency

Tasks and threads; Passing Arguments; Returning Results; Sharing Data; Communicating Tasks

• Small Utility Components

Time; Type Functions; pair and tuple

• Regular Expressions

• Math

Mathematical Functions and Algorithms; Complex Numbers; Random Numbers; Vector Arithmetic; Numeric Limits

• Advice

5.1. Introduction
From an end-user’s perspective, the ideal standard library would provide components directly supporting essentially every need. For a given application domain, a huge commercial library can come close to that ideal. However, that is not what the C++ standard library is trying to do. A manageable, universally available, library cannot be everything to everybody. Instead, the C++ standard library aims to provide components that are useful to most people in most application areas. That is, it aims to serve the intersection of all needs rather than their union. In addition, support for a few widely important application areas, such as mathematical computation and text manipulation, have crept in.

5.2. Resource Management
One of the key tasks of any nontrivial program is to manage resources. A resource is something that must be acquired and later (explicitly or implicitly) released. Examples are memory, locks, sockets, thread handles, and file handles. For a long-running program, failing to release a resource in a timely manner (“a leak”) can cause serious performance degradation and possibly even a miserable crash. Even for short programs, a leak can become an embarrassment, say by a resource shortage increasing the run time by orders of magnitude.

The standard library components are designed not to leak resources. To do this, they rely on the basic language support for resource management using constructor/destructor pairs to ensure that a resource doesn’t outlive an object responsible for it. The use of a constructor/destructor pair in Vector to manage the lifetime of its elements is an example (§3.2.1.2) and all standard-library containers are implemented in similar ways. Importantly, this approach interacts correctly with error handling using exceptions. For example, the technique is used for the standard-library lock classes:

Click here to view code image

mutex m;  // used to protect access to shared data
 //...
void f()
{
     unique_lock<mutex> lck {m};  // acquire the mutex m
      //... manipulate shared data ...
}
A thread will not proceed until lck’s constructor has acquired its mutex, m (§5.3.4). The corresponding destructor releases the resource. So, in this example, unique_lock’s destructor releases the mutex when the thread of control leaves f() (through a return, by “falling off the end of the function,” or through an exception throw).

This is an application of the “Resource Acquisition Is Initialization” technique (RAII; §3.2.1.2, §13.3). This technique is fundamental to the idiomatic handling of resources in C++. Containers (such as vector and map), string, and iostream manage their resources (such as file handles and buffers) similarly.

5.2.1. unique_ptr and shared_ptr
The examples so far take care of objects defined in a scope, releasing the resources they acquire at the exit from the scope, but what about objects allocated on the free store? In <memory>, the standard library provides two “smart pointers” to help manage objects on the free store:

[1] unique_ptr to represent unique ownership (§34.3.1)

[2] shared_ptr to represent shared ownership (§34.3.2)

The most basic use of these “smart pointers” is to prevent memory leaks caused by careless programming. For example:

Click here to view code image

void f(int i, int j)  // X* vs. unique_ptr<X>
{
     X* p = new X;                  // allocate a new X
     unique_ptr<X> sp {new X};      // allocate a new X and give its pointer to unique_ptr
      //...
     if (i<99) throw Z{};           // may throw an exception
     if (j<77) return;              // may return "early"
     p–>do_something();             // may throw an exception
     sp–>do_something();            // may throw an exception
      //...
     delete p;                      // destroy *p
}
Here, we “forgot” to delete p if i<99 or if j<77. On the other hand, unique_ptr ensures that its object is properly destroyed whichever way we exit f() (by throwing an exception, by executing return, or by “falling off the end”). Ironically, we could have solved the problem simply by not using a pointer and not using new:

Click here to view code image

void f(int i, int j)      // use a local variable
{
     X x;
      //...
}
Unfortunately, overuse of new (and of pointers and references) seems to be an increasing problem.

However, when you really need the semantics of pointers, unique_ptr is a very lightweight mechanism with no space or time overhead compared to correct use of a built-in pointer. Its further uses include passing free-store allocated objects in and out of functions:

Click here to view code image

unique_ptr<X> make_X(int i)
     // make an X and immediately give it to a unique_ptr
{
     //... check i, etc. ...
    return unique_ptr<X>{new X{i}};
}
A unique_ptr is a handle to an individual object (or an array) in much the same way that a vector is a handle to a sequence of objects. Both control the lifetime of other objects (using RAII) and both rely on move semantics to make return simple and efficient.

The shared_ptr is similar to unique_ptr except that shared_ptrs are copied rather than moved. The shared_ptrs for an object share ownership of an object and that object is destroyed when the last of its shared_ptrs is destroyed. For example:

Click here to view code image

void f(shared_ptr<fstream>);
void g(shared_ptr<fstream>);

void user(const string& name, ios_base::openmode mode)
{
     shared_ptr<fstream> fp {new fstream(name,mode)};
     if (!*fp) throw No_file{};  // make sure the file was properly opened

     f(fp);
     g(fp);
      //...
}
Now, the file opened by fp’s constructor will be closed by the last function to (explicitly or implicitly) destroy a copy of fp. Note that f() or g() may spawn a task holding a copy of fp or in some other way store a copy that outlives user(). Thus, shared_ptr provides a form of garbage collection that respects the destructor-based resource management of the memory-managed objects. This is neither cost free nor exorbitantly expensive, but does make the lifetime of the shared object hard to predict. Use shared_ptr only if you actually need shared ownership.

Given unique_ptr and shared_ptr, we can implement a complete “no naked new” policy (§3.2.1.2) for many programs. However, these “smart pointers” are still conceptually pointers and therefore only my second choice for resource management – after containers and other types that manage their resources at a higher conceptual level. In particular, shared_ptrs do not in themselves provide any rules for which of their owners can read and/or write the shared object. Data races (§41.2.4) and other forms of confusion are not addressed simply by eliminating the resource management issues.

Where do we use “smart pointers” (such as unique_ptr) rather than resource handles with operations designed specifically for the resource (such as vector or thread)? Unsurprisingly, the answer is “when we need pointer semantics.”

• When we share an object, we need pointers (or references) to refer to the shared object, so a shared_ptr becomes the obvious choice (unless there is an obvious single owner).

• When we refer to a polymorphic object, we need a pointer (or a reference) because we don’t know the exact type of the object referred to (or even its size), so a unique_ptr becomes the obvious choice.

• A shared polymorphic object typically requires shared_ptrs.

We do not need to use a pointer to return a collection of objects from a function; a container that is a resource handle will do that simply and efficiently (§3.3.2).

5.3. Concurrency
Concurrency – the execution of several tasks simultaneously – is widely used to improve throughput (by using several processors for a single computation) or to improve responsiveness (by allowing one part of a program to progress while another is waiting for a response). All modern programming languages provide support for this. The support provided by the C++ standard library is a portable and type-safe variant of what has been used in C++ for more than 20 years and is almost universally supported by modern hardware. The standard-library support is primarily aimed at supporting systems-level concurrency rather than directly providing sophisticated higher-level concurrency models; those can be supplied as libraries built using the standard-library facilities.

The standard library directly supports concurrent execution of multiple threads in a single address space. To allow that, C++ provides a suitable memory model (§41.2) and a set of atomic operations (§41.3). However, most users will see concurrency only in terms of the standard library and libraries built on top of that. This section briefly gives examples of the main standard-library concurrency support facilities: threads, mutexes, lock() operations, packaged_tasks, and futures. These features are built directly upon what operating systems offer and do not incur performance penalties compared with those.

5.3.1. Tasks and threads
We call a computation that can potentially be executed concurrently with other computations a task. A thread is the system-level representation of a task in a program. A task to be executed concurrently with other tasks is launched by constructing a std::thread (found in <thread>) with the task as its argument. A task is a function or a function object:

Click here to view code image

void f();                 // function

struct F {                // function object
     void operator()();   // F's call operator (§3.4.3)
};

void user()
{
     thread t1 {f};       // f() executes in separate thread
     thread t2 {F()};     // F()() executes in separate thread

     t1.join();           // wait for t1
     t2.join();           // wait for t2
}
The join()s ensure that we don’t exit user() until the threads have completed. To “join” means to “wait for the thread to terminate.”

Threads of a program share a single address space. In this, threads differ from processes, which generally do not directly share data. Since threads share an address space, they can communicate through shared objects (§5.3.4). Such communication is typically controlled by locks or other mechanisms to prevent data races (uncontrolled concurrent access to a variable).

Programming concurrent tasks can be very tricky. Consider possible implementations of the tasks f (a function) and F (a function object):

Click here to view code image

void f() { cout << "Hello "; }

struct F {
     void operator()() { cout << "Parallel World!\n"; }
};
This is an example of a bad error: Here, f and F() each use the object cout without any form of synchronization. The resulting output would be unpredictable and could vary between different executions of the program because the order of execution of the individual operations in the two tasks is not defined. The program may produce “odd” output, such as

PaHerallllel o World!
When defining tasks of a concurrent program, our aim is to keep tasks completely separate except where they communicate in simple and obvious ways. The simplest way of thinking of a concurrent task is as a function that happens to run concurrently with its caller. For that to work, we just have to pass arguments, get a result back, and make sure that there is no use of shared data in between (no data races).

5.3.2. Passing Arguments
Typically, a task needs data to work upon. We can easily pass data (or pointers or references to the data) as arguments. Consider:

Click here to view code image

void f(vector<double>& v);     // function do something with v

struct F {                     // function object: do something with v
     vector<double>& v;
     F(vector<double>& vv) :v{vv} { }
     void operator()();        // application operator; §3.4.3
};

int main()
{
     vector<double> some_vec {1,2,3,4,5,6,7,8,9};
     vector<double> vec2 {10,11,12,13,14};

     thread t1 {f,ref(some_vec)};   // f(some_vec) executes in a separate thread
     thread t2 {F{vec2}};      // F(vec2)() executes in a separate thread

     t1.join();
     t2.join();
}
Obviously, F{vec2} saves a reference to the argument vector in F. Hopefully no other task accesses vec2 while F is executing. Passing vec2 by value would eliminate that risk.

The initialization with {f,ref(some_vec)} uses a thread variadic template constructor that can accept an arbitrary sequence of arguments (§28.6). The ref() is a type function from <functional> that unfortunately is needed to tell the variadic template to treat some_vec as a reference, rather than as an object (§33.5.1). The compiler checks that the first argument can be invoked given the following arguments and builds the necessary function object to pass to the thread. Thus, if f() and F::operator()() perform the same algorithm, the handling of the two tasks are roughly equivalent: in both cases, a function object is constructed for the thread to execute.

5.3.3. Returning Results
In the example in §5.3.2, I pass the arguments by non-const reference. I only do that if I expect the task to modify the value of the data referred to (§7.7). That’s a somewhat sneaky, but not uncommon, way of returning a result. A less obscure technique is to pass the input data by const reference and to pass the location of a place to deposit the result as a separate argument:

Click here to view code image

void f(const vector<double>& v, double* res); // take input from v; place result in *res

class F {
public:
     F(const vector<double>& vv, double* p) :v{vv}, res{p} { }
     void operator()();           // place result in *res
private:
     const vector<double>& v;          // source of input
     double* res;                // target for output
};

int main()
{
     vector<double> some_vec;
     vector<double> vec2;
      //...

     double res1;
     double res2;

     thread t1 {f,some_vec,&res1};  // f(ctrf(some_vec),&res1) executes in a separate thread
     thread t2 {F{vec2,&res2}};           // F{vec2,&res2}() executes in a separate thread

     t1.join();
     t2.join();

     cout << res1 << ' ' << res2 << '\n';
}
This works and the technique is very common, but I don’t consider returning results through arguments particularly elegant, so I return to this topic in §5.3.5.1.

5.3.4. Sharing Data
Sometimes tasks need to share data. In that case, the access has to be synchronized so that at most one task at a time has access. Experienced programmers will recognize this as a simplification (e.g., there is no problem with many tasks simultaneously reading immutable data), but consider how to ensure that at most one task at a time has access to a given set of objects.

The fundamental element of the solution is a mutex, a “mutual exclusion object.” A thread acquires a mutex using a lock() operation:

Click here to view code image

mutex m;  // controlling mutex
int sh;   // shared data

void f()
{
     unique_lock<mutex> lck {m};  // acquire mutex
     sh += 7;                     // manipulate shared data
}     // release mutex implicitly
The unique_lock’s constructor acquires the mutex (through a call m.lock()). If another thread has already acquired the mutex, the thread waits (“blocks”) until the other thread completes its access. Once a thread has completed its access to the shared data, the unique_lock releases the mutex (with a call m.unlock()). The mutual exclusion and locking facilities are found in <mutex>.

The correspondence between the shared data and a mutex is conventional: the programmer simply has to know which mutex is supposed to correspond to which data. Obviously, this is error-prone, and equally obviously we try to make the correspondence clear through various language means. For example:

class Record {
public:
     mutex rm;
      //...
};
It doesn’t take a genius to guess that for a Record called rec, rec.rm is a mutex that you are supposed to acquire before accessing the other data of rec, though a comment or a better name might have helped a reader.

It is not uncommon to need to simultaneously access several resources to perform some action. This can lead to deadlock. For example, if thread1 acquires mutex1 and then tries to acquire mutex2 while thread2 acquires mutex2 and then tries to acquire mutex1, then neither task will ever proceed further. The standard library offers help in the form of an operation for acquiring several locks simultaneously:

Click here to view code image

void f()
{
      //...
     unique_lock<mutex> lck1 {m1,defer_lock};     // defer_lock: don't yet try to acquire the mutex
     unique_lock<mutex> lck2 {m2,defer_lock};
     unique_lock<mutex> lck3 {m3,defer_lock};
      //...
     lock(lck1,lck2,lck3);                        // acquire all three locks
      //... manipulate shared data ...
}  // implicitly release all mutexes
This lock() will proceed only after acquiring all its mutex arguments and will never block (“go to sleep”) while holding a mutex. The destructors for the individual unique_locks ensure that the mutexes are released when a thread leaves the scope.

Communicating through shared data is pretty low level. In particular, the programmer has to devise ways of knowing what work has and has not been done by various tasks. In that regard, use of shared data is inferior to the notion of call and return. On the other hand, some people are convinced that sharing must be more efficient than copying arguments and returns. That can indeed be so when large amounts of data are involved, but locking and unlocking are relatively expensive operations. On the other hand, modern machines are very good at copying data, especially compact data, such as vector elements. So don’t choose shared data for communication because of “efficiency” without thought and preferably not without measurement.

5.3.4.1. Waiting for Events
Sometimes, a thread needs to wait for some kind of external event, such as another thread completing a task or a certain amount of time having passed. The simplest “event” is simply time passing. Consider:

Click here to view code image

using namespace std::chrono;  // see §35.2

auto t0 = high_resolution_clock::now();
this_thread::sleep_for(milliseconds{20});
auto t1 = high_resolution_clock::now();
cout << duration_cast<nanoseconds>(t1–t0).count() << " nanoseconds passed\n";
Note that I didn’t even have to launch a thread; by default, this_thread refers to the one and only thread (§42.2.6).

I used duration_cast to adjust the clock’s units to the nanoseconds I wanted. See §5.4.1 and §35.2 before trying anything more complicated than this with time. The time facilities are found in <chrono>.

The basic support for communicating using external events is provided by condition_variables found in <condition_variable> (§42.3.4). A condition_variable is a mechanism allowing one thread to wait for another. In particular, it allows a thread to wait for some condition (often called an event) to occur as the result of work done by other threads.

Consider the classical example of two threads communicating by passing messages through a queue. For simplicity, I declare the queue and the mechanism for avoiding race conditions on that queue global to the producer and consumer:

Click here to view code image

class Message {    // object to be communicated
      //...
};

queue<Message> mqueue;           // the queue of messages
condition_variable mcond;        // the variable communicating events
mutex mmutex;                    // the locking mechanism
The types queue, condition_variable, and mutex are provided by the standard library.

The consumer() reads and processes Messages:

Click here to view code image

void consumer()
{
     while(true) {
          unique_lock<mutex> lck{mmutex};              // acquire mmutex
          mcond.wait(lck,[this]{ return !mqueue.empty(); });          // release lck and wait until not empty;
                                                       // re-acquire lck upon wakeup
          auto m = mqueue.front();                     // get the message
          mqueue.pop();
          lck.unlock();                                // release lck
           //... process m ...
     }
}
Here, I explicitly protect the operations on the queue and on the condition_variable with a unique_lock on the mutex. Waiting on condition_variable releases its lock argument until the wait is over (so that the queue is non-empty) and then reacquires it.

The corresponding producer looks like this:

Click here to view code image

void producer()
{
     while(true) {
          Message m;
           //... fill the message ...
          unique_lock<mutex> lck {mmutex};   // protect operations
          mqueue.push(m);
          mcond.notify_one();                // notify
     }                                       // release lock (at end of scope)
}
Using condition_variables supports many forms of elegant and efficient sharing, but can be rather tricky (§42.3.4).

5.3.5. Communicating Tasks
The standard library provides a few facilities to allow programmers to operate at the conceptual level of tasks (work to potentially be done concurrently) rather than directly at the lower level of threads and locks:

[1] future and promise for returning a value from a task spawned on a separate thread

[2] packaged_task to help launch tasks and connect up the mechanisms for returning a result

[3] async() for launching of a task in a manner very similar to calling a function.

These facilities are found in <future>.

5.3.5.1. future and promise
The important point about future and promise is that they enable a transfer of a value between two tasks without explicit use of a lock; “the system” implements the transfer efficiently. The basic idea is simple: When a task wants to pass a value to another, it puts the value into a promise. Somehow, the implementation makes that value appear in the corresponding future, from which it can be read (typically by the launcher of the task). We can represent this graphically:



If we have a future<X> called fx, we can get() a value of type X from it:

X v = fx.get();  // if necessary, wait for the value to get computed
If the value isn’t there yet, our thread is blocked until it arrives. If the value couldn’t be computed, get() might throw an exception (from the system or transmitted from the task from which we were trying to get() the value).

The main purpose of a promise is to provide simple “put” operations (called set_value() and set_exception()) to match future’s get(). The names “future” and “promise” are historical; please don’t blame or credit me. They are yet another fertile source of puns.

If you have a promise and need to send a result of type X to a future, you can do one of two things: pass a value or pass an exception. For example:

Click here to view code image

void f(promise<X>& px)  // a task: place the result in px
{
      //...
     try {
          X res;
           //... compute a value for res ...
          px.set_value(res);
     }
     catch (...) {       // oops: couldn't compute res
           // pass the exception to the future's thread:
          px.set_exception(current_exception());
     }
}
The current_exception() refers to the caught exception (§30.4.1.2).

To deal with an exception transmitted through a future, the caller of get() must be prepared to catch it somewhere. For example:

Click here to view code image

void g(future<X>& fx)            // a task: get the result from fx
{
      //...
     try {
          X v = fx.get();   // if necessary, wait for the value to get computed
           //... use v ...
     }
     catch (...) {          // oops: someone couldn't compute v
           //... handle error ...
     }
}
5.3.5.2. packaged_task
How do we get a future into the task that needs a result and the corresponding promise into the thread that should produce that result? The packaged_task type is provided to simplify setting up tasks connected with futures and promises to be run on threads. A packaged_task provides wrapper code to put the return value or exception from the task into a promise (like the code shown in §5.3.5.1). If you ask it by calling get_future, a packaged_task will give you the future corresponding to its promise. For example, we can set up two tasks to each add half of the elements of a vector<double> using the standard-library accumulate() (§3.4.2, §40.6):

Click here to view code image

double accum(double* beg, double * end, double init)
      // compute the sum of [beg:end) starting with the initial value init
{
     return accumulate(beg,end,init);
}

double comp2(vector<double>& v)
{
     using Task_type = double(double*,double*,double);    // type of task

     packaged_task<Task_type> pt0 {accum};                // package the task (i.e., accum)
     packaged_task<Task_type> pt1 {accum};

     future<double> f0 {pt0.get_future()};                // get hold of pt0's future
     future<double> f1 {pt1.get_future()};                // get hold of pt1's future

     double* first = &v[0];
     thread t1 {move(pt0),first,first+v.size()/2,0};      // start a thread for pt0
     thread t2 {move(pt1),first+v.size()/2,first+v.size(),0};                                                    // start a thread for pt1

      //...

     return f0.get()+f1.get();        // get the results
}
The packaged_task template takes the type of the task as its template argument (here Task_type, an alias for double(double*,double*,double)) and the task as its constructor argument (here, accum). The move() operations are needed because a packaged_task cannot be copied.

Please note the absence of explicit mention of locks in this code: we are able to concentrate on tasks to be done, rather than on the mechanisms used to manage their communication. The two tasks will be run on separate threads and thus potentially in parallel.

5.3.5.3. async()
The line of thinking I have pursued in this chapter is the one I believe to be the simplest yet still among the most powerful: Treat a task as a function that may happen to run concurrently with other tasks. It is far from the only model supported by the C++ standard library, but it serves well for a wide range of needs. More subtle and tricky models, e.g., styles of programming relying on shared memory, can be used as needed.

To launch tasks to potentially run asynchronously, we can use async():

Click here to view code image

double comp4(vector<double>& v)
     // spawn many tasks if v is large enough
{
    if (v.size()<10000) return accum(v.begin(),v.end(),0.0);

    auto v0 = &v[0];
    auto sz = v.size();

    auto f0 = async(accum,v0,v0+sz/4,0.0);          // first quarter
    auto f1 = async(accum,v0+sz/4,v0+sz/2,0.0);     // second quarter
    auto f2 = async(accum,v0+sz/2,v0+sz*3/4,0.0);   // third quarter
    auto f3 = async(accum,v0+sz*3/4,v0+sz,0.0);     // fourth quarter

    return f0.get()+f1.get()+f2.get()+f3.get();   // collect and combine the results
}
Basically, async() separates the “call part” of a function call from the “get the result part,” and separates both from the actual execution of the task. Using async(), you don’t have to think about threads and locks. Instead, you think just in terms of tasks that potentially compute their results asynchronously. There is an obvious limitation: Don’t even think of using async() for tasks that share resources needing locking – with async() you don’t even know how many threads will be used because that’s up to async() to decide based on what it knows about the system resources available at the time of a call. For example, async() may check whether any idle cores (processors) are available before deciding how many threads to use.

Please note that async() is not just a mechanism specialized for parallel computation for increased performance. For example, it can also be used to spawn a task for getting information from a user, leaving the “main program” active with something else (§42.4.6).

5.4. Small Utility Components
Not all standard-library components come as part of obviously labeled facilities, such as “containers” or “I/O.” This section gives a few examples of small, widely useful components:

• clock and duration for measuring time.

• Type functions, such as iterator_traits and is_arithmetic, for gaining information about types.

• pair and tuple for representing small, potentially heterogeneous sets of values.

The point here is that a function or a type need not be complicated or closely tied to a mass of other functions and types to be useful. Such library components mostly act as building blocks for more powerful library facilities, including other components of the standard library.

5.4.1. Time
The standard library provides facilities for dealing with time. For example, here is the basic way of timing something:

Click here to view code image

using namespace std::chrono;       // see §35.2

auto t0 = high_resolution_clock::now();
do_work();
auto t1 = high_resolution_clock::now();
cout << duration_cast<milliseconds>(t1–t0).count() << "msec\n";
The clock returns a time_point (a point in time). Subtracting two time_points gives a duration (a period of time). Various clocks give their results in various units of time (the clock I used measures nanoseconds), so it is usually a good idea to convert a duration into a known unit. That’s what duration_cast does.

The standard-library facilities for dealing with time are found in the subnamespace std::chrono in <chrono> (§35.2).

Don’t make statements about “efficiency” of code without first doing time measurements. Guesses about performance are most unreliable.

5.4.2. Type Functions
A type function is a function that is evaluated at compile-time given a type as its argument or returning a type. The standard library provides a variety of type functions to help library implementers and programmers in general to write code that take advantage of aspects of the language, the standard library, and code in general.

For numerical types, numeric_limits from <limits> presents a variety of useful information (§5.6.5). For example:

Click here to view code image

constexpr float min = numeric_limits<float>::min();     // smallest positive float (§40.2)
Similarly, object sizes can be found by the built-in sizeof operator (§2.2.2). For example:

Click here to view code image

constexpr int szi = sizeof(int);  // the number of bytes in an int (assuming a char fits into a byte)
Such type functions are part of C++’s mechanisms for compile-time computation that allow tighter type checking and better performance than would otherwise have been possible. Use of such features is often called metaprogramming or (when templates are involved) template metaprogramming (Chapter 28). Here, I just present two facilities provided by the standard library: iterator_traits (§5.4.2.1) and type predicates (§5.4.2.2).

5.4.2.1. iterator_traits
The standard-library sort() takes a pair of iterators supposed to define a sequence (§4.5). Furthermore, those iterators must offer random access to that sequence, that is, they must be random-access iterators. Some containers, such as forward_list, do not offer that. In particular, a forward_list is a singly-linked list so subscripting would be expensive and there is no reasonable way to refer back to a previous element. However, like most containers, forward_list offers forward iterators that can be used to traverse the sequence by algorithms and for-statements (§33.1.1).

The standard library provides a mechanism, iterator_traits that allows us to check which kind of iterator is supported. Given that, we can improve the range sort() from §4.5.6 to accept either a vector or a forward_list. For example:

Click here to view code image

void test(vector<string>& v, forward_list<int>& lst)
{
     sort(v);     // sort the vector
     sort(lst);   // sort the singly-linked list
}
The techniques needed to make that work are generally useful.

First, I write two helper functions that take an extra argument indicating whether they are to be used for random-access iterators or forward iterators. The version taking random-access iterator arguments is trivial:

Click here to view code image

template<typename Ran>                                               // for random-access iterators
void sort_helper(Ran beg, Ran end, random_access_iterator_tag)       // we can subscript into [beg:end)
{
     sort(beg,end);      // just sort it
}
The version for forward iterators simply copies the list into a vector, sorts, and copies back:

Click here to view code image

template<typename For>                                        // for forward iterators
void sort_helper(For beg, For end, forward_iterator_tag)      // we can traverse [beg:end)
{
     vector<Value_type<For>> v {beg,end};     // initialize a vector from [beg:end)
     sort(v.begin(),v.end());
     copy(v.begin(),v.end(),beg);            // copy the elements back
}
Value_type<For>> is the type of For’s elements, called its value type. Every standard-library iterator has a member value_type. I get the Value_type<For>> notation by defining a type alias (§3.4.5):

Click here to view code image

template<typename C>
    using Value_type = typename C::value_type; // C’s value type
Thus, v is a vector<X> where X is the element type of the input sequence.

The real “type magic” is in the selection of helper functions:

Click here to view code image

template<typename C>
void sort(C& c)
{
     using Iter = Iterator_type<C>;
     sort_helper(c.begin(),c.end(),Iterator_category<Iter>{});
}
Here, I use two type functions: Iterator_type<C> returns the iterator type of C (that is, C::iterator) and then Iterator_category<Iter>{} constructs a “tag” value indicating the kind of iterator provided:

• std::random_access_iterator_tag if C’s iterator supports random access.

• std::forward_iterator_tag if C’s iterator supports forward iteration.

Given that, we can select between the two sorting algorithms at compile time. This technique, called tag dispatch is one of several used in the standard library and elsewhere to improve flexibility and performance.

The standard-library support for techniques for using iterators, such as tag dispatch, comes in the form of a simple class template iterator_traits from <iterator> (§33.1.3). This allows simple definitions of the type functions used in sort():

Click here to view code image

template<typename C>
    using Iterator_type = typename C::iterator;    // C's iterator type
template<typename Iter>
    using Iterator_category = typename std::iterator_traits<Iter>::iterator_category;   // Iter's category
If you don’t want to know what kind of “compile-time type magic” is used to provide the standard-library features, you are free to ignore facilities such as iterator_traits. But then you can’t use the techniques they support to improve your own code.

5.4.2.2. Type Predicates
A standard-library type predicate is a simple type function that answers a fundamental question about types. For example:

Click here to view code image

bool b1 = Is_arithmetic<int>();      // yes, int is an arithmetic type
bool b2 = Is_arithmetic<string>();   // no, std::string is not an arithmetic type
These predicates are found in <type_traits> and described in §35.4.1. Other examples are is_class, is_pod, is_literal_type, has_virtual_destructor, and is_base_of. They are most useful when we write templates. For example:

Click here to view code image

template<typename Scalar>
class complex {
     Scalar re, im;
public:
     static_assert(Is_arithmetic<Scalar>(), "Sorry, I only support complex of arithmetic types"); 
      //...
};
To improve readability compared to using the standard library directly, I defined a type function:

Click here to view code image

template<typename T>
constexpr bool Is_arithmetic()
{
     return std::is_arithmetic<T>::value ;
}
Older programs use ::value directly instead of (), but I consider that quite ugly and it exposes implementation details.

5.4.3. pair and tuple
Often, we need some data that is just data; that is, a collection of values, rather than an object of a class with a well-defined semantics and an invariant for its value (§2.4.3.2, §13.4). In such cases, we could define a simple struct with an appropriate set of appropriately named members. Alternatively, we could let the standard library write the definition for us. For example, the standard-library algorithm equal_range (§32.6.1) returns a pair of iterators specifying a sub-sequence meeting a predicate:

Click here to view code image

template<typename Forward_iterator, typename T, typename Compare>
    pair<Forward_iterator,Forward_iterator>
    equal_range(Forward_iterator first, Forward_iterator last, const T& val, Compare cmp);
Given a sorted sequence [first:last), equal_range() will return the pair representing the subsequence that matches the predicate cmp. We can use that to search in a sorted sequence of Records:

Click here to view code image

auto rec_lt = [](const Record& r1, const Record& r2) { return r1.name<r2.name;}; // compare names

void f(const vector<Record>& v)      // assume that v is sorted on its "name" field
{
     auto er = equal_range(v.begin(),v.end(),Record{"Reg"},rec_lt);
     for (auto p = er.first; p!=er.second; ++p)     // print all equal records
           cout << *p;                              // assume that << is defined for Record
}
The first member of a pair is called first and the second member is called second. This naming is not particularly creative and may look a bit odd at first, but such consistent naming is a boon when we want to write generic code.

The standard-library pair (from <utility>) is quite frequently used in the standard library and elsewhere. A pair provides operators, such as =, ==, and <, if its elements do. The make_pair() function makes it easy to create a pair without explicitly mentioning its type (§34.2.4.1). For example:

Click here to view code image

void f(vector<string>& v)
{
     auto pp = make_pair(v.begin(),2);     // pp is a pair<vector<string>::iterator,int>
      //...
}
If you need more than two elements (or less), you can use tuple (from <utility>; §34.2.4.2). A tuple is a heterogeneous sequence of elements; for example:

Click here to view code image

tuple<string,int,double> t2{"Sild",123, 3.14};  // the type is explicitly specified

auto t = make_tuple(string{"Herring"},10, 1.23);  // the type is deduced
                                                  // t is a tuple<string,int,double>

string s = get<0>(t);  // get first element of tuple: "Herring"
int x = get<1>(t);    // 10
double d = get<2>(t); // 1.23
The elements of a tuple are numbered (starting with zero), rather than named the way elements of pairs are (first and second). To get compile-time selection of elements, I must unfortunately use the ugly get<1>(t), rather than get(t,1) or t[1] (§28.5.2).

Like pairs, tuples can be assigned and compared if their elements can be.

A pair is common in interfaces because often we want to return more than one value, such as a result and an indicator of the quality of that result. It is less common to need three or more parts to a result, so tuples are more often found in the implementations of generic algorithms.

5.5. Regular Expressions
Regular expressions are a powerful tool for text processing. They provide a way to simply and tersely describe patterns in text (e.g., a U.S. ZIP code such as TX 77845, or an ISO-style date, such as 2009–06–07) and to efficiently find such patterns in text. In <regex>, the standard library provides support for regular expressions in the form of the std::regex class and its supporting functions. To give a taste of the style of the regex library, let us define and print a pattern:

Click here to view code image

regex pat (R"(\w{2}\s*\d{5}(–\d{4})?)");  // ZIP code pattern: XXddddd-dddd and variants
People who have used regular expressions in just about any language will find \w{2}\s*\d{5}(–\d{4})? familiar. It specifies a pattern starting with two letters \w{2} optionally followed by some space \s* followed by five digits \d{5} and optionally followed by a dash and four digits –\d{4}. If you are not familiar with regular expressions, this may be a good time to learn about them ([Stroustrup,2009], [Maddock,2009], [Friedl,1997]). Regular expressions are summarized in §37.1.1.

To express the pattern, I use a raw string literal (§7.3.2.1) starting with R"( and terminated by )". This allows backslashes and quotes to be used directly in the string.

The simplest way of using a pattern is to search for it in a stream:

Click here to view code image

int lineno = 0;
for (string line; getline(cin,line); ) {           // read into line buffer
      ++lineno;
      smatch matches;                              // matched strings go here
      if (regex_search(line,matches,pat))          // search for pat in line
            cout << lineno << ": " << matches[0] << '\n';
}
The regex_search(line,matches,pat) searches the line for anything that matches the regular expression stored in pat and if it finds any matches, it stores them in matches. If no match was found, regex_search(line,matches,pat) returns false. The matches variable is of type smatch. The “s” stands for “sub” or “string” and an smatch is a vector of sub-matches of type string. The first element, here matches[0], is the complete match.

For a more complete description see Chapter 37.

5.6. Math
C++ wasn’t designed primarily with numerical computation in mind. However, C++ is heavily used for numerical computation and the standard library reflects that.

5.6.1. Mathematical Functions and Algorithms
In <cmath>, we find the “usual mathematical functions,” such as sqrt(), log(), and sin() for arguments of type float, double, and long double (§40.3). Complex number versions of these functions are found in <complex> (§40.4).

In <numeric>, we find a small set of generalized numerical algorithms, such as accumulate(). For example:

Click here to view code image

void f()
{
     list<double> lst {1, 2, 3, 4, 5, 9999.99999};
     auto s = accumulate(lst.begin(),lst.end(),0.0);  // calculate the sum
     cout << s << '\n';                               // print 10014.9999
}
These algorithms work for every standard-library sequence and can have operations supplied as arguments (§40.6).

5.6.2. Complex Numbers
The standard library supports a family of complex number types along the lines of the complex class described in §2.3. To support complex numbers where the scalars are single-precision floating-point numbers (floats), double-precision floating-point numbers (doubles), etc., the standard library complex is a template:

Click here to view code image

template<typename Scalar>
class complex {
public:
     complex(const Scalar& re ={}, const Scalar& im ={});
      //...
};
The usual arithmetic operations and the most common mathematical functions are supported for complex numbers. For example:

Click here to view code image

void f(complex<float> fl, complex<double> db)
{
     complex<long double> ld {fl+sqrt(db)};
     db += fl*3;
     fl = pow(1/fl,2);
      //...
}
The sqrt() and pow() (exponentiation) functions are among the usual mathematical functions defined in <complex>. For more details, see §40.4.

5.6.3. Random Numbers
Random numbers are useful in many contexts, such as testing, games, simulation, and security. The diversity of application areas is reflected in the wide selection of random number generators provided by the standard library in <random>. A random number generator consists of two parts:

[1] an engine that produces a sequence of random or pseudo-random values.

[2] a distribution that maps those values into a mathematical distribution in a range.

Examples of distributions are uniform_int_distribution (where all integers produced are equally likely), normal_distribution (“the bell curve”), and exponential_distribution (exponential growth); each for some specified range. For example:

Click here to view code image

using my_engine = default_random_engine;             // type of engine
using my_distribution = uniform_int_distribution<>;  // type of distribution

my_engine re {};                                     // the default engine
my_distribution one_to_six {1,6};                    // distribution that maps to the ints 1..6
auto die = bind(one_to_six,re);                      // make a generator

int x = die();                                       // roll the die: x becomes a value in [1:6]
The standard-library function bind() makes a function object that will invoke its first argument (here, one_to_six) given its second argument (here, re) as its argument (§33.5.1). Thus a call die() is equivalent to a call one_to_six(re).

Thanks to its uncompromising attention to generality and performance one expert has deemed the standard-library random number component “what every random number library wants to be when it grows up.” However, it can hardly be deemed “novice friendly.” The using statements makes what is being done a bit more obvious. Instead, I could just have written:

auto die = bind(uniform_int_distribution<>{1,6}, default_random_engine{});
Which version is the more readable depends entirely on the context and the reader.

For novices (of any background) the fully general interface to the random number library can be a serious obstacle. A simple uniform random number generator is often sufficient to get started. For example:

Click here to view code image

Rand_int rnd {1,10};                // make a random number generator for [1:10]
int x = rnd();       // x is a number in [1:10]
So, how could we get that? We have to get something like die() inside a class Rand_int:

Click here to view code image

class Rand_int {
public:
     Rand_int(int low, int high) :dist{low,high} { }
     int operator()() { return dist(re); }      // draw an int
private:
     default_random_engine re;
     uniform_int_distribution<> dist;
};
That definition is still “expert level,” but the use of Rand_int() is manageable in the first week of a C++ course for novices. For example:

Click here to view code image

int main()
{
     Rand_int rnd {0,4};  // make a uniform random number generator

     vector<int> histogram(5);              // make a vector of size 5
     for (int i=0; i!=200; ++i)
           ++histogram[rnd()];              // fill histogram with the frequencies of numbers [0:4]

     for (int i = 0; i!=histogram.size(); ++i) {   // write out a bar graph
           cout << i << '\t';
           for (int j=0; j!=mn[i]; ++j) cout << '*';
           cout << endl;
     }
}
The output is a (reassuringly boring) uniform distribution (with reasonable statistical variation):

Click here to view code image

0   ********************************************
1   ******************************************
2   *******************************
3   ******************************************
4   *****************************************
There is no standard graphics library for C++, so I use “ASCII graphics.” Obviously, there are lots of open source and commercial graphics and GUI libraries for C++, but in this book I’ll restrict myself to ISO standard facilities.

For more information about random numbers, see §40.7.

5.6.4. Vector Arithmetic
The vector described in §4.4.1 was designed to be a general mechanism for holding values, to be flexible, and to fit into the architecture of containers, iterators, and algorithms. However, it does not support mathematical vector operations. Adding such operations to vector would be easy, but its generality and flexibility precludes optimizations that are often considered essential for serious numerical work. Consequently, the standard library provides (in <valarray>) a vector-like template, called valarray, that is less general and more amenable to optimization for numerical computation:

template<typename T>
class valarray {
     //...
};
The usual arithmetic operations and the most common mathematical functions are supported for valarrays. For example:

Click here to view code image

void f(valarray<double>& a1, valarray<double>& a2)
{
     valarray<double> a = a1*3.14+a2/a1;       // numeric array operators *, +, /, and =
     a2 += a1*3.14;
     a = abs(a);
     double d = a2[7];
      //...
}
For more details, see §40.5. In particular, valarray offers stride access to help implement multidimensional computations.

5.6.5. Numeric Limits
In <limits>, the standard library provides classes that describe the properties of built-in types – such as the maximum exponent of a float or the number of bytes in an int; see §40.2. For example, we can assert that a char is signed:

Click here to view code image

static_assert(numeric_limits<char>::is_signed,"unsigned characters!");
static_assert(100000<numeric_limits<int>::max(),"small ints!");
Note that the second assert (only) works because numeric_limits<int>::max() is a constexpr function (§2.2.3, §10.4).

5.7. Advice
[1] Use resource handles to manage resources (RAII); §5.2.

[2] Use unique_ptr to refer to objects of polymorphic type; §5.2.1.

[3] Use shared_ptr to refer to shared objects; §5.2.1.

[4] Use type-safe mechanisms for concurrency; §5.3.

[5] Minimize the use of shared data; §5.3.4.

[6] Don’t choose shared data for communication because of “efficiency” without thought and preferably not without measurement; §5.3.4.

[7] Think in terms of concurrent tasks, rather than threads; §5.3.5.

[8] A library doesn’t have to be large or complicated to be useful; §5.4.

[9] Time your programs before making claims about efficiency; §5.4.1.

[10] You can write code to explicitly depend on properties of types; §5.4.2.

[11] Use regular expressions for simple pattern matching; §5.5.

[12] Don’t try to do serious numeric computation using only the language; use libraries; §5.6.

[13] Properties of numeric types are accessible through numeric_limits; §5.6.5.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


5. A Tour of C++: Concurrency and Utilities
Part II: Basic Facilities
6. Types and Declarations
47h 26m remaining
Part II: Basic Facilities
This part describes C++’s built-in types and the basic facilities for constructing programs out of them. The C subset of C++ is presented together with C++’s additional support for traditional styles of programming. It also discusses the basic facilities for composing a C++ program out of logical and physical parts.

Chapters

6 Types and Declarations

7 Pointers, Arrays, and References

8 Structures, Unions, and Enumerations

9 Statements

10 Expressions

11 Select Operations

12 Functions

13 Exception Handling

14 Namespaces

15 Source Files and Programs

“... I have long entertained a suspicion, with regard to the decisions of philosophers upon all subjects, and found in myself a greater inclination to dispute, than assent to their conclusions. There is one mistake, to which they seem liable, almost without exception; they confine too much their principles, and make no account of that vast variety, which nature has so much affected in all her operations. When a philosopher has once laid hold of a favourite principle, which perhaps accounts for many natural effects, he extends the same principle over the whole creation, and reduces to it every phænomenon, though by the most violent and absurd reasoning. ...”

– David Hume,
Essays, Moral, Political, and Literary. PART I. (1752)


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


Part II: Basic Facilities
6. Types and Declarations
7. Pointers, Arrays, and References
47h 26m remaining
6. Types and Declarations
Perfection is achieved only on the point of collapse.

– C. N. Parkinson

• The ISO C++ Standard

Implementations; The Basic Source Character Set

• Types

Fundamental Types; Booleans; Character Types; Integer Types; Floating-Point Types; Prefixes and Suffixes; void; Sizes; Alignment

• Declarations

The Structure of Declarations; Declaring Multiple Names; Names; Scope; Initialization; Deducing a Type: auto and decltype()

• Objects and Values

Lvalues and Rvalues; Lifetimes of Objects

• Type Aliases

• Advice

6.1. The ISO C++ Standard
The C++ language and standard library are defined by their ISO standard: ISO/IEC 14882:2011. In this book, references to the standard are of the form §iso.23.3.6.1. In cases where the text of this book is considered imprecise, incomplete, or possibly wrong, consult the standard. But don’t expect the standard to be a tutorial or to be easily accessible by non-experts.

Strictly adhering to the C++ language and library standard doesn’t by itself guarantee good code or even portable code. The standard doesn’t say whether a piece of code is good or bad; it simply says what a programmer can and cannot rely on from an implementation. It is easy to write perfectly awful standard-conforming programs, and most real-world programs rely on features that the standard does not guarantee to be portable. They do so to access system interfaces and hardware features that cannot be expressed directly in C++ or require reliance on specific implementation details.

Many important things are deemed implementation-defined by the standard. This means that each implementation must provide a specific, well-defined behavior for a construct and that behavior must be documented. For example:

Click here to view code image

unsigned char c1 = 64;        // well defined: a char has at least 8 bits and can always hold 64
unsigned char c2 = 1256;      // implementation-defined: truncation if a char has only 8 bits
The initialization of c1 is well defined because a char must be at least 8 bits. However, the behavior of the initialization of c2 is implementation-defined because the number of bits in a char is implementation-defined. If the char has only 8 bits, the value 1256 will be truncated to 232 (§10.5.2.1). Most implementation-defined features relate to differences in the hardware used to run a program.

Other behaviors are unspecified; that is, a range of possible behaviors are acceptable, but the implementer is not obliged to specify which actually occur. Usually, the reason for deeming something unspecified is that the exact behavior is unpredictable for fundamental reasons. For example, the exact value returned by new is unspecified. So is the value of a variable assigned to from two threads unless some synchronization mechanism has been employed to prevent a data race (§41.2).

When writing real-world programs, it is usually necessary to rely on implementation-defined behavior. Such behavior is the price we pay for the ability to operate effectively on a large range of systems. For example, C++ would have been much simpler if all characters had been 8 bits and all pointers 32 bits. However, 16-bit and 32-bit character sets are not uncommon, and machines with 16-bit and 64-bit pointers are in wide use.

To maximize portability, it is wise to be explicit about what implementation-defined features we rely on and to isolate the more subtle examples in clearly marked sections of a program. A typical example of this practice is to present all dependencies on hardware sizes in the form of constants and type definitions in some header file. To support such techniques, the standard library provides numeric_limits (§40.2). Many assumptions about implementation-defined features can be checked by stating them as static assertions (§2.4.3.3). For example:

static_assert(4<=sizeof(int),"sizeof(int) too small");
Undefined behavior is nastier. A construct is deemed undefined by the standard if no reasonable behavior is required by an implementation. Typically, some obvious implementation technique will cause a program using an undefined feature to behave very badly. For example:

const int size = 4*1024;
char page[size];

void f()
{
     page[size+size] = 7;  // undefined
}
Plausible outcomes of this code fragment include overwriting unrelated data and triggering a hardware error/exception. An implementation is not required to choose among plausible outcomes. Where powerful optimizers are used, the actual effects of undefined behavior can become quite unpredictable. If a set of plausible and easily implementable alternatives exist, a feature is deemed unspecified or implementation-defined rather than undefined.

It is worth spending considerable time and effort to ensure that a program does not use something deemed unspecified or undefined by the standard. In many cases, tools exist to help do this.

6.1.1. Implementations
A C++ implementation can be either hosted or freestanding (§iso.17.6.1.3). A hosted implementation includes all the standard-library facilities as described in the standard (§30.2) and in this book. A freestanding implementation may provide fewer standard-library facilities, as long as the following are provided:

Freestanding Implementation Headers

Types

<cstddef>

§10.3.1

Implementation properties

<cfloat> <limits> <climits>

§40.2

Integer types

<cstdint>

§43.7

Start and termination

<cstdlib>

§43.7

Dynamic memory management

<new>

§11.2.3

Type identification

<typeinfo>

§22.5

Exception handling

<exception>

§30.4.1.1

Initializer lists

<initializer_list>

§30.3.1

Other run-time support

<cstdalign> <cstdarg> <cstdbool>

§12.2.4, §44.3.4

Type traits

<type_traits>

§35.4.1

Atomics

<atomic>

§41.3

Freestanding implementations are meant for code running with only the most minimal operating system support. Many implementations also provide a (non-standard) option for not using exceptions for really minimal, close-to-the-hardware, programs.

6.1.2. The Basic Source Character Set
The C++ standard and the examples in this book are written using the basic source character set consisting of the letters, digits, graphical characters, and whitespace characters from the U.S. variant of the international 7-bit character set ISO 646-1983 called ASCII (ANSI3.4-1968). This can cause problems for people who use C++ in an environment with a different character set:

• ASCII contains punctuation characters and operator symbols (such as ], {, and !) that are not available in some character sets.

• We need a notation for characters that do not have a convenient character representation (such as newline and “the character with value 17”).

• ASCII doesn’t contain characters (such as apn, ñ, þ, and Æ) that are used for writing languages other than English.

To use an extended character set for source code, a programming environment can map the extended character set into the basic source character set in one of several ways, for example, by using universal character names (§6.2.3.2).

6.2. Types
Consider:

x = y+f(2);
For this to make sense in a C++ program, the names x, y, and f must be suitably declared. That is, the programmer must specify that entities named x, y, and f exist and that they are of types for which = (assignment), + (addition), and () (function call), respectively, are meaningful.

Every name (identifier) in a C++ program has a type associated with it. This type determines what operations can be applied to the name (that is, to the entity referred to by the name) and how such operations are interpreted. For example:

Click here to view code image

float x;             // x is a floating-point variable
int y = 7;           // y is an integer variable with the initial value 7
float f(int);        // f is a function taking an argument of type int and returning a floating-point number
These declarations would make the example meaningful. Because y is declared to be an int, it can be assigned to, used as an operand for +, etc. On the other hand, f is declared to be a function that takes an int as its argument, so it can be called given the integer 2.

This chapter presents fundamental types (§6.2.1) and declarations (§6.3). Its examples just demonstrate language features; they are not intended to do anything useful. More extensive and realistic examples are saved for later chapters. This chapter simply provides the most basic elements from which C++ programs are constructed. You must know these elements, plus the terminology and simple syntax that go with them, in order to complete a real project in C++ and especially to read code written by others. However, a thorough understanding of every detail mentioned in this chapter is not a requirement for understanding the following chapters. Consequently, you may prefer to skim through this chapter, observing the major concepts, and return later as the need for understanding more details arises.

6.2.1. Fundamental Types
C++ has a set of fundamental types corresponding to the most common basic storage units of a computer and the most common ways of using them to hold data:

§6.2.2 A Boolean type (bool)

§6.2.3 Character types (such as char and wchar_t)

§6.2.4 Integer types (such as int and long long)

§6.2.5 Floating-point types (such as double and long double)

§6.2.7 A type, void, used to signify the absence of information

From these types, we can construct other types using declarator operators:

§7.2 Pointer types (such as int*)

§7.3 Array types (such as char[])

§7.7 Reference types (such as double& and vector<int>&&)

Also, a user can define additional types:

§8.2 Data structures and classes (Chapter 16)

§8.4 Enumeration types for representing specific sets of values (enum and enum class)

The Boolean, character, and integer types are collectively called integral types. The integral and floating-point types are collectively called arithmetic types. Enumerations and classes (Chapter 16) are called user-defined types because they must be defined by users rather than being available for use without previous declaration, the way fundamental types are. In contrast, fundamental types, pointers, and references are collectively referred to as built-in types. The standard library provides many user-defined types (Chapter 4, Chapter 5).

The integral and floating-point types are provided in a variety of sizes to give the programmer a choice of the amount of storage consumed, the precision, and the range available for computations (§6.2.8). The assumption is that a computer provides bytes for holding characters, words for holding and computing integer values, some entity most suitable for floating-point computation, and addresses for referring to those entities. The C++ fundamental types together with pointers and arrays present these machine-level notions to the programmer in a reasonably implementation-independent manner.

For most applications, we could use bool for logical values, char for characters, int for integer values, and double for floating-point values. The remaining fundamental types are variations for optimizations, special needs, and compatibility that are best ignored until such needs arise.

6.2.2. Booleans
A Boolean, bool, can have one of the two values true or false. A Boolean is used to express the results of logical operations. For example:

void f(int a, int b)
{
     bool b1 {a==b};
      //...
}
If a and b have the same value, b1 becomes true; otherwise, b1 becomes false.

A common use of bool is as the type of the result of a function that tests some condition (a predicate). For example:

Click here to view code image

bool is_open(File*);

bool greater(int a, int b) { return a>b; }
By definition, true has the value 1 when converted to an integer and false has the value 0. Conversely, integers can be implicitly converted to bool values: nonzero integers convert to true and 0 converts to false. For example:

Click here to view code image

bool b1 = 7;       //7!=0, so b becomes true
bool b2 {7};       // error: narrowing (§2.2.2, §10.5)

int i1 = true;     // i1 becomes 1
int i2 {true};     // i2 becomes 1
If you prefer to use the {}-initializer syntax to prevent narrowing, yet still want to convert an int to a bool, you can be explicit:

void f(int i)
{
     bool b {i!=0};
      //...
}
In arithmetic and bitwise logical expressions, bools are converted to ints; integer arithmetic and logical operations are performed on the converted values. If the result needs to be converted back to bool, a 0 is converted to false and a nonzero value is converted to true. For example:

Click here to view code image

bool a = true;
bool b = true;

bool x = a+b;    // a+b is 2, so x becomes true
bool y = a||b;   // a||b is true, so y becomes true ("||" means "or")
bool z = a–b;    // a-b is 0, so z becomes false
A pointer can be implicitly converted to a bool (§10.5.2.5). A non-null pointer converts to true; pointers with the value nullptr convert to false. For example:

Click here to view code image

void g(int* p)
{
     bool b = p;               // narrows to true or false
     bool b2 {p!=nullptr};     // explicit test against nullptr

     if (p) {   // equivalent to p!=nullptr
            //...
     }
}
I prefer if (p) over if (p!=nullptr) because it more directly expresses the notion “if p is valid” and also because it is shorter. The shorter form leaves fewer opportunities for mistakes.

6.2.3. Character Types
There are many character sets and character set encodings in use. C++ provides a variety of character types that reflect that – often bewildering – variety:

• char: The default character type, used for program text. A char is used for the implementation’s character set and is usually 8 bits.

• signed char: Like char, but guaranteed to be signed, that is, capable of holding both positive and negative values.

• unsigned char: Like char, but guaranteed to be unsigned.

• wchar_t: Provided to hold characters of a larger character set such as Unicode (see §7.3.2.2). The size of wchar_t is implementation-defined and large enough to hold the largest character set supported by the implementation’s locale (Chapter 39).

• char16_t: A type for holding 16-bit character sets, such as UTF-16.

• char32_t: A type for holding 32-bit character sets, such as UTF-32.

These are six distinct types (despite the fact that the _t suffix is often used to denote aliases; §6.5). On each implementation, the char type will be identical to that of either signed char or unsigned char, but these three names are still considered separate types.

A char variable can hold a character of the implementation’s character set. For example:

char ch = 'a';
Almost universally, a char has 8 bits so that it can hold one of 256 different values. Typically, the character set is a variant of ISO-646, for example ASCII, thus providing the characters appearing on your keyboard. Many problems arise from the fact that this set of characters is only partially standardized.

Serious variations occur between character sets supporting different natural languages and between character sets supporting the same natural language in different ways. Here, we are interested only in how such differences affect the rules of C++. The larger and more interesting issue of how to program in a multilingual, multi-character-set environment is beyond the scope of this book, although it is alluded to in several places (§6.2.3, §36.2.1, Chapter 39).

It is safe to assume that the implementation character set includes the decimal digits, the 26 alphabetic characters of English, and some of the basic punctuation characters. It is not safe to assume that:

• There are no more than 127 characters in an 8-bit character set (e.g., some sets provide 255 characters).

• There are no more alphabetic characters than English provides (most European languages provide more, e.g., æ, þ, and ß).

• The alphabetic characters are contiguous (EBCDIC leaves a gap between 'i' and 'j').

• Every character used to write C++ is available (e.g., some national character sets do not provide {, }, [, ], |, and \).

• A char fits in one conventional 8-bit byte. There are embedded processors without byte accessing hardware for which a char is 32-bits (conventionally known as 4 bytes). Also, one could reasonably use a 16-bit Unicode encoding for the basic chars.

Whenever possible, we should avoid making assumptions about the representation of objects. This general rule applies even to characters.

Each character has an integer value in the character set used by the implementation. For example, the value of 'b' is 98 in the ASCII character set. Here is a loop that outputs the the integer value of any character you care to input:

Click here to view code image

void intval()
{
     for (char c; cin >> c; )
           cout << "the value of '" << c << "' is " << int{c} << '\n';
}
The notation int{c} gives the integer value for a character c (“the int we can construct from c”). The possibility of converting a char to an integer raises the question: is a char signed or unsigned? The 256 values represented by an 8-bit byte can be interpreted as the values 0 to 255 or as the values –127 to 127. No, not –128 to 127 as one might expect: the C++ standard leaves open the possibility of one’s-complement hardware and that eliminates one value; thus, a use of –128 is nonportable. Unfortunately, the choice of signed or unsigned for a plain char is implementation-defined. C++ provides two types for which the answer is definite: signed char, which can hold at least the values –127 to 127, and unsigned char, which can hold at least the values 0 to 255. Fortunately, the difference matters only for values outside the 0 to 127 range, and the most common characters are within that range.

Values outside that range stored in a plain char can lead to subtle portability problems. See §6.2.3.1 if you need to use more than one type of char or if you store integers in char variables.

Note that the character types are integral types (§6.2.1) so that arithmetic and bitwise logical operations (§10.3) apply. For example:

Click here to view code image

void digits()
{
     for (int i=0; i!=10; ++i)
           cout << static_cast<char>('0'+i);
}
This is a way of writing the ten digits to cout. The character literal '0' is converted to its integer value and i is added. The resulting int is then converted to a char and written to cout. Plain '0'+i is an int, so if I had left out the static_cast<char>, the output would have been something like 48, 49, and so on, rather than 0, 1, and so on.

6.2.3.1. Signed and Unsigned Characters
It is implementation-defined whether a plain char is considered signed or unsigned. This opens the possibility for some nasty surprises and implementation dependencies. For example:

Click here to view code image

char c = 255; //  255 is "all ones," hexadecimal 0xFF
int i = c;
What will be the value of i? Unfortunately, the answer is undefined. On an implementation with 8-bit bytes, the answer depends on the meaning of the “all ones” char bit pattern when extended into an int. On a machine where a char is unsigned, the answer is 255. On a machine where a char is signed, the answer is –1. In this case, the compiler might warn about the conversion of the literal 255 to the char value –1. However, C++ does not offer a general mechanism for detecting this kind of problem. One solution is to avoid plain char and use the specific char types only. Unfortunately, some standard-library functions, such as strcmp(), take plain chars only (§43.4).

A char must behave identically to either a signed char or an unsigned char. However, the three char types are distinct, so you can’t mix pointers to different char types. For example:

Click here to view code image

void f(char c, signed char sc, unsigned char uc)
{
     char* pc = &uc;                // error: no pointer conversion
     signed char* psc = pc;         // error: no pointer conversion
     unsigned char* puc = pc;       // error: no pointer conversion
     psc = puc;                     // error: no pointer conversion
}
Variables of the three char types can be freely assigned to each other. However, assigning a toolarge value to a signed char (§10.5.2.1) is implementation defined. For example:

Click here to view code image

void g(char c, signed char sc, unsigned char uc)
{
     c = 255;    // implementation-defined if plain chars are signed and have 8 bits
     c = sc;     // OK
     c = uc;     // implementation-defined if plain chars are signed and if uc's value is too large
     sc = uc;    // implementation defined if uc's value is too large
     uc = sc;    // OK: conversion to unsigned
     sc = c;     // implementation-defined if plain chars are unsigned and if c's value is too large
     uc = c;     // OK: conversion to unsigned
}
To be concrete, assume that a char is 8 bits:

Click here to view code image

signed char sc = –120;
unsigned char uc = sc;    // uc == 136 (because 256-120==136)
sc = ++uc;                       // sc is -119 (because 136+1==137 and 256-137==119)

char count[256];          // assume 8-bit chars (uninitialized)
char c1 = count[sc];      // likely disaster: out-of-range access
char c2 = count[uc];      // OK
None of these potential problems and confusions occur if you use plain char throughout and avoid negative character values.

6.2.3.2. Character Literals
A character literal is a single character enclosed in single quotes, for example, 'a' and '0'. The type of a character literal is char. A character literal can be implicitly converted to its integer value in the character set of the machine on which the C++ program is to run. For example, if you are running on a machine using the ASCII character set, the value of '0' is 48. The use of character literals rather than decimal notation makes programs more portable.

A few characters have standard names that use the backslash, \ , as an escape character:

Name

ASCII Name

C++ Name

Newline

NL (LF)

\n

Horizontal tab

HT

\t

Vertical tab

VT

\v

Backspace

BS

\b

Carriage return

CR

\r

Form feed

FF

\f

Alert

BEL

\a

Backslash

\

\\

Question mark

?

\?

Single quote

′

\’

Double quote

"

\"

Octal number

ooo

\ooo

Hexadecimal number

hhh

\xhhh...

Despite their appearance, these are single characters.

We can represent a character from the implementation character set as a one-, two-, or three-digit octal number (\ followed by octal digits) or as a hexadecimal number (\x followed by hexadecimal digits). There is no limit to the number of hexadecimal digits in the sequence. A sequence of octal or hexadecimal digits is terminated by the first character that is not an octal digit or a hexadecimal digit, respectively. For example:

Octal

Hexadecimal

Decimal

ASCII

'\6'

'\x6'

6

ACK

'\60'

'\x30'

48

'0'

'\137'

'\x05f'

95

'_'

This makes it possible to represent every character in the machine’s character set and, in particular, to embed such characters in character strings (see §7.3.2). Using any numeric notation for characters makes a program nonportable across machines with different character sets.

It is possible to enclose more than one character in a character literal, for example, 'ab'. Such uses are archaic, implementation-dependent, and best avoided. The type of such a multicharacter literal is int.

When embedding a numeric constant in a string using the octal notation, it is wise always to use three digits for the number. The notation is hard enough to read without having to worry about whether or not the character after a constant is a digit. For hexadecimal constants, use two digits. Consider these examples:

Click here to view code image

char v1[] = "a\xah\129";      //6 chars: 'a' '\xa' 'h' '\12' '9' '\0'
char v2[] = "a\xah\127";      //5 chars: 'a' '\xa' 'h' '\127' '\0'
char v3[] = "a\xad\127";      //4 chars: 'a' '\xad' '\127' '\0'
char v4[] = "a\xad\0127";     //5 chars: 'a' '\xad' '\012' '7' '\0'
Wide character literals are of the form L'ab' and are of type wchar_t. The number of characters between the quotes and their meanings are implementation-defined.

A C++ program can manipulate character sets that are much richer than the 127-character ASCII set, such as Unicode. Literals of such larger character sets are presented as sequences of four or eight hexadecimal digits preceded by a u or a U, respectively. For example:

U'\UFADEBEEF'
u'\uDEAD'
u'\xDEAD'
The shorter notation u'\uXXXX' is equivalent to U'\U0000XXXX' for any hexadecimal digit X. A number of hexadecimal digits different from four or eight is a lexical error. The meaning of the hexadecimal number is defined by the ISO/IEC 10646 standard and such values are called universal character names. In the C++ standard, universal character names are described in §iso.2.2, §iso.2.3, §iso.2.14.3, §iso.2.14.5, and §iso.E.

6.2.4. Integer Types
Like char, each integer type comes in three forms: “plain” int, signed int, and unsigned int. In addition, integers come in four sizes: short int, “plain” int, long int, and long long int. A long int can be referred to as plain long, and a long long int can be referred to as plain long long. Similarly, short is a synonym for short int, unsigned for unsigned int, and signed for signed int. No, there is no long short int equivalent to int.

The unsigned integer types are ideal for uses that treat storage as a bit array. Using an unsigned instead of an int to gain one more bit to represent positive integers is almost never a good idea. Attempts to ensure that some values are positive by declaring variables unsigned will typically be defeated by the implicit conversion rules (§10.5.1, §10.5.2.1).

Unlike plain chars, plain ints are always signed. The signed int types are simply more explicit synonyms for their plain int counterparts, rather than different types.

If you need more detailed control over integer sizes, you can use aliases from <cstdint> (§43.7), such as int64_t (a signed integer with exactly 64 bits, if such an integer exists), uint_fast16_t (an unsigned integer with at least 16 bits, supposedly the fastest such integer), and int_least32_t (a signed integer with at least 32 bits, just like plain long). The plain integer types have well-defined minimal sizes (§6.2.8), so the <cstdint> are sometimes redundant and can be overused.

In addition to the standard integer types, an implementation may provide extended integer types (signed and unsigned). These types must behave like integers and are considered integer types when considering conversions and integer literal values, but they usually have greater range (occupy more space).

6.2.4.1. Integer Literals
Integer literals come in three guises: decimal, octal, and hexadecimal. Decimal literals are the most commonly used and look as you would expect them to:

7  1234  976  12345678901234567890
The compiler ought to warn about literals that are too long to represent, but an error is only guaranteed for {} initializers (§6.3.5).

A literal starting with zero followed by x or X (0x or 0X) is a hexadecimal (base 16) number. A literal starting with zero but not followed by x or X is an octal (base 8) number. For example:

Decimal

Octal

Hexadecimal

0

0x0

2

02

0x2

63

077

0x3f

83

0123

0x53

Yes, plain 0 is octal, rather than decimal.

The letters a, b, c, d, e, and f, or their uppercase equivalents, are used to represent 10, 11, 12, 13, 14, and 15, respectively. Octal and hexadecimal notations are most useful for expressing bit patterns. Using these notations to express genuine numbers can lead to surprises. For example, on a machine on which an int is represented as a two’s complement 16-bit integer, 0xffff is the negative decimal number –1. Had more bits been used to represent an integer, it would have been the positive decimal number 65535.

The suffix U can be used to write explicitly unsigned literals. Similarly, the suffix L can be used to write explicitly long literals. For example, 3 is an int, 3U is an unsigned int, and 3L is a long int.

Combinations of suffixes are allowed. For example:

cout << 0xF0UL << ' ' << 0LU << '\n';
If no suffix is provided, the compiler gives an integer literal a suitable type based on its value and the implementation’s integer sizes (§6.2.4.2).

It is a good idea to limit the use of nonobvious constants to a few well-commented const (§7.5), constexpr (§10.4), and enumerator (§8.4) initializers.

6.2.4.2. Types of Integer Literals
In general, the type of an integer literal depends on its form, value, and suffix:

• If it is decimal and has no suffix, it has the first of these types in which its value can be represented: int, long int, long long int.

• If it is octal or hexadecimal and has no suffix, it has the first of these types in which its value can be represented: int, unsigned int, long int, unsigned long int, long long int, unsigned long long int.

• If it is suffixed by u or U, its type is the first of these types in which its value can be represented: unsigned int, unsigned long int, unsigned long long int.

• If it is decimal and suffixed by l or L, its type is the first of these types in which its value can be represented: long int, long long int.

• If it is octal or hexadecimal and suffixed by l or L, its type is the first of these types in which its value can be represented: long int, unsigned long int, long long int, unsigned long long int.

• If it is suffixed by ul, lu, uL, Lu, Ul, lU, UL, or LU, its type is the first of these types in which its value can be represented: unsigned long int, unsigned long long int.

• If it is decimal and is suffixed by ll or LL, its type is long long int.

• If it is octal or hexadecimal and is suffixed by ll or LL, its type is the first of these types in which its value can be represented: long long int, unsigned long long int.

• If it is suffixed by llu, llU, ull, Ull, LLu, LLU, uLL, or ULL, its type is unsigned long long int.

For example, 100000 is of type int on a machine with 32-bit ints but of type long int on a machine with 16-bit ints and 32-bit longs. Similarly, 0XA000 is of type int on a machine with 32-bit ints but of type unsigned int on a machine with 16-bit ints. These implementation dependencies can be avoided by using suffixes: 100000L is of type long int on all machines and 0XA000U is of type unsigned int on all machines.

6.2.5. Floating-Point Types
The floating-point types represent floating-point numbers. A floating-point number is an approximation of a real number represented in a fixed amount of memory. There are three floating-point types: float (single-precision), double (double-precision), and long double (extended-precision).

The exact meaning of single-, double-, and extended-precision is implementation-defined. Choosing the right precision for a problem where the choice matters requires significant understanding of floating-point computation. If you don’t have that understanding, get advice, take the time to learn, or use double and hope for the best.

6.2.5.1. Floating-Point Literals
By default, a floating-point literal is of type double. Again, a compiler ought to warn about floating-point literals that are too large to be represented. Here are some floating-point literals:

1.23  .23  0.23  1.  1.0  1.2e10  1.23e–15
Note that a space cannot occur in the middle of a floating-point literal. For example, 65.43 e–21 is not a floating-point literal but rather four separate lexical tokens (causing a syntax error):

65.43 e – 21
If you want a floating-point literal of type float, you can define one using the suffix f or F:

3.14159265f  2.0f  2.997925F  2.9e–3f
If you want a floating-point literal of type long double, you can define one using the suffix l or L:

3.14159265L  2.0L  2.997925L  2.9e–3L
6.2.6. Prefixes and Suffixes
There is a minor zoo of suffixes indicating types of literals and also a few prefixes:

Arithmetic Literal Prefixes and Suffixes

Notation

 

*fix

Meaning

Example

Reference

ISO

0

 

prefix

octal

0776

§6.2.4.1

§iso.2.14.2

0x

0X

prefix

hexadecimal

0xff

§6.2.4.1

§iso.2.14.2

u

U

suffix

unsigned

10U

§6.2.4.1

§iso.2.14.2

I

L

suffix

long

20000L

§6.2.4.1

§iso.2.14.2

II

LL

suffix

long long

20000LL

§6.2.4.1

§iso.2.14.2

f

F

suffix

float

10.3f

§6.2.5.1

§iso.2.14.4

e

E

infix

floating-point

10e-4

§6.2.5.1

§iso.2.14.4

·

 

infix

floating-point

12.3

§6.2.5.1

§iso.2.14.4

'

 

prefix

char

'c'

§6.2.3.2

§iso.2.14.3

u'

 

prefix

char16_t

u'c'

§6.2.3.2

§iso.2.14.3

U'

 

prefix

char32_t

U'c'

§6.2.3.2

§iso.2.14.3

L'

 

prefix

wchar_t

L'c'

§6.2.3.2

§iso.2.14.3

"

 

prefix

string

"mess"

§7.3.2

§iso.2.14.5

R"

 

prefix

raw string

R"(\b)"

§7.3.2.1

§iso.2.14.5

u8"

u8R"

prefix

UTF-8 string

u8"foo"

§7.3.2.2

§iso.2.14.5

u"

uR"

prefix

UTF-16 string

u"foo"

§7.3.2.2

§iso.2.14.5

U"

UR"

prefix

UTF-32 string

U"foo"

§7.3.2.2

§iso.2.14.5

L"

LR"

prefix

wchar_t string

L"foo"

§7.3.2.2

§iso.2.14.5

Note that “string” here means “string literal” (§7.3.2) rather than “of type std::string.”

Obviously, we could also consider . and e as infix and R" and u8" as the first part of a set of delimiters. However, I consider the nomenclature less important than giving an overview of the bewildering variety of literals.

The suffixes l and L can be combined with the suffixes u and U to express unsigned long types. For example:

1LU        // unsigned long
2UL        // unsigned long
3ULL       // unsigned long long
4LLU       // unsigned long long
5LUL       // error
The suffixes l and L can be used for floating-point literals to express long double. For example:

1L         // long int
1.0L       // long double
Combinations of R, L, and u prefixes are allowed, for example, uR"**(foo\(bar))**". Note the dramatic difference in the meaning of a U suffix for an integer (unsigned) and a U prefix for a character or a string (UTF-32 encoding; §7.3.2.2).

In addition, a user can define new suffixes for user-defined types. For example, by defining a user-defined literal operator (§19.2.6), we can get

Click here to view code image

"foo bar"s      // a literal of type std::string
123_km          // a literal of type Distance
Suffixes not starting with _ are reserved for the standard library.

6.2.7. void
The type void is syntactically a fundamental type. It can, however, be used only as part of a more complicated type; there are no objects of type void. It is used either to specify that a function does not return a value or as the base type for pointers to objects of unknown type. For example:

Click here to view code image

void x;       // error: there are no void objects
void& r;      // error: there are no references to void
void f();     // function f does not return a value (§12.1.4)
void* pv;     // pointer to object of unknown type (§7.2.1)
When declaring a function, you must specify the type of the value returned. Logically, you would expect to be able to indicate that a function didn’t return a value by omitting the return type. However, that would make a mess of the grammar (§iso.A). Consequently, void is used as a “pseudo return type” to indicate that a function doesn’t return a value.

6.2.8. Sizes
Some of the aspects of C++’s fundamental types, such as the size of an int, are implementation-defined (§6.1). I point out these dependencies and often recommend avoiding them or taking steps to minimize their impact. Why should you bother? People who program on a variety of systems or use a variety of compilers care a lot because if they don’t, they are forced to waste time finding and fixing obscure bugs. People who claim they don’t care about portability usually do so because they use only a single system and feel they can afford the attitude that “the language is what my compiler implements.” This is a narrow and shortsighted view. If your program is a success, it will be ported, so someone will have to find and fix problems related to implementation-dependent features. In addition, programs often need to be compiled with other compilers for the same system, and even a future release of your favorite compiler may do some things differently from the current one. It is far easier to know and limit the impact of implementation dependencies when a program is written than to try to untangle the mess afterward.

It is relatively easy to limit the impact of implementation-dependent language features. Limiting the impact of system-dependent library facilities is far harder. Using standard-library facilities wherever feasible is one approach.

The reason for providing more than one integer type, more than one unsigned type, and more than one floating-point type is to allow the programmer to take advantage of hardware characteristics. On many machines, there are significant differences in memory requirements, memory access times, and computation speed among the different varieties of fundamental types. If you know a machine, it is usually easy to choose, for example, the appropriate integer type for a particular variable. Writing truly portable low-level code is harder.

Here is a graphical representation of a plausible set of fundamental types and a sample string literal (§7.3.2):



On the same scale (.2 inch to a byte), a megabyte of memory would stretch about 3 miles (5 km) to the right.

Sizes of C++ objects are expressed in terms of multiples of the size of a char, so by definition the size of a char is 1. The size of an object or type can be obtained using the sizeof operator (§10.3). This is what is guaranteed about sizes of fundamental types:

• 1 ≡ sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)

• 1 ≤ sizeof(bool) ≤ sizeof(long)

• sizeof(char) ≤ sizeof(wchar_t) ≤ sizeof(long)

• sizeof(float) ≤ sizeof(double) ≤ sizeof(long double)

• sizeof(N) ≡ sizeof(signed N) ≡ sizeof(unsigned N)

In that last line, N can be char, short, int, long, or long long. In addition, it is guaranteed that a char has at least 8 bits, a short at least 16 bits, and a long at least 32 bits. A char can hold a character of the machine’s character set. The char type is supposed to be chosen by the implementation to be the most suitable type for holding and manipulating characters on a given computer; it is typically an 8-bit byte. Similarly, the int type is supposed to be chosen to be the most suitable for holding and manipulating integers on a given computer; it is typically a 4-byte (32-bit) word. It is unwise to assume more. For example, there are machines with 32-bit chars. It is extremely unwise to assume that the size of an int is the same as the size of a pointer; many machines (“64-bit architectures”) have pointers that are larger than integers. Note that it is not guaranteed that sizeof(long)<sizeof(long long) or that sizeof(double)<sizeof(long double).

Some implementation-defined aspects of fundamental types can be found by a simple use of sizeof, and more can be found in <limits>. For example:

Click here to view code image

#include <limits>   //§40.2
#include <iostream>

int main()
{
     cout << "size of long " << sizeof(1L) << '\n';
     cout << "size of long long " << sizeof(1LL) << '\n';

     cout << "largest float == " << std::numeric_limits<float>::max() << '\n';
     cout << "char is signed == " << std::numeric_limits<char>::is_signed << '\n';
}
The functions in <limits> (§40.2) are constexpr (§10.4) so that they can be used without run-time overhead and in contexts that require a constant expression.

The fundamental types can be mixed freely in assignments and expressions. Wherever possible, values are converted so as not to lose information (§10.5).

If a value v can be represented exactly in a variable of type T, a conversion of v to T is value-preserving. Conversions that are not value-preserving are best avoided (§2.2.2, §10.5.2.6).

If you need a specific size of integer, say, a 16-bit integer, you can #include the standard header <cstdint> that defines a variety of types (or rather type aliases; §6.5). For example:

Click here to view code image

int16_t x {0xaabb};                  //2 bytes
int64_t xxxx {0xaaaabbbbccccdddd};   //8 bytes
int_least16_t y;                     // at least 2 bytes (just like int)
int_least32_t yy                     // at least 4 bytes (just like long)
int_fast32_t z;                      // the fastest int type with at least 4 bytes
The standard header <cstddef> defines an alias that is very widely used in both standard-library declarations and user code: size_t is an implementation-defined unsigned integer type that can hold the size in bytes of every object. Consequently, it is used where we need to hold an object size. For example:

void* allocate(size_t n);     // get n bytes
Similarly, <cstddef> defines the signed integer type ptrdiff_t for holding the result of subtracting two pointers to get a number of elements.

6.2.9. Alignment
An object doesn’t just need enough storage to hold its representation. In addition, on some machine architectures, the bytes used to hold it must have proper alignment for the hardware to access it efficiently (or in extreme cases to access it at all). For example, a 4-byte int often has to be aligned on a word (4-byte) boundary. Simiarly, some implementations align an 8-byte double on a double-word (8-byte) boundary. Of course, this is all very implementation specific, and for most programmers completely implicit. You can write good C++ code for decades without needing to be explicit about alignment. Where alignment most often becomes visible is in object layouts: sometimes structs contain “holes” to improve alignment (§8.2.1).

The alignof() operator returns the alignment of its argument type. For example:

Click here to view code image

auto ac = alignof(char);              // the alignment of a char
auto ai = alignof(int);               // the alignment of an int
auto at = alignof(T);                 // the alignment of some type T

int a[20];
auto aa = alignof(decltype(a));       // the alignment of an array of int
Sometimes, we have to use alignment in a declaration, where an expression, such as alignof(T) is not allowed. Instead, we can use the type specifier alignas: alignas(T) means “align just like a T.” For example, we can set aside uninitialized storage for some type X like this:

Click here to view code image

void user(const vector<X>& vx)
{
     constexpr int bufmax = 1024;
     alignas(X) char buffer[bufmax];   // uninitialized

     const int max = min(vx.size(),bufmax/sizeof(X));
     uninitializ ed_copy(vx.begin(),vx.begin()+max,reinterpret_cast<X.>(buffer));
     //...
}
6.3. Declarations
Before a name (identifier) can be used in a C++ program, it must be declared. That is, its type must be specified to inform the compiler what kind of entity the name refers to. For example:

Click here to view code image

char ch;
string s;
auto count = 1;
const double pi {3.1415926535897};
extern int error_number;

const char* name = "Njal";
const char* season[] = { "spring", "summer", "fall", "winter" };
vector<string> people { name, "Skarphedin", "Gunnar" };

struct Date
{ int d, m, y; }; int day(Date* p) { return p–>d; }
double sqrt(double);
template<typename T> T abs(T a) { return a<0 ? –a: a; }

constexpr int fac(int n) { return (n<2)?1:n* fac(n–1); }    // possible compile-time evaluation (§2.2.3)
constexpr double zz { ii*fac(7) };                          // compile-time initialization

using Cmplx = std::complex<double>;                         // type alias (§3.4.5, §6.5)
struct User;                                                // type name
enum class Beer { Carlsberg, Tuborg, Thor };
namespace NS { int a; }
As can be seen from these examples, a declaration can do more than simply associate a type with a name. Most of these declarations are also definitions. A definition is a declaration that supplies all that is needed in a program for the use of an entity. In particular, if it takes memory to represent something, that memory is set aside by its definition. A different terminology deems declarations parts of an interface and definitions parts of an implementation. When taking that view, we try to compose interfaces out of declarations that can be replicated in separate files (§15.2.2); definitions that set aside memory do not belong in interfaces.

Assuming that these declarations are in the global scope (§6.3.4), we have:

Click here to view code image

char ch;                                // set aside memory for a char and initialize it to 0
auto count = 1;                         // set aside memory for an int initialized to 1
const char* name = "Njal";              // set aside memory for a pointer to char
                                        // set aside memory for a string literal "Njal"
                                        // initialize the pointer with the address of that string literal

struct Date { int d, m, y; };           // Date is a struct with three members
int day(Date* p) { return p–>d; }       // day is a function that executes the specified code

using Point = std::complex<short>; // Point is a name for std::complex<short>
Of the declarations above, only three are not also definitions:

Click here to view code image

double sqrt(double);           // function declaration
extern int error_number;       // variable declaration
struct User;                   // type name declaration
That is, if used, the entity they refer to must be defined elsewhere. For example:

Click here to view code image

double sqrt(double d) { /* ... */ }
int error_number = 1;
struct User { /* ... */ };
There must always be exactly one definition for each name in a C++ program (for the effects of #include, see §15.2.3). However, there can be many declarations.

All declarations of an entity must agree on its type. So, this fragment has two errors:

Click here to view code image

int count;
int count;        // error: redefinition
extern int error_number;
extern short error_number;       // error: type mismatch
This has no errors (for the use of extern, see §15.2):

Click here to view code image

extern int error_number;
extern int error_number;  // OK: redeclaration
Some definitions explicitly specify a “value” for the entities they define. For example:

Click here to view code image

struct Date { int d, m, y; };
using Point = std::complex<short>;      // Point is a name for std::complex<short>
int day(Date* p) { return p–>d; }
const double pi {3.1415926535897};
For types, aliases, templates, functions, and constants, the “value” is permanent. For non-const data types, the initial value may be changed later. For example:

Click here to view code image

void f()
{
     int count {1};                 // initialize count to 1
     const char* name {"Bjarne"};   // name is a variable that points to a constant (§7.5)
     count = 2;                     // assign 2 to count
     name = "Marian";
}
Of the definitions, only two do not specify values:

char ch;
string s;
See §6.3.5 and §17.3.3 for explanations of how and when a variable is assigned a default value. Any declaration that specifies a value is a definition.

6.3.1. The Structure of Declarations
The structure of a declaration is defined by the C++ grammar (§iso.A). This grammar evolved over four decades, starting with the early C grammars, and is quite complicated. However, without too many radical simplifications, we can consider a declaration as having five parts (in order):

• Optional prefix specifiers (e.g., static or virtual)

• A base type (e.g., vector<double> or const int)

• A declarator optionally including a name (e.g., p[7], n, or *(*)[])

• Optional suffix function specifiers (e.g., const or noexcept)

• An optional initializer or function body (e.g., ={7,5,3} or {return x;})

Except for function and namespace definitions, a declaration is terminated by a semicolon. Consider a definition of an array of C-style strings:

const char* kings[] = { "Antigonus", "Seleucus", "Ptolemy" };
Here, the base type is const char, the declarator is * kings[], and the initializer is the = followed by the {}-list.

A specifier is an initial keyword, such as virtual (§3.2.3, §20.3.2), extern (§15.2), or constexpr (§2.2.3), that specifies some non-type attribute of what is being declared.

A declarator is composed of a name and optionally some declarator operators. The most common declarator operators are:

Declarator Operators

prefix

*

pointer

prefix

*const

constant pointer

prefix

volatile

volatile pointer

prefix

&

lvalue reference (§7.7.1)

prefix

&&

rvalue reference (§7.7.2)

prefix

auto

function (using suffix return type)

postfix

[]

array

postfix

()

function

postfix

->

returns from function

Their use would be simple if they were all either prefix or postfix. However, *, [], and () were designed to mirror their use in expressions (§10.3). Thus, * is prefix and [] and () are postfix. The postfix declarator operators bind tighter than the prefix ones. Consequently, char*kings[] is an array of pointers to char, whereas char(*kings)[] is a pointer to an array of char. We have to use parentheses to express types such as “pointer to array” and “pointer to function”; see the examples in §7.2.

Note that the type cannot be left out of a declaration. For example:

Click here to view code image

const c = 7;      // error: no type

gt(int a, int b)  // error: no return type
{
     return (a>b) ? a : b;
}

unsigned ui;      // OK: "unsigned"means "unsigned int"
long li;          // OK: "long" means "long int"
In this, standard C++ differs from early versions of C and C++ that allowed the first two examples by considering int to be the type when none was specified (§44.3). This “implicit int” rule was a source of subtle errors and much confusion.

Some types have names composed out of multiple keywords, such as long long and volatile int. Some type names don’t even look much like names, such as decltype(f(x)) (the return type of a call f(x); §6.3.6.3).

The volatile specifier is described in §41.4.

The alignas() specifier is described in §6.2.9.

6.3.2. Declaring Multiple Names
It is possible to declare several names in a single declaration. The declaration simply contains a list of comma-separated declarators. For example, we can declare two integers like this:

int x, y;        // int x; int y;
Operators apply to individual names only – and not to any subsequent names in the same declaration. For example:

Click here to view code image

int* p, y;        // int* p; int y;  NOT int* y;
int x, *q;        // int x; int* q;
int v[10], *pv;   // int v[10]; int* pv;
Such declarations with multiple names and nontrivial declarators make a program harder to read and should be avoided.

6.3.3. Names
A name (identifier) consists of a sequence of letters and digits. The first character must be a letter. The underscore character, _, is considered a letter. C++ imposes no limit on the number of characters in a name. However, some parts of an implementation are not under the control of the compiler writer (in particular, the linker), and those parts, unfortunately, sometimes do impose limits. Some run-time environments also make it necessary to extend or restrict the set of characters accepted in an identifier. Extensions (e.g., allowing the character $ in a name) yield nonportable programs. A C++ keyword (§6.3.3.1), such as new or int, cannot be used as a name of a user-defined entity. Examples of names are:

Click here to view code image

hello      this_is_a_most_unusually_long_identifier_that_is_better_avoided
DEFINED    foO       bAr          u_name          HorseSense
var0       var1      CLASS        _class          ___
Examples of character sequences that cannot be used as identifiers are:

Click here to view code image

012          a fool      $sys      class      3var
pay.due      foo~bar     .name     if
Nonlocal names starting with an underscore are reserved for special facilities in the implementation and the run-time environment, so such names should not be used in application programs. Similarly, names containing a double underscore (trouble__ahead) or an underscore followed by an uppercase letter (e.g., _Foo) are reserved (§iso.17.6.4.3.2).

When reading a program, the compiler always looks for the longest string of characters that could make up a name. Hence, var10 is a single name, not the name var followed by the number 10. Also, elseif is a single name, not the keyword else followed by the keyword if.

Uppercase and lowercase letters are distinct, so Count and count are different names, but it is often unwise to choose names that differ only by capitalization. In general, it is best to avoid names that differ only in subtle ways. For example, in some fonts, the uppercase “o” (O) and zero (0) can be hard to tell apart, as can the lowercase “L” (l), uppercase “i” (I), and one (1). Consequently, l0, lO, l1, ll, and I1l are poor choices for identifier names. Not all fonts have the same problems, but most have some.

Names from a large scope ought to have relatively long and reasonably obvious names, such as vector, Window_with_border, and Department_number. However, code is clearer if names used only in a small scope have short, conventional names such as x, i, and p. Functions (Chapter 12), classes (Chapter 16), and namespaces (§14.3.1) can be used to keep scopes small. It is often useful to keep frequently used names relatively short and reserve really long names for infrequently used entities.

Choose names to reflect the meaning of an entity rather than its implementation. For example, phone_book is better than number_vector even if the phone numbers happen to be stored in a vector (§4.4). Do not encode type information in a name (e.g., pcname for a name that’s a char* or icount for a count that’s an int) as is sometimes done in languages with dynamic or weak type systems:

• Encoding types in names lowers the abstraction level of the program; in particular, it prevents generic programming (which relies on a name being able to refer to entities of different types).

• The compiler is better at keeping track of types than you are.

• If you want to change the type of a name (e.g., use a std::string to hold the name), you’ll have to change every use of the name (or the type encoding becomes a lie).

• Any system of type abbreviations you can come up with will become overelaborate and cryptic as the variety of types you use increases.

Choosing good names is an art.

Try to maintain a consistent naming style. For example, capitalize names of user-defined types and start names of non-type entities with a lowercase letter (for example, Shape and current_token). Also, use all capitals for macros (if you must use macros (§12.6); for example, HACK) and never for non-macros (not even for non-macro constants). Use underscores to separate words in an identifier; number_of_elements is more readable than numberOfElements. However, consistency is hard to achieve because programs are typically composed of fragments from different sources and several different reasonable styles are in use. Be consistent in your use of abbreviations and acronyms. Note that the language and the standard library use lowercase for types; this can be seen as a hint that they are part of the standard.

6.3.3.1. Keywords
The C++ keywords are:

C++ Keywords

alignas

alignof

and

and_eq

asm

auto

bitand

bitor

bool

break

case

catch

char

char16_t

char32_t

class

compl

const

constexpr

const_cast

continue

decltype

default

delete

do

double

dynamic_cast

else

enum

explicit

extern

false

float

for

friend

goto

if

inline

int

long

mutable

namespace

new

noexcept

not

not_eq

nullptr

operator

or

or_eq

private

protected

public

register

reinterpret_cast

return

short

signed

sizeof

static

static_assert

static_cast

struct

switch

template

this

thread_local

throw

true

try

typedef

typeid

typename

union

unsigned

using

virtual

void

volatile

wchar_t

while

xor

xor_eq

 

In addition, the word export is reserved for future use.

6.3.4. Scope
A declaration introduces a name into a scope; that is, a name can be used only in a specific part of the program text.

• Local scope: A name declared in a function (Chapter 12) or lambda (§11.4) is called a local name. Its scope extends from its point of declaration to the end of the block in which its declaration occurs. A block is a section of code delimited by a {} pair. Function and lambda parameter names are considered local names in the outermost block of their function or lambda.

• Class scope: A name is called a member name (or a class member name) if it is defined in a class outside any function (Chapter 12), lambda (§11.4), class (Chapter 16), or enum class (§8.4.1). Its scope extends from the opening { of the class declaration to the end of the class declaration.

• Namespace scope: A name is called a namespace member name if it is defined in a namespace (§14.3.1) outside any function(Chapter 12), lambda (§11.4), class (Chapter 16), or enum class (§8.4.1). Its scope extends from the point of declaration to the end of its namespace. A namespace name may also be accessible from other translation units (§15.2).

• Global scope: A name is called a global name if it is defined outside any function, class (Chapter 16), enum class (§8.4.1), or namespace (§14.3.1). The scope of a global name extends from the point of declaration to the end of the file in which its declaration occurs. A global name may also be accessible from other translation units (§15.2). Technically, the global namespace is considered a namespace, so a global name is an example of a namespace member name.

• Statement scope: A name is in a statement scope if it is defined within the () part of a for-, while-, if-, or switch-statement. Its scope extends from its point of declaration to the end of its statement. All names in statement scope are local names.

• Function scope: A label (§9.6) is in scope throughout the body of its function.

A declaration of a name in a block can hide a declaration in an enclosing block or a global name. That is, a name can be redefined to refer to a different entity within a block. After exit from the block, the name resumes its previous meaning. For example:

Click here to view code image

int x;               // global x

void f()
{
     int x;          // local x hides global x
     x = 1;          // assign to local x
     {
          int x;     // hides first local x
          x = 2;     // assign to second local x
     }
     x = 3;          // assign to first local x
}

int* p = &x;        // take address of global x
Hiding names is unavoidable when writing large programs. However, a human reader can easily fail to notice that a name has been hidden (also known as shadowed). Because such errors are relatively rare, they can be very difficult to find. Consequently, name hiding should be minimized. Using names such as i and x for global variables or for local variables in a large function is asking for trouble.

A hidden global name can be referred to using the scope resolution operator, ::. For example:

Click here to view code image

int x;

void f2()
{
     int x = 1;  // hide global x
     ::x = 2;    // assign to global x
     x = 2;      // assign to local x
      //...
}
There is no way to use a hidden local name.

The scope of a name that is not a class member starts at its point of declaration, that is, after the complete declarator and before the initializer. This implies that a name can be used even to specify its own initial value. For example:

Click here to view code image

int x = 97;

void f3()
{
     int x = x;      // perverse: initialize x with its own (uninitialized) value
}
A good compiler warns if a variable is used before it has been initialized.

It is possible to use a single name to refer to two different objects in a block without using the :: operator. For example:

Click here to view code image

int x = 11;

void f4()            // perverse: use of two different objects both called x in a single scope
{
     int y = x;      // use global x: y = 11
     int x = 22;
     y = x;          // use local x: y = 22
}
Again, such subtleties are best avoided.

The names of function arguments are considered declared in the outermost block of a function. For example:

void f5(int x)
{
     int x;      // error
}
This is an error because x is defined twice in the same scope.

Names introduced in a for-statement are local to that statement (in statement scope). This allows us to use conventional names for loop variables repeatedly in a function. For example:

Click here to view code image

void f(vector<string>& v, list<int>& lst)
{
     for (const auto& x : v) cout << x << '\n';
     for (auto x : lst) cout << x << '\n';
     for (int i = 0; i!=v.size(); ++i) cout << v[i] << '\n';
     for (auto i : {1, 2, 3, 4, 5, 6, 7}) cout << i << '\n';
}
This contains no name clashes.

A declaration is not allowed as the only statement on the branch of an if-statement (§9.4.1).

6.3.5. Initialization
If an initializer is specified for an object, that initializer determines the initial value of an object. An initializer can use one of four syntactic styles:

X a1 {v};
X a2 = {v};
X a3 = v;
X a4(v);
Of these, only the first can be used in every context, and I strongly recommend its use. It is clearer and less error-prone than the alternatives. However, the first form (used for a1) is new in C++11, so the other three forms are what you find in older code. The two forms using = are what you use in C. Old habits die hard, so I sometimes (inconsistently) use = when initializing a simple variable with a simple value. For example:

int x1 = 0;
char c1 = 'z';
However, anything much more complicated than that is better done using {}. Initialization using {}, list initialization, does not allow narrowing (§iso.8.5.4). That is:

• An integer cannot be converted to another integer that cannot hold its value. For example, char to int is allowed, but not int to char.

• A floating-point value cannot be converted to another floating-point type that cannot hold its value. For example, float to double is allowed, but not double to float.

• A floating-point value cannot be converted to an integer type.

• An integer value cannot be converted to a floating-point type.

For example:

Click here to view code image

void f(double val, int val2)
{
     int x2 = val;         // if val==7.9, x2 becomes 7
     char c2 = val2;       // if val2==1025, c2 becomes 1

     int x3 {val};         // error: possible truncation
     char c3 {val2};       // error: possible narrowing

     char c4 {24};         // OK: 24 can be represented exactly as a char
     char c5 {264};        // error (assuming 8-bit chars): 264 cannot be represented as a char

     int x4 {2.0};         // error: no double to int value conversion

      //...
}
See §10.5 for the conversion rules for built-in types.

There is no advantage to using {} initialization, and one trap, when using auto to get the type determined by the initializer. The trap is that if the initializer is a {}-list, we may not want its type deduced (§6.3.6.2). For example:

Click here to view code image

auto z1 {99};    // z1 is an initializer_list<int>
auto z2 = 99;    // z2 is an int
So prefer = when using auto.

It is possible to define a class so that an object can be initialized by a list of values and alternatively be constructed given a couple of arguments that are not simply values to be stored. The classical example is a vector of integers:

Click here to view code image

vector<int> v1 {99};     // v1 is a vector of 1 element with the value 99
vector<int> v2(99);      // v2 is a vector of 99 elements each with the default value 0
I use the explicit invocation of a constructor, (99), to get the second meaning. Most types do not offer such confusing alternatives – even most vectors do not; for example:

Click here to view code image

vector<string> v1{"hello!"};       // v1 is a vector of 1 element with the value "hello!"
vector<string> v2("hello!");       // error: no vector constructor takes a string literal
So, prefer {} initialization over alternatives unless you have a strong reason not to.

The empty initializer list, {}, is used to indicate that a default value is desired. For example:

Click here to view code image

int x4 {};           // x4 becomes 0
double d4 {};        // d4 becomes 0.0
char* p {};          // p becomes nullptr
vector<int> v4{};    // v4 becomes the empty vector
string s4 {};        // s4 becomes ""
Most types have a default value. For integral types, the default value is a suitable representation of zero. For pointers, the default value is nullptr (§7.2.2). For user-defined types, the default value (if any) is determined by the type’s constructors (§17.3.3).

For user-defined types, there can be a distinction between direct initialization (where implicit conversions are allowed) and copy initialization (where they are not); see §16.2.6.

Initialization of particular kinds of objects is discussed where appropriate:

• Pointers: §7.2.2, §7.3.2, §7.4

• References: §7.7.1 (lvalues), §7.7.2 (rvalues)

• Arrays: §7.3.1, §7.3.2

• Constants: §10.4

• Classes: §17.3.1 (not using constructors), §17.3.2 (using constructors), §17.3.3 (default), §17.4 (member and base), §17.5 (copy and move)

• User-defined containers: §17.3.4

6.3.5.1. Missing Initializers
For many types, including all built-in types, it is possible to leave out the initializer. If you do that – and that has unfortunately been common – the situation is more complicated. If you don’t like the complications, just initialize consistently. The only really good case for an uninitialized variable is a large input buffer. For example:

Click here to view code image

constexpr int max = 1024*1024;
char buf[max];
some_stream.get(buf,max);     // read at most max characters into buf
We could easily have initialized buf:

char buf[max] {};      // initialize every char to 0
By redundantly initializing, we would have suffered a performance hit which just might have been significant. Avoid such low-level use of buffers where you can, and don’t leave such buffers uninitialized unless you know (e.g., from measurement) that the optimization compared to using an initialized array is significant.

If no initializer is specified, a global (§6.3.4), namespace (§14.3.1), local static (§12.1.8), or static member (§16.2.12) (collectively called static objects) is initialized to {} of the appropriate type. For example:

Click here to view code image

int a;      // means "int a{};" so that a becomes 0
double d;   // means "double d{};" so that d becomes 0.0
Local variables (allocated on the stack) and objects created on the free store (sometimes called dynamic objects or heap objects; §11.2) are not initialized by default unless they are of user-defined types with a default constructor (§17.3.3). For example:

Click here to view code image

void f()
{
     int x;                       // x does not have a well-defined value
     char buf[1024];              // buf[i] does not have a well-defined value

     int* p {new int};            //*p does not have a well-defined value
     char* q {new char[1024]};    // q[i] does not have a well-defined value

     string s;                    // s=="" because of string's default constructor
     vector<char> v;              // v=={} because of vector's default constructor

     string* ps {new string};     //*ps is "" because of string's default constructor
      //...
}
If you want initialization of local variables of built-in type or objects of built-in type created with new, use {}. For example:

Click here to view code image

void ff()
{
     int x {};                      // x becomes 0
     char buf[1024]{};              // buf[i] becomes 0 for all i

     int* p {new int{10}};          //*p becomes 10
     char* q {new char[1024]{}};    // q[i] becomes 0 for all i

      //...
}
A member of an array or a class is default initialized if the array or structure is.

6.3.5.2. Initializer Lists
So far, we have considered the cases of no initializer and one initializer value. More complicated objects can require more than one value as an initializer. This is primarily handled by initializer lists delimited by { and }. For example:

Click here to view code image

int a[] = { 1, 2 };                          // array initializer
struct S { int x, string s; };
S s = { 1, "Helios" };                       // struct initializer
complex<double> z = { 0, pi };               // use constructor
vector<double> v = { 0.0, 1.1, 2.2, 3.3 };   // use list constructor
For C-style initialization of arrays, see §7.3.1. For C-style structures, see §8.2. For user-defined types with constructors, see §2.3.2 or §16.2.5. For initializer-list constructors, see §17.3.4.

In the cases above, the = is redundant. However, some prefer to add it to emphasize that a set of values are used to initialize a set of member variables.

In some cases, function-style argument lists can also be used (§2.3, §16.2.5). For example:

Click here to view code image

complex<double> z(0,pi);       // use constructor
vector<double> v(10,3.3);      // use constructor: v gets 10 elements initialized to 3.3
In a declaration, an empty pair of parentheses, (), always means “function” (§12.1). So, if you want to be explicit about “use default initialization” you need {}. For example:

Click here to view code image

complex<double> z1(1,2);         // function-style initializer (initialization by constructor)
complex<double> f1();            // function declaration

complex<double> z2 {1,2};        // initialization by constructor to {1,2}
complex<double> f2 {};           // initialization by constructor to the default value {0,0}
Note that initialization using the {} notation does not narrow (§6.3.5).

When using auto, a {}-list has its type deduced to std::initializer_list<T>. For example:

Click here to view code image

auto x1 {1,2,3,4};           // x1 is an initializer_list<int>
auto x2 {1.0, 2.25, 3.5 };   // x2 is an initializer_list of<double>
auto x3 {1.0,2};             // error: cannot deduce the type of {1.0,2} (§6.3.6.2)
6.3.6. Deducing a Type: auto and decltype()
The language provides two mechanisms for deducing a type from an expression:

• auto for deducing a type of an object from its initializer; the type can be the type of a variable, a const, or a constexpr.

• decltype(expr) for deducing the type of something that is not a simple initializer, such as the return type for a function or the type of a class member.

The deduction done here is very simple: auto and decltype() simply report the type of an expression already known to the compiler.

6.3.6.1. The auto Type Specifier
When a declaration of a variable has an initializer, we don’t need to explicitly specify a type. Instead, we can let the variable have the type of its initializer. Consider:

Click here to view code image

int a1 = 123;
char a2 = 123;
auto a3 = 123;   // the type of a3 is "int"
The type of the integer literal 123 is int, so a3 is an int. That is, auto is a placeholder for the type of the initializer.

Using auto instead of int for an expression as simple as 123 doesn’t help much. The harder the type is to write and the harder the type is to know, the more useful auto becomes. For example:

Click here to view code image

template<typename T> void f1(vector<T>& arg)
{
     for (typename vector<T>::iterator p = arg.begin(); p!=arg.end(); ++p)
          *p = 7;

     for (auto p = arg.begin(); p!=arg.end(); ++p)
          *p = 7;
}
The loop using auto is the more convenient to write and the easier to read. Also, it is more resilient to code changes. For example, if I changed arg to be a list, the loop using auto would still work correctly whereas the first loop would need to be rewritten. So, unless there is a good reason not to, use auto in small scopes.

If a scope is large, mentioning a type explicitly can help localize errors. That is, compared to using a specific type, using auto can delay the detection of type errors. For example:

Click here to view code image

void f(complex<double> d)
{
     // ...
     auto max = d+7;        // fine: max is a complex<double>
     double min = d-9;      // error : we assumed that d was a scalar
     // ...
}
If auto causes surprises, the best cure is typically to make functions smaller, which most often is a good idea anyway (§12.1).

We can decorate a deduced type with specifiers and modifiers (§6.3.1), such as const and & (reference; §7.7). For example:

Click here to view code image

void f(vector<int>& v)
{
     for (const auto& x : v) {  // x is a const int&
            //...
     }
}
Here, auto is determined by the element type of v, that is, int.

Note that the type of an expression is never a reference because references are implicitly dereferenced in expressions (§7.7). For example:

Click here to view code image

void g(int& v)
{
     auto x = v;     // x is an int (not an int&)
     auto& y = v;    // y is an int&
}
6.3.6.2. auto and {}-lists
When we explicitly mention the type of an object we are initializing, we have two types to consider: the type of the object and the type of the initializer. For example:

Click here to view code image

char v1 = 12345;      //12345 is an int
int v2 = 'c';         //'c' is a char
T v3 = f();
By using the {}-initializer syntax for such definitions, we minimize the chances for unfortunate conversions:

Click here to view code image

char v1 {12345};      // error: narrowing
int v2 {'c'};         // fine: implicit char->int conversion
T v3 {f()};           // works if and only if the type of f() can be implicitly converted to a T
When we use auto, there is only one type involved, the type of the initializer, and we can safely use the = syntax:

Click here to view code image

auto v1 = 12345;       // v1 is an int
auto v2 = 'c';         // v2 is a char
auto v3 = f();         // v3 is of some appropriate type
In fact, it can be an advantage to use the = syntax with auto, because the {}-list syntax might surprise someone:

Click here to view code image

auto v1 {12345};        // v1 is a list of int
auto v2 {'c'};          // v2 is a list of char
auto v3 {f()};          // v3 is a list of some appropriate type
This is logical. Consider:

Click here to view code image

auto x0 {};          // error: cannot deduce a type
auto x1 {1};         // list of int with one element
auto x2 {1,2};       // list of int with two elements
auto x3 {1,2,3};     // list of int with three elements
The type of a homogeneous list of elements of type T is taken to be of type initializer_list<T> (§3.2.1.3, §11.3.3). In particular, the type of x1 is not deduced to be int. Had it been, what would be the types of x2 and x3?

Consequently, I recommend using = rather than {} for objects specified auto whenever we don’t mean “list.”

6.3.6.3. The decltype() Specifier
We can use auto when we have a suitable initializer. But sometimes, we want to have a type deduced without defining an initialized variable. Then, we can use a declaration type specifier: decltype(expr) is the declared type of expr. This is mostly useful in generic programming. Consider writing a function that adds two matrices with potentially different element types. What should be the type of the result of the addition? A matrix, of course, but what might its element type be? The obvious answer is that the element type of the sum is the type of the sum of the elements. So, I can declare:

Click here to view code image

template<typename T, typename U>
auto operator+(const Matrix<T>& a, const Matrix<U>& b) –> Matrix<decltype(T{}+U{})>;
I use the suffix return type syntax (§12.1) to be able to express the return type in terms of the arguments: Matrix<decltype(T{}+U{})>. That is, the result is a Matrix with the element type being what you get from adding a pair of elements from the argument Matrixes: T{}+U{}.

In the definition, I again need decltype() to express Matrix’s element type:

Click here to view code image

template<typename T, typename U>
auto operator+(const Matrix<T>& a, const Matrix<U>& b) –> Matrix<decltype(T{}+U{})>
{
     Matrix<decltype(T{}+U{})> res;
     for (int i=0; i!=a.rows(); ++i)
           for (int j=0; j!=a.cols(); ++j)
                 res(i,j) += a(i,j) + b(i,j);
     return res;
}
6.4. Objects and Values
We can allocate and use objects that do not have names (e.g., created using new), and it is possible to assign to strange-looking expressions (e.g., *p[a+10]=7). Consequently, we need a name for “something in memory.” This is the simplest and most fundamental notion of an object. That is, an object is a contiguous region of storage; an lvalue is an expression that refers to an object. The word “lvalue” was originally coined to mean “something that can be on the left-hand side of an assignment.” However, not every lvalue may be used on the left-hand side of an assignment; an lvalue can refer to a constant (§7.7). An lvalue that has not been declared const is often called a modifiable lvalue. This simple and low-level notion of an object should not be confused with the notions of class object and object of polymorphic type (§3.2.2, §20.3.2).

6.4.1. Lvalues and Rvalues
To complement the notion of an lvalue, we have the notion of an rvalue. Roughly, rvalue means “a value that is not an lvalue,” such as a temporary value (e.g., the value returned by a function).

If you need to be more technical (say, because you want to read the ISO C++ standard), you need a more refined view of lvalue and rvalue. There are two properties that matter for an object when it comes to addressing, copying, and moving:

• Has identity: The program has the name of, pointer to, or reference to the object so that it is possible to determine if two objects are the same, whether the value of the object has changed, etc.

• Is Movable: The object may be moved from (i.e., we can move its value to another location and leave the object in a valid but unspecified state, rather than copy; §17.5).

It turns out that three of the four possible combinations of those two properties are needed to precisely describe the C++ language rules (we have no need for objects that do not have identity and cannot be moved). Using “m for is movable” and “i for has identity,” we can represent this classification of expressions graphically:



So, a classical lvalue is something that has identity and cannot be moved (because we could examine it after a move), and a classical rvalue is anything that we are allowed to move from. The other alternatives are prvalue (“pure rvalue”), glvalue (“generalized lvalue”), and xvalue (“x” for “extraordinary” or “expert only”; the suggestions for the meaning of this “x” have been quite imaginative). For example:

Click here to view code image

void f(vector<string>& vs)
{
     vector<string> v2 = std::move(vs);     // move vs to v2
      //...
}
Here, std::move(vs) is an xvalue: it clearly has identity (we can refer to it as vs), but we have explicitly given permission for it to be moved from by calling std::move() (§3.3.2, §35.5.1).

For practical programming, thinking in terms of rvalue and lvalue is usually sufficient. Note that every expression is either an lvalue or an rvalue, but not both.

6.4.2. Lifetimes of Objects
The lifetime of an object starts when its constructor completes and ends when its destructor starts executing. Objects of types without a declared constructor, such as an int, can be considered to have default constructors and destructors that do nothing.

We can classify objects based on their lifetimes:

• Automatic: Unless the programmer specifies otherwise (§12.1.8, §16.2.12), an object declared in a function is created when its definition is encountered and destroyed when its name goes out of scope. Such objects are sometimes called automatic objects. In a typical implementation, automatic objects are allocated on the stack; each call of the function gets its own stack frame to hold its automatic objects.

• Static: Objects declared in global or namespace scope (§6.3.4) and statics declared in functions (§12.1.8) or classes (§16.2.12) are created and initialized once (only) and “live” until the program terminates (§15.4.3). Such objects are called static objects. A static object has the same address throughout the life of a program execution. Static objects can cause serious problems in a multi-threaded program because they are shared among all threads and typically require locking to avoid data races (§5.3.1, §42.3).

• Free store: Using the new and delete operators, we can create objects whose lifetimes are controlled directly (§11.2).

• Temporary objects (e.g., intermediate results in a computation or an object used to hold a value for a reference to const argument): their lifetime is determined by their use. If they are bound to a reference, their lifetime is that of the reference; otherwise, they “live” until the end of the full expression of which they are part. A full expression is an expression that is not part of another expression. Typically, temporary objects are automatic.

• Thread-local objects; that is, objects declared thread_local (§42.2.8): such objects are created when their thread is and destroyed when their thread is.

Static and automatic are traditionally referred to as storage classes.

Array elements and nonstatic class members have their lifetimes determined by the objects of which they are part.

6.5. Type Aliases
Sometimes, we need a new name for a type. Possible reasons include:

• The original name is too long, complicated, or ugly (in some programmer’s eyes).

• A programming technique requires different types to have the same name in a context.

• A specific type is mentioned in one place only to simplify maintenance.

For example:

Click here to view code image

using Pchar = char*;         // pointer to character
using PF = int(*)(double);   // pointer to function taking a double and returning an int
Similar types can define the same name as a member alias:

Click here to view code image

template<typename T>
class vector {
     using value_type = T;     // every container has a value_type
      //...
};
template<typename T>
class list {
     using value_type = T;     // every container has a value_type
      //...
};
For good and bad, type aliases are synonyms for other types rather than distinct types. That is, an alias refers to the type for which it is an alias. For example:

Pchar p1 = nullptr;      // p1 is a char*
char* p3 = p1;           // fine
People who would like to have distinct types with identical semantics or identical representation should look at enumerations (§8.4) and classes (Chapter 16).

An older syntax using the keyword typedef and placing the name being declared where it would have been in a declaration of a variable can equivalently be used in many contexts. For example:

Click here to view code image

typedef int int32_t;        // equivalent to "using int32_t = int;"
typedef short int16_t;      // equivalent to "using int16_t = short;"
typedef void(*PtoF)(int);   // equivalent to "using PtoF = void(*)(int);"
Aliases are used when we want to insulate our code from details of the underlying machine. The name int32_t indicates that we want it to represent a 32-bit integer. Having written our code in terms of int32_t, rather than “plain int,” we can port our code to a machine with sizeof(int)==2 by redefining the single occurrence of int32_t in our code to use a longer integer:

using int32_t = long;
The _t suffix is conventional for aliases (“typedefs”). The int16_t, int32_t, and other such aliases can be found in <stdint> (§43.7). Note that naming a type after its representation rather than its purpose is not necessarily a good idea (§6.3.3).

The using keyword can also be used to introduce a template alias (§23.6). For example:

Click here to view code image

template<typename T>
     using Vector = std::vector<T, My_allocator<T>>;
We cannot apply type specifiers, such as unsigned, to an alias. For example:

Click here to view code image

using Char = char;
using Uchar = unsigned Char;      // error
using Uchar = unsigned char;      // OK
6.6. Advice
[1] For the final word on language definition issues, see the ISO C++ standard; §6.1.

[2] Avoid unspecified and undefined behavior; §6.1.

[3] Isolate code that must depend on implementation-defined behavior; §6.1.

[4] Avoid unnecessary assumptions about the numeric value of characters; §6.2.3.2, §10.5.2.1.

[5] Remember that an integer starting with a 0 is octal; §6.2.4.1.

[6] Avoid “magic constants”; §6.2.4.1.

[7] Avoid unnecessary assumptions about the size of integers; §6.2.8.

[8] Avoid unnecessary assumptions about the range and precision of floating-point types; §6.2.8.

[9] Prefer plain char over signed char and unsigned char; §6.2.3.1.

[10] Beware of conversions between signed and unsigned types; §6.2.3.1.

[11] Declare one name (only) per declaration; §6.3.2.

[12] Keep common and local names short, and keep uncommon and nonlocal names longer; §6.3.3.

[13] Avoid similar-looking names; §6.3.3.

[14] Name an object to reflect its meaning rather than its type; §6.3.3.

[15] Maintain a consistent naming style; §6.3.3.

[16] Avoid ALL_CAPS names; §6.3.3.

[17] Keep scopes small; §6.3.4.

[18] Don’t use the same name in both a scope and an enclosing scope; §6.3.4.

[19] Prefer the {}-initializer syntax for declarations with a named type; §6.3.5.

[20] Prefer the = syntax for the initialization in declarations using auto; §6.3.5.

[21] Avoid uninitialized variables; §6.3.5.1.

[22] Use an alias to define a meaningful name for a built-in type in cases in which the built-in type used to represent a value might change; §6.5.

[23] Use an alias to define synonyms for types; use enumerations and classes to define new types; §6.5.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


6. Types and Declarations
7. Pointers, Arrays, and References
8. Structures, Unions, and Enumerations
47h 26m remaining
7. Pointers, Arrays, and References
The sublime and the ridiculous are often so nearly related that it is difficult to class them separately.

– Thomas Paine

• Introduction

• Pointers

void*; nullptr

• Arrays

Array Initializers; String Literals

• Pointers into Arrays

Navigating Arrays; Multidimensional Arrays; Passing Arrays

• Pointers and const

• Pointers and Ownership

• References

Lvalue References; Rvalue References; References to References; Pointers and References

• Advice

7.1. Introduction
This chapter deals with the basic language mechanisms for referring to memory. Obviously, we can refer to an object by name, but in C++ (most) objects “have identity.” That is, they reside at a specific address in memory, and an object can be accessed if you know its address and its type. The language constructs for holding and using addresses are pointers and references.

7.2. Pointers
For a type T, T * is the type “pointer to T.” That is, a variable of type T* can hold the address of an object of type T. For example:

Click here to view code image

char c = 'a';
char* p = &c;         // p holds the address of c; & is the address-of operator
or graphically:


The fundamental operation on a pointer is dereferencing, that is, referring to the object pointed to by the pointer. This operation is also called indirection. The dereferencing operator is (prefix) unary *. For example:

Click here to view code image

char c = 'a';
char* p = &c;   // p holds the address of c; & is the address-of operator
char c2 = *p;   // c2 == 'a'; * is the dereference operator
The object pointed to by p is c, and the value stored in c is 'a', so the value of *p assigned to c2 is 'a'.

It is possible to perform some arithmetic operations on pointers to array elements (§7.4).

The implementation of pointers is intended to map directly to the addressing mechanisms of the machine on which the program runs. Most machines can address a byte. Those that can’t tend to have hardware to extract bytes from words. On the other hand, few machines can directly address an individual bit. Consequently, the smallest object that can be independently allocated and pointed to using a built-in pointer type is a char. Note that a bool occupies at least as much space as a char (§6.2.8). To store smaller values more compactly, you can use the bitwise logical operations (§11.1.1), bit-fields in structures (§8.2.7), or a bitset (§34.2.2).

The *, meaning “pointer to,” is used as a suffix for a type name. Unfortunately, pointers to arrays and pointers to functions need a more complicated notation:

Click here to view code image

int* pi;              // pointer to int
char* ppc;            // pointer to pointer to char
int* ap[15];          // array of 15 pointers to ints
int (*fp)(char*);     // pointer to function taking a char* argument; returns an int
int* f(char*);        // function taking a char* argument; returns a pointer to int
See §6.3.1 for an explanation of the declaration syntax and §iso.A for the complete grammar.

Pointers to functions can be useful; they are discussed in §12.5. Pointers to class members are presented in §20.6.

7.2.1. void*
In low-level code, we occasionally need to store or pass along an address of a memory location without actually knowing what type of object is stored there. A void* is used for that. You can read void* as “pointer to an object of unknown type.”

A pointer to any type of object can be assigned to a variable of type void*, but a pointer to function (§12.5) or a pointer to member (§20.6) cannot. In addition, a void* can be assigned to another void*, void*s can be compared for equality and inequality, and a void* can be explicitly converted to another type. Other operations would be unsafe because the compiler cannot know what kind of object is really pointed to. Consequently, other operations result in compile-time errors. To use a void*, we must explicitly convert it to a pointer to a specific type. For example:

Click here to view code image

void f(int* pi)
{
    void* pv = pi;   // ok: implicit conversion of int* to void*
    *pv;             // error: can't dereference void*
    ++pv;            // error: can't increment void* (the size of the object pointed to is unknown)

    int* pi2 = static_cast<int* >(pv);           // explicit conversion back to int*

    double* pd1 = pv;                            // error
    double* pd2 = pi;                            // error
    double* pd3 = static_cast<double*>(pv);      // unsafe (§11.5.2)
}
In general, it is not safe to use a pointer that has been converted (“cast”) to a type that differs from the type of the object pointed to. For example, a machine may assume that every double is allocated on an 8-byte boundary. If so, strange behavior could arise if pi pointed to an int that wasn’t allocated that way. This form of explicit type conversion is inherently unsafe and ugly. Consequently, the notation used, static_cast (§11.5.2), was designed to be ugly and easy to find in code.

The primary use for void* is for passing pointers to functions that are not allowed to make assumptions about the type of the object and for returning untyped objects from functions. To use such an object, we must use explicit type conversion.

Functions using void* pointers typically exist at the very lowest level of the system, where real hardware resources are manipulated. For example:

void* my_alloc(size_t n);       // allocate n bytes from my special heap
Occurrences of void*s at higher levels of the system should be viewed with great suspicion because they are likely indicators of design errors. Where used for optimization, void* can be hidden behind a type-safe interface (§27.3.1).

Pointers to functions (§12.5) and pointers to members (§20.6) cannot be assigned to void*s.

7.2.2. nullptr
The literal nullptr represents the null pointer, that is, a pointer that does not point to an object. It can be assigned to any pointer type, but not to other built-in types:

Click here to view code image

int* pi = nullptr;
double* pd = nullptr;
int i = nullptr;        // error: i is not a pointer
There is just one nullptr, which can be used for every pointer type, rather than a null pointer for each pointer type.

Before nullptr was introduced, zero (0) was used as a notation for the null pointer. For example:

int* x = 0;  // x gets the value nullptr
No object is allocated with the address 0, and 0 (the all-zeros bit pattern) is the most common representation of nullptr. Zero (0) is an int. However, the standard conversions (§10.5.2.3) allow 0 to be used as a constant of pointer or pointer-to-member type.

It has been popular to define a macro NULL to represent the null pointer. For example:

int* p = NULL;  // using the macro NULL
However, there are differences in the definition of NULL in different implementations; for example, NULL might be 0 or 0L. In C, NULL is typically (void*)0, which makes it illegal in C++ (§7.2.1):

int* p = NULL;  // error: can't assign a void* to an int*
Using nullptr makes code more readable than alternatives and avoids potential confusion when a function is overloaded to accept either a pointer or an integer (§12.3.1).

7.3. Arrays
For a type T, T[size] is the type “array of size elements of type T.” The elements are indexed from 0 to size–1. For example:

Click here to view code image

float v[3];      // an array of three floats: v[0], v[1], v[2]
char* a[32];     // an array of 32 pointers to char: a[0] .. a[31]
You can access an array using the subscript operator, [], or through a pointer (using operator * or operator []; §7.4). For example:

Click here to view code image

void f()
{
     int aa[10];
     aa[6] = 9;        // assign to aa's 7th element
     int x = aa[99];   // undefined behavior
}
Access out of the range of an array is undefined and usually disastrous. In particular, run-time range checking is neither guaranteed nor common.

The number of elements of the array (not allocated using new), the array bound, must be a constant expression (§10.4). If you need variable bounds, use a vector (§4.4.1, §31.4). For example:

Click here to view code image

void f(int n)
{
     int v1[n];           // error: array size not a constant expression
     vector<int> v2(n);   // OK: vector with n int elements
}
Multidimensional arrays are represented as arrays of arrays (§7.4.2).

An array is C++’s fundamental way of representing a sequence of objects in memory. If what you want is a simple fixed-length sequence of objects of a given type in memory, an array is the ideal solution. For every other need, an array has serious problems.

An array can be allocated statically, on the stack, and on the free store (§6.4.2). For example:

Click here to view code image

int a1[10];                 //10 ints in static storage

void f()
{
     int a2 [20];           //20 ints on the stack
     int*p = new int[40];   //40 ints on the free store
      //...
}
The C++ built-in array is an inherently low-level facility that should primarily be used inside the implementation of higher-level, better-behaved, data structures, such as the standard-library vector or array. There is no array assignment, and the name of an array implicitly converts to a pointer to its first element at the slightest provocation (§7.4). In particular, avoid arrays in interfaces (e.g., as function arguments; §7.4.3, §12.2.2) because the implicit conversion to pointer is the root cause of many common errors in C code and C-style C++ code. If you allocate an array on the free store, be sure to delete[] its pointer once only and only after its last use (§11.2.2). That’s most easily and most reliably done by having the lifetime of the free-store array controlled by a resource handle (e.g., string (§19.3, §36.3), vector (§13.6, §34.2), or unique_ptr (§34.3.1)). If you allocate an array statically or on the stack, be sure never to delete[] it. Obviously, C programmers cannot follow these pieces of advice because C lacks the ability to encapsulate arrays, but that doesn’t make the advice bad in the context of C++.

One of the most widely used kinds of arrays is a zero-terminated array of char. That’s the way C stores strings, so a zero-terminated array of char is often called a C-style string. C++ string literals follow that convention (§7.3.2), and some standard-library functions (e.g., strcpy() and strcmp(); §43.4) rely on it. Often, a char* or a const char* is assumed to point to a zero-terminated sequence of characters.

7.3.1. Array Initializers
An array can be initialized by a list of values. For example:

int v1[] = { 1, 2, 3, 4 };
char v2[] = { 'a', 'b', 'c', 0 };
When an array is declared without a specific size, but with an initializer list, the size is calculated by counting the elements of the initializer list. Consequently, v1 and v2 are of type int[4] and char[4], respectively. If a size is explicitly specified, it is an error to give surplus elements in an initializer list. For example:

Click here to view code image

char v3[2] = { 'a', 'b', 0 };        // error: too many initializers
char v4[3] = { 'a', 'b', 0 };        // OK
If the initializer supplies too few elements for an array, 0 is used for the rest. For example:

int v5[8] = { 1, 2, 3, 4 };
is equivalent to

int v5[] = { 1, 2, 3, 4 , 0, 0, 0, 0 };
There is no built-in copy operation for arrays. You cannot initialize one array with another (not even of exactly the same type), and there is no array assignment:

Click here to view code image

int v6[8] = v5;   // error: can't copy an array (cannot assign an int* to an array)
v6 = v5;          // error: no array assignment
Similarly, you can’t pass arrays by value. See also §7.4.

When you need assignment to a collection of objects, use a vector (§4.4.1, §13.6, §34.2), an array (§8.2.4), or a valarray (§40.5) instead.

An array of characters can be conveniently initialized by a string literal (§7.3.2).

7.3.2. String Literals
A string literal is a character sequence enclosed within double quotes:

"this is a string"
A string literal contains one more character than it appears to have; it is terminated by the null character, '\0', with the value 0. For example:

sizeof("Bohr")==5
The type of a string literal is “array of the appropriate number of const characters,” so "Bohr" is of type const char[5].

In C and in older C++ code, you could assign a string literal to a non-const char*:

Click here to view code image

void f()
{
    char* p = "Plato";   // error, but accepted in pre-C++11-standard code
    p[4] = 'e';          // error: assignment to const
}
It would obviously be unsafe to accept that assignment. It was (and is) a source of subtle errors, so please don’t grumble too much if some old code fails to compile for this reason. Having string literals immutable is not only obvious but also allows implementations to do significant optimizations in the way string literals are stored and accessed.

If we want a string that we are guaranteed to be able to modify, we must place the characters in a non-const array:

Click here to view code image

void f()
{
    char p[] = "Zeno";   // p is an array of 5 char
    p[0] = 'R';          // OK
}
A string literal is statically allocated so that it is safe to return one from a function. For example:

const char* error_message(int i)
{
     //...
    return "range error";
}
The memory holding "range error" will not go away after a call of error_message().

Whether two identical string literals are allocated as one array or as two is implementation-defined (§6.1). For example:

Click here to view code image

const char* p = "Heraclitus";
const char* q = "Heraclitus";

void g()
{
     if (p == q) cout << "one!\n";         // the result is implementation-defined
      //...
}
Note that == compares addresses (pointer values) when applied to pointers, and not the values pointed to.

The empty string is written as a pair of adjacent double quotes, "", and has the type const char[1]. The one character of the empty string is the terminating '\0'.

The backslash convention for representing nongraphic characters (§6.2.3.2) can also be used within a string. This makes it possible to represent the double quote (") and the escape character backslash (\) within a string. The most common such character by far is the newline character, '\n'. For example:

cout<<"beep at end of message\a\n";
The escape character, '\a', is the ASCII character BEL (also known as alert), which causes a sound to be emitted.

It is not possible to have a “real” newline in a (nonraw) string literal:

"this is not a string
but a syntax error"
Long strings can be broken by whitespace to make the program text neater. For example:

Click here to view code image

char alpha[] = "abcdefghijklmnopqrstuvwxyz"
               "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
The compiler will concatenate adjacent strings, so alpha could equivalently have been initialized by the single string

"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
It is possible to have the null character in a string, but most programs will not suspect that there are characters after it. For example, the string "Jens\000Munk" will be treated as "Jens" by standard-library functions such as strcpy() and strlen(); see §43.4.

7.3.2.1. Raw Character Strings
To represent a backslash (\) or a double quote (") in a string literal, we have to precede it with a backslash. That’s logical and in most cases quite simple. However, if we need a lot of backslashes and a lot of quotes in string literals, this simple technique becomes unmanageable. In particular, in regular expressions a backslash is used both as an escape character and to introduce characters representing character classes (§37.1.1). This is a convention shared by many programming languages, so we can’t just change it. Therefore, when you write regular expressions for use with the standard regex library (Chapter 37), the fact that a backslash is an escape character becomes a notable source of errors. Consider how to write the pattern representing two words separated by a backslash (\):

string s = "\\w+\\\\\\w+";     // I hope I got that right
To prevent the frustration and errors caused by this clash of conventions, C++ provides raw string literals. A raw string literal is a string literal where a backslash is just a backslash (and a double quote is just a double quote) so that our example becomes:

string s = R"(\w+\\\w+)";     // I'm pretty sure I got that right
Raw string literals use the R"(ccc)" notation for a sequence of characters ccc. The initial R is there to distinguish raw string literals from ordinary string literals. The parentheses are there to allow (“unescaped”) double quotes. For example:

R"("quoted string")"       // the string is "quoted string"
So, how do we get the character sequence )" into a raw string literal? Fortunately, that’s a rare problem, but "( and )" is only the default delimiter pair. We can add delimiters before the ( and after the ) in "(...)". For example:

Click here to view code image

R"***("quoted string containing the usual terminator ("))")***"
      //"quoted string containing the usual terminator ("))"
The character sequence after the ) must be identical to the sequence before the (. This way we can cope with (almost) arbitrarily complicated patterns.

Unless you work with regular expressions, raw string literals are probably just a curiosity (and one more thing to learn), but regular expressions are useful and widely used. Consider a real-world example:

"('(?:[^\\\\']|\\\\.)*'|\"(?:[^\\\\\"]|\\\\.)*\")|"     // Are the five backslashes correct or not?
With examples like that, even experts easily become confused, and raw string literals provide a significant service.

In contrast to nonraw string literals, a raw string literal can contain a newline. For example:

string counts {R"(1
22
333)"};
is equivalent to

string counts {"1\n22\n333"};
7.3.2.2. Larger Character Sets
A string with the prefix L, such as L"angst", is a string of wide characters (§6.2.3). Its type is const wchar_t[]. Similarly, a string with the prefix LR, such as LR"(angst)", is a raw string (§7.3.2.1) of wide characters of type const wchar_t[]. Such a string is terminated by a L'\0' character.

There are six kinds of character literals supporting Unicode (Unicode literals). This sounds excessive, but there are three major encodings of Unicode: UTF-8, UTF-16, and UTF-32. For each of these three alternatives, both raw and “ordinary” strings are supported. All three UTF encodings support all Unicode characters, so which you use depends on the system you need to fit into. Essentially all Internet applications (e.g., browsers and email) rely on one or more of these encodings.

UTF-8 is a variable-width encoding: common characters fit into 1 byte, less frequently used characters (by some estimate of use) into 2 bytes, and rarer characters into 3 or 4 bytes. In particular, the ASCII characters fit into 1 byte with the same encodings (integer values) in UTF-8 as in ASCII. The various Latin alphabets, Greek, Cyrillic, Hebrew, Arabic, and more fit into 2 bytes.

A UTF-8 string is terminated by '\0', a UTF-16 string by u'\0', and a UTF-32 string by U'\0'.

We can represent an ordinary English character string in a variety of ways. Consider a file name using a backslash as the separator:

Click here to view code image

"folder\\file"        // implementation character set string
R"(folder\file)"      // implementation character raw set string
u8"folder\\file"      // UTF-8 string
u8R"(folder\file)"    // UTF-8 raw string
u"folder\\file"       // UTF-16 string
uR"(folder\file)"          // UTF-16 raw string
U"folder\\file"       // UTF-32 string
UR"(folder\file)"          // UTF-32 raw string
If printed, these strings will all look the same, but except for the “plain” and UTF-8 strings their internal representations are likely to differ.

Obviously, the real purpose of Unicode strings is to be able to put Unicode characters into them. For example:

u8"The official vowels in Danish are: a, e, i, o, u, \u00E6, \u00F8, \u00E5 and y."
Printing that string appropriately gives you

The official vowels in Danish are: a, e, i, o, u, æ, ø, å and y.
The hexadecimal number after the \u is a Unicode code point (§iso.2.14.3) [Unicode,1996]. Such a code point is independent of the encoding used and will in fact have different representations (as bits in bytes) in different encodings. For example, u'0430' (Cyrillic lowercase letter “a”) is the 2-byte hexadecimal value D0B0 in UTF-8, the 2-byte hexadecimal value 0430 in UTF-16, and the 4-byte hexadecimal value 00000430 in UTF-32. These hexadecimal values are referred to as universal character names.

The order of the us and Rs and their cases are significant: RU and Ur are not valid string prefixes.

7.4. Pointers into Arrays
In C++, pointers and arrays are closely related. The name of an array can be used as a pointer to its initial element. For example:

Click here to view code image

int v[] = { 1, 2, 3, 4 };
int* p1 = v;             // pointer to initial element (implicit conversion)
int* p2 = &v[0];         // pointer to initial element
int* p3 = v+4;           // pointer to one-beyond-last element
or graphically:


Taking a pointer to the element one beyond the end of an array is guaranteed to work. This is important for many algorithms (§4.5, §33.1). However, since such a pointer does not in fact point to an element of the array, it may not be used for reading or writing. The result of taking the address of the element before the initial element or beyond one-past-the-last element is undefined and should be avoided. For example:

Click here to view code image

int* p4 = v–1;  // before the beginning, undefined: don't do it
int* p5 = v+7;  // beyond the end, undefined: don't do it
The implicit conversion of an array name to a pointer to the initial element of the array is extensively used in function calls in C-style code. For example:

Click here to view code image

extern "C" int strlen(const char*);        // from <string.h>

void f()
{
     char v[] = "Annemarie";
     char* p = v;    // implicit conversion of char[] to char*
     strlen(p);
     strlen(v);      // implicit conversion of char[] to char*
     v = p;          // error: cannot assign to array
}
The same value is passed to the standard-library function strlen() in both calls. The snag is that it is impossible to avoid the implicit conversion. In other words, there is no way of declaring a function so that the array v is copied when the function is called. Fortunately, there is no implicit or explicit conversion from a pointer to an array.

The implicit conversion of the array argument to a pointer means that the size of the array is lost to the called function. However, the called function must somehow determine the size to perform a meaningful operation. Like other C standard-library functions taking pointers to characters, strlen() relies on zero to indicate end-of-string; strlen(p) returns the number of characters up to and not including the terminating 0. This is all pretty low-level. The standard-library vector (§4.4.1, §13.6, §31.4), array (§8.2.4, §34.2.1), and string (§4.2) don’t suffer from this problem. These library types give their number of elements as their size() without having to count elements each time.

7.4.1. Navigating Arrays
Efficient and elegant access to arrays (and similar data structures) is the key to many algorithms (see §4.5, Chapter 32). Access can be achieved either through a pointer to an array plus an index or through a pointer to an element. For example:

void fi(char v[])
{
     for (int i = 0; v[i]!=0; ++i)
           use(v[i]);
}

void fp(char v[])
{
     for (char* p = v; *p!=0; ++p)
           use(*p);
}
The prefix * operator dereferences a pointer so that *p is the character pointed to by p, and ++ increments the pointer so that it refers to the next element of the array.

There is no inherent reason why one version should be faster than the other. With modern compilers, identical code should be (and usually is) generated for both examples. Programmers can choose between the versions on logical and aesthetic grounds.

Subscripting a built-in array is defined in terms of the pointer operations + and *. For every built-in array a and integer j within the range of a, we have:

a[j] == *(&a[0]+j) == *(a+j) == *(j+a) == j[a]
It usually surprises people to find that a[j]==j[a]. For example, 3["Texas"]=="Texas"[3]=='a'. Such cleverness has no place in production code. These equivalences are pretty low-level and do not hold for standard-library containers, such as array and vector.

The result of applying the arithmetic operators +, –, ++, or –– to pointers depends on the type of the object pointed to. When an arithmetic operator is applied to a pointer p of type T*, p is assumed to point to an element of an array of objects of type T; p+1 points to the next element of that array, and p–1 points to the previous element. This implies that the integer value of p+1 will be sizeof(T) larger than the integer value of p. For example:

Click here to view code image

template<typename T>
int byte_diff(T* p, T* q)
{
     return reinterpret_cast<char *>(q)–reinterpret_cast<char*>(p);
}

void diff_test()
{
     int vi[10];
     short vs[10];
     cout << vi << ' ' << &vi[1] << ' ' << &vi[1]–&vi[0] << ' ' << byte_diff(&vi[0],&vi[1]) << '\n';
     cout << vs << ' ' << &vs[1] << ' ' << &vs[1]–&vs[0] << ' ' << byte_diff(&vs[0],&vs[1]) << '\n';
}
This produced:

0x7fffaef0 0x7fffaef4 1 4
0x7fffaedc 0x7fffaede 1 2
The pointer values were printed using the default hexadecimal notation. This shows that on my implementation, sizeof(short) is 2 and sizeof(int) is 4.

Subtraction of pointers is defined only when both pointers point to elements of the same array (although the language has no fast way of ensuring that is the case). When subtracting a pointer p from another pointer q, q–p, the result is the number of array elements in the sequence [p:q) (an integer). One can add an integer to a pointer or subtract an integer from a pointer; in both cases, the result is a pointer value. If that value does not point to an element of the same array as the original pointer or one beyond, the result of using that value is undefined. For example:

Click here to view code image

void f()
{
     int v1[10];
     int v2[10];

     int i1 = &v1[5]–&v1[3];     // i1 = 2
     int i2 = &v1[5]–&v2[3];     // result undefined

     int* p1 = v2+2;             // p1 = &v2[2]
     int* p2 = v2–2;             //*p2 undefined
}
Complicated pointer arithmetic is usually unnecessary and best avoided. Addition of pointers makes no sense and is not allowed.

Arrays are not self-describing because the number of elements of an array is not guaranteed to be stored with the array. This implies that to traverse an array that does not contain a terminator the way C-style strings do, we must somehow supply the number of elements. For example:

Click here to view code image

void fp(char v[], int size)
{
     for (int i=0; i!=size; ++i)
           use(v[i]);              // hope that v has at least size elements
     for (int x : v)
           use(x);                 // error: range-for does not work for pointers

     const int N = 7;
     char v2[N];
     for (int i=0; i!=N; ++i)
           use(v2[i]);
     for (int x : v2)
           use(x);                 // range-for works for arrays of known size
}
This array concept is inherently low-level. Most advantages of the built-in array and few of the disadvantages can be obtained through the use of the standard-library container array (§8.2.4, §34.2.1). Some C++ implementations offer optional range checking for arrays. However, such checking can be quite expensive, so it is often used only as a development aid (rather than being included in production code). If you are not using range checking for individual accesses, try to maintain a consistent policy of accessing elements only in well-defined ranges. That is best done when arrays are manipulated through the interface of a higher-level container type, such as vector, where it is harder to get confused about the range of valid elements.

7.4.2. Multidimensional Arrays
Multidimensional arrays are represented as arrays of arrays; a 3-by-5 array is declared like this:

int ma[3][5];    //3 arrays with 5 ints each
We can initialize ma like this:

void init_ma()
{
     for (int i = 0; i!=3; i++)
          for (int j = 0; j!=5; j++)
                ma[i][j] = 10*i+j;
}
or graphically:


The array ma is simply 15 ints that we access as if it were 3 arrays of 5 ints. In particular, there is no single object in memory that is the matrix ma – only the elements are stored. The dimensions 3 and 5 exist in the compiler source only. When we write code, it is our job to remember them somehow and supply the dimensions where needed. For example, we might print ma like this:

Click here to view code image

void print_ma()
{
     for (int i = 0; i!=3; i++) {
          for (int j = 0; j!=5; j++)
                cout << ma[i][j] << '\t';
          cout << '\n';
    }
}
The comma notation used for array bounds in some languages cannot be used in C++ because the comma (,) is a sequencing operator (§10.3.2). Fortunately, most mistakes are caught by the compiler. For example:

Click here to view code image

int bad[3,5];             // error: comma not allowed in constant expression
int good[3][5];           //3 arrays with 5 ints each
int ouch = good[1,4];     // error: int initialized by int* (good[1,4] means good[4], which is an int*)
int nice = good[1][4];
7.4.3. Passing Arrays
Arrays cannot directly be passed by value. Instead, an array is passed as a pointer to its first element. For example:

Click here to view code image

void comp(double arg[10])           // arg is a double* 
{
     for (int i=0; i!=10; ++i)
           arg[i]+=99;
}
void f()
{
     double a1[10];
     double a2[5];
     double a3[100];

     comp(a1);
     comp(a2);      // disaster!
     comp(a3);      // uses only the first 10 elements
};
This code looks sane, but it is not. The code compiles, but the call comp(a2) will write beyond the bounds of a2. Also, anyone who guessed that the array was passed by value will be disappointed: the writes to arg[i] are writes directly to the elements of comp()’s argument, rather than to a copy. The function could equivalently have been written as

void comp(double* arg)
{
     for (int i=0; i!=10; ++i)
           arg[i]+=99;
}
Now the insanity is (hopefully) obvious. When used as a function argument, the first dimension of an array is simply treated as a pointer. Any array bound specified is simply ignored. This implies that if you want to pass a sequence of elements without losing size information, you should not pass a built-in array. Instead, you can place the array inside a class as a member (as is done for std::array) or define a class that acts as a handle (as is done for std::string and std::vector).

If you insist on using arrays directly, you will have to deal with bugs and confusion without getting noticeable advantages in return. Consider defining a function to manipulate a two-dimensional matrix. If the dimensions are known at compile time, there is no problem:

Click here to view code image

void print_m35(int m[3][5])
{
     for (int i = 0; i!=3; i++) {
           for (int j = 0; j!=5; j++)
                 cout << m[i][j] << '\t';
           cout << '\n';
     }
}
A matrix represented as a multidimensional array is passed as a pointer (rather than copied; §7.4). The first dimension of an array is irrelevant to finding the location of an element; it simply states how many elements (here, 3) of the appropriate type (here, int[5]) are present. For example, look at the layout of ma above and note that by knowing only that the second dimension is 4, we can locate ma[i][4] for any i. The first dimension can therefore be passed as an argument:

void print_mi5(int m[][5], int dim1)
{
     for (int i = 0; i!=dim1; i++) {
           for (int j = 0; j!=5; j++)
                 cout << m[i][j] << '\t';
           cout << '\n';
     }
}
When both dimensions need to be passed, the “obvious solution” does not work:

Click here to view code image

void print_mij(int m[][], int dim1, int dim2)      // doesn't behave as most people would think
{
     for (int i = 0; i!=dim1; i++) {
           for (int j = 0; j!=dim2; j++)
                 cout << m[i][j] << '\t';     // surprise!
           cout << '\n';
     }
}
Fortunately, the argument declaration m[][] is illegal because the second dimension of a multidimensional array must be known in order to find the location of an element. However, the expression m[i][j] is (correctly) interpreted as *(*(m+i)+j), although that is unlikely to be what the programmer intended. A correct solution is:

Click here to view code image

void print_mij(int* m, int dim1, int dim2)
{
    for (int i = 0; i!=dim1; i++) {
          for (int j = 0; j!=dim2; j++)
                cout << m[i*dim2+j] << '\t';  // obscure
          cout << '\n';
    }
}
The expression used for accessing the members in print_mij() is equivalent to the one the compiler generates when it knows the last dimension.

To call this function, we pass a matrix as an ordinary pointer:

Click here to view code image

int test()
{
    int v[3][5] = {
          {0,1,2,3,4}, {10,11,12,13,14}, {20,21,22,23,24}
    };
    print_m35(v);
    print_mi5(v,3);
    print_mij(&v[0][0],3,5);
}
Note the use of &v[0][0] for the last call; v[0] would do because it is equivalent, but v would be a type error. This kind of subtle and messy code is best hidden. If you must deal directly with multidimensional arrays, consider encapsulating the code relying on it. In that way, you might ease the task of the next programmer to touch the code. Providing a multidimensional array type with a proper subscripting operator saves most users from having to worry about the layout of the data in the array (§29.2.2, §40.5.2).

The standard vector (§31.4) doesn’t suffer from these problems.

7.5. Pointers and const
C++ offers two related meanings of “constant”:

• constexpr: Evaluate at compile time (§2.2.3, §10.4).

• const: Do not modify in this scope (§2.2.3).

Basically, constexpr’s role is to enable and ensure compile-time evaluation, whereas const’s primary role is to specify immutability in interfaces. This section is primarily concerned with the second role: interface specification.

Many objects don’t have their values changed after initialization:

• Symbolic constants lead to more maintainable code than using literals directly in code.

• Many pointers are often read through but never written through.

• Most function parameters are read but not written to.

To express this notion of immutability after initialization, we can add const to the definition of an object. For example:

Click here to view code image

const int model = 90;                 // model is a const
const int v[] = { 1, 2, 3, 4 };       // v[i] is a const
const int x;                          // error: no initializer
Because an object declared const cannot be assigned to, it must be initialized.

Declaring something const ensures that its value will not change within its scope:

void f()
{
     model = 200;      // error
     v[2] = 3;         // error
}
Note that const modifies a type; it restricts the ways in which an object can be used, rather than specifying how the constant is to be allocated. For example:

Click here to view code image

void g(const X* p)
{
      // can't modify *p here
}
void h()
{
     X val;        // val can be modified here
     g(&val);
      //...
}
When using a pointer, two objects are involved: the pointer itself and the object pointed to. “Prefixing” a declaration of a pointer with const makes the object, but not the pointer, a constant. To declare a pointer itself, rather than the object pointed to, to be a constant, we use the declarator operator *const instead of plain *. For example:

Click here to view code image

void f1(char* p)
{
     char s[] = "Gorm";

     const char* pc = s;            // pointer to constant
     pc[3] = 'g';                   // error: pc points to constant
     pc = p;                        // OK

     char *const cp = s;            // constant pointer
     cp[3] = 'a';                   // OK
     cp = p;                        // error: cp is constant

     const char *const cpc = s;     // const pointer to const
     cpc[3] = 'a';                  // error: cpc points to constant
     cpc = p;                       // error: cpc is constant
}
The declarator operator that makes a pointer constant is *const. There is no const* declarator operator, so a const appearing before the * is taken to be part of the base type. For example:

Click here to view code image

char *const cp;          // const pointer to char
char const* pc;          // pointer to const char
const char* pc2;         // pointer to const char
Some people find it helpful to read such declarations right-to-left, for example, “cp is a const pointer to a char” and “pc2 is a pointer to a char const.”

An object that is a constant when accessed through one pointer may be variable when accessed in other ways. This is particularly useful for function arguments. By declaring a pointer argument const, the function is prohibited from modifying the object pointed to. For example:

Click here to view code image

const char* strchr(const char* p, char c);     // find first occurrence of c in p
char* strchr(char* p, char c);                 // find first occurrence of c in p
The first version is used for strings where the elements mustn’t be modified and returns a pointer to const that does not allow modification. The second version is used for mutable strings.

You can assign the address of a non-const variable to a pointer to constant because no harm can come from that. However, the address of a constant cannot be assigned to an unrestricted pointer because this would allow the object’s value to be changed. For example:

Click here to view code image

void f4()
{
     int a = 1;
     const int c = 2;
     const int* p1 = &c;  // OK
     const int* p2 = &a;  // OK
     int* p3 = &c;        // error: initialization of int* with const int*
     *p3 = 7;             // try to change the value of c
}
It is possible, but typically unwise, to explicitly remove the restrictions on a pointer to const by explicit type conversion (§16.2.9, §11.5).

7.6. Pointers and Ownership
A resource is something that has to be acquired and later released (§5.2). Memory acquired by new and released by delete (§11.2) and files opened by fopen() and closed by fclose() (§43.2) are examples of resources where the most direct handle to the resource is a pointer. This can be most confusing because a pointer is easily passed around in a program, and there is nothing in the type system that distinguishes a pointer that owns a resource from one that does not. Consider:

void confused(int* p)
{
      // delete p?
}

int global {7};

void f()
{
     X* pn = new int{7};
     int i {7};
     int* q = &i;
     confused(pn);
     confused(q);
     confused(&global);
}
If confused() deletes p the program will seriously misbehave for the second two calls because we may not delete objects not allocated by new (§11.2). If confused() does not delete p the program leaks (§11.2.1). In this case, obviously f() must manage the lifetime of the object it creates on the free store, but in general keeping track of what needs to be deleted in a large program requires a simple and consistent strategy.

It is usually a good idea to immediately place a pointer that represents ownership in a resource handle class, such as vector, string, and unique_ptr. That way, we can assume that every pointer that is not within a resource handle is not an owner and must not be deleted. Chapter 13 discusses resource management in greater detail.

7.7. References
A pointer allows us to pass potentially large amounts of data around at low cost: instead of copying the data we simply pass its address as a pointer value. The type of the pointer determines what can be done to the data through the pointer. Using a pointer differs from using the name of an object in a few ways:

• We use a different syntax, for example, *p instead of obj and p–>m rather than obj.m.

• We can make a pointer point to different objects at different times.

• We must be more careful when using pointers than when using an object directly: a pointer may be a nullptr or point to an object that wasn’t the one we expected.

These differences can be annoying; for example, some programmers find f(&x) ugly compared to f(x). Worse, managing pointer variables with varying values and protecting code against the possibility of nullptr can be a significant burden. Finally, when we want to overload an operator, say +, we want to write x+y rather than &x+&y. The language mechanism addressing these problems is called a reference. Like a pointer, a reference is an alias for an object, is usually implemented to hold a machine address of an object, and does not impose performance overhead compared to pointers, but it differs from a pointer in that:

• You access a reference with exactly the same syntax as the name of an object.

• A reference always refers to the object to which it was initialized.

• There is no “null reference,” and we may assume that a reference refers to an object (§7.7.4).

A reference is an alternative name for an object, an alias. The main use of references is for specifying arguments and return values for functions in general and for overloaded operators (Chapter 18) in particular. For example:

Click here to view code image

template<typename T>
class vector {
     T* elem;
     // ...
public:
     T& operator[](int i) { return elem[i]; }              // return reference to element
     const T& operator[](int i) const { return elem[i]; }  // return reference to const element

     void push_back(const T& a);                           // pass element to be added by reference
     // ...
};

void f(vector<double>& v)
{
     double d1 = v[1];    // copy the value of the double referred to by v.operator[](1) into d1
     v[2] = 7;            // place 7 in the double referred to by the result of v.operator[](2)

     v.push_back(d1);     // give push_back() a reference to d1 to work with
}
The idea of passing function arguments by reference is as old as high-level programming languages (the first version of Fortran used that).

To reflect the lvalue/rvalue and const/non-const distinctions, there are three kinds of references:

• lvalue references: to refer to objects whose value we want to change

• const references: to refer to objects whose value we do not want to change (e.g., a constant)

• rvalue references: to refer to objects whose value we do not need to preserve after we have used it (e.g., a temporary)

Collectively, they are called references. The first two are both called lvalue references.

7.7.1. Lvalue References
In a type name, the notation X& means “reference to X.” It is used for references to lvalues, so it is often called an lvalue reference. For example:

Click here to view code image

void f()
{
     int var = 1;
     int& r {var};     // r and var now refer to the same int
     int x = r;        // x becomes 1

     r = 2;            // var becomes 2
}
To ensure that a reference is a name for something (that is, that it is bound to an object), we must initialize the reference. For example:

Click here to view code image

int var = 1;
int& r1 {var};       // OK: r1 initialized
int& r2;             // error: initializer missing
extern int& r3;      // OK: r3 initialized elsewhere
Initialization of a reference is something quite different from assignment to it. Despite appearances, no operator operates on a reference. For example:

Click here to view code image

void g()
{
     int var = 0;
     int& rr {var};
     ++rr;                // var is incremented to 1
     int* pp = &rr;       // pp points to var
}
Here, ++rr does not increment the reference rr; rather, ++ is applied to the int to which rr refers, that is, to var. Consequently, the value of a reference cannot be changed after initialization; it always refers to the object it was initialized to denote. To get a pointer to the object denoted by a reference rr, we can write &rr. Thus, we cannot have a pointer to a reference. Furthermore, we cannot define an array of references. In that sense, a reference is not an object.

The obvious implementation of a reference is as a (constant) pointer that is dereferenced each time it is used. It doesn’t do much harm to think about references that way, as long as one remembers that a reference isn’t an object that can be manipulated the way a pointer is:


In some cases, the compiler can optimize away a reference so that there is no object representing that reference at run time.

Initialization of a reference is trivial when the initializer is an lvalue (an object whose address you can take; see §6.4). The initializer for a “plain” T& must be an lvalue of type T.

The initializer for a const T& need not be an lvalue or even of type T. In such cases:

[1] First, implicit type conversion to T is applied if necessary (see §10.5).

[2] Then, the resulting value is placed in a temporary variable of type T.

[3] Finally, this temporary variable is used as the value of the initializer. Consider:

Click here to view code image

double& dr = 1;               // error: lvalue needed
const double& cdr {1};        // OK
The interpretation of this last initialization might be:

Click here to view code image

double temp = double{1};      // first create a temporary with the right value
const double& cdr {temp};     // then use the temporary as the initializer for cdr
A temporary created to hold a reference initializer persists until the end of its reference’s scope.

References to variables and references to constants are distinguished because introducing a temporary for a variable would have been highly error-prone; an assignment to the variable would become an assignment to the – soon-to-disappear – temporary. No such problem exists for references to constants, and references to constants are often important as function arguments (§18.2.4).

A reference can be used to specify a function argument so that the function can change the value of an object passed to it. For example:

void increment(int& aa)
{
     ++aa;
}

void f()
{
     int x = 1;
     increment(x);       // x = 2
}
The semantics of argument passing are defined to be those of initialization, so when called, increment’s argument aa became another name for x. To keep a program readable, it is often best to avoid functions that modify their arguments. Instead, you can return a value from the function explicitly:

int next(int p) { return p+1; }

void g()
{
     int x = 1;
     increment(x);        // x = 2
     x = next(x);         // x = 3
}
The increment(x) notation doesn’t give a clue to the reader that x’s value is being modified, the way x=next(x) does. Consequently, “plain” reference arguments should be used only where the name of the function gives a strong hint that the reference argument is modified.

References can also be used as return types. This is mostly used to define functions that can be used on both the left-hand and right-hand sides of an assignment. A Map is a good example. For example:

Click here to view code image

template<typename K, typename V>
class Map {          // a simple map class
public:
     V& operator[](const K& v);       // return the value corresponding to the key v

     pair<K,V>* begin() { return &elem[0]; }
     pair<K,V>* end() { return &elem[0]+elem.size(); }
private:
     vector<pair<K,V>> elem;          //{key,value} pairs
};
The standard-library map (§4.4.3, §31.4.3) is typically implemented as a red-black tree, but to avoid distracting implementation details, I’ll just show an implementation based on linear search for a key match:

Click here to view code image

template<typename K, typename V>
V& Map<K,V>::operator[](const K& k)
{
    for (auto& x : elem)
          if (k == x.first)
                return x.second;

    elem.push_back({k,V{}});      // add pair at end (§4.4.2)
    return elem.back().second;    // return the (default) value of the new element
}
I pass the key argument, k, by reference because it might be of a type that is expensive to copy. Similarly, I return the value by reference because it too might be of a type that is expensive to copy. I use a const reference for k because I don’t want to modify it and because I might want to use a literal or a temporary object as an argument. I return the result by non-const reference because the user of a Map might very well want to modify the found value. For example:

Click here to view code image

int main()  // count the number of occurrences of each word on input
{
     Map<string,int> buf;

     for (string s; cin>>s;) ++buf[s];

     for (const auto& x : buf)
           cout << x.first << ": " << x.second << '\n';
}
Each time around, the input loop reads one word from the standard input stream cin into the string s (§4.3.2) and then updates the counter associated with it. Finally, the resulting table of different words in the input, each with its number of occurrences, is printed. For example, given the input

aa bb bb aa aa bb aa aa
this program will produce

aa: 5
bb: 3
The range-for loop works for this because Map defined begin() and end(), just as is done for the standard-library map.

7.7.2. Rvalue References
The basic idea of having more than one kind of reference is to support different uses of objects:

• A non-const lvalue reference refers to an object, to which the user of the reference can write.

• A const lvalue reference refers to a constant, which is immutable from the point of view of the user of the reference.

• An rvalue reference refers to a temporary object, which the user of the reference can (and typically will) modify, assuming that the object will never be used again.

We want to know if a reference refers to a temporary, because if it does, we can sometimes turn an expensive copy operation into a cheap move operation (§3.3.2, §17.1, §17.5.2). An object (such as a string or a list) that is represented by a small descriptor pointing to a potentially huge amount of information can be simply and cheaply moved if we know that the source isn’t going to be used again. The classic example is a return value where the compiler knows that a local variable returned will never again be used (§3.3.2).

An rvalue reference can bind to an rvalue, but not to an lvalue. In that, an rvalue reference is exactly opposite to an lvalue reference. For example:

Click here to view code image

string var {"Cambridge"};
string f();

string& r1 {var};               // lvalue reference, bind r1 to var (an lvalue)
string& r2 {f()};               // lvalue reference, error: f() is an rvalue
string& r3 {"Princeton"};       // lvalue reference, error: cannot bind to temporary
string&& rr1 {f()};             // rvalue reference, fine: bind rr1 to rvalue (a temporary)
string&& rr2 {var};             // rvalue reference, error: var is an lvalue
string&& rr3 {"Oxford"};        // rr3 refers to a temporary holding "Oxford"

const string& cr1 {"Harvard"};  // OK: make temporary and bind to cr1
The && declarator operator means “rvalue reference.” We do not use const rvalue references; most of the benefits from using rvalue references involve writing to the object to which it refers. Both a const lvalue reference and an rvalue reference can bind to an rvalue. However, the purposes will be fundamentally different:

• We use rvalue references to implement a “destructive read” for optimization of what would otherwise have required a copy.

• We use a const lvalue reference to prevent modification of an argument.

An object referred to by an rvalue reference is accessed exactly like an object referred to by an lvalue reference or an ordinary variable name. For example:

string f(string&& s)
{
     if (s.size())
            s[0] = toupper(s[0]);
     return s;
}
Sometimes, a programmer knows that an object won’t be used again, even though the compiler does not. Consider:

Click here to view code image

template<typename T>
void swap(T& a, T& b)          //"old-style swap"
{
    T tmp {a}; // now we have two copies of a
    a = b;     // now we have two copies of b
    b = tmp;   // now we have two copies of tmp (aka a)
}
If T is a type for which it can be expensive to copy elements, such as string and vector, this swap() becomes an expensive operation. Note something curious: we didn’t want any copies at all; we just wanted to move the values of a, b, and tmp around. We can tell that to the compiler:

Click here to view code image

template<typename T>
void swap(T& a, T& b)     //"perfect swap" (almost)
{
     T tmp {static_cast<T&&>(a)};  // the initialization may write to a
     a = static_cast<T&&>(b);      // the assignment may write to b
     b = static_cast<T&&>(tmp);    // the assignment may write to tmp
}
The result value of static_cast<T&&>(x) is an rvalue of type T&& for x. An operation that is optimized for rvalues can now use its optimization for x. In particular, if a type T has a move constructor (§3.3.2, §17.5.2) or a move assignment, it will be used. Consider vector:

Click here to view code image

template<typename T> class vector {
     //...
    vector(const vector& r);  // copy constructor (copy r's representation)
    vector(vector&& r);       // move constructor ("steal" representation from r)
};

vector<string> s;
vector<string> s2 {s};             // s is an lvalue, so use copy constructor
vector<string> s3 {s+"tail"};      // s+"tail" is an rvalue so pick move constructor
The use of static_cast in swap() is a bit verbose and slightly prone to mistyping, so the standard library provides a move() function: move(x) means static_cast<X&&>(x) where X is the type of x. Given that, we can clean up the definition of swap() a bit:

Click here to view code image

template<typename T>
void swap(T& a, T& b)     //"perfect swap" (almost)
{
    T tmp {move(a)};      // move from a
    a = move(b);          // move from b
    b = move(tmp);        // move from tmp
}
In contrast to the original swap(), this latest version need not make any copies; it will use move operations whenever possible.

Since move(x) does not move x (it simply produces an rvalue reference to x), it would have been better if move() had been called rval(), but by now move() has been used for years.

I deemed this swap() “almost perfect” because it will swap only lvalues. Consider:

Click here to view code image

void f(vector<int>& v)
{
     swap(v,vector<int>{1,2,3});     // replace v's elements with 1,2,3
      //...
}
It is not uncommon to want to replace the contents of a container with some sort of default value, but this particular swap() cannot do that. A solution is to augment it by two overloads:

Click here to view code image

template<typename T> void swap(T&& a, T& b);
template<typename T> void swap(T& a, T&& b)
Our example will be handled by that last version of swap(). The standard library takes a different approach by defining shrink_to_fit() and clear() for vector, string, etc. (§31.3.3) to handle the most common cases of rvalue arguments to swap():

Click here to view code image

void f(string& s, vector<int>& v)
{
    s.shrink_to_fit();          // make s.capacity()==s.size()
    swap(s,string{s});          // make s.capacity()==s.size()
    v.clear();                  // make v empty
    swap(v,vector<int>{});      // make v empty
    v = {};                     // make v empty
}
Rvalue references can also be used to provide perfect forwarding (§23.5.2.1, §35.5.1).

All standard-library containers provide move constructors and move assignment (§31.3.2). Also, their operations that insert new elements, such as insert() and push_back(), have versions that take rvalue references.

7.7.3. References to References
If you take a reference to a reference to a type, you get a reference to that type, rather than some kind of special reference to reference type. But what kind of reference? Lvalue reference or rvalue reference? Consider:

Click here to view code image

using rr_i = int&&;
using lr_i = int&;
using rr_rr_i = rr_i&&;     //"int && &&" is an int&&
using lr_rr_i = rr_i&;      //"int && &" is an int&
using rr_lr_i = lr_i&&;     //"int & &&" is an int&
using lr_lr_i = lr_i&;      //"int & &" is an int&
In other words, lvalue reference always wins. This makes sense: nothing we can do with types can change the fact that an lvalue reference refers to an lvalue. This is sometimes known as reference collapse.

The syntax does not allow

int && & r = i;
Reference to reference can only happen as the result of an alias (§3.4.5, §6.5) or a template type argument (§23.5.2.1).

7.7.4. Pointers and References
Pointers and references are two mechanisms for referring to an object from different places in a program without copying. We can show this similarity graphically:


Each has its strengths and weaknesses.

If you need to change which object to refer to, use a pointer. You can use =, +=, –=, ++, and –– to change the value of a pointer variable (§11.1.4). For example:

Click here to view code image

void fp(char* p)
{
     while (*p)
          cout << *p++;
}

void fr(char& r)
{
     while (r)
          cout << r++;     // oops: increments the char referred to, not the reference
                           // near-infinite loop!
}

void fr2(char& r)
{
     char* p = &r;         // get a pointer to the object referred to
     while (*p)
          cout << *p++;
}
Conversely, if you want to be sure that a name always refers to the same object, use a reference. For example:

Click here to view code image

template<typename T> class Proxy {        // Proxy refers to the object with which it is initialized
    T& m;
public:
    Proxy(T& mm) :m{mm} {}
     //...
};

template<typename T> class Handle {  // Handle refers to its current object
    T* m;
public:
    Handle(T* mm) :m{mm} {}
    void rebind(T* mm) { m = mm; }
    //...
};
If you want to use a user-defined (overloaded) operator (§18.1) on something that refers to an object, use a reference:

Click here to view code image

Matrix operator+(const Matrix&, const Matrix&);    // OK
Matrix operator–(const Matrix*, const Matrix*);    // error: no user-defined type argument

Matrix y, z;
 //...
Matrix x = y+z;      // OK
Matrix x2 = &y–&z;   // error and ugly
It is not possible to (re)define an operator for a pair of built-in types, such as pointers (§18.2.3).

A reference is not an object (§7.7.1). In many cases, a reference can be optimized away by the compiler, so that uses directly access the object referred to, rather than indirectly through the reference. If you want a collection of something that refers to an object, you must use a pointer:

Click here to view code image

string x = "College Station"
string y = "Manhattan";
string& a1[] = {x, y};              // error: array of references
string* a2[] = {&x, &y};            // OK
vector<string&> s1 = {x , y};       // error: vector of references
vector<string*> s2 = {&x, &y};      // OK
Once we leave the cases where C++ leaves no choice for the programmer, we enter the domain of aesthetics. Ideally, we will make our choices so as to minimize the probability of error and in particular to maximize readability of code.

If you need a notion of “no value,” pointers offer nullptr. There is no equivalent “null reference,” so if you need a “no value,” using a pointer may be most appropriate. For example:

Click here to view code image

void fp(X* p)
{
     if (p == nullptr) {
            // no value
     }
     else {
            // use *p
     }
}

void fr(X& r)    // common style
{
      // assume that r is valid and use it
}
If you really want to, you can construct and check for a “null reference” for a particular type:

Click here to view code image

void fr2(X& r)
{
     if (&r == &nullX) {     // or maybe r==nullX
            // no value
     }
     else {
            // use r
     }
}
Obviously, you need to have suitably defined nullX. The style is not idiomatic and I don’t recommend it. A programmer is allowed to assume that a reference is valid. It is possible to create an invalid reference, but you have to go out of your way to do so. For example:

Click here to view code image

char* ident(char* p) { return p; }

char& r {*ident(nullptr)};  // invalid code
This code is not valid C++ code. Don’t write such code even if your current implementation doesn’t catch it.

7.8. Advice
[1] Keep use of pointers simple and straightforward; §7.4.1.

[2] Avoid nontrivial pointer arithmetic; §7.4.

[3] Take care not to write beyond the bounds of an array; §7.4.1.

[4] Avoid multidimensional arrays; define suitable containers instead; §7.4.2.

[5] Use nullptr rather than 0 or NULL; §7.2.2.

[6] Use containers (e.g., vector, array, and valarray) rather than built-in (C-style) arrays; §7.4.1.

[7] Use string rather than zero-terminated arrays of char; §7.4.

[8] Use raw strings for string literals with complicated uses of backslash; §7.3.2.1.

[9] Prefer const reference arguments to plain reference arguments; §7.7.3.

[10] Use rvalue references (only) for forwarding and move semantics; §7.7.2.

[11] Keep pointers that represent ownership inside handle classes; §7.6.

[12] Avoid void* except in low-level code; §7.2.1.

[13] Use const pointers and const references to express immutability in interfaces; §7.5.

[14] Prefer references to pointers as arguments, except where “no object” is a reasonable option; §7.7.4.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


7. Pointers, Arrays, and References
8. Structures, Unions, and Enumerations
9. Statements
47h 26m remaining
8. Structures, Unions, and Enumerations
Form a more perfect Union.

– The people

• Introduction

• Structures

struct Layout; struct Names; Structures and Classes; Structures and Arrays; Type Equivalence; Plain Old Data; Fields

• Unions

Unions and Classes; Anonymous unions

• Enumerations

enum classes; Plain enums; Unnamed enums

• Advice

8.1. Introduction
The key to effective use of C++ is the definition and use of user-defined types. This chapter introduces the three most primitive variants of the notion of a user-defined type:

• A struct (a structure) is a sequence of elements (called members) of arbitrary types.

• A union is a struct that holds the value of just one of its elements at any one time.

• An enum (an enumeration) is a type with a set of named constants (called enumerators).

• enum class (a scoped enumeration) is an enum where the enumerators are within the scope of the enumeration and no implicit conversions to other types are provided.

Variants of these kinds of simple types have existed since the earliest days of C++. They are primarily focused on the representation of data and are the backbone of most C-style programming. The notion of a struct as described here is a simple form of a class (§3.2, Chapter 16).

8.2. Structures
An array is an aggregate of elements of the same type. In its simplest form, a struct is an aggregate of elements of arbitrary types. For example:

Click here to view code image

struct Address {
     const char* name;        //"Jim Dandy"
     int number;              //61
     const char* street;      //"South St"
     const char* town;        //"New Providence"
     char state[2];           //'N' 'J'
     const char* zip;         //"07974"
};
This defines a type called Address consisting of the items you need in order to send mail to someone within the USA. Note the terminating semicolon.

Variables of type Address can be declared exactly like other variables, and the individual members can be accessed using the . (dot) operator. For example:

void f()
{
     Address jd;
     jd.name = "Jim Dandy";
     jd.number = 61;
}
Variables of struct types can be initialized using the {} notation (§6.3.5). For example:

Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    {'N','J'}, "07974"
};
Note that jd.state could not be initialized by the string "NJ". Strings are terminated by a zero character, '\0', so "NJ" has three characters – one more than will fit into jd.state. I deliberately use rather low-level types for the members to illustrate how that can be done and what kinds of problems it can cause.

Structures are often accessed through pointers using the –> (struct pointer dereference) operator. For example:

Click here to view code image

void print_addr(const Address* p)
{
     cout << p–>name << '\n'
          << p–>number << ' ' << p–>street << '\n'
          << p–>town << '\n'
          << p–>state[0] << p–>state[1] << ' ' << p–>zip << '\n';
}
When p is a pointer, p–>m is equivalent to (*p).m.

Alternatively, a struct can be passed by reference and accessed using the . (struct member access) operator:

Click here to view code image

void print_addr2(const Address& r)
{
     cout << r.name << '\n'
          << r.number << ' ' << r.street << '\n'
          << r.town << '\n'
          << r.state[0] << r.state[1] << ' ' << r.zip << '\n';
}
Argument passing is discussed in §12.2.

Objects of structure types can be assigned, passed as function arguments, and returned as the result from a function. For example:

Address current;

Address set_current(Address next)
{
    address prev = current;
    current = next;
    return prev;
}
Other plausible operations, such as comparison (== and !=), are not available by default. However, the user can define such operators (§3.2.1.1, Chapter 18).

8.2.1. struct Layout
An object of a struct holds its members in the order they are declared. For example, we might store primitive equipment readout in a structure like this:

Click here to view code image

struct Readout {
     char hour;      //[0:23]
     int value;
     char seq;       // sequence mark ['a':'z']
};
You could imagine the members of a Readout object laid out in memory like this:


Members are allocated in memory in declaration order, so the address of hour must be less than the address of value. See also §8.2.6.

However, the size of an object of a struct is not necessarily the sum of the sizes of its members. This is because many machines require objects of certain types to be allocated on architecture-dependent boundaries or handle such objects much more efficiently if they are. For example, integers are often allocated on word boundaries. On such machines, objects are said to have to be properly aligned (§6.2.9). This leads to “holes” in the structures. A more realistic layout of a Readout on a machine with 4-byte int would be:


In this case, as on many machines, sizeof(Readout) is 12, and not 6 as one would naively expect from simply adding the sizes of the individual members.

You can minimize wasted space by simply ordering members by size (largest member first). For example:

Click here to view code image

struct Readout {
     int value;
     char hour;     //[0:23]
     char seq;      // sequence mark ['a':'z']
};
This would give us:



Note that this still leaves a 2-byte “hole” (unused space) in a Readout and sizeof(Readout)==8. The reason is that we need to maintain alignment when we put two objects next to each other, say, in an array of Readouts. The size of an array of 10 Readout objects is 10*sizeof(Readout).

It is usually best to order members for readability and sort them by size only if there is a demonstrated need to optimize.

Use of multiple access specifiers (i.e., public, private, or protected) can affect layout (§20.5).

8.2.2. struct Names
The name of a type becomes available for use immediately after it has been encountered and not just after the complete declaration has been seen. For example:

struct Link {
     Link* previous;
     Link* successor;
};
However, it is not possible to declare new objects of a struct until its complete declaration has been seen. For example:

Click here to view code image

struct No_good {
     No_good member;   // error: recursive definition
};
This is an error because the compiler is not able to determine the size of No_good. To allow two (or more) structs to refer to each other, we can declare a name to be the name of a struct. For example:

Click here to view code image

struct List;        // struct name declaration: List to be defined later

struct Link {
     Link* pre;
     Link* suc;
     List* member_of;
     int data;
};

struct List {
     Link* head;
};
Without the first declaration of List, use of the pointer type List* in the declaration of Link would have been a syntax error.

The name of a struct can be used before the type is defined as long as that use does not require the name of a member or the size of the structure to be known. However, until the completion of the declaration of a struct, that struct is an incomplete type. For example:

Click here to view code image

struct S;  //"S" is the name of some type

extern S a;
S f();
void g(S);
S* h(S*);
However, many such declarations cannot be used unless the type S is defined:

Click here to view code image

void k(S* p)
{
     S a;            // error: S not defined; size needed to allocate

     f();            // error: S not defined; size needed to return value
     g(a);           // error: S not defined; size needed to pass argument
     p–>m = 7;       // error: S not defined; member name not known

     S* q = h(p);    // ok: pointers can be allocated and passed
     q–>m = 7;       // error: S not defined; member name not known
}
For reasons that reach into the prehistory of C, it is possible to declare a struct and a non-struct with the same name in the same scope. For example:

Click here to view code image

struct stat { /* ... */ };
int stat(char* name, struct stat* buf);
In that case, the plain name (stat) is the name of the non-struct, and the struct must be referred to with the prefix struct. Similarly, the keywords class, union (§8.3), and enum (§8.4) can be used as prefixes for disambiguation. However, it is best not to overload names to make such explicit disambiguation necessary.

8.2.3. Structures and Classes
A struct is simply a class where the members are public by default. So, a struct can have member functions (§2.3.2, Chapter 16). In particular, a struct can have constructors. For example:

Click here to view code image

struct Points {
     vector<Point> elem; // must contain at least one Point
     Points(Point p0) { elem.push_back(p0);}
     Points(Point p0, Point p1) { elem.push_back(p0); elem.push_back(p1); }
      //...
};

Points x0;                           // error: no default constructor
Points x1{ {100,200} };              // one Point
Points x2{ {100,200}, {300,400} };   // two Points
You do not need to define a constructor simply to initialize members in order. For example:

Click here to view code image

struct Point {
     int x, y;
};

Point p0;         // danger: uninitialized if in local scope (§6.3.5.1)
Point p1 {};      // default construction: {{},{}}; that is {0.0}
Point p2 {1};     // the second member is default constructed: {1,{}}; that is {1,0}
Point p3 {1,2};   //{1,2}
Constructors are needed if you need to reorder arguments, validate arguments, modify arguments, establish invariants (§2.4.3.2, §13.4), etc. For example:

Click here to view code image

struct Address {
     string name;        //"Jim Dandy"
     int number;         //61
     string street;      //"South St"
     string town;        //"New Providence"
     char state[2];      //'N' 'J'
     char zip[5];        //07974

     Address(const string& n, int nu, const string& s, const string& t, const string& st, int z);
};
Here, I added a constructor to ensure that every member was initialized and to allow me to use a string and an int for the postal code, rather than fiddling with individual characters. For example:

Click here to view code image

Address jd = {
    "Jim Dandy",
    61, "South St",
    "New Providence",
    "NJ", 7974             //(07974 would be octal; §6.2.4.1)
};
The Address constructor might be defined like this:

Click here to view code image

Address::Address(const string& n, int nu, const string& s, const string& t, const string& st, int z)
                   // validate address
    :name{n},
    number{nu},
    street{s},
    town{t}
{
    if (st.size()!=2)
           error("State abbreviation should be two characters")
    state = {st[0],st[1]};      // store postal code state abbreviation as characters
    ostringstream ost;          // an output string stream; see §38.4.2
    ost << z;                   // extract characters from int
    string zi {ost.str()};
    switch (zi.size()) {
    case 5:
         zip = {zi[0], zi[1], zi[2], zi[3], zi[4]};
         break;
    case 4:   // starts with '0'
         zip = {'0', zi[0], zi[1], zi[2], zi[3]};
         break;
    default:
         error("unexpected ZIP code format");
    }
     //... check that the code makes sense ...
}
8.2.4. Structures and Arrays
Naturally, we can have arrays of structs and structs containing arrays. For example:

Click here to view code image

struct Point {
     int x,y;
};

Point points[3] {{1,2},{3,4},{5,6}};
int x2 = points[2].x;

struct Array {
     Point elem[3];
};

Array points2 {{1,2},{3,4},{5,6}};
int y2 = points2.elem[2].y;
Placing a built-in array in a struct allows us to treat that array as an object: we can copy the struct containing it in initialization (including argument passing and function return) and assignment. For example:

Click here to view code image

Array shift(Array a, Point p)
{
     for (int i=0; i!=3; ++i) {
           a.elem[i].x += p.x;
           a.elem[i].y += p.y;
     }
     return a;
}

Array ax = shift(points2,{10,20});
The notation for Array is a bit primitive: Why i!=3? Why keep repeating .elem[i]? Why just elements of type Point? The standard library provides std::array (§34.2.1) as a more complete and elegant development of the idea of a fixed-size array as a struct:

Click here to view code image

template<typename T, size_t N>
struct array {  // simplified (see §34.2.1)
     using size_type = size_t;
     T elem[N];

     T* begin() noexcept { return elem; }
     const T* begin() const noexcept {return elem; }
     T* end() noexcept { return elem+N; } const T* end()
     const noexcept { return elem+N; }

     constexpr size_type size() noexcept;

     T& operator[](size_type n) { return elem[n]; }
     const T& operator[](size_type n) const { return elem[n]; }

     T* data() noexcept { return elem; }
     const T * data() const noexcept { return elem; }

      //...
};
This array is a template to allow arbitrary numbers of elements of arbitrary types. It also deals directly with the possibility of exceptions (§13.5.1.1) and const objects (§16.2.9.1). Using array, we can now write:

Click here to view code image

struct Point {
     int x,y
};

using Array = array<Point,3>;  // array of 3 Points

Array points {{1,2},{3,4},{5,6}};
int x2 = points[2].x;
int y2 = points[2].y;

Array shift(Array a, Point p)
{
     for (int i=0; i!=a.size(); ++i) {
           a[i].x += p.x;
           a[i].y += p.y;
     }
     return a;
}

Array ax = shift(points,{10,20});
The main advantages of std::array over a built-in array are that it is a proper object type (has assignment, etc.) and does not implicitly convert to a pointer to an individual element:

Click here to view code image

ostream& operator<<(ostream& os, Point p)
{
     return os << '{' << p.x << ',' << p.y << '}';
}

void print(const Point a[],int s)      // must specify number of elements
{
     for (int i=0; i!=s; ++i)
           cout << a[i] << '\n';
}

template<typename T, int N>
void print(const array<T,N>& a)
{
     for (int i=0; i!=a.size(); ++i)   // or use a range-for (§2.2.4, §9.5.1)
           cout << a[i] << '\n';
}

Point point1[] = {{1,2},{3,4},{5,6}};           //3 elements
array<Point,3> point2 = {{1,2},{3,4},{5,6}};    //3 elements

void f()
{
     print(point1,4);     //4 is a bad error
     print(point2);
}
The disadvantage of std::array compared to a built-in array is that we can’t deduce the number of elements from the length of the initializer:

Click here to view code image

Point point1[] = {{1,2},{3,4},{5,6}};            //3 elements
array<Point,3> point2 = {{1,2},{3,4},{5,6}};     //3 elements
array<Point> point3 = {{1,2},{3,4},{5,6}};       // error: number of elements not given
8.2.5. Type Equivalence
Two structs are different types even when they have the same members. For example:

struct S1 { int a; };
struct S2 { int a; };
S1 and S2 are two different types, so:

S1 x;
S2 y = x;  // error: type mismatch
A struct is also a different type from a type used as a member. For example:

S1 x;
int i = x;   // error: type mismatch
Every struct must have a unique definition in a program (§15.2.3).

8.2.6. Plain Old Data
Sometimes, we want to treat an object as just “plain old data” (a contiguous sequence of bytes in memory) and not worry about more advanced semantic notions, such as run-time polymorphism (§3.2.3, §20.3.2), user-defined copy semantics (§3.3, §17.5), etc. Often, the reason for doing so is to be able to move objects around in the most efficient way the hardware is capable of. For example, copying a 100-element array using 100 calls of a copy constructor is unlikely to be as fast as calling std::memcpy(), which typically simply uses a block-move machine instruction. Even if the constructor is inlined, it could be hard for an optimizer to discover this optimization. Such “tricks” are not uncommon, and are important, in implementations of containers, such as vector, and in low-level I/O routines. They are unnecessary and should be avoided in higher-level code.

So, a POD (“Plain Old Data”) is an object that can be manipulated as “just data” without worrying about complications of class layouts or user-defined semantics for construction, copy, and move. For example:

Click here to view code image

struct S0 { };                                                 // a POD
struct S1 { int a; };                                          // a POD
struct S2 { int a; S2(int aa) : a(aa) { } };                   // not a POD (no default constructor)
struct S3 { int a; S3(int aa) : a(aa) { } S3() {} };           // not a POD (user-defined default constructor)
struct S4 { int a; S4(int aa) : a(aa) { } S4() = default; };   // a POD
struct S5 { virtual void f(); /* ... */ };                     // not a POD (has a virtual function)

struct S6 : S1 { };               // a POD
struct S7 : S0 { int b; };        // a POD
struct S8 : S1 { int b; };        // not a POD (data in both S1 and S8)
struct S9 : S0, S1 {};            // a POD
For us to manipulate an object as “just data” (as a POD), the object must

• not have a complicated layout (e.g., with a vptr; (§3.2.3, §20.3.2),

• not have nonstandard (user-defined) copy semantics, and

• have a trivial default constructor.

Obviously, we need to be precise about the definition of POD so that we only use such optimizations where they don’t break any language guarantees. Formally (§iso.3.9, §iso.9), a POD object must be of

• a standard layout type, and

• a trivially copyable type,

• a type with a trivial default constructor.

A related concept is a trivial type, which is a type with

• a trivial default constructor and

• trivial copy and move operations

Informally, a default constructor is trivial if it does not need to do any work (use =default if you need to define one §17.6.1).

A type has standard layout unless it

• has a non-static member or a base that is not standard layout,

• has a virtual function (§3.2.3, §20.3.2),

• has a virtual base (§21.3.5),

• has a member that is a reference (§7.7),

• has multiple access specifiers for non-static data members (§20.5), or

• prevents important layout optimizations

• by having non-static data members in more than one base class or in both the derived class and a base, or

• by having a base class of the same type as the first non-static data member.

Basically, a standard layout type is one that has a layout with an obvious equivalent in C and is in the union of what common C++ Application Binary Interfaces (ABIs) can handle.

A type is trivially copyable unless it has a nontrivial copy operation, move operation, or destructor (§3.2.1.2, §17.6). Informally, a copy operation is trivial if it can be implemented as a bitwise copy. So, what makes a copy, move, or destructor nontrivial?

• It is user-defined.

• Its class has a virtual function.

• Its class has a virtual base.

• Its class has a base or a member that is not trivial.

An object of built-in type is trivially copyable, and has standard layout. Also, an array of trivially copyable objects is trivially copyable and an array of standard layout objects has standard layout. Consider an example:

Click here to view code image

template<typename T>
    void mycopy(T* to, const T* from, int count);
I’d like to optimize the simple case where T is a POD. I could do that by only calling mycopy() for PODs, but that’s error-prone: if I use mycopy(), can I rely on a maintainer of the code to remember never to call mycopy() for non-PODs? Realistically, I cannot. Alternatively, I could call std::copy(), which is most likely implemented with the necessary optimization. Anyway, here is the general and optimized code:

Click here to view code image

template<typename T>
void mycopy(T* to, const T* from, int count)
{
     if (is_pod<T>::value)
           memcpy(to,from,count*sizeof(T));
     else
           for (int i=0; i!=count; ++i)
                 to[i]=from[i];
}
The is_pod is a standard-library type property predicate (§35.4.1) defined in <type_traits> allowing us to ask the question “Is T a POD?” in our code. The best thing about is_pod<T> is that it saves us from remembering the exact rules for what a POD is.

Note that adding or subtracting non-default constructors does not affect layout or performance (that was not true in C++98).

If you feel an urge to become a language lawyer, study the layout and triviality concepts in the standard (§iso.3.9, §iso.9) and try to think about their implications to programmers and compiler writers. Doing so might cure you of the urge before it has consumed too much of your time.

8.2.7. Fields
It seems extravagant to use a whole byte (a char or a bool) to represent a binary variable – for example, an on/off switch – but a char is the smallest object that can be independently allocated and addressed in C++ (§7.2). It is possible, however, to bundle several such tiny variables together as fields in a struct. A field is often called a bit-field. A member is defined to be a field by specifying the number of bits it is to occupy. Unnamed fields are allowed. They do not affect the meaning of the named fields, but they can be used to make the layout better in some machine-dependent way:

Click here to view code image

struct PPN {       // R6000 Physical Page Number
    unsigned int PFN : 22;   // Page Frame Number
    int : 3;                 // unused
    unsigned int CCA : 3;          // Cache Coherency Algorithm
    bool nonreachable : 1;
    bool dirty : 1;
    bool valid : 1;
    bool global : 1;
};
This example also illustrates the other main use of fields: to name parts of an externally imposed layout. A field must be of an integral or enumeration type (§6.2.1). It is not possible to take the address of a field. Apart from that, however, it can be used exactly like other variables. Note that a bool field really can be represented by a single bit. In an operating system kernel or in a debugger, the type PPN might be used like this:

Click here to view code image

void part_of_VM_system(PPN* p)
{
      //...
     if (p–>dirty) {  // contents changed
            // copy to disk
           p–>dirty = 0;
     }
}
Surprisingly, using fields to pack several variables into a single byte does not necessarily save space. It saves data space, but the size of the code needed to manipulate these variables increases on most machines. Programs have been known to shrink significantly when binary variables were converted from bit-fields to characters! Furthermore, it is typically much faster to access a char or an int than to access a field. Fields are simply a convenient shorthand for using bitwise logical operators (§11.1.1) to extract information from and insert information into part of a word.

A bit-field with size zero has a special meaning: Start in a new “allocation unit.” The exact meaning is implementation defined, but usually it means that the following field starts at a word boundary.

8.3. Unions
A union is a struct in which all members are allocated at the same address so that the union occupies only as much space as its largest member. Naturally, a union can hold a value for only one member at a time. For example, consider a symbol table entry that holds a name and a value:

Click here to view code image

enum Type { str, num };

struct Entry {
     char* name;
     Type t;
     char* s;   // use s if t==str
     int i;     // use i if t==num
};

void f(Entry* p)
{
     if (p–>t == str)
           cout << p–>s;
      //...
}
The members s and i can never be used at the same time, so space is wasted. It can be easily recovered by specifying that both should be members of a union, like this:

union Value {
     char* s;
     int i;
};
The language doesn’t keep track of which kind of value is held by a union, so the programmer must do that:

Click here to view code image

struct Entry {
     char* name;
     Type t;
     Value v;  // use v.s if t==str; use v.i if t==num
};

void f(Entry* p)
{
     if (p–>t == str)
           cout << p–>v.s;
      //...
}
To avoid errors, one can encapsulate a union so that the correspondence between a type field and access to the union members can be guaranteed (§8.3.2).

Unions are sometimes misused for “type conversion.” This misuse is practiced mainly by programmers trained in languages that do not have explicit type conversion facilities, so that cheating is necessary. For example, the following “converts” an int to an int* simply by assuming bitwise equivalence:

Click here to view code image

union Fudge {
     int i;
     int* p;
};

int* cheat(int i)
{
     Fudge a;
     a.i = i;
     return a.p;      // bad use
}
This is not really a conversion at all. On some machines, an int and an int* do not occupy the same amount of space, while on others, no integer can have an odd address. Such use of a union is dangerous and nonportable. If you need such an inherently ugly conversion, use an explicit type conversion operator (§11.5.2) so that the reader can see what is going on. For example:

Click here to view code image

int* cheat2(int i)
{
     return reinterpret_cast<int*>(i);     // obviously ugly and dangerous
}
Here, at least the compiler has a chance to warn you if the sizes of objects are different and such code stands out like the sore thumb it is.

Use of unions can be essential for compactness of data and through that for performance. However, most programs don’t improve much from the use of unions and unions are rather error-prone. Consequently, I consider unions an overused feature; avoid them when you can.

8.3.1. Unions and Classes
Many nontrivial unions have a member that is much larger than the most frequently used members. Because the size of a union is at least as large as its largest member, space is wasted. This waste can often be eliminated by using a set of derived classes (§3.2.2, Chapter 20) instead of a union.

Technically, a union is a kind of a struct (§8.2) which in turn is a kind of a class (Chapter 16). However, many of the facilities provided for classes are not relevant for unions, so some restrictions are imposed on unions:

[1] A union cannot have virtual functions.

[2] A union cannot have members of reference type.

[3] A union cannot have base classes.

[4] If a union has a member with a user-defined constructor, a copy operation, a move operation, or a destructor, then that special function is deleted (§3.3.4, §17.6.4) for that union; that is, it cannot be used for an object of the union type.

[5] At most one member of a union can have an in-class initializer (§17.4.4).

[6] A union cannot be used as a base class.

These restrictions prevent many subtle errors and simplify the implementation of unions. The latter is important because the use of unions is often an optimization and we won’t want “hidden costs” imposed to compromise that.

The rule that deletes constructors (etc.) from a union with a member that has a constructor (etc.) keeps simple unions simple and forces the programmer to provide complicated operations if they are needed. For example, since Entry has no member with constructors, destructors, or assignments, we can create and copy Entrys freely. For example:

void f(Entry a)
{
     Entry b = a;
};
Doing so with a more complicated union would cause implementation difficulties or errors:

Click here to view code image

union U {
     int m1;
     complex<double> m2;    // complex has a constructor
     string m3;             // string has a constructor (maintaining a serious invariant)
};
To copy a U we would have to decide which copy operation to use. For example:

Click here to view code image

void f2(U x)
{
     U u;                    // error: which default constructor?
     U u2 = x;               // error: which copy constructor?
     u.m1 = 1;               // assign to int member
     string s = u.m3;        // disaster: read from string member
     return;                 // error: which destructors are called for x, u, and u2?
}
It’s illegal to write one member and then read another, but people do that nevertheless (usually by mistake). In this case, the string copy constructor would be called with an invalid argument. It is fortunate that U won’t compile. When needed, a user can define a class containing a union that properly handles union members with constructors, destructors, and assignments (§8.3.2). If desired, such a class can also prevent the error of writing one member and then reading another.

It is possible to specify an in-class initializer for at most one member. If so, this initializer will be used for default initialization. For example:

Click here to view code image

union U2 {
     int a;
     const char* p {""};
};

U2 x1;          // default initialized to x1.p == ""
U2 x2 {7};      // x2.a == 7
8.3.2. Anonymous unions
To see how we can write a class that overcomes the problems with misuse of a union, consider a variant of Entry (§8.3):

Click here to view code image

class Entry2 {  // two alternative representations represented as a union
private:
     enum class Tag { number, text };
     Tag type;  // discriminant

     union {    // representation
         int i;
         string s;  // string has default constructor, copy operations, and destructor
     };
public:
     struct Bad_entry { };      // used for exceptions

     string name;

     ~Entry2();
     Entry2& operator=(const Entry2&);      // necessary because of the string variant
     Entry2(const Entry2&);
      //...

     int number() const;
     string text() const;

     void set_number(int n);
     void set_text(const string&);
      //...
};
I’m not a fan of get/set functions, but in this case we really need to perform a nontrivial user-specified action on each access. I chose to name the “get” function after the value and use the set_ prefix for the “set” function. That happens to be my favorite among the many naming conventions.

The read-access functions can be defined like this:

Click here to view code image

int Entry2::number() const
{
     if (type!=Tag::number) throw Bad_entry{};
     return i;
}

string Entry2::text() const
{
     if (type!=Tag::text) throw Bad_entry{};
     return s;
};
These access functions check the type tag, and if it is the one that correctly corresponds to the access we want, it returns a reference to the value; otherwise, it throws an exception. Such a union is often called a tagged union or a discriminated union.

The write-access functions basically do the same checking of the type tag, but note how setting a new value must take the previous value into account:

Click here to view code image

void Entry2::set_number(int n)
{
     if (type==Tag::text) {
           s.~string();              // explicitly destroy string (§11.2.4)
           type = Tag::number;
     }
     i = n;
}

void Entry2::set_text(const string& ss)
{
     if (type==Tag::text)
           s = ss;
     else {
           new(&s) string{ss};       // placement new: explicitly construct string (§11.2.4)
           type = Tag::text;
     }
}
The use of a union forces us to use otherwise obscure and low-level language facilities (explicit construction and destruction) to manage the lifetime of the union elements. This is another reason to be wary of using unions.

Note that the union in the declaration of Entry2 is not named. That makes it an anonymous union. An anonymous union is an object, not a type, and its members can be accessed without mentioning an object name. That means that we can use members of an anonymous union exactly as we use other members of a class – as long as we remember that union members really can be used only one at a time.

Entry2 has a member of a type with a user-defined assignment operator, string, so Entry2’s assignment operator is deleted (§3.3.4, §17.6.4). If we want to assign Entry2s, we have to define Entry2::operator=(). Assignment combines the complexities of reading and writing but is otherwise logically similar to the access functions:

Click here to view code image

Entry2& Entry2::operator=(const Entry2& e)  // necessary because of the string variant
{
     if (type==Tag::text && e.type==Tag::text) {
           s = e.s;      // usual string assignment
           return *this;
     }

     if (type==Tag::text) s.~string();  // explicit destroy (§11.2.4)

     switch (e.type) {
     case Tag::number:
          i = e.i;
          break;
     case Tag::text:
          new(&s)(e.s);  // placement new: explicit construct (§11.2.4)
          type = e.type;
     }

     return *this;
}
Constructors and a move assignment can be defined similarly as needed. We need at least a constructor or two to establish the correspondence between the type tag and a value. The destructor must handle the string case:

Click here to view code image

Entry2::~Entry2()
{
     if (type==Tag::text) s.~string();  // explicit destroy (§11.2.4)
}
8.4. Enumerations
An enumeration is a type that can hold a set of integer values specified by the user (§iso.7.2). Some of an enumeration’s possible values are named and called enumerators. For example:

enum class Color { red, green, blue };
This defines an enumeration called Color with the enumerators red, green, and blue. “An enumeration” is colloquially shortened to “an enum.”

There are two kinds of enumerations:

[1] enum classes, for which the enumerator names (e.g., red) are local to the enum and their values do not implicitly convert to other types

[2] “Plain enums,” for which the enumerator names are in the same scope as the enum and their values implicitly convert to integers

In general, prefer the enum classes because they cause fewer surprises.

8.4.1. enum classes
An enum class is a scoped and strongly typed enumeration. For example:

Click here to view code image

enum class Traffic_light { red, yellow, green };
enum class Warning { green, yellow, orange, red }; // fire alert levels

Warning a1 = 7;                    // error: no int->Warning conversion
int a2 = green;                    // error: green not in scope
int a3 = Warning::green;           // error: no Warning->int conversion
Warning a4 = Warning::green;       // OK

void f(Traffic_light x)
{
     if (x) { / ... /}                               // error : 9 is not a Traffic_light
     if (x == 9) { /* ... */ }                       // error: 9 is not a Traffic_light
     if (x == red) { /* ... */ }                     // error: no red in scope
     if (x == Warning::red) { /* ... */ }            // error: x is not a Warning
     if (x == Traffic_light::red) { /* ... */ }      // OK
}
Note that the enumerators present in both enums do not clash because each is in the scope of its own enum class.

An enumeration is represented by some integer type and each enumerator by some integer value. We call the type used to represent an enumeration its underlying type. The underlying type must be one of the signed or unsigned integer types (§6.2.4); the default is int. We could be explicit about that:

enum class Warning : int { green, yellow, orange, red };  // sizeof(Warning)==sizeof(int)
If we considered that too wasteful of space, we could instead use a char:

enum class Warning : char { green, yellow, orange, red };  // sizeof(Warning)==1
By default, enumerator values are assigned increasing from 0. Here, we get:

Click here to view code image

static_cast<int>(Warning::green)==0
static_cast<int>(Warning::yellow)==1
static_cast<int>(Warning::orange)==2
static_cast<int>(Warning::red)==3
Declaring a variable Warning instead of plain int can give both the user and the compiler a hint as to the intended use. For example:

Click here to view code image

void f(Warning key)
{
     switch (key) {
     case Warning::green:
          // ... do something ...
         break;
     case Warning::orange:
          // ... do something ...
         break;
    case Warning::red:
          // ... do something ...
         break;
     }
}
A human might notice that yellow was missing, and a compiler might issue a warning because only three out of four Warning values are handled.

An enumerator can be initialized by a constant expression (§10.4) of integral type (§6.2.1). For example:

enum class Printer_flags {
    none=0,
    acknowledge=1,
    paper_empty=2,
    busy=4,
    out_of_black=8,
    out_of_color=16,
    // ...
};
The values for the Printer_flags enumerators are chosen so that they can be combined by bitwise operations. An enum is a user-defined type, so we can define the | and & operators for it (§3.2.1.1, Chapter 18). For example:

Click here to view code image

constexpr Printer_flags operator|(Printer_flags a, Printer_flags b)
{
    return static_cast<Printer_flags>(static_cast<int>(a)|static_cast<int>(b));
}

constexpr Printer_flags operator&(Printer_flags a, Printer_flags b)
{
    return static_cast<Printer_flags>(static_cast<int>(a)&static_cast<int>(b));
}
The explicit conversions are necessary because a enum class does not support implicit conversions. Given these definitions of | and & for Printer_flags, we can write:

Click here to view code image

void try_to_print(Printer_flags x)
{
     if ((x&Printer_flags::acknowledge)!=Printer_flags::none) {
            // ...
     }
     else if ((x&Printer_flags::busy)!=Printer_flags::none) {
            // ...
     }
     else if ((x&(Printer_flags::out_of_black|Printer_flags::out_of_color))!=Printer_flags::none) {
            // we are out of black or we are out of color
            // ...
     }
}
I defined operator|() and operator&() to be constexpr functions (§10.4, §12.1.6) because someone might want to use those operators in constant expressions. For example:

Click here to view code image

void g(Printer_flags x)
{
     switch (x) {
     case Printer_flags::acknowledge:
           //...
          break;
     case Printer_flags::busy:
           //...
          break;
     case Printer_flags::out_of_black:
           //...
          break;
     case Printer_flags::out_of_color:
           //...
          break;
     case Printer_flags::out_of_black|Printer_flags::out_of_color:
           // we are out of black or we are out of color
           //...
          break;
     }

      //...
}
It is possible to declare an enum class without defining it (§6.3) until later. For example:

Click here to view code image

enum class Color_code : char;      // declaration
void foobar(Color_code* p);        // use of declaration
 //...
enum class Color_code : char {     // definition
    red, yellow, green, blue
};
A value of integral type may be explicitly converted to an enumeration type. The result of such a conversion is undefined unless the value is within the range of the enumeration’s underlying type. For example:

Click here to view code image

enum class Flag : char{ x=1, y=2, z=4, e=8 };

Flag f0 {};                          // f0 gets the default value 0
Flag f1 = 5;                         // type error: 5 is not of type Flag
Flag f2 = Flag{5};                   // error: no narrowing conversion to an enum class
Flag f3 = static_cast<Flag>(5);      // brute force
Flag f4 = static_cast<Flag>(999);    // error: 999 is not a char value (maybe not caught)
The last assignments show why there is no implicit conversion from an integer to an enumeration; most integer values do not have a representation in a particular enumeration.

Each enumerator has an integer value. We can extract that value explicitly. For example:

Click here to view code image

int i = static_cast<int>(Flag::y);       // i becomes 2
char c = static_cast<char>(Flag::e);     // c becomes 8
The notion of a range of values for an enumeration differs from the enumeration notion in the Pascal family of languages. However, bit-manipulation examples that require values outside the set of enumerators to be well defined (e.g., the Printer_flags example) have a long history in C and C++.

The sizeof an enum class is the sizeof of its underlying type. In particular, if the underlying type is not explicitly specified, the size is sizeof(int).

8.4.2. Plain enums
A “plain enum” is roughly what C++ offered before the enum classes were introduced, so you’ll find them in lots of C and C++98-style code. The enumerators of a plain enum are exported into the enum’s scope, and they implicitly convert to values of some integer type. Consider the examples from §8.4.1 with the “class” removed:

Click here to view code image

enum Traffic_light { red, yellow, green };
enum Warning { green, yellow, orange, red };  // fire alert levels

 // error: two definitions of yellow (to the same value)
 // error: two definitions of red (to different values)

Warning a1 = 7;                    // error: no int->Warning conversion
int a2 = green;                    // OK: green is in scope and converts to int
int a3 = Warning::green;           // OK: Warning->int conversion
Warning a4 = Warning::green;       // OK

void f(Traffic_light x)
{
     if (x == 9) { /* ... */ }                   // OK (but Traffic_light doesn't have a 9)
     if (x == red) { /* ... */ }                 // error: two reds in scope
     if (x == Warning::red) { /* ... */ }        // OK (Ouch!)
     if (x == Traffic_light::red) { /* ... */ }  // OK
}
We were “lucky” that defining red in two plain enumerations in a single scope saved us from hard-to-spot errors. Consider “cleaning up” the plain enums by disambiguating the enumerators (as is easily done in a small program but can be done only with great difficulty in a large one):

Click here to view code image

enum Traffic_light { tl_red, tl_yellow, tl_green };
enum Warning { green, yellow, orange, red };  // fire alert levels
void f(Traffic_light x)
{
     if (x == red) { /* ... */ }                     // OK (ouch!)
     if (x == Warning::red) { /* ... */ }            // OK (ouch!)
     if (x == Traffic_light::red) { /* ... */ }      // error: red is not a Traffic_light value
}
The compiler accepts the x==red, which is almost certainly a bug. The injection of names into an enclosing scope (as enums, but not enum classes or classes, do) is namespace pollution and can be a major problem in larger programs (Chapter 14).

You can specify the underlying type of a plain enumeration, just as you can for enum classes. If you do, you can declare the enumerations without defining them until later. For example:

Click here to view code image

enum Traffic_light : char { tl_red, tl_yellow, tl_green };   // underlying type is char

enum Color_code : char;        // declaration
void foobar(Color_code* p);    // use of declaration
 //...
enum Color_code : char { red, yellow, green, blue };  // definition
If you don’t specify the underlying type, you can’t declare the enum without defining it, and its underlying type is determined by a relatively complicated algorithm: when all enumerators are nonnegative, the range of the enumeration is [0:2k-1] where 2k is the smallest power of 2 for which all enumerators are within the range. If there are negative enumerators, the range is [-2k:2k-1]. This defines the smallest bit-field capable of holding the enumerator values using the conventional two’s complement representation. For example:

Click here to view code image

enum E1 { dark, light };                // range 0:1
enum E2 { a = 3, b = 9 };               // range 0:15
enum E3 { min = –10, max = 1000000 };   // range -1048576:1048575
The rule for explicit conversion of an integer to a plain enum is the same as for the enum class except that when there is no explicit underlying type, the result of such a conversion is undefined unless the value is within the range of the enumeration. For example:

Click here to view code image

enum Flag { x=1, y=2, z=4, e=8 };    // range 0:15

Flag f0 {};                          // f0 gets the default value 0
Flag f1 = 5;                         // type error: 5 is not of type Flag
Flag f2 = Flag{5};                   // error: no explicit conversion from int to Flag
Flag f2 = static_cast<Flag>(5);      // OK: 5 is within the range of Flag
Flag f3 = static_cast<Flag>(z|e);    // OK: 12 is within the range of Flag (z bitor e)
Flag f4 = static_cast<Flag>(99);     // undefined: 99 is not within the range of Flag
Because there is an implicit conversion from a plain enum to its underlying type, we don’t need to define | to make this example work: z and e are converted to int so that z|e can be evaluated. The sizeof an enumeration is the sizeof its underlying type. If the underlying type isn’t explicitly specified, it is some integral type that can hold its range and not larger than sizeof(int), unless an enumerator cannot be represented as an int or as an unsigned int. For example, sizeof(E1) could be 1 or maybe 4 but not 8 on a machine where sizeof(int)==4.

8.4.3. Unnamed enums
A plain enum can be unnamed. For example:

enum { arrow_up=1, arrow_down, arrow_sideways };
We use that when all we need is a set of integer constants, rather than a type to use for variables.

8.5. Advice
[1] When compactness of data is important, lay out structure data members with larger members before smaller ones; §8.2.1.

[2] Use bit-fields to represent hardware-imposed data layouts; §8.2.7.

[3] Don’t naively try to optimize memory consumption by packing several values into a single byte; §8.2.7.

[4] Use unions to save space (represent alternatives) and never for type conversion; §8.3.

[5] Use enumerations to represent sets of named constants; §8.4.

[6] Prefer enum classes over “plain” enums to minimize surprises; §8.4.

[7] Define operations on enumerations for safe and simple use; §8.4.1.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


8. Structures, Unions, and Enumerations
9. Statements
10. Expressions
47h 26m remaining
9. Statements
A programmer is a machine for turning caffeine into code.

– A programmer

• Introduction

• Statement Summary

• Declarations as Statements

• Selection Statements

if Statements; switch Statements; Declarations in Conditions

• Iteration Statements

Range-for Statements; for Statements; while Statements; do Statements; Loop exit

• goto Statements

• Comments and Indentation

• Advice

9.1. Introduction
C++ offers a conventional and flexible set of statements. Basically all that is either interesting or complicated is found in expressions and declarations. Note that a declaration is a statement and that an expression becomes a statement when you add a semicolon at its end.

Unlike an expression, a statement does not have a value. Instead, statements are used to specify the order of execution. For example:

Click here to view code image

a = b+c;         // expression statement
if (a==7)        // if-statement
      b = 9;     // execute if and only if a==7
Logically, a=b+c is executed before the if, as everyone would expect. A compiler may reorder code to improve performance as long as the result is identical to that of the simple order of execution.

9.2. Statement Summary
Here is a summary of C++ statements:

statement:
          declaration
          expressionopt ;
          { statement-listopt }
          try { statement-listopt } handler-list
          
          case constant-expression : statement
          default : statement
          break ;
          continue ;
          
          return expressionopt ;
          return {expression-listopt}; ;
          goto identifier ;
          identifier : statement
          
          selection-statement
          iteration-statement

selection-statement:
          if ( condition ) statement
          if ( condition ) statement else statement
          switch ( condition ) statement

iteration-statement:
          while ( condition ) statement
          do statement while ( expression ) ;
          for ( for-init-statement conditionopt ; expressionopt ) statement
          for ( for-init-declaration : expression ) statement

statement-list:
          statement statement-listopt

condition:
          expression
          type-specifier declarator = expression
          type-specifier declarator { expression }

handler-list:
          handler handler-listopt

handler:
          catch ( exception-declaration ) { statement-listopt}

A semicolon is by itself a statement, the empty statement.

A (possibly empty) sequence of statements within “curly braces” (i.e., { and }) is called a block or a compound statement. A name declared in a block goes out of scope at the end of its block (§6.3.4).

A declaration is a statement and there is no assignment statement or procedure-call statement; assignments and function calls are expressions.

A for-init-statement must be either a declaration or an expression-statement. Note that both end with a semicolon.

A for-init-declaration must be the declaration of a single uninitialized variable. The variable is initialized by an element of the sequence specified as the expression. Thus, auto can be used.

The statements for handling exceptions, try-blocks, are described in §13.5.

9.3. Declarations as Statements
A declaration is a statement. Unless a variable is declared static, its initializer is executed whenever the thread of control through the declaration (see also §6.4.2). The reason for allowing declarations wherever a statement can be used (and a few other places; §9.4.3, §9.5.2) is to enable the programmer to minimize the errors caused by uninitialized variables and to allow better locality in code. There is rarely a reason to introduce a variable before there is a value for it to hold. For example:

void f(vector<string>& v, int i, const char* p)
{
     if (p==nullptr) return;
     if (i<0 || v.size()<=i)
           error("bad index");
     string s = v[i];
     if (s == p) {
            //...
     }
      //...
}
The ability to place declarations after executable code is essential for many constants and for single-assignment styles of programming where a value of an object is not changed after initialization. For user-defined types, postponing the definition of a variable until a suitable initializer is available can also lead to better performance. For example:

void use()
{
     string s1;
     s1 = "The best is the enemy of the good.";
      //...
}
This requests a default initialization (to the empty string) followed by an assignment. This can be slower than a simple initialization to the desired value:

string s2 {"Voltaire"};
The most common reason to declare a variable without an initializer is that it requires a statement to give it its desired value. Input variables are among the few reasonable examples of that:

Click here to view code image

void input()
{
     int buf[max];
     int count = 0;
     for (int i; cin>>i; ) {
           if (i<0) error("unexpected negative value");
           if (count==max) error("buffer overflow");
           buf[count++] = i;
     }
      //...
}
I assume that error() does not return; if it does, this code may cause a buffer overflow. Often, push_back() (§3.2.1.3, §13.6, §31.3.6) provides a better solution to such examples.

9.4. Selection Statements
A value can be tested by either an if-statement or a switch-statement:

if ( condition ) statement
if ( condition ) statement else statement
switch ( condition ) statement

A condition is either an expression or a declaration (§9.4.3).

9.4.1. if Statements
In an if-statement, the first (or only) statement is executed if the condition is true and the second statement (if it is specified) is executed otherwise. If a condition evaluates to something different from a Boolean, it is – if possible – implicitly converted to a bool. This implies that any arithmetic or pointer expression can be used as a condition. For example, if x is an integer, then

if (x)  //...
means

if (x != 0)  //...
For a pointer p,

if (p)  //...
is a direct statement of the test “Does p point to a valid object (assuming proper initialization)?” and is equivalent to

if (p != nullptr)  //...
Note that a “plain” enum can be implicitly converted to an integer and then to a bool, whereas an enum class cannot (§8.4.1). For example:

Click here to view code image

enum E1 { a, b };
enum class E2 { a, b };

void f(E1 x, E2 y)
{
    if (x)          // OK
           //...
    if (y)          // error: no conversion to bool
           //...
    if (y==E2::a)   // OK
           //...
}
The logical operators

&& || !
are most commonly used in conditions. The operators && and || will not evaluate their second argument unless doing so is necessary. For example,

if (p && 1<p–>count)  //...
This tests 1<p–>count only if p is not nullptr.

For choosing between two alternatives each of which produces a value, a conditional expression (§11.1.3) is a more direct expression of intent than an if-statement. For example:

Click here to view code image

int max(int a, int b)
{
     return (a>b)?a:b;     // return the larger of a and b
}
A name can only be used within the scope in which it is declared. In particular, it cannot be used on another branch of an if-statement. For example:

Click here to view code image

void f2(int i)
{
     if (i) {
            int x = i+2;
            ++x;
             //...
     }
     else {
           ++x;  // error: x is not in scope
     }
     ++x;        // error: x is not in scope
}
A branch of an if-statement cannot be just a declaration. If we need to introduce a name in a branch, it must be enclosed in a block (§9.2). For example:

Click here to view code image

void f1(int i)
{
      if (i)
            int x = i+2;       // error: declaration of if-statement branch
}
9.4.2. switch Statements
A switch-statement selects among a set of alternatives (case-labels). The expression in the case labels must be a constant expression of integral or enumeration type. A value may not be used more than once for case-labels in a switch-statement. For example:

Click here to view code image

void f(int i)
{
     switch (i) {
     case 2.7:  // error: floating point uses for case
           //...
     case 2:
           //...
     case 4–2:  // error: 2 used twice in case labels
           //...
};
A switch-statement can alternatively be written as a set of if-statements. For example:

switch (val) {
case 1:
     f();
     break;
case 2:
     g();
     break;
default:
     h();
     break;
}
This could be expressed as:

if (val == 1)
       f();
else if (val == 2)
       g();
else
       h();
The meaning is the same, but the first (switch) version is preferred because the nature of the operation (testing a single value against a set of constants) is explicit. This makes the switch-statement easier to read for nontrivial examples. It typically also leads to the generation of better code because there is no reason to repeatedly check individual values. Instead, a jump table can be used.

Beware that a case of a switch must be terminated somehow unless you want to carry on executing the next case. Consider:

Click here to view code image

switch (val) {            // beware
case 1:
     cout << "case 1\n";
case 2:
     cout << "case 2\n";
default:
     cout << "default: case not found\n";
}
Invoked with val==1, the output will greatly surprise the uninitiated:

case 1
case 2
default: case not found
It is a good idea to comment the (rare) cases in which a fall-through is intentional so that an uncommented fall-through can be assumed to be an error. For example:

Click here to view code image

switch (action) {            // handle (action,value) pair
case do_and_print:
     act(value);
      // no break: fall through to print
case print:
     print(value);
     break;
 //...
}
A break is the most common way of terminating a case, but a return is often useful (§10.2.1).

When should a switch-statement have a default? There is no single answer that covers all situations. One use is for the default to handle the most common case. Another common use is the exact opposite: the default: action is simply a way to catch errors; every valid alternative is covered by the cases. However, there is one case where a default should not be used: if a switch is intended to have one case for each enumerator of an enumeration. If so, leaving out the default gives the compiler a chance to warn against a set of cases that almost but not quite match the set of enumerators. For example, this is almost certainly an error:

Click here to view code image

enum class Vessel { cup, glass, goblet, chalice };

void problematic(Vessel v)
{
     switch (v) {
     case Vessel::cup:       /* ... */    break;
     case Vessel::glass:     /* ... */    break;
     case Vessel::goblet:    /* ... */    break;
     }
}
Such a mistake can easily occur when a new enumerator is added during maintenance.

Testing for an “impossible” enumerator value is best done separately.

9.4.2.1. Declarations in Cases
It is possible, and common, to declare variables within the block of a switch-statement. However, it is not possible to bypass an initialization. For example:

Click here to view code image

void f(int i)
{
     switch (i) {
     case 0:
          int x;          // uninitialized
          int y = 3;      // error: declaration can be bypassed (explicitly initialized)
          string s;       // error: declaration can be bypassed (implicitly initialized)
     case 1:
          ++x;            // error: use of uninitialized object
          ++y;
          s = "nasty!";
     }
}
Here, if i==1, the thread of execution would bypass the initializations of y and s, so f() will not compile. Unfortunately, because an int needn’t be initialized, the declaration of x is not an error. However, its use is an error: we read an uninitialized variable. Unfortunately, compilers often give just a warning for the use of an uninitialized variable and cannot reliably catch all such misuses. As usual, avoid uninitialized variables (§6.3.5.1).

If we need a variable within a switch-statement, we can limit its scope by enclosing its declaration and its use in a block. For an example, see prim() in §10.2.1.

9.4.3. Declarations in Conditions
To avoid accidental misuse of a variable, it is usually a good idea to introduce the variable into the smallest scope possible. In particular, it is usually best to delay the definition of a local variable until one can give it an initial value. That way, one cannot get into trouble by using the variable before its initial value is assigned.

One of the most elegant applications of these two principles is to declare a variable in a condition. Consider:

if (double d = prim(true)) {
     left /= d;
     break;
}
Here, d is declared and initialized and the value of d after initialization is tested as the value of the condition. The scope of d extends from its point of declaration to the end of the statement that the condition controls. For example, had there been an else-branch to the if-statement, d would be in scope on both branches.

The obvious and traditional alternative is to declare d before the condition. However, this opens the scope (literally) for the use of d before its initialization or after its intended useful life:

Click here to view code image

double d;
 //...
d2 = d;  // oops!
 //...
if (d = prim(true)) {
      left /= d;
      break;
}
 //...
d = 2.0;  // two unrelated uses of d
In addition to the logical benefits of declaring variables in conditions, doing so also yields the most compact source code.

A declaration in a condition must declare and initialize a single variable or const.

9.5. Iteration Statements
A loop can be expressed as a for-, while-, or do-statement:

while ( condition ) statement
do statement while ( expression ) ;
for ( for-init-statement conditionopt ; expressionopt ) statement
for ( for-init-declaration : expression ) statement

A for-init-statement must be either a declaration or an expression-statement. Note that both end with a semicolon. A for-init-declaration must be the declaration of a single uninitialized variable.

The statement of a for-statement (called the controlled statement or the loop body) is executed repeatedly until the condition becomes false or the programmer breaks out of the loop some other way (such as a break, a return, a throw, or a goto).

More complicated loops can be expressed as an algorithm plus a lambda expression (§11.4.2).

9.5.1. Range-for Statements
The simplest loop is a range-for-statement; it simply gives the programmer access to each element of a range. For example:

int sum(vector<int>& v)
{
     int s = 0;
     for (int x : v)
           s+=x;
     return s;
}
The for (int x : v) can be read as “for each element x in the range v” or just “for each x in v.” The elements of v are visited in order from the first to the last.

The scope of the variable naming the element (here, x) is the for-statement.

The expression after the colon must denote a sequence (a range); that is, it must yield a value for which we can call v.begin() and v.end() or begin(v) and end(v) to obtain iterators (§4.5):

[1] the compiler first looks for members begin and end and tries to use those. If a begin or an end is found that cannot be used as a range (e.g., because a member begin is a variable rather than a function), the range-for is an error.

[2] Otherwise, the compiler looks for a begin/end member pair in the enclosing scope. If none is found or if what is found cannot be used (e.g., because the begin did not take an argument of the sequence’s type), the range-for is an error.

The compiler uses v and v+N as begin(v) and end(v) for a built-in array T v[N]. The <iterator> header provides begin(c) and end(c) for built-in arrays and for all standard-library containers. For sequences of our own design, we can define begin() and end() in the same way as it is done for standard-library containers (§4.4.5).

The controlled variable, x in the example, that refers to the current element is equivalent to *p when using an equivalent for-statement:

Click here to view code image

int sum2(vector<int>& v)
{
     int s = 0;
     for (auto p = begin(v); p!=end(v); ++p)
           s+=*p;
     return s;
}
If you need to modify an element in a range-for loop, the element variable should be a reference. For example, we can increment each element of a vector like this:

void incr(vector<int>& v)
{
     for (int& x : v)
           ++x;
}
References are also appropriate for elements that might be large, so that copying them to the element value could be costly. For example:

Click here to view code image

template<typename T> T accum(vector<T>& v)
{
     T sum = 0;
     for (const T& x : v)
           sum += x;
     return sum;
}
Note that a range-for loop is a deliberately simple construct. For example, using it you can’t touch two elements at the same time and can’t effectively traverse two ranges simultaneously. For that we need a general for-statement.

9.5.2. for Statements
There is also a more general for-statement allowing greater control of the iteration. The loop variable, the termination condition, and the expression that updates the loop variable are explicitly presented “up front” on a single line. For example:

void f(int v[], int max)
{
     for (int i = 0; i!=max; ++i)
           v[i] = i*i;
}
This is equivalent to

Click here to view code image

void f(int v[], int max)
{
     int i = 0;        // introduce loop variable
     while (i!=max) {         // test termination condition
          v[i] = i*i;  // execute the loop body
          ++i;         // increment loop variable
     }
}
A variable can be declared in the initializer part of a for-statement. If that initializer is a declaration, the variable (or variables) it introduced is in scope until the end of the for-statement.

It is not always obvious what is the right type to use for a controlled variable in a for loop, so auto often comes in handy:

Click here to view code image

for (auto p = begin(c); p!=end(c); ++p) {
       //... use iterator p for elements in container c ...
}
If the final value of an index needs to be known after exit from a for-loop, the index variable must be declared outside the for-loop (e.g., see §9.6).

If no initialization is needed, the initializing statement can be empty.

If the expression that is supposed to increment the loop variable is omitted, we must update some form of loop variable elsewhere, typically in the body of the loop. If the loop isn’t of the simple “introduce a loop variable, test the condition, update the loop variable” variety, it is often better expressed as a while-statement. However, consider this elegant variant:

for (string s; cin>>s; )
      v.push_back(s);
Here, the reading and testing for termination are combined in cin>>s, so we don’t need an explicit loop variable. On the other hand, the use of for, rather than while, allows us to limit the scope of the “current element,” s, to the loop itself (the for-statement).

A for-statement is also useful for expressing a loop without an explicit termination condition:

for (;;) {  //"forever"
       //...
}
However, many consider this idiom obscure and prefer to use:

while(true) {     //"forever"
      //...
}
9.5.3. while Statements
A while-statement executes its controlled statement until its condition becomes false. For example:

template<typename Iter, typename Value>
Iter find(Iter first, Iter last, Value val)
{
      while (first!=last && *first!=val)
           ++first;
      return first;
}
I tend to prefer while-statements over for-statements when there isn’t an obvious loop variable or where the update of a loop variable naturally comes in the middle of the loop body.

A for-statement (§9.5.2) is easily rewritten into an equivalent while-statement and vice versa.

9.5.4. do Statements
A do-statement is similar to a while-statement except that the condition comes after the body. For example:

Click here to view code image

void print_backwards(char a[], int i)     // i must be positive
{
     cout << '{';
     do {
          cout << a[––i];
     } while (i);
     cout << '}';
}
This might be called like this: print_backwards(s,strlen(s)); but it is all too easy to make a horrible mistake. For example, what if s was the empty string?

In my experience, the do-statement is a source of errors and confusion. The reason is that its body is always executed once before the condition is evaluated. However, for the body to work correctly, something very much like the condition must hold even the first time through. More often than I would have guessed, I have found that condition not to hold as expected either when the program was first written and tested or later after the code preceding it has been modified. I also prefer the condition “up front where I can see it.” Consequently, I recommend avoiding do-statements.

9.5.5. Loop Exit
If the condition of a for-statement is omitted, the loop will not terminate unless the user explicitly exits it by a break, return (§12.1.4), goto (§9.6), throw (§13.5), or some less obvious way such as a call of exit() (§15.4.3). A break “breaks out of” the nearest enclosing switch-statement (§9.4.2) or iteration-statement. For example:

Click here to view code image

void f(vector<string>& v, string terminator)
{
     char c;
     string s;
     while (cin>>c) {
           //...
          if (c == '\n') break;
           //...
     }
}
We use a break when we need to leave the loop body “in the middle.” Unless it warps the logic of a loop (e.g., requires the introduction of an extra variable), it is usually better to have the complete exit condition as the condition of a while-statement or a for-statement.

Sometimes, we don’t want to exit the loop completely, we just want to get to the end of the loop body. A continue skips the rest of the body of an iteration-statement. For example:

Click here to view code image

string find_prime(vector<string>& v)
{
     for (int i = 0; i!=v.size(); ++i) {
           if (!prime(v[i]))
                continue;
           return v[i];
     }
}
After a continue, the increment part of the loop (if any) is executed, followed by the loop condition (if any). So find_prime() could equivalently have been written as:

Click here to view code image

string find_prime(vector<string>& v)
{
     for (int i = 0; i!=v.size(); ++i) {
           if (prime(v[i]))
                 return v[i];
     }
}
9.6. goto Statements
C++ possesses the infamous goto:

goto identifier ;
identifier : statement

The goto has few uses in general high-level programming, but it can be very useful when C++ code is generated by a program rather than written directly by a person; for example, gotos can be used in a parser generated from a grammar by a parser generator.

The scope of a label is the function it is in (§6.3.4). This implies that you can use goto to jump both into and out of blocks. The only restriction is that you cannot jump past an initializer or into an exception handler (§13.5).

One of the few sensible uses of goto in ordinary code is to break out from a nested loop or switch-statement (a break breaks out of only the innermost enclosing loop or switch-statement). For example:

Click here to view code image

void do_something(int n, int m, int a)
      // do something to a two-dimensional matrix called mn
{
     for (int i = 0; i!=n; ++i)
          for (int j = 0; j!=m; ++j)
                if (nm[i][j] == a)
                      goto found;
      // not found
      //...
found:
      // nm[i][j] == a
}
Note that this goto just jumps forward to exit its loop. It does not introduce a new loop or enter a new scope. That makes it the least troublesome and least confusing use of a goto.

9.7. Comments and Indentation
There are two forms of comments:

• line comments: // the comment extends to the end of the line

• block comments: /* the comment extends to the end-of-comment marker /*

The /* */ style comments do not nest. For example:

Click here to view code image

/*
     remove expensive check
     if (check(p,q)) error("bad p q") /* should never happen */
*/
This nesting should give an error for an unmatched final */.

Judicious use of comments and consistent use of indentation can make the task of reading and understanding a program much more pleasant. Several different consistent styles of indentation are in use. I see no fundamental reason to prefer one over another (although, like most programmers, I have my preferences, and this book reflects them). The same applies to styles of comments.

Comments can be misused in ways that seriously affect the readability of a program. The compiler does not understand the contents of a comment, so it has no way of ensuring that a comment

• is meaningful,

• describes the program, and

• is up to date.

Most programs contain comments that are incomprehensible, ambiguous, and just plain wrong. Bad comments can be worse than no comments.

If something can be stated in the language itself, it should be, and not just mentioned in a comment. This remark is aimed at comments such as these:

Click here to view code image

 // variable "v" must be initialized

 // variable "v" must be used only by function "f()"

 // call function "init()" before calling any other function in this file

 // call function "cleanup()" at the end of your program
 // don't use function "weird()"

 // function "f(int ...)" takes two or three arguments
Such comments can typically be rendered unnecessary by proper use of C++.

Once something has been stated clearly in the language, it should not be mentioned a second time in a comment. For example:

a = b+c;  // a becomes b+c
count++;  // increment the counter
Such comments are worse than simply redundant. They increase the amount of text the reader has to look at, they often obscure the structure of the program, and they may be wrong. Note, however, that such comments are used extensively for teaching purposes in programming language textbooks such as this. This is one of the many ways a program in a textbook differs from a real program.

A good comment states what a piece of code is supposed to do (the intent of the code), whereas the code (only) states what it does (in terms of how it does it). Preferably, a comment is expressed at a suitably high level of abstraction so that it is easy for a human to understand without delving into minute details.

My preference is for:

• A comment for each source file stating what the declarations in it have in common, references to manuals, the name of the programmer, general hints for maintenance, etc.

• A comment for each class, template, and namespace

• A comment for each nontrivial function stating its purpose, the algorithm used (unless it is obvious), and maybe something about the assumptions it makes about its environment

• A comment for each global and namespace variable and constant

• A few comments where the code is nonobvious and/or nonportable

• Very little else

For example:

Click here to view code image

//    tbl.c: Implementation of the symbol table.

/*
      Gaussian elimination with partial pivoting.
      See Ralston: "A first course ..." pg 411.
*/

//    scan(p,n,c) requires that p points to an array of at least n elements

 // sort(p,q) sorts the elements of the sequence [p:q) using < for comparison.

 // Revised to handle invalid dates. Bjarne Stroustrup, Feb 29 2013
A well-chosen and well-written set of comments is an essential part of a good program. Writing good comments can be as difficult as writing the program itself. It is an art well worth cultivating.

9.8. Advice
[1] Don’t declare a variable until you have a value to initialize it with; §9.3, §9.4.3, §9.5.2.

[2] Prefer a switch-statement to an if-statement when there is a choice; §9.4.2.

[3] Prefer a range-for-statement to a for-statement when there is a choice; §9.5.1.

[4] Prefer a for-statement to a while-statement when there is an obvious loop variable; §9.5.2.

[5] Prefer a while-statement to a for-statement when there is no obvious loop variable; §9.5.3.

[6] Avoid do-statements; §9.5.

[7] Avoid goto; §9.6.

[8] Keep comments crisp; §9.7.

[9] Don’t say in comments what can be clearly stated in code; §9.7.

[10] State intent in comments; §9.7.

[11] Maintain a consistent indentation style; §9.7.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


9. Statements
10. Expressions
11. Select Operations
47h 26m remaining
10. Expressions
Programming is like sex: It may give some concrete results, but that is not why we do it.

– apologies to Richard Feynman

• Introduction

• A Desk Calculator

The Parser; Input; Low-Level Input; Error Handling; The Driver; Headers; Command-Line Arguments; A Note on Style

• Operator Summary

Results; Order of Evaluation; Operator Precedence; Temporary Objects

• Constant Expressions

Symbolic Constants; consts in Constant Expressions; Literal Types; Reference Arguments; Address Constant Expressions

• Implicit Type Conversion

Promotions; Conversions; Usual Arithmetic Conversions

• Advice

10.1. Introduction
This chapter discusses expressions in some detail. In C++, an assignment is an expression, a function call is an expression, the construction of an object is an expression, and so are many other operations that go beyond conventional arithmetic expression evaluation. To give an impression of how expressions are used and to show them in context, I first present a small complete program, a simple “desk calculator.” Next, the complete set of operators is listed and their meaning for builtin types is briefly outlined. The operators that require more extensive explanation are discussed in Chapter 11.

10.2. A Desk Calculator
Consider a simple desk calculator program that provides the four standard arithmetic operations as infix operators on floating-point numbers. The user can also define variables. For example, given the input

r = 2.5
area = pi * r * r
(pi is predefined) the calculator program will write

2.5
19.635
where 2.5 is the result of the first line of input and 19.635 is the result of the second.

The calculator consists of four main parts: a parser, an input function, a symbol table, and a driver. Actually, it is a miniature compiler in which the parser does the syntactic analysis, the input function handles input and lexical analysis, the symbol table holds permanent information, and the driver handles initialization, output, and errors. We could add many features to this calculator to make it more useful, but the code is long enough as it is, and most features would just add code without providing additional insight into the use of C++.

10.2.1. The Parser
Here is a grammar for the language accepted by the calculator:

Click here to view code image

program:
     end                            // end is end-of-input
     expr_list end

expr_list:
     expression print               // print is newline or semicolon
     expression print expr_list

expression:
     expression + term
     expression – term
     term

term:
     term / primary
     term * primary
     primary

primary:
     number                         // number is a floating-point literal
     name                           // name is an identifier
     name = expression
     – primary
     ( expression )
In other words, a program is a sequence of expressions separated by semicolons. The basic units of an expression are numbers, names, and the operators *, /, +, – (both unary and binary), and = (assignment). Names need not be declared before use.

I use a style of syntax analysis called recursive descent; it is a popular and straightforward top-down technique. In a language such as C++, in which function calls are relatively cheap, it is also efficient. For each production in the grammar, there is a function that calls other functions. Terminal symbols (for example, end, number, +, and –) are recognized by a lexical analyzer and nonterminal symbols are recognized by the syntax analyzer functions, expr(), term(), and prim(). As soon as both operands of a (sub)expression are known, the expression is evaluated; in a real compiler, code could be generated at this point.

For input, the parser uses a Token_stream that encapsulates the reading of characters and their composition into Tokens. That is, a Token_stream “tokenizes”: it turns streams of characters, such as 123.45, into Tokens. A Token is a {kind-of-token,value} pair, such as {number,123.45}, where the 123.45 has been turned into a floating point value. The main parts of the parser need only to know the name of the Token_stream, ts, and how to get Tokens from it. To read the next Token, it calls ts.get(). To get the most recently read Token (the “current token”), it calls ts.current(). In addition to providing tokenizing, the Token_stream hides the actual source of the characters. We’ll see that they can come directly from a user typing to cin, from a program command line, or from any other input stream (§10.2.7).

The definition of Token looks like this:

Click here to view code image

enum class Kind : char {
     name, number, end,
     plus='+', minus='–', mul='*', div='/', print=';', assign='=', lp='(', rp=')'
};
  
struct Token {
     Kind kind;
     string string_value;
     double number_value;
};
Representing each token by the integer value of its character is convenient and efficient and can be a help to people using debuggers. This works as long as no character used as input has a value used as an enumerator – and no current character set I know of has a printing character with a single-digit integer value.

The interface to Token_stream looks like this:

Click here to view code image

class Token_stream {
public:
     Token get();             // read and return next token
     const Token& current();  // most recently read token
      //...
};
The implementation is presented in §10.2.2.

Each parser function takes a bool (§6.2.2) argument, called get, indicating whether the function needs to call Token_stream::get() to get the next token. Each parser function evaluates “its” expression and returns the value. The function expr() handles addition and subtraction. It consists of a single loop that looks for terms to add or subtract:

Click here to view code image

double expr(bool get)           // add and subtract
{
    double left = term(get);

    for (;;) {                        //"forever"
          switch (ts.current().kind) {
          case Kind::plus:
              left += term(true);
              break;
          case Kind::minus:
              left –= term(true);
              break;
          default:
              return left;
          }
    }
}
This function really does not do much itself. In a manner typical of higher-level functions in a large program, it calls other functions to do the work.

The switch-statement (§2.2.4, §9.4.2) tests the value of its condition, which is supplied in parentheses after the switch keyword, against a set of constants. The break-statements are used to exit the switch-statement. If the value tested does not match any case label, the default is chosen. The programmer need not provide a default.

Note that an expression such as 2–3+4 is evaluated as (2–3)+4, as specified in the grammar.

The curious notation for(;;) is a way to specify an infinite loop; you could pronounce it “forever” (§9.5); while(true) is an alternative. The switch-statement is executed repeatedly until something different from + and – is found, and then the return-statement in the default case is executed.

The operators += and –= are used to handle the addition and subtraction; left=left+term(true) and left=left–term(true) could have been used without changing the meaning of the program. However, left+=term(true) and left–=term(true) are not only shorter but also express the intended operation directly. Each assignment operator is a separate lexical token, so a + = 1; is a syntax error because of the space between the + and the =.

C++ provides assignment operators for the binary operators:

+ – * / % & | ^ << >>
so that the following assignment operators are possible:

= += –= *= /= %= &= |= ^= <<= >>=
The % is the modulo, or remainder, operator; &, |, and ^ are the bitwise logical operators and, or, and exclusive or; << and >> are the left shift and right shift operators; §10.3 summarizes the operators and their meanings. For a binary operator @ applied to operands of built-in types, an expression x@=y means x=x@y, except that x is evaluated once only.

The function term() handles multiplication and division in the same way expr() handles addition and subtraction:

Click here to view code image

double term(bool get)          // multiply and divide
{
    double left = prim(get);

    for (;;) {
          switch (ts.current().kind) {
          case Kind::mul:
               left *= prim(true);
               break;
          case Kind::div:
               if (auto d = prim(true)) {
                     left /= d;
                     break;
               }
               return error("divide by 0");
          default:
               return left;
          }
    }
}
The result of dividing by zero is undefined and usually disastrous. We therefore test for 0 before dividing and call error() if we detect a zero divisor. The function error() is described in §10.2.4.

The variable d is introduced into the program exactly where it is needed and initialized immediately. The scope of a name introduced in a condition is the statement controlled by that condition, and the resulting value is the value of the condition (§9.4.3). Consequently, the division and assignment left/=d are done if and only if d is nonzero.

The function prim() handling a primary is much like expr() and term(), except that because we are getting lower in the call hierarchy a bit of real work is being done and no loop is necessary:

Click here to view code image

double prim(bool get)              // handle primaries
{
    if (get) ts.get();  // read next token

    switch (ts.current().kind) {
    case Kind::number:          // floating-point constant
    {    double v = ts.current().number_value;
         ts.get();
         return v;
    }
    case Kind::name:
    {    double& v = table[ts.current().string_value];         // find the corresponding
         if (ts.get().kind == Kind::assign) v = expr(true);    //'=' seen: assignment
         return v;
    }
    case Kind::minus:         // unary minus
         return –prim(true);
    case Kind::lp:
    {    auto e = expr(true);
         if (ts.current().kind != Kind::rp) return error("')' expected");
         ts.get();          // eat ')'
         return e;
    }
    default:
         return error("primary expected");
    }
}
When a Token that is a number (that is, an integer or floating-point literal) is seen, its value is placed in its number_value. Similarly, when a Token that is a name (however defined; see §10.2.2 and §10.2.3) is seen, its value is placed in its string_value.

Note that prim() always reads one more Token than it uses to analyze its primary expression. The reason is that it must do that in some cases (e.g., to see if a name is assigned to), so for consistency it must do it in all cases. In the cases where a parser function simply wants to move ahead to the next Token, it doesn’t use the return value from ts.get(). That’s fine because we can get the result from ts.current(). Had ignoring the return value of get() bothered me, I’d have either added a read() function that just updated current() without returning a value or explicitly “thrown away” the result: void(ts.get()).

Before doing anything to a name, the calculator must first look ahead to see if it is being assigned to or simply read. In both cases, the symbol table is consulted. The symbol table is a map (§4.4.3, §31.4.3):

map<string,double> table;
That is, when table is indexed by a string, the resulting value is the double corresponding to the string. For example, if the user enters

radius = 6378.388;
the calculator will reach case Kind::name and execute

Click here to view code image

double& v = table["radius"];
 //... expr() calculates the value to be assigned ...
v = 6378.388;
The reference v is used to hold on to the double associated with radius while expr() calculates the value 6378.388 from the input characters.

Chapter 14 and Chapter 15 discuss how to organize a program as a set of modules. However, with one exception, the declarations for this calculator example can be ordered so that everything is declared exactly once and before it is used. The exception is expr(), which calls term(), which calls prim(), which in turn calls expr(). This loop of calls must be broken somehow. A declaration

double expr(bool);
before the definition of prim() will do nicely.

10.2.2. Input
Reading input is often the messiest part of a program. To communicate with a person, the program must cope with that person’s whims, conventions, and seemingly random errors. Trying to force the person to behave in a manner more suitable for the machine is often (rightly) considered offensive. The task of a low-level input routine is to read characters and compose higher-level tokens from them. These tokens are then the units of input for higher-level routines. Here, low-level input is done by ts.get(). Writing a low-level input routine need not be an everyday task. Many systems provide standard functions for this.

First we need to see the complete definition of Token_stream:

Click here to view code image

class Token_stream {
public:
     Token_stream(istream& s) : ip{&s}, owns{false} { }
     Token_stream(istream* p) : ip{p}, owns{true} { }

     ∼Token_stream() { close(); }

     Token get();         // read and return next token
     Token& current();    // most recently read token

     void set_input(istream& s) { close(); ip = &s; owns=false; }
     void set_input(istream* p) { close(); ip = p; owns = true; }

private:
     void close() { if (owns) delete ip; }

     istream* ip;                      // pointer to an input stream
     bool owns;                        // does the Token_stream own the istream?
     Token ct {Kind::end} ;            // current token
};
We initialize a Token_stream with an input stream (§4.3.2, Chapter 38) from which it gets its characters. The Token_stream implements the convention that it owns (and eventually deletes; §3.2.1.2, §11.2) an istream passed as a pointer, but not an istream passed as a reference. This may be a bit elaborate for this simple program, but it is a useful and general technique for classes that hold a pointer to a resource requiring destruction.

A Token_stream holds three values: a pointer to its input stream (ip), a Boolean (owns), indicating ownership of the input stream, and the current token (ct).

I gave ct a default value because it seemed sloppy not to. People should not call current() before get(), but if they do, they get a well-defined Token. I chose Kind::end as the initial value for ct so that a program that misuses current() will not get a value that wasn’t on the input stream.

I present Token_stream::get() in two stages. First, I provide a deceptively simple version that imposes a burden on the user. Next, I modify it into a slightly less elegant, but much easier to use, version. The idea for get() is to read a character, use that character to decide what kind of token needs to be composed, read more characters when needed, and then return a Token representing the characters read.

The initial statements read the first non-whitespace character from *ip (the stream pointed to by ip) into ch and check that the read operation succeeded:

Click here to view code image

Token Token_stream::get()
{

    char ch = 0;
    *ip>>ch;

    switch (ch) {
    case 0:
         return ct={Kind::end};  // assign and return
By default, operator >> skips whitespace (that is, spaces, tabs, newlines, etc.) and leaves the value of ch unchanged if the input operation failed. Consequently, ch==0 indicates end-of-input.

Assignment is an operator, and the result of the assignment is the value of the variable assigned to. This allows me to assign the value {Kind::end} to ct and return it in the same statement. Having a single statement rather than two is useful in maintenance. If the assignment and the return became separated in the code, a programmer might update the one and forget to update the other.

Note also how the {}-list notation (§3.2.1.3, §11.3) is used on the right-hand side of an assignment. That is, it is an expression. I could have written that return-statement as:

ct.kind = Kind::end;  // assign
return ct;            // return
However, I think that assigning a complete object {Kind::end} is clearer than dealing with individual members of ct. The {Kind::end} is equivalent to {Kind::end,0,0}. That’s good if we care about the last two members of the Token and not so good if we are worried about performance. Neither is the case here, but in general dealing with complete objects is clearer and less error-prone than manipulating data members individually. The cases below give examples of the other strategy.

Consider some of the cases separately before considering the complete function. The expression terminator, ';', the parentheses, and the operators are handled simply by returning their values:

Click here to view code image

case ';':   // end of expression; print
case '*':
case '/':
case '+':
case '–':
case '(':
case ')':
case '=':
     return ct={static_cast<Kind>(ch)};
The static_cast (§11.5.2) is needed because there is no implicit conversion from char to Kind (§8.4.1); only some characters correspond to Kind values, so we have to “certify” that in this case ch does.

Numbers are handled like this:

Click here to view code image

case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
case '.':
ip–>putback(ch);         // put the first digit (or .) back into the input stream
*ip >> ct.number_value;  // read the number into ct
ct.kind=Kind::number;
return ct;
Stacking case labels horizontally rather than vertically is generally not a good idea because this arrangement is harder to read. However, having one line for each digit is tedious. Because operator >> is already defined for reading floating-point values into a double, the code is trivial. First the initial character (a digit or a dot) is put back into cin. Then, the floating-point value can be read into ct.number_value.

If the token is not the end of input, an operator, a punctuation character, or a number, it must be a name. A name is handled similarly to a number:

Click here to view code image

default:              // name, name =, or error
    if (isalpha(ch)) {
          ip–>putback(ch);                 // put the first character back into the input stream
          *ip>>ct.string_value;            // read the string into ct
          ct.kind=Kind::name;
          return ct;
    }
Finally, we may simply have an error. The simple-minded, but reasonably effective way to deal with an error is to call an error() function and then return a print token if error() returns:

error("bad token");
return ct={Kind::print};
The standard-library function isalpha() (§36.2.1) is used to avoid listing every character as a separate case label. Operator >> applied to a string (in this case, string_value) reads until it hits whitespace. Consequently, a user must terminate a name by a space before an operator using the name as an operand. This is less than ideal, so we will return to this problem in §10.2.3.

Here, finally, is the complete input function:

Click here to view code image

Token Token_stream::get()
{
    char ch = 0;
    *ip>>ch;

    switch (ch) {
    case 0:
         return ct={Kind::end};     // assign and return
    case ';':  // end of expression; print
    case '*':
    case '/':
    case '+':
    case '–':
    case '(':
    case ')':
    case '=':
         return ct={static_cast<Kind>(ch)};
    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
    case '.':
         ip–>putback(ch);                 // put the first digit (or .) back into the input stream
         *ip >> ct.number_value;          // read number into ct
         ct.kind=Kind::number;
         return ct;
    default:               // name, name =, or error
         if (isalpha(ch)) {
              ip–>putback(ch);            // put the first character back into the input stream
              *ip>>ct.string_value;       // read string into ct
              ct.kind=Kind::name;
              return ct;
          }

          error("bad token");
          return ct={Kind::print};
    }
}
The conversion of an operator to its Token value is trivial because the kind of an operator was defined as the integer value of the operator (§10.2.1).

10.2.3. Low-Level Input
Using the calculator as defined so far reveals a few inconveniences. It is tedious to remember to add a semicolon after an expression in order to get its value printed, and having a name terminated by whitespace only is a real nuisance. For example, x=7 is an identifier – rather than the identifier x followed by the operator = and the number 7. To get what we (usually) want, we would have to add whitespace after x: x =7. Both problems are solved by replacing the type-oriented default input operations in get() with code that reads individual characters.

First, we’ll make a newline equivalent to the semicolon used to mark the end-of-expression:

Click here to view code image

Token Token_stream::get()
{

    char ch;

    do {  // skip whitespace except '\n'
         if (!ip–>get(ch)) return ct={Kind::end};
    } while (ch!='\n' && isspace(ch));

    switch (ch) {
    case ';':
    case '\n':
         return ct={Kind::print};
Here, I use a do-statement; it is equivalent to a while-statement except that the controlled statement is always executed at least once. The call ip–>get(ch) reads a single character from the input stream *ip into ch. By default, get() does not skip whitespace the way >> does. The test if (!ip–>get(ch)) succeeds if no character can be read from cin; in this case, Kind::end is returned to terminate the calculator session. The operator ! (not) is used because get() returns true in case of success.

The standard-library function isspace() provides the standard test for whitespace (§36.2.1); isspace(c) returns a nonzero value if c is a whitespace character and zero otherwise. The test is implemented as a table lookup, so using isspace() is much faster than testing for the individual whitespace characters. Similar functions test if a character is a digit (isdigit()), a letter (isalpha()), or a digit or letter (isalnum()).

After whitespace has been skipped, the next character is used to determine what kind of lexical token is coming.

The problem caused by >> reading into a string until whitespace is encountered is solved by reading one character at a time until a character that is not a letter or a digit is found:

Click here to view code image

default:             // NAME, NAME=, or error
    if (isalpha(ch)) {
        ct.string_value = ch;
        while (ip->get(ch))
            if (isalnum(ch))
               ct.string_value += ch;  // append ch to end of string_value
            else {
               ip->putback(ch);
               break;
            }
        ct.kind = Kind::name;
        return ct;
    }
Fortunately, these two improvements could both be implemented by modifying a single local section of code. Constructing programs so that improvements can be implemented through local modifications only is an important design aim.

You might worry that adding characters to the end of a string one by one would be inefficient. It would be for very long strings, but all modern string implementations provide the “small string optimization” (§19.3.3). That means that handling the kind of strings we are likely to use as names in a calculator (or even in a compiler) doesn’t involve any inefficient operations. In particular, using a short string doesn’t require any use of free store. The maximum number of characters for a short string is implementation-dependent, but 14 would be a good guess.

10.2.4. Error Handling
It is always important to detect and report errors. However, for this program, a simple error handling strategy suffices. The error() function counts errors, writes out an error message, and returns:

int no_of_errors;

double error(const string& s)
{
    no_of_errors++;
    cerr << "error: " << s << '\n';
    return 1;
}
The stream cerr is an unbuffered output stream usually used to report errors (§38.1).

The reason for returning a value is that errors typically occur in the middle of the evaluation of an expression, so we should either abort that evaluation entirely or return a value that is unlikely to cause subsequent errors. The latter is adequate for this simple calculator. Had Token_stream::get() kept track of the line numbers, error() could have informed the user approximately where the error occurred. This would be useful when the calculator is used noninteractively.

A more stylized and general error-handling strategy would separate error detection from error recovery. This can be implemented using exceptions (see §2.4.3.1, Chapter 13), but what we have here is quite suitable for a 180-line calculator.

10.2.5. The Driver
With all the pieces of the program in place, we need only a driver to start things. I decided on two functions: main() to do setup and error reporting and calculate() to handle the actual calculation:

Click here to view code image

Token_stream ts {cin};   // use input from cin

void calculate()
{
     for (;;) {
           ts.get();
           if (ts.current().kind == Kind::end) break;
           if (ts.current().kind == Kind::print) continue;
           cout << expr(false) << '\n';
     }
}

int main()
{
     table["pi"] = 3.1415926535897932385;   // insert predefined names
     table["e"] = 2.7182818284590452354;

     calculate();

     return no_of_errors;
}
Conventionally, main() returns zero if the program terminates normally and nonzero otherwise (§2.2.1). Returning the number of errors accomplishes this nicely. As it happens, the only initialization needed is to insert the predefined names into the symbol table.

The primary task of the main loop (in calculate()) is to read expressions and write out the answer. This is achieved by the line:

cout << expr(false) << '\n';
The argument false tells expr() that it does not need to call ts.get() to read a token on which to work.

Testing for Kind::end ensures that the loop is correctly exited when ts.get() encounters an input error or an end-of-file. A break-statement exits its nearest enclosing switch-statement or loop (§9.5). Testing for Kind::print (that is, for '\n' and ';') relieves expr() of the responsibility for handling empty expressions. A continue-statement is equivalent to going to the very end of a loop.

10.2.6. Headers
The calculator uses standard-library facilities. Therefore, appropriate headers must be #included to complete the program:

#include<iostream>  // I/O
#include<string>    // strings
#include<map>       // map
#include<cctype>    // isalpha(), etc.
All of these headers provide facilities in the std namespace, so to use the names they provide we must either use explicit qualification with std:: or bring the names into the global namespace by

using namespace std;
To avoid confusing the discussion of expressions with modularity issues, I did the latter. Chapter 14 and Chapter 15 discuss ways of organizing this calculator into modules using namespaces and how to organize it into source files.

10.2.7. Command-Line Arguments
After the program was written and tested, I found it a bother to first start the program, then type the expressions, and finally quit. My most common use was to evaluate a single expression. If that expression could be presented as a command-line argument, a few keystrokes could be avoided.

A program starts by calling main() (§2.2.1, §15.4). When this is done, main() is given two arguments specifying the number of arguments, conventionally called argc, and an array of arguments, conventionally called argv. The arguments are C-style character strings (§2.2.5, §7.3), so the type of argv is char*[argc+1]. The name of the program (as it occurs on the command line) is passed as argv[0], so argc is always at least 1. The list of arguments is zero-terminated; that is, argv[argc]==0. For example, for the command

dc 150/1.1934
the arguments have these values:



Because the conventions for calling main() are shared with C, C-style arrays and strings are used.

The idea is to read from the command string in the same way that we read from the input stream. A stream that reads from a string is unsurprisingly called an istringstream (§38.2.2). So to calculate expressions presented on the command line, we simply have to get our Token_stream to read from an appropriate istringstream:

Click here to view code image

Token_stream ts {cin};

int main(int argc, char* argv[])
{
    switch (argc) {
    case 1:                                       // read from standard input
         break;
    case 2:                                       // read from argument string
         ts.set_input(new istringstream{argv[1]});
         break;
    default:
         error("too many arguments");
         return 1;
    }

    table["pi"] = 3.1415926535897932385;          // insert predefined names
    table["e"] = 2.7182818284590452354;

    calculate();

    return no_of_errors;
}
To use an istringstream, include <sstream>.

It would be easy to modify main() to accept several command-line arguments, but this does not appear to be necessary, especially as several expressions can be passed as a single argument:

dc "rate=1.1934;150/rate;19.75/rate;217/rate"
I use quotes because ; is the command separator on my UNIX systems. Other systems have different conventions for supplying arguments to a program on startup.

Simple as they are, argc and argv are still a source of minor, yet annoying, bugs. To avoid those and especially to make it easier to pass around the program arguments, I tend to use a simple function to create a vector<string>:

Click here to view code image

vector<string> arguments(int argc, char* argv[])
{
    vector<string> res;
    for (int i = 0; i!=argc; ++i)
          res.push_back(argv[i]);
    return res;
}
More elaborate argument parsing functions are not uncommon.

10.2.8. A Note on Style
To programmers unacquainted with associative arrays, the use of the standard-library map as the symbol table seems almost like cheating. It is not. The standard library and other libraries are meant to be used. Often, a library has received more care in its design and implementation than a programmer could afford for a handcrafted piece of code to be used in just one program.

Looking at the code for the calculator, especially at the first version, we can see that there isn’t much traditional C-style, low-level code presented. Many of the traditional tricky details have been replaced by uses of standard-library classes such as ostream, string, and map (§4.3.1, §4.2, §4.4.3, §31.4, Chapter 36, Chapter 38).

Note the relative scarcity of loops, arithmetic, and assignments. This is the way things ought to be in code that doesn’t manipulate hardware directly or implement low-level abstractions.

10.3. Operator Summary
This section presents a summary of expressions and some examples. Each operator is followed by one or more names commonly used for it and an example of its use. In these tables:

• A name is an identifier (e.g., sum and map), an operator name (e.g., operator int, operator+, and operator"" km), or the name of a template specialization (e.g., sort<Record> and array<int,10>), possibly qualified using :: (e.g., std::vector and vector<T>::operator[]).

• A class-name is the name of a class (including decltype(expr) where expr denotes a class).

• A member is a member name (including the name of a destructor or a member template).

• An object is an expression yielding a class object.

• A pointer is an expression yielding a pointer (including this and an object of that type that supports the pointer operation).

• An expr is an expression, including a literal (e.g., 17, "mouse", and true)

• An expr-list is a (possibly empty) list of expressions.

• An lvalue is an expression denoting a modifiable object (§6.4.1).

• A type can be a fully general type name (with *, (), etc.) only when it appears in parentheses; elsewhere, there are restrictions (§iso.A).

• A lambda-declarator is a (possibly empty, comma-separated) list of parameters optionally followed by the mutable specifier, optionally followed by a noexcept specifier, optionally followed by a return type (§11.4).

• A capture-list is a (possibly empty) list specifying context dependencies (§11.4).

• A stmt-list is a (possibly empty) list of statements (§2.2.4, Chapter 9).

The syntax of expressions is independent of operand types. The meanings presented here apply when the operands are of built-in types (§6.2.1). In addition, you can define meanings for operators applied to operands of user-defined types (§2.3, Chapter 18).

A table can only approximate the rules of the grammar. For details, see §iso.5 and §iso.A.

Operator Summary (continues) (§iso.5.1)

Parenthesized expression Lambda

( expr )

 

Lambda

[ capture-list ] lambda-declarator { stmt-list }

§11.4

Scope resolution

class-name :: member

§16.2.3

Scope resolution

namespace-name :: member

§14.2.1

Global

:: name

§14.2.1

Each box holds operators with the same precedence. Operators in higher boxes have higher precedence. For example, N::x.m means (N::m).m rather than the illegal N::(x.m).

Operator Summary (continued, continues)

Member selection

object. member

§16.2.3

Member selection

pointer -> member

§16.2.3

Subscripting

pointer [ expi ]

§7.3

Function call

expi ( expr-list )

§12.2

Value construction

type { expr-list}

§11.3.2

Function-style type conversion

type ( expr-list )

§11.5.4

Post increment

lvalue ++

§11.1.4

Post decrement

lvalue --

§11.1.4

Type identification

typeid ( type )

§22.5

Run-time type identification

typeid ( expr )

§22.5

Run-time checked conversion

dynamic_cast < type >( expr )

§22.2.1

Compile-time checked conversion

static_cast < type >( expr )

§11.5.2

Unchecked conversion

reinterpret_cast < type >( expr )

§11.5.2

const conversion

const_cast < type >( expr )

§11.5.2

Size of object

sizeof expr

§6.2.8

Size of type

sizeof ( type )

§6.2.8

Size of parameter pack

sizeof... name

§28.6.2

Alignment of type

alignof ( type )

§6.2.9

Pre increment

++ lvalue

§11.1.4

Pre decrement

-- lvalue

§11.1.4

Complement

~ expr

§11.1.2

Not

! expr

§11.1.1

Unary minus

- expr

§2.2.2

Unary plus

+ expr

§2.2.2

Address of

& lvalue

§7.2

Dereference

* expr

§7.2

Create (allocate)

new type

§11.2

Create (allocate and initialize)

new type ( expr-list )

§11.2

Create (allocate and initialize)

new type { expr-list }

§11.2

Create (place)

new ( expr-list ) type

§11.2.4

Create (place and initialize)

new ( expr-list ) type ( expr-list )

§11.2.4

Create (place and initialize)

new ( expr-list ) type { expr-list }

§11.2.4

Destroy (deallocate)

delete pointer

§11.2

Destroy array

delete [] pointer

§11.2.2

Can expression throw?

noexcept ( expr)

§13.5.1.2

Cast (type conversion)

( type ) expr

§11.5.3

Member selection

object .* pointer-to-member

§20.6

Member selection

pointer ->* pointer-to-member

§20.6

For example, postfix ++ has higher precedence than unary *, so *p++ means *(p++), not (*p)++.

Operator Summary (continued)

Multiply

expr * expr

§10.2.1

Divide

expr / expr

§10.2.1

Modulo (remainder)

expr % expr

§10.2.1

Add (plus)

expr + expr

§10.2.1

Subtract (minus)

expr - expr

§10.2.1

Shift left

expr << expr

§11.1.2

Shift right

expr >> expr

§11.1.2

Less than

expr < expr

§2.2.2

Less than or equal

expr <= expr

§2.2.2

Greater than

expr > expr

§2.2.2

Greater than or equal

expr >= expr

§2.2.2

Equal

expr == expr

§2.2.2

Not equal

expr != expr

§2.2.2

Bitwise and

expr & expr

§11.1.2

Bitwise exclusive-or

expr ^ expr

§11.1.2

Bitwise inclusive-or

expr | expr

§11.1.2

Logical and

expr && expr

§11.1.1

Logical inclusive or

expr || expr

§11.1.1

Conditional expression

expr ? expr : expr

§11.1.3

List

{ expr-list}

§11.3

Throw exception

throw expr

§13.5

Simple assignment

lvalue = expr

§10.2.1

Multiply and assign

lvalue *= expr

§10.2.1

Divide and assign

lvalue /= expr

§10.2.1

Modulo and assign

lvalue %= expr

§10.2.1

Add and assign

lvalue += expr

§10.2.1

Subtract and assign

lvalue -= expr

§10.2.1

Shift left and assign

lvalue <<= expr

§10.2.1

Shift right and assign

lvalue >>= expr

§10.2.1

Bitwise and and assign

lvalue &= expr

§10.2.1

Bitwise inclusive-or and assign

lvalue |= expr

§10.2.1

Bitwise exclusive-or and assign

lvalue ^= expr

§10.2.1

comma (sequencing)

expr, expr

§10.3.2

For example: a+b*c means a+(b*c) rather than (a+b)*c because * has higher precedence than +.

Unary operators and assignment operators are right-associative; all others are left-associative. For example, a=b=c means a=(b=c) whereas a+b+c means (a+b)+c.

A few grammar rules cannot be expressed in terms of precedence (also known as binding strength) and associativity. For example, a=b<c?d=e:f=g means a=((b<c)?(d=e):(f=g)), but you need to look at the grammar (§iso.A) to determine that.

Before applying the grammar rules, lexical tokens are composed from characters. The longest possible sequence of characters is chosen to make a token. For example, && is a single operator, rather than two & operators, and a+++1 means (a ++) + 1. This is sometimes called the Max Munch rule.

Token Summary (§iso.2.7)

Token Class

Examples

Reference

Identifier

vector, foo_bar, x3

§6.3.3

Keyword

int, for, virtual

§6.3.3.1

Character literal

'x', '\n', U'\UFADEFADE'

§6.2.3.2

Integer literal

12, 012, 0x12

§6.2.4.1

Floating-point literal

1.2, 1.2e-3, 1.2L

§6.2.5.1

String literal

"Hello!", R"("World"!)"

§7.3.2

Operator

+=, %, <<

§10.3

Punctuation

;,,, {,}, (, )

 

Preprocessor notation

#, ##

§12.6

Whitespace characters (e.g., space, tab, and newline) can be token separators (e.g., int count is a keyword followed by an identifier, rather than intcount) but are otherwise ignored.

Some characters from the basic source character set (§6.1.2), such as |, are not convenient to type on some keyboards. Also, some programmers find it odd to use symbols, such as && and ~, for basic logical operations. Consequently, a set of alternative representations are provided as keywords:

Alternative Representation (§iso.2.12)

and

&&

and_eq

&=

bitand

&

bitor

|

compl

~

not

!

not_eq

!=

or

||

or_eq

|=

xor

^

xor_eq

^=

For example

bool b = not (x or y) and z;
int x4 = compl (x1 bitor x2) bitand x3;
is equivalent to

bool b = !(x || y) && z;
int x4 = ~ (x1 | x2) & x3;
Note that and= is not equivalent to &=; if you prefer keywords, you must write and_eq.

10.3.1. Results
The result types of arithmetic operators are determined by a set of rules known as “the usual arithmetic conversions” (§10.5.3). The overall aim is to produce a result of the “largest” operand type. For example, if a binary operator has a floating-point operand, the computation is done using floating-point arithmetic and the result is a floating-point value. Similarly, if it has a long operand, the computation is done using long integer arithmetic, and the result is a long. Operands that are smaller than an int (such as bool and char) are converted to int before the operator is applied.

The relational operators, ==, <=, etc., produce Boolean results. The meaning and result type of user-defined operators are determined by their declarations (§18.2).

Where logically feasible, the result of an operator that takes an lvalue operand is an lvalue denoting that lvalue operand. For example:

Click here to view code image

void f(int x, int y)
{
     int j = x = y;            // the value of x=y is the value of x after the assignment with y
     int* p = &++x;            // p points to x
     int* q = &(x++);          // error: x++ is not an lvalue (it is not the value stored in x)
     int* p2 = &(x>y?x:y);     // address of the int with the larger value
     int& r = (x<y)?x:1;       // error: 1 is not an lvalue
}
If both the second and third operands of ?: are lvalues and have the same type, the result is of that type and is an lvalue. Preserving lvalues in this way allows greater flexibility in using operators. This is particularly useful when writing code that needs to work uniformly and efficiently with both built-in and user-defined types (e.g., when writing templates or programs that generate C++ code).

The result of sizeof is of an unsigned integral type called size_t defined in <cstddef>. The result of pointer subtraction is of a signed integral type called ptrdiff_t defined in <cstddef>.

Implementations do not have to check for arithmetic overflow and hardly any do. For example:

Click here to view code image

void f()
{
     int i = 1;
     while (0 < i) ++i;
     cout << "i has become negative!" << i << '\n';
}
This will (eventually) try to increase i past the largest integer. What happens then is undefined, but typically the value “wraps around” to a negative number (on my machine –2147483648). Similarly, the effect of dividing by zero is undefined, but doing so usually causes abrupt termination of the program. In particular, underflow, overflow, and division by zero do not throw standard exceptions (§30.4.1.1).

10.3.2. Order of Evaluation
The order of evaluation of subexpressions within an expression is undefined. In particular, you cannot assume that the expression is evaluated left-to-right. For example:

int x = f(2)+g(3);        // undefined whether f() or g() is called first
Better code can be generated in the absence of restrictions on expression evaluation order. However, the absence of restrictions on evaluation order can lead to undefined results. For example:

int i = 1;
v[i] = i++;  // undefined result
The assignment may be evaluated as either v[1]=1 or v[2]=1 or may cause some even stranger behavior. Compilers can warn about such ambiguities. Unfortunately, most do not, so be careful not to write an expression that both reads and writes an object, unless it does so using a single operator that makes it well defined, such as ++ and +=, or explicitly express sequencing using , (comma), &&, or ||.

The operators , (comma), && (logical and), and || (logical or) guarantee that their left-hand operand is evaluated before their right-hand operand. For example, b=(a=2,a+1) assigns 3 to b. Examples of the use of || and && can be found in §10.3.3. For built-in types, the second operand of && is evaluated only if its first operand is true, and the second operand of || is evaluated only if its first operand is false; this is sometimes called short-circuit evaluation. Note that the sequencing operator , (comma) is logically different from the comma used to separate arguments in a function call. For example:

f1(v[i],i++);         // two arguments
f2( (v[i],i++) );     // one argument
The call of f1 has two arguments, v[i] and i++, and the order of evaluation of the argument expressions is undefined. So it should be avoided. Order dependence of argument expressions is very poor style and has undefined behavior. The call of f2 has only one argument, the comma expression (v[i],i++), which is equivalent to i++. That is confusing, so that too should be avoided.

Parentheses can be used to force grouping. For example, a*b/c means (a*b)/c, so parentheses must be used to get a*(b/c); a*(b/c) may be evaluated as (a*b)/c only if the user cannot tell the difference. In particular, for many floating-point computations a*(b/c) and (a*b)/c are significantly different, so a compiler will evaluate such expressions exactly as written.

10.3.3. Operator Precedence
Precedence levels and associativity rules reflect the most common usage. For example:

if (i<=0 || max<i)  //...
means “if i is less than or equal to 0 or if max is less than i.” That is, it is equivalent to

if ( (i<=0) || (max<i) )  //...
and not the legal but nonsensical

if (i <= (0||max) < i)  //...
However, parentheses should be used whenever a programmer is in doubt about those rules. Use of parentheses becomes more common as the subexpressions become more complicated, but complicated subexpressions are a source of errors. Therefore, if you start feeling the need for parentheses, you might consider breaking up the expression by using an extra variable.

There are cases when the operator precedence does not result in the “obvious” interpretation. For example:

if (i&mask == 0)    // oops! == expression as operand for &
This does not apply a mask to i and then test if the result is zero. Because == has higher precedence than &, the expression is interpreted as i&(mask==0). Fortunately, it is easy enough for a compiler to warn about most such mistakes. In this case, parentheses are important:

if ((i&mask) == 0)  //...
It is worth noting that the following does not work the way a mathematician might expect:

if (0 <= x <= 99)  //...
This is legal, but it is interpreted as (0<=x)<=99, where the result of the first comparison is either true or false. This Boolean value is then implicitly converted to 1 or 0, which is then compared to 99, yielding true. To test whether x is in the range 0..99, we might use

if (0<=x && x<=99)  //...
A common mistake for novices is to use = (assignment) instead of == (equals) in a condition:

if (a = 7)  // oops! constant assignment in condition
This is natural because = means “equals” in many languages. Again, it is easy for a compiler to warn about most such mistakes – and many do. I do not recommend warping your style to compensate for compilers with weak warnings. In particular, I don’t consider this style worthwhile:

if (7 == a)  // try to protect against misuse of =; not recommended
10.3.4. Temporary Objects
Often, the compiler must introduce an object to hold an intermediate result of an expression. For example, for v=x+y*z the result of y*z has to be put somewhere before it is added to x. For built-in types, this is all handled so that a temporary object (often referred to as just a temporary) is invisible to the user. However, for a user-defined type that holds a resource knowing the lifetime of a temporary can be important. Unless bound to a reference or used to initialize a named object, a temporary object is destroyed at the end of the full expression in which it was created. A full expression is an expression that is not a subexpression of some other expression.

The standard-library string has a member c_str() (§36.3) that returns a C-style pointer to a zero-terminated array of characters (§2.2.5, §43.4). Also, the operator + is defined to mean string concatenation. These are useful facilities for strings. However, in combination they can cause obscure problems. For example:

Click here to view code image

void f(string& s1, string& s2, string& s3)
{
     const char* cs = (s1+s2).c_str();
     cout << cs;
     if (<8strlen(cs=(s2+s3).c_str()) && cs[0]=='a') {
             // cs used here
     }
}
Probably, your first reaction is “But don’t do that!” and I agree. However, such code does get written, so it is worth knowing how it is interpreted.

A temporary string object is created to hold s1+s2. Next, a pointer to a C-style string is extracted from that object. Then – at the end of the expression – the temporary object is deleted. However, the C-style string returned by c_str() was allocated as part of the temporary object holding s1+s2, and that storage is not guaranteed to exist after that temporary is destroyed. Consequently, cs points to deallocated storage. The output operation cout<<cs might work as expected, but that would be sheer luck. A compiler can detect and warn against many variants of this problem.

The problem with the if-statement is a bit more subtle. The condition will work as expected because the full expression in which the temporary holding s2+s3 is created is the condition itself. However, that temporary is destroyed before the controlled statement is entered, so any use of cs there is not guaranteed to work.

Please note that in this case, as in many others, the problems with temporaries arose from using a high-level data type in a low-level way. A cleaner programming style yields a more understandable program fragment and avoids the problems with temporaries completely. For example:

Click here to view code image

void f(string& s1, string& s2, string& s3)
{
     cout << s1+s2;
     string s = s2+s3;
     if (<8s.length() && s[0]=='a') {
             // use s here
     }
}
A temporary can be used as an initializer for a const reference or a named object. For example:

Click here to view code image

void g(const string&, const string&);

void h(string& s1, string& s2)
{
     const string& s = s1+s2;
     string ss = s1+s2;

     g(s,ss);  // we can use s and ss here
}
This is fine. The temporary is destroyed when “its” reference or named object goes out of scope. Remember that returning a reference to a local variable is an error (§12.1.4) and that a temporary object cannot be bound to a non-const lvalue reference (§7.7).

A temporary object can also be created explicitly in an expression by invoking a constructor (§11.5.1). For example:

Click here to view code image

void f(string& s, int n, char ch)
{
     s.move(string{n,ch});  // construct a string with n copies of ch to pass to strinng::move() (§36.3.2)
      //...
}
Such temporaries are destroyed in exactly the same way as the implicitly generated temporaries.

10.4. Constant Expressions
C++ offers two related meanings of “constant”:

• constexpr: Evaluate at compile time (§2.2.3).

• const: Do not modify in this scope (§2.2.3, §7.5).

Basically, constexpr’s role is to enable and ensure compile-time evaluation, whereas const’s primary role is to specify immutability in interfaces. This section is primarily concerned with the first role: compile-time evaluation.

A constant expression is an expression that a compiler can evaluate. It cannot use values that are not known at compile time and it cannot have side effects. Ultimately, a constant expression must start out with an integral value (§6.2.1), a floating-point value (§6.2.5), or an enumerator (§8.4), and we can combine those using operators and constexpr functions that in turn produce values. In addition, some addresses can be used in some forms of constant expressions. For simplicity, I discuss those separately in §10.4.5.

There are a variety of reasons why someone might want a named constant rather than a literal or a value stored in a variable:

[1] Named constants make the code easier to understand and maintain.

[2] A variable might be changed (so we have to be more careful in our reasoning than for a constant).

[3] The language requires constant expressions for array sizes, case labels, and template value arguments.

[4] Embedded systems programmers like to put immutable data into read-only memory because read-only memory is cheaper than dynamic memory (in terms of cost and energy consumption), and often more plentiful. Also, data in read-only memory is immune to most system crashes.

[5] If initialization is done at compile time, there can be no data races on that object in a multi-threaded system.

[6] Sometimes, evaluating something once (at compile time) gives significantly better performance than doing so a million times at run time.

Note that reasons [1], [2], [5], and (partly) [4] are logical. We don’t just use constant expressions because of an obsession with performance. Often, the reason is that a constant expression is a more direct representation of our system requirements.

As part of the definition of a data item (here, I deliberately avoid the word “variable”), constexpr expresses the need for compile-time evaluation. If the initializer for a constexpr can’t be evaluated at compile time, the compiler will give an error. For example:

Click here to view code image

int x1 = 7;
constexpr int x2 = 7;

constexpr int x3 = x1;            // error: initializer is not a constant expression
constexpr int x4 = x2;            // OK

void f()
{
     constexpr int y3 = x1;       // error: initializer is not a constant expression
     constexpr int y4 = x2;       // OK
      //...
}
A clever compiler could deduce that the value of x1 in the initializer for x3 was 7. However, we prefer not to rely on degrees of cleverness in compilers. In a large program, determining the values of variables at compile time is typically either very difficult or impossible.

The expressive power of constant expressions is great. We can use integer, floating-point, and enumeration values. We can use any operator that doesn’t modify state (e.g., +, ?:, and [], but not = or ++). We can use constexpr functions (§12.1.6) and literal types (§10.4.3) to provide a significant level of type safety and expressive power. It is almost unfair to compare this to what is commonly done with macros (§12.6).

The conditional-expression operator ?: is the means of selection in a constant expression. For example, we can compute an integer square root at compile time:

Click here to view code image

constexpr int isqrt_helper(int sq, int d, int a)
{
    return sq <= a ? isqrt_helper(sq+d,d+2,a) : d;
}

constexpr int isqrt(int x)
{
    return isqrt_helper(1,3,x)/2 – 1;
}

constexpr int s1 = isqrt(9);     // s1 becomes 3
constexpr int s2 = isqrt(1234);
The condition of a ?: is evaluated and then the selected alternative is evaluated. The alternative not selected is not evaluated and might even not be a constant expression. Similarly, operands of && and || that are not evaluated need not be constant expressions. This feature is primarily useful in constexpr functions that are sometimes used as constant expressions and sometimes not.

10.4.1. Symbolic Constants
The most important single use of constants (constexpr or const values) is simply to provide symbolic names for values. Symbolic names should be used systematically to avoid “magic numbers” in code. Literal values scattered freely around in code is one of the nastiest maintenance hazards. If a numeric constant, such as an array bound, is repeated in code, it becomes hard to revise that code because every occurrence of that constant must be changed to update the code correctly. Using a symbolic name instead localizes information. Usually, a numeric constant represents an assumption about the program. For example, 4 may represent the number of bytes in an integer, 128 the number of characters needed to buffer input, and 6.24 the exchange factor between Danish kroner and U.S. dollars. Left as numeric constants in the code, these values are hard for a maintainer to spot and understand. Also, many such values need to change over time. Often, such numeric values go unnoticed and become errors when a program is ported or when some other change violates the assumptions they represent. Representing assumptions as well-commented named (symbolic) constants minimizes such maintenance problems.

10.4.2. consts in Constant Expressions
A const is primarily used to express interfaces (§7.5). However, const can also be used to express constant values. For example:

const int x = 7;
const string s = "asdf";
const int y = sqrt(x);
A const initialized with a constant expression can be used in a constant expression. A const differs from a constexpr in that it can be initialized by something that is not a constant expression; in that case, the const cannot be used as a constant expression. For example:

Click here to view code image

constexpr int xx = x;        // OK
constexpr string ss = s;     // error: s is not a constant expression
constexpr int yy = y;        // error: sqrt(x) is not a constant expression
The reasons for the errors are that string is not a literal type (§10.4.3) and sqrt() is not a constexpr function (§12.1.6).

Usually, constexpr is a better choice than const for defining simple constants, but constexpr is new in C++11, so older code tends to use const. In many cases, enumerators (§8.4) are another alternative to consts.

10.4.3. Literal Types
A sufficiently simple user-defined type can be used in a constant expression. For example:

Click here to view code image

struct Point {
     int x,y,z;
     constexpr Point up(int d) { return {x,y,z+d}; }
     constexpr Point move(int dx, int dy) { return {x+dx,y+dy}; }
      //...
};
A class with a constexpr constructor is called a literal type. To be simple enough to be constexpr, a constructor must have an empty body and all members must be initialized by potentially constant expressions. For example:

Click here to view code image

constexpr Point origo {0,0};
constexpr int z = origo.x;

constexpr Point a[] = {
    origo, Point{1,1}, Point{2,2}, origo.move(3,3)
};
constexpr int x = a[1].x;       // x becomes 1

constexpr Point xy{0,sqrt(2)};  // error: sqrt(2) is not a constant expression
Note that we can have constexpr arrays and also access array elements and object members.

Naturally, we can define constexpr functions to take arguments of literal types. For example:

Click here to view code image

constexpr int square(int x)
{
    return x*x;
}

constexpr int radial_distance(Point p)
{
    return isqrt(square(p.x)+square(p.y)+square(p.z));
}

constexpr Point p1 {10,20,30};            // the default constructor is constexpr
constexpr Point p2 {p1.up(20)};                 // Point::up() is constexpr
constexpr int dist = radial_distance(p2);
I used int rather than double just because I didn’t have a constexpr floating-point square root function handy.

For a member function constexpr implies const, so I did not have to write:

constexpr Point move(int dx, int dy) const { return {x+dx,y+dy}; }
10.4.4. Reference Arguments
When working with constexpr, the key thing to remember is that constexpr is all about values. There are no objects that can change values or side effects here: constexpr provides a miniature compile-time functional programming language. That said, you might guess that constexpr cannot deal with references, but that’s only partially true because const references refer to values and can therefore be used. Consider the specialization of the general complex<T> to a complex<double> from the standard library:

Click here to view code image

template<> class complex<double> {
public:
     constexpr complex(double re = 0.0, double im = 0.0);
     constexpr complex(const complex<float>&);
     explicit constexpr complex(const complex<long double>&);

     constexpr double real();      // read the real part
     void real(double);            // set the real part
     constexpr double imag();      // read the imaginary part
     void imag(double);            // set the imaginary part

     complex<double>& operator= (double);
     complex<double>& operator+=(double);
      //...
};
Obviously, operations, such as = and +=, that modify an object cannot be constexpr. Conversely, operations that simply read an object, such as real() and imag(), can be constexpr and be evaluated at compile time given a constant expression. The interesting member is the template constructor from another complex type. Consider:

Click here to view code image

constexpr complex<float> z1 {1,2};         // note: <float> not <double>
constexpr double re = z1.real();
constexpr double im = z1.imag();
constexpr complex<double> z2 {re,im};      // z2 becomes a copy of z1
constexpr complex<double> z3 {z1};         // z3 becomes a copy of z1
The copy constructor works because the compiler recognizes that the reference (the const complex<float>&) refers to a constant value and we just use that value (rather than trying anything advanced or silly with references or pointers).

Literal types allow for type-rich compile-time programming. Traditionally, C++ compile-time evaluation has been restricted to using integer values (and without functions). This has resulted in code that was unnecessarily complicated and error-prone, as people encoded every kind of information as integers. Some uses of template metaprogramming (Chapter 28) are examples of that. Other programmers have simply preferred run-time evaluation to avoid the difficulties of writing in an impoverished language.

10.4.5. Address Constant Expressions
The address of a statically allocated object (§6.4.2), such as a global variable, is a constant. However, its value is assigned by the linker, rather than the compiler, so the compiler cannot know the value of such an address constant. That limits the range of constant expressions of pointer and reference type. For example:

Click here to view code image

constexpr const char* p1 = "asdf";
constexpr const char* p2 = p1;        // OK
constexpr const char* p2 = p1+2;      // error: the compiler does not know the value of p1
constexpr char c = p1[2];             // OK, c=='d'; the compiler knows the value pointed to by p1
10.5. Implicit Type Conversion
Integral and floating-point types (§6.2.1) can be mixed freely in assignments and expressions. Wherever possible, values are converted so as not to lose information. Unfortunately, some value-destroying (“narrowing”) conversions are also performed implicitly. A conversion is value-preserving if you can convert a value and then convert the result back to its original type and get the original value. If a conversion cannot do that, it is a narrowing conversion (§10.5.2.6). This section provides a description of conversion rules, conversion problems, and their resolution.

10.5.1. Promotions
The implicit conversions that preserve values are commonly referred to as promotions. Before an arithmetic operation is performed, integral promotion is used to create ints out of shorter integer types. Note that these promotions will not promote to long (unless the operand is a char16_t, char32_t, wchar_t, or a plain enumeration that is already larger than an int). This reflects the original purpose of these promotions in C: to bring operands to the “natural” size for arithmetic operations.

The integral promotions are:

• A char, signed char, unsigned char, short int, or unsigned short int is converted to an int if int can represent all the values of the source type; otherwise, it is converted to an unsigned int.

• A char16_t, char32_t, wchar_t (§6.2.3), or a plain enumeration type (§8.4.2) is converted to the first of the following types that can represent all the values of its underlying type: int, unsigned int, long, unsigned long, or unsigned long long.

• A bit-field (§8.2.7) is converted to an int if int can represent all the values of the bit-field; otherwise, it is converted to unsigned int if unsigned int can represent all the values of the bit-field. Otherwise, no integral promotion applies to it.

• A bool is converted to an int; false becomes 0 and true becomes 1.

Promotions are used as part of the usual arithmetic conversions (§10.5.3).

10.5.2. Conversions
The fundamental types can be implicitly converted into each other in a bewildering number of ways (§iso.4). In my opinion, too many conversions are allowed. For example:

Click here to view code image

void f(double d)
{
     char c = d;        // beware: double-precision floating-point to char conversion
}
When writing code, you should always aim to avoid undefined behavior and conversions that quietly throw away information (“narrowing conversions”).

A compiler can warn about many questionable conversions. Fortunately, many compilers do.

The {}-initializer syntax prevents narrowing (§6.3.5). For example:

Click here to view code image

void f(double d)
{
     char c {d};        // error: double-precision floating-point to char conversion
}
If potentially narrowing conversions are unavoidable, consider using some form of run-time checked conversion function, such as narrow_cast<>() (§11.5).

10.5.2.1. Integral Conversions
An integer can be converted to another integer type. A plain enumeration value can be converted to an integer type (§8.4.2) .

If the destination type is unsigned, the resulting value is simply as many bits from the source as will fit in the destination (high-order bits are thrown away if necessary). More precisely, the result is the least unsigned integer congruent to the source integer modulo 2 to the nth, where n is the number of bits used to represent the unsigned type. For example:

unsigned char uc = 1023; // binary 1111111111: uc becomes binary 11111111, that is, 255
If the destination type is signed, the value is unchanged if it can be represented in the destination type; otherwise, the value is implementation-defined:

signed char sc = 1023;     // implementation-defined
Plausible results are 127 and –1 (§6.2.3).

A Boolean or plain enumeration value can be implicitly converted to its integer equivalent (§6.2.2, §8.4).

10.5.2.2. Floating-Point Conversions
A floating-point value can be converted to another floating-point type. If the source value can be exactly represented in the destination type, the result is the original numeric value. If the source value is between two adjacent destination values, the result is one of those values. Otherwise, the behavior is undefined. For example:

Click here to view code image

float f = FLT_MAX;       // largest float value
double d = f;            // OK: d == f

double d2 = DBL_MAX;     // largest double value
float f2 = d2;           // undefined if FLT_MAX<DBL_MAX

long double ld = d2;     // OK: ld == d2
long double ld2 = numeric_limits<long double>::max();
double d3 = ld2;         // undefined if sizeof(long double)>sizeof(double)
DBL_MAX and FLT_MAX are defined in <cfloat>; numeric_limits is defined in <limits> (§40.2).

10.5.2.3. Pointer and Reference Conversions
Any pointer to an object type can be implicitly converted to a void* (§7.2.1). A pointer (reference) to a derived class can be implicitly converted to a pointer (reference) to an accessible and unambiguous base (§20.2). Note that a pointer to function or a pointer to member cannot be implicitly converted to a void*.

A constant expression (§10.4) that evaluates to 0 can be implicitly converted to a null pointer of any pointer type. Similarly, a constant expression that evaluates to 0 can be implicitly converted to a pointer-to-member type (§20.6). For example:

int* p = (1+2)*(2*(1–1));  // OK, but weird
Prefer nullptr (§7.2.2).

A T* can be implicitly converted to a const T* (§7.5). Similarly, a T& can be implicitly converted to a const T&.

10.5.2.4. Pointer-to-Member Conversions
Pointers and references to members can be implicitly converted as described in §20.6.3.

10.5.2.5. Boolean Conversions
Pointer, integral, and floating-point values can be implicitly converted to bool (§6.2.2). A nonzero value converts to true; a zero value converts to false. For example:

Click here to view code image

void f(int* p, int i)
{
     bool is_not_zero = p;         // true if p!=0
     bool b2 = i;                  // true if i!=0
      //...
}
The pointer-to-bool conversion is useful in conditions, but confusing elsewhere:

Click here to view code image

void fi(int);
void fb(bool);

void ff(int* p, int* q)
{
     if (p) do_something(*p);           // OK
     if (q!=nullptr) do_something(*q);  // OK, but verbose
      //...
     fi(p);                         // error: no pointer to int conversion
     fb(p);                         // OK: pointer to bool conversion (surprise!?)
}
Hope for a compiler warning for fb(p).

10.5.2.6. Floating-Integral Conversions
When a floating-point value is converted to an integer value, the fractional part is discarded. In other words, conversion from a floating-point type to an integer type truncates. For example, the value of int(1.6) is 1. The behavior is undefined if the truncated value cannot be represented in the destination type. For example:

Click here to view code image

int i = 2.7;         // i becomes 2
char b = 2000.7;     // undefined for 8-bit chars: 2000 cannot be represented as an 8-bit char
Conversions from integer to floating types are as mathematically correct as the hardware allows. Loss of precision occurs if an integral value cannot be represented exactly as a value of the floating type. For example:

int i = float(1234567890);
On a machine where both ints and floats are represented using 32 bits, the value of i is 1234567936.

Clearly, it is best to avoid potentially value-destroying implicit conversions. In fact, compilers can detect and warn against some obviously dangerous conversions, such as floating to integral and long int to char. However, general compile-time detection is impractical, so the programmer must be careful. When “being careful” isn’t enough, the programmer can insert explicit checks. For example:

Click here to view code image

char checked_cast(int i)
{
     char c = i;    // warning: not portable (§10.5.2.1)
     if (i != c) throw std::runtime_error{"int–to–char check failed"};
     return c;
}

void my_code(int i)
{
     char c = checked_cast(i);
      //...
}
A more general technique for expressing checked conversions is presented in §25.2.5.1.

To truncate in a way that is guaranteed to be portable requires the use of numeric_limits (§40.2). In initializations, truncation can be avoided by using the {}-initializer notation (§6.3.5).

10.5.3. Usual Arithmetic Conversions
These conversions are performed on the operands of a binary operator to bring them to a common type, which is then used as the type of the result:

[1] If either operand is of type long double, the other is converted to long double.

• Otherwise, if either operand is double, the other is converted to double.

• Otherwise, if either operand is float, the other is converted to float.

• Otherwise, integral promotions (§10.5.1) are performed on both operands.

[2] Otherwise, if either operand is unsigned long long, the other is converted to unsigned long long.

• Otherwise, if one operand is a long int and the other is an unsigned long int, then if a long int can represent all the values of an unsigned long int, the unsigned long int is converted to a long int; otherwise, both operands are converted to unsigned long int

• Otherwise, if one operand is a long int and the other is an unsigned int, then if a long int can represent all the values of an unsigned int, the unsigned int is converted to a long int; otherwise, both operands are converted to unsigned long int.

• Otherwise, if either operand is long, the other is converted to long.

• Otherwise, if either operand is unsigned, the other is converted to unsigned.

• Otherwise, both operands are int.

These rules make the result of converting an unsigned integer to a signed one of possibly larger size implementation-defined. That is yet another reason to avoid mixing unsigned and signed integers.

10.6. Advice
[1] Prefer the standard library to other libraries and to “handcrafted code”; §10.2.8.

[2] Use character-level input only when you have to; §10.2.3.

[3] When reading, always consider ill-formed input; §10.2.3.

[4] Prefer suitable abstractions (classes, algorithms, etc.) to direct use of language features (e.g., ints, statements); §10.2.8.

[5] Avoid complicated expressions; §10.3.3.

[6] If in doubt about operator precedence, parenthesize; §10.3.3.

[7] Avoid expressions with undefined order of evaluation; §10.3.2.

[8] Avoid narrowing conversions; §10.5.2.

[9] Define symbolic constants to avoid “magic constants”; §10.4.1.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


10. Expressions
11. Select Operations
12. Functions
47h 26m remaining
11. Select Operations
When someone says “I want a programming language in which I need only say what I wish done,” give him a lollipop.

– Alan Perlis

• Etc. Operators

Logical Operators; Bitwise Logical Operators; Conditional Expressions; Increment and Decrement

• Free Store

Memory Management; Arrays; Getting Memory Space; Overloading new

• Lists

Implementation Model; Qualified Lists; Unqualified Lists

• Lambda Expressions

Implementation Model; Alternatives to Lambdas; Capture; Call and Return; The Type of a Lambda

• Explicit Type Conversion

Construction; Named Casts; C-Style Cast; Function-Style Cast

• Advice

11.1. Etc. Operators
This section examines a mixed bag of simple operators: logical operators (&&, ||, and !), bitwise logical operators (&, |, ~, <<, and >>), conditional expressions (?:), and increment and decrement operators (++ and ––). They have little in common beyond their details not fitting elsewhere in the discussions of operators.

11.1.1. Logical Operators
The logical operators && (and), || (or), and ! (not) take operands of arithmetic and pointer types, convert them to bool, and return a bool result. The && and || operators evaluate their second argument only if necessary, so they can be used to control evaluation order (§10.3.2). For example:

while (p && !whitespace(p)) ++p;
Here, p is not dereferenced if it is the nullptr.

11.1.2. Bitwise Logical Operators
The bitwise logical operators & (and), | (or), ^ (exclusive or, xor), ~ (complement), >> (right shift), and << (left shift) are applied to objects of integral types – that is, char, short, int, long, long long and their unsigned counterparts, and bool, wchar_t, char16_t, and char32_t. A plain enum (but not an enum class) can be implicitly converted to an integer type and used as an operand to bitwise logical operations. The usual arithmetic conversions (§10.5.3) determine the type of the result.

A typical use of bitwise logical operators is to implement the notion of a small set (a bit vector). In this case, each bit of an unsigned integer represents one member of the set, and the number of bits limits the number of members. The binary operator & is interpreted as intersection, | as union, ^ as symmetric difference, and ~ as complement. An enumeration can be used to name the members of such a set. Here is a small example borrowed from an implementation of ostream:

Click here to view code image

enum ios_base::iostate {
    goodbit=0, eofbit=1, failbit=2, badbit=4
};
The implementation of a stream can set and test its state like this:

Click here to view code image

state = goodbit;
 //...
if (state&(badbit|failbit))  // stream not good
The extra parentheses are necessary because & has higher precedence than | (§10.3).

A function that reaches the end-of-input might report it like this:

state |= eofbit;
The |= operator is used to add to the state. A simple assignment, state=eofbit, would have cleared all other bits.

These stream state flags are observable from outside the stream implementation. For example, we could see how the states of two streams differ like this:

Click here to view code image

int old = cin.rdstate();    // rdstate() returns the state
 //... use cin ...
if (cin.rdstate()^old) {    // has anything changed?
        //...
}
Computing differences of stream states is not common. For other similar types, computing differences is essential. For example, consider comparing a bit vector that represents the set of interrupts being handled with another that represents the set of interrupts waiting to be handled.

Please note that this bit fiddling is taken from the implementation of iostreams rather than from the user interface. Convenient bit manipulation can be very important, but for reliability, maintainability, portability, etc., it should be kept at low levels of a system. For more general notions of a set, see the standard-library set (§31.4.3) and bitset (§34.2.2).

Bitwise logical operations can be used to extract bit-fields from a word. For example, one could extract the middle 16 bits of a 32-bit int like this:

Click here to view code image

constexpr unsigned short middle(int a)
{
    static_assert(sizeof(int)==4,"unexpected int size");
    static_assert(sizeof(short)==2,"unexpected short size"); 
    return (a>>8)&0xFFFF;
}

int x = 0xFF00FF00;  // assume sizeof(int)==4
short y = middle(x);  // y = 0x00FF
Using fields (§8.2.7) is a convenient shorthand for such shifting and masking.

Do not confuse the bitwise logical operators with the logical operators: &&, ||, and !. The latter return true or false, and they are primarily useful for writing the test in an if-, while-, or for-statement (§9.4, §9.5). For example, !0 (not zero) is the value true, which converts to 1, whereas ~0 (complement of zero) is the bit pattern all-ones, which in two’s complement representation is the value –1 .

11.1.3. Conditional Expressions
Some if-statements can conveniently be replaced by conditional-expressions. For example:

if (a <= b)
      max = b;
else
      max = a;
This is more directly expressed like this:

max = (a<=b) ? b : a;
The parentheses around the condition are not necessary, but I find the code easier to read when they are used.

Conditional expressions are important in that they can be used in constant expressions (§10.4).

A pair of expressions e1 and e2 can be used as alternatives in a conditional expression, c?e1:e2, if they are of the same type or if there is a common type T, to which they can both be implicitly converted. For arithmetic types, the usual arithmetic conversions (§10.5.3) are used to find that common type. For other types, either e1 must be implicitly convertible to e2’s type or vice versa. In addition, one branch may be a throw-expression (§13.5.1). For example:

Click here to view code image

void fct(int* p)
{
     int i = (p) ? *p : throw std::runtime_error{"unexpected nullptr"};
      //...
}
11.1.4. Increment and Decrement
The ++ operator is used to express incrementing directly, rather than expressing it indirectly using a combination of an addition and an assignment. Provided lvalue has no side effects, ++lvalue means lvalue+=1, which again means lvalue=lvalue+1. The expression denoting the object to be incremented is evaluated once (only). Decrementing is similarly expressed by the –– operator.

The operators ++ and –– can be used as both prefix and postfix operators. The value of ++x is the new (that is, incremented) value of x. For example, y=++x is equivalent to y=(x=x+1). The value of x++, however, is the old value of x. For example, y=x++ is equivalent to y=(t=x,x=x+1,t), where t is a variable of the same type as x.

Like adding an int to a pointer, or subtracting it, ++ and –– on a pointer operate in terms of elements of the array into which the pointer points; p++ makes p point to the next element (§7.4.1).

The ++ and –– operators are particularly useful for incrementing and decrementing variables in loops. For example, one can copy a zero-terminated C-style string like this:

void cpy(char* p, const char* q)
{
     while (*p++ = *q++);
}
Like C, C++ is both loved and hated for enabling such terse, expression-oriented coding. Consider:

while (*p++ = *q++) ;
This is more than a little obscure to non-C programmers, but because the style of coding is not uncommon, it is worth examining more closely. Consider first a more traditional way of copying an array of characters:

int length = strlen(q);
for (int i = 0; i<=length; i++)
      p[i] = q[i];
This is wasteful. The length of a zero-terminated string is found by reading the string looking for the terminating zero. Thus, we read the string twice: once to find its length and once to copy it. So we try this instead:

int i;
for (i = 0; q[i]!=0 ; i++)
      p[i] = q[i];
p[i] = 0;          // terminating zero
The variable i used for indexing can be eliminated because p and q are pointers:

Click here to view code image

while (*q !=0){
      *p= *q;
      p++;      // point to next character
      q++;      // point to next character
}
*p = 0;         // terminating zero
Because the post-increment operation allows us first to use the value and then to increment it, we can rewrite the loop like this:

while (*q!=0) {
      *p++ = *q++;
}
*p = 0;  // terminating zero
The value of *p++ = *q++ is *q. We can therefore rewrite the example like this:

while ((*p++ = *q++) != 0) { }
In this case, we don’t notice that *q is zero until we already have copied it into *p and incremented p. Consequently, we can eliminate the final assignment of the terminating zero. Finally, we can reduce the example further by observing that we don’t need the empty block and that the !=0 is redundant because the result of an integral condition is always compared to zero anyway. Thus, we get the version we set out to discover:

while (*p++ = *q++) ;
Is this version less readable than the previous versions? Not to an experienced C or C++ programmer. Is this version more efficient in time or space than the previous versions? Except for the first version that called strlen(), not really; the performance will be equivalent and often identical code will be generated.

The most efficient way of copying a zero-terminated character string is typically the standard C-style string copy function:

char* strcpy(char*, const char*);   // from <string.h>
For more general copying, the standard copy algorithm (§4.5, §32.5) can be used. Whenever possible, use standard-library facilities in preference to fiddling with pointers and bytes. Standard-library functions may be inlined (§12.1.3) or even implemented using specialized machine instructions. Therefore, you should measure carefully before believing that some piece of handcrafted code outperforms library functions. Even if it does, the advantage may not exist on some other hardware+compiler combination, and your alternative may give a maintainer a headache.

11.2. Free Store
A named object has its lifetime determined by its scope (§6.3.4). However, it is often useful to create an object that exists independently of the scope in which it was created. For example, it is common to create objects that can be used after returning from the function in which they were created. The operator new creates such objects, and the operator delete can be used to destroy them. Objects allocated by new are said to be “on the free store” (also, “on the heap” or “in dynamic memory”).

Consider how we might write a compiler in the style used for the desk calculator (§10.2). The syntax analysis functions might build a tree of the expressions for use by the code generator:

Click here to view code image

struct Enode {
     Token_value oper;
     Enode* left;
     Enode* right;
      //...
};
Enode* expr(bool get)
{
     Enode* left = term(get);

     for (;;) {
            switch (ts.current().kind) {
            case Kind::plus:
            case Kind::minus:
                 left = new Enode {ts.current().kind,left,term(true)};
                 break;
            default:
                 return left;             // return node
            }
     }
}
In cases Kind::plus and Kind::minus, a new Enode is created on the free store and initialized by the value {ts.current().kind,left,term(true)}. The resulting pointer is assigned to left and eventually returned from expr().

I used the {}-list notation for specifying arguments. Alternatively, I could have used the old-style ()-list notation to specify an initializer. However, trying the = notation for initializing an object created using new results in an error:

int* p = new int = 7;  // error
If a type has a default constructor, we can leave out the initializer, but built-in types are by default uninitialized. For example:

Click here to view code image

auto pc = new complex<double>;   // the complex is initialized to {0,0}
auto pi = new int;               // the int is uninitialized
This can be confusing. To be sure to get default initialization, use {}. For example:

Click here to view code image

auto pc = new complex<double>{};  // the complex is initialized to {0,0}
auto pi = new int{};              // the int is initialized to 0
A code generator could use the Enodes created by expr() and delete them:

Click here to view code image

void generate(Enode* n)
{
     switch (n–>oper) {
     case Kind::plus:
           // use n
          delete n;  // delete an Enode from the free store
     }
}
An object created by new exists until it is explicitly destroyed by delete. Then, the space it occupied can be reused by new. A C++ implementation does not guarantee the presence of a “garbage collector” that looks out for unreferenced objects and makes them available to new for reuse. Consequently, I will assume that objects created by new are manually freed using delete.

The delete operator may be applied only to a pointer returned by new or to the nullptr. Applying delete to the nullptr has no effect.

If the deleted object is of a class with a destructor (§3.2.1.2, §17.2), that destructor is called by delete before the object’s memory is released for reuse.

11.2.1. Memory Management
The main problems with free store are:

• Leaked objects: People use new and then forget to delete the allocated object.

• Premature deletion: People delete an object that they have some other pointer to and later use that other pointer.

• Double deletion: An object is deleted twice, invoking its destructor (if any) twice.

Leaked objects are potentially a bad problem because they can cause a program to run out of space. Premature deletion is almost always a nasty problem because the pointer to the “deleted object” no longer points to a valid object (so reading it may give bad results) and may indeed point to memory that has been reused for another object (so writing to it may corrupt an unrelated object). Consider this example of very bad code:

Click here to view code image

int* p1 = new int{99};
int* p2 = p1;                  // potential trouble
delete p1;                     // now p2 doesn't point to a valid object
p1 = nullptr;                  // gives a false sense of safety
char* p3 = new char{'x'};      // p3 may now point to the memory pointed to by p2
*p2 = 999;                     // this may cause trouble
cout << *p3 << '\n';           // may not print x
Double deletion is a problem because resource managers typically cannot track what code owns a resource. Consider:

Click here to view code image

void sloppy()  // very bad code
{
     int* p = new int[1000];    // acquire memory
      //... use *p ...
     delete[] p;                // release memory

      //... wait a while ...

     delete[] p;                // but sloppy() does not own *p
}
By the second delete[], the memory pointed to by* p may have been reallocated for some other use and the allocator may get corrupted. Replace int with string in that example, and we’ll see string’s destructor trying to read memory that has been reallocated and maybe overwritten by other code, and using what it read to try to delete memory. In general, a double deletion is undefined behavior and the results are unpredictable and usually disastrous.

The reason people make these mistakes is typically not maliciousness and often not even simple sloppiness; it is genuinely hard to consistently deallocate every allocated object in a large program (once and at exactly the right point in a computation). For starters, analysis of a localized part of a program will not detect these problems because an error usually involves several separate parts.

As alternatives to using “naked” news and deletes, I can recommend two general approaches to resource management that avoid such problems:

[1] Don’t put objects on the free store if you don’t have to; prefer scoped variables.

[2] When you construct an object on the free store, place its pointer into a manager object (sometimes called a handle) with a destructor that will destroy it. Examples are string, vector and all the other standard-library containers, unique_ptr (§5.2.1, §34.3.1), and shared_ptr (§5.2.1, §34.3.2). Wherever possible, have that manager object be a scoped variable. Many classical uses of free store can be eliminated by using move semantics (§3.3, §17.5.2) to return large objects represented as manager objects from functions.

This rule [2] is often referred to as RAII (“Resource Acquisition Is Initialization”; §5.2, §13.3) and is the basic technique for avoiding resource leaks and making error handling using exceptions simple and safe.

The standard-library vector is an example of these techniques:

void f(const string& s)
{
      vector<char> v;
      for (auto c : s)
           v.push_back(c);
       //...
}
The vector keeps its elements on the free store, but it handles all allocations and deallocations itself. In this example, push_back() does news to acquire space for its elements and deletes to free space that it no longer needs. However, the users of vector need not know about those implementation details and will just rely on vector not leaking.

The Token_stream from the calculator example is an even simpler example (§10.2.2). There, a user can use new and hand the resulting pointer to a Token_stream to manage:

Token_stream ts{new istringstream{some_string}};
We do not need to use the free store just to get a large object out of a function. For example:

Click here to view code image

string reverse(const string& s)
{
     string ss;
     for (int i=s.size()–1; 0<=i; ––i)
           ss.push_back(s[i]);
     return ss;
}
Like vector, a string is really a handle to its elements. So, we simply move the ss out of reverse() rather than copying any elements (§3.3.2).

The resource management “smart pointers” (e.g., unique_ptr and shared_ptr) are a further example of these ideas (§5.2.1, §34.3.1). For example:

Click here to view code image

void f(int n)
{
     int* p1 = new int[n];                    // potential trouble
     unique_ptr<int[]> p2 {new int[n]};
 //...
     if (n%2) throw runtime_error("odd");
     delete[] p1;                        // we may never get here
}
For f(3) the memory pointed to by p1 is leaked, but the memory pointed to by p2 is correctly and implicitly deallocated.

My rule of thumb for the use of new and delete is “no naked news”; that is, new belongs in constructors and similar operations, delete belongs in destructors, and together they provide a coherent memory management strategy. In addition, new is often used in arguments to resource handles.

If everything else fails (e.g., if someone has a lot of old code with lots of undisciplined use of new), C++ offers a standard interface to a garbage collector (§34.5).

11.2.2. Arrays
Arrays of objects can also be created using new. For example:

Click here to view code image

char* save_string(const char* p)
{
    char* s = new char[strlen(p)+1];
    strcpy(s,p);         // copy from p to s
    return s;
}

int main(int argc, char* argv[])
{
    if (argc < 2) exit(1);
    char* p = save_string(argv[1]);
     //...
    delete[] p;
}
The “plain” operator delete is used to delete individual objects; delete[] is used to delete arrays.

Unless you really must use a char* directly, the standard-library string can be used to simplify the save_string():

Click here to view code image

string save_string(const char* p)
{
     return string{p};
}
 int main(int argc, char* argv[])
{
     if (argc < 2) exit(1);
     string s = save_string(argv[1]);
      //...
}
In particular, the new[] and the delete[] vanished.

To deallocate space allocated by new, delete and delete[] must be able to determine the size of the object allocated. This implies that an object allocated using the standard implementation of new will occupy slightly more space than a static object. At a minimum, space is needed to hold the object’s size. Usually two or more words per allocation are used for free-store management. Most modern machines use 8-byte words. This overhead is not significant when we allocate many objects as an array or large objects, but it can matter if we allocate lots of small objects (e.g., ints or Points) on the free store.

Note that a vector (§4.4.1, §31.4) is a proper object and can therefore be allocated and deallocated using plain new and delete. For example:

Click here to view code image

void f(int n)
{
     vector<int>* p = new vector<int>(n);    // individual object
     int* q = new int[n];                // array
      //...
     delete p;
     delete[] q;
}
The delete[] operator may be applied only to a pointer to an array returned by new of an array or to the null pointer (§7.2.2). Applying delete[] to the null pointer has no effect.

However, do not use new to create local objects. For example:

void f1()
{
     X* p =new X;
      //... use *p ...
     delete p;
}
That’s verbose, inefficient, and error-prone (§13.3). In particular, a return or an exception thrown before the delete will cause a memory leak (unless even more code is added). Instead, use a local variable:

void f2()
{
     X x;
      //... use x ...
}
The local variable x is implicitly destroyed upon exit from f2.

11.2.3. Getting Memory Space
The free-store operators new, delete, new[], and delete[] are implemented using functions presented in the <new> header:

Click here to view code image

void* operator new(size_t);        // allocate space for individual object
void operator delete(void* p);     // if (p) deallocate space allocated using operator new()
void* operator new[](size_t);      // allocate space for array
void operator delete[](void* p);   // if (p) deallocate space allocated using operator new[]()
When operator new needs to allocate space for an object, it calls operator new() to allocate a suitable number of bytes. Similarly, when operator new needs to allocate space for an array, it calls operator new[]().

The standard implementations of operator new() and operator new[]() do not initialize the memory returned.

The allocation and deallocation functions deal in untyped and uninitialized memory (often called “raw memory”), as opposed to typed objects. Consequently, they take arguments or return values of type void*. The operators new and delete handle the mapping between this untyped-memory layer and the typed-object layer.

What happens when new can find no store to allocate? By default, the allocator throws a standard-library bad_alloc exception (for an alternative, see §11.2.4.1). For example:

Click here to view code image

void f()
{
     vector<char* > v;
     try {
          for (;;) {
                 char* p = new char[10000];   // acquire some memory
                 v.push_back(p);              // make sure the new memory is referenced
                 p[0] = 'x';                  // use the new memory
          }
     }
     catch(bad_alloc) {
          cerr << "Memory exhausted!\n";
     }
}
However much memory we have available, this will eventually invoke the bad_alloc handler. Please be careful: the new operator is not guaranteed to throw when you run out of physical main memory. So, on a system with virtual memory, this program can consume a lot of disk space and take a long time doing so before the exception is thrown.

We can specify what new should do upon memory exhaustion by defining a new handler: set_new_handler(my_new_handler). A new handler should find more memory for operator new() to allocate, throw an exception, or terminate the program. See §30.4.1.3.

In addition to the functions defined in <new>, a user can define operator new(), etc., for a specific class (§19.2.5). Class members operator new(), etc., are found and used in preference to the ones from <new> according to the usual scope rules.

11.2.4. Overloading new
By default, operator new creates its object on the free store. What if we wanted the object allocated elsewhere? Consider a simple class:

class X {
public:
     X(int);
      //...
};
We can place objects anywhere by providing an allocator function (§11.2.3) with extra arguments and then supplying such extra arguments when using new:

Click here to view code image

void* operator new(size_t, void *p) { return p; }    // explicit placement operator

void* buf = reinterpret_cast<void* =>(0xF00F);       // significant address
X* p2 = new(buf) X;                                  // construct an X at buf;
                                                     // invokes: operator new(sizeof(X),buf)
Because of this usage, the new(buf) X syntax for supplying extra arguments to operator new() is known as the placement syntax. Note that every operator new() takes a size as its first argument and that the size of the object allocated is implicitly supplied (§19.2.5). The operator new() used by the new operator is chosen by the usual argument matching rules (§12.3); every operator new() has a size_t as its first argument.

The “placement” operator new() is the simplest such allocator. It is defined in the standard header <new>:

Click here to view code image

void* operator new (size_t sz, void* p) noexcept;        // place object of size sz at p
void* operator new[](size_t sz, void* p) noexcept;       // place object of size sz at p

void operator delete (void* p, void*) noexcept;          // if (p) make *p invalid
void operator delete[](void* p, void*) noexcept;         // if (p) make *p invalid
The “placement delete” operators do nothing except possibly inform a garbage collector that the deleted pointer is no longer safely derived (§34.5).

The placement new construct can also be used to allocate memory from a specific arena:

Click here to view code image

class Arena {
public:
     virtual void* alloc(size_t) =0;
     virtual void free(void*) =0;
      //...
};

void* operator new(size_t sz, Arena* a)
{
     return a–>alloc(sz);
}
Now objects of arbitrary types can be allocated from different Arenas as needed. For example:

Click here to view code image

extern Arena* Persistent;
extern Arena* Shared;

void g(int i)
{
     X* p = new(Persistent) X(i);    // X in persistent storage
     X* q = new(Shared) X(i);        // X in shared memory
      //...
}
Placing an object in an area that is not (directly) controlled by the standard free-store manager implies that some care is required when destroying the object. The basic mechanism for that is an explicit call of a destructor:

void destroy(X* p, Arena* a)
{
     p–>~X();        // call destructor
     a–>free(p);     // free memory
}
Note that explicit calls of destructors should be avoided except in the implementation of resource management classes. Even most resource handles can be written using new and delete. However, it would be hard to implement an efficient general container along the lines of the standard-library vector (§4.4.1, §31.3.3) without using explicit destructor calls. A novice should think thrice before calling a destructor explicitly and also should ask a more experienced colleague before doing so.

See §13.6.1 for an example of how placement new can interact with exception handling.

There is no special syntax for placement of arrays. Nor need there be, since arbitrary types can be allocated by placement new. However, an operator delete[]() can be defined for arrays (§11.2.3).

11.2.4.1. nothrow new
In programs where exceptions must be avoided (§13.1.5), we can use nothrow versions of new and delete. For example:

Click here to view code image

void f(int n)
{
     int* p = new(nothrow) int[n];         // allocate n ints on the free store
     if (p==nullptr) { // no memory available
            //... handle allocation error ...
     }
      //... 
     operator delete(p,nothrow);          // deallocate *p
}
That nothrow is the name of an object of the standard-library type nothrow_t that is used for disambiguation; nothrow and nothrow_t are declared in <new>.

The functions implementing this are found in <new>:

Click here to view code image

void* operator new(size_t sz, const nothrow_t&) noexcept;    // allocate sz bytes;
                                                             // return nullptr if allocation failed
void operator delete(void* p, const nothrow_t&) noexcept;    // deallocate space allocated by new

void* operator new[](size_t sz, const nothrow_t&) noexcept;  // allocate sz bytes;
                                                             // return nullptr if allocation failed
void operator delete[](void* p, const nothrow_t&) noexcept;  // deallocate space allocated by new
These operator new functions return nullptr, rather than throwing bad_alloc, if there is not sufficient memory to allocate.

11.3. Lists
In addition to their use for initializing named variables (§6.3.5.2), {}-lists can be used as expressions in many (but not all) places. They can appear in two forms:

[1] Qualified by a type, T{...}, meaning “create an object of type T initialized by T{...}”; §11.3.2

[2] Unqualified {...}, for which the type must be determined from the context of use; §11.3.3

For example:

Click here to view code image

struct S { int a, b; };
struct SS { double a, b; };

void f(S);      // f() takes an S

void g(S);
void g(SS);     // g() is overloaded

void h()
{
     f({1,2});           // OK: call f(S{1,2})

     g({1,2});           // error: ambiguous
     g(S{1,2});          // OK: call g(S)
     g(SS{1,2});         // OK: call g(SS)
}
As in their use for initializing named variables (§6.3.5), lists can have zero, one, or more elements. A {}-list is used to construct an object of some type, so the number of elements and their types must be what is required to construct an object of that type.

11.3.1. Implementation Model
The implementation model for {}-lists comes in three parts:

• If the {}-list is used as constructor arguments, the implementation is just as if you had used a ()-list. List elements are not copied except as by-value constructor arguments.

• If the {}-list is used to initialize the elements of an aggregate (an array or a class without a constructor), each list element initializes an element of the aggregate. List elements are not copied except as by-value arguments to aggregate element constructors.

• If the {}-list is used to construct an initializer_list object, each list element is used to initialize an element of the underlying array of the initializer_list. Elements are typically copied from the initializer_list to wherever we use them.

Note that this is the general model that we can use to understand the semantics of a {}-list; a compiler may apply clever optimizations as long as the meaning is preserved.

Consider:

vector<double> v = {1, 2, 3.14};
The standard-library vector has an initializer-list constructor (§17.3.4), so the initializer list {1,2,3.14} is interpreted as a temporary constructed and used like this:

Click here to view code image

const double temp[] = {double{1}, double{2}, 3.14 } ;
const initializer_list<double> tmp(temp,sizeof(temp)/sizeof(double));
vector<double> v(tmp);
That is, the compiler constructs an array containing the initializers converted to the desired type (here, double). This array is passed to vector’s initializer-list constructor as an initializer_list. The initializer-list constructor then copies the values from the array into its own data structure for elements. Note that an initializer_list is a small object (probably two words), so passing it by value makes sense.

The underlying array is immutable, so there is no way (within the standard’s rules) that the meaning of a {}-list can change between two uses. Consider:

Click here to view code image

void f()
{
     initializer_list<int> lst {1,2,3};
     cout << *lst.begin() << '\n';
     *lst.begin() = 2;                  // error: lst is immutable
     cout << *lst.begin() << '\n';
}
In particular, having a {}-list be immutable implies that a container taking elements from it must use a copy operation, rather than a move operation.

The lifetime of a {}-list (and its underlying array) is determined by the scope in which it is used (§6.4.2). When used to initialize a variable of type initializer_list<T>, the list lives as long as the variable. When used in an expression (including as an initializer to a variable of some other type, such as vector<T>), the list is destroyed at the end of its full expression.

11.3.2. Qualified Lists
The basic idea of initializer lists as expressions is that if you can initialize a variable x using the notation

T x {v};
then you can create an object with the same value as an expression using T{v} or new T{v}. Using new places the object on the free store and returns a pointer to it, whereas “plain T{v}” makes a temporary object in the local scope (§6.4.2). For example:

Click here to view code image

struct S { int a, b; };

void f()
{
      S v {7,8};           // direct initialization of a variable
      v = S{7,8};          // assign using qualified list
      S* p = new S{7,8};   // construct on free store using qualified list
}
The rules for constructing an object using a qualified list are those of direct initialization (§16.2.6).

One way of looking at a qualified initializer list with one element is as a conversion from one type to another. For example:

Click here to view code image

template<typename T>
T square(T x)
{
    return x*x;
}
void f(int i)
{
    double d = square(double{i});
    complex<double> z = square(complex<double>{i});
}
That idea is explored further in §11.5.1.

11.3.3. Unqualified Lists
An unqualified list is used where an expected type is unambiguously known. It can be used as an expression only as:

• A function argument

• A return value

• The right-hand operand of an assignment operator (=, +=*, =, etc.)

• A subscript

For example:

Click here to view code image

int f(double d, Matrix& m)
{
      int v {7};           // initializer (direct initialization)
      int v2 = {7};        // initializer (copy initialization)
      int v3 = m[{2,3}];   // assume m takes value pairs as subscripts

      v = {8};             // right-hand operand of assignment
      v += {88};           // right-hand operand of assignment
      {v} = 9;             // error: not left-hand operand of assignment
      v = 7+{10};          // error: not an operand of a non-assignment operator
      f({10.0},m);           // function argument
      return {11};         // return value
}
The reason that an unqualified list is not allowed on the left-hand side of assignments is primarily that the C++ grammar allows { in that position for compound statements (blocks), so that readability would be a problem for humans and ambiguity resolution would be tricky for compilers. This is not an insurmountable problem, but it was decided not to extend C++ in that direction.

When used as the initializer for a named object without the use of an = (as for v above), an unqualified {}-list performs direct initialization (§16.2.6). In all other cases, it performs copy initialization (§16.2.6). In particular, the otherwise redundant = in an initializer restricts the set of initializations that can be performed with a given {}-list.

The standard-library type initializer_list<T> is used to handle variable-length {}-lists (§12.2.3). Its most obvious use is to allow initializer lists for user-defined containers (§3.2.1.3), but it can also be used directly; for example:

Click here to view code image

int high_value(initializer_list<int> val)
{
      int high = numeric_traits<int>::lowest();
      if (val.size()==0) return high;
      for (auto x : val)
            if (x>high) high = x;
      return high;
}

 int v1 = high_value({1,2,3,4,5,6,7});
int v2 = high_value({–1,2,v1,4,–9,20,v1});
A {}-list is the simplest way of dealing with homogeneous lists of varying lengths. However, beware that zero elements can be a special case. If so, that case should be handled by a default constructor (§17.3.3).

The type of a {}-list can be deduced (only) if all elements are of the same type. For example:

Click here to view code image

auto x0 = {};        // error (no element type)
auto x1 = {1};       // initializer_list<int>
auto x2 = {1,2};     // initializer_list<int>
auto x3 = {1,2,3};   // initializer_list<int>
auto x4 = {1,2.0};   // error: nonhomogeneous list
Unfortunately, we do not deduce the type of an unqualified list for a plain template argument. For example:

Click here to view code image

template<typename T>
void f(T);

f({});         // error: type of initializer is unknown
f({1});        // error: an unqualified list does not match "plain T"
f({1,2});      // error: an unqualified list does not match "plain T"
f({1,2,3});    // error: an unqualified list does not match "plain T"
I say “unfortunately” because this is a language restriction, rather than a fundamental rule. It would be technically possible to deduce the type of those {}-lists as initializer_list<int>, just like we do for auto initializers.

Similarly, we do not deduce the element type of a container represented as a template. For example:

Click here to view code image

template<typename T>
void f2(const vector<T>&);

f2({1,2,3});                 // error: cannot deduce T
f2({"Kona","Sidney"});       // error: cannot deduce T
This too is unfortunate, but it is a bit more understandable from a language-technical point of view: nowhere in those calls does it say vector. To deduce T the compiler would first have to decide that the user really wanted a vector and then look into the definition of vector to see if it has a constructor that accepts {1,2,3}. In general, that would require an instantiation of vector (§26.2). It would be possible to handle that, but it could be costly in compile time, and the opportunities for ambiguities and confusion if there were many overloaded versions of f2() are reasons for caution. To call f2(), be more specific:

Click here to view code image

f2(vector<int>{1,2,3});                // OK
f2(vector<string>{"Kona","Sidney"});   // OK
11.4. Lambda Expressions
A lambda expression, sometimes also referred to as a lambda function or (strictly speaking incorrectly, but colloquially) as a lambda, is a simplified notation for defining and using an anonymous function object. Instead of defining a named class with an operator(), later making an object of that class, and finally invoking it, we can use a shorthand. This is particularly useful when we want to pass an operation as an argument to an algorithm. In the context of graphical user interfaces (and elsewhere), such operations are often referred to as callbacks. This section focuses on technical aspects of lambdas; examples and techniques for the use of lambdas can be found elsewhere (§3.4.3, §32.4, §33.5.2).

A lambda expression consists of a sequence of parts:

• A possibly empty capture list, specifying what names from the definition environment can be used in the lambda expression’s body, and whether those are copied or accessed by reference. The capture list is delimited by [] (§11.4.3).

• An optional parameter list, specifying what arguments the lambda expression requires. The parameter list is delimited by () (§11.4.4).

• An optional mutable specifier, indicating that the lambda expression’s body may modify the state of the lambda (i.e., change the lambda’s copies of variables captured by value) (§11.4.3.4).

• An optional noexcept specifier.

• An optional return type declaration of the form –> type (§11.4.4).

• A body, specifying the code to be executed. The body is delimited by {} (§11.4.3).

The details of passing arguments, returning results, and specifying the body are those of functions and are presented in Chapter 12. The notion of “capture” of local variables is not provided for functions. This implies that a lambda can act as a local function even though a function cannot.

11.4.1. Implementation Model
Lambda expressions can be implemented in a variety of ways, and there are some rather effective ways of optimizing them. However, I find it useful to understand the semantics of a lambda by considering it a shorthand for defining and using a function object. Consider a relatively simple example:

Click here to view code image

void print_modulo(const vector<int>& v, ostream& os, int m)
      // output v[i] to os if v[i]%m==0
{
     for_each(begin(v),end(v),
          [&os,m](int x) { if (x%m==0) os << x << '\n'; }
     );
}
To see what this means, we can define the equivalent function object:

Click here to view code image

class Modulo_print {
     ostream& os;  // members to hold the capture list
     int m;
public:
      Modulo_print(ostream& s, int mm) :os(s), m(mm) {}  // capture
      void operator()(int x) const
           { if (x%m==0) os << x << '\n'; }
};
The capture list, [&os,m], becomes two member variables and a constructor to initialize them. The & before os means that we should store a reference, and the absence of a & for m means that we should store a copy. This use of & mirrors its use in function argument declarations.

The body of the lambda simply becomes the body of the operator()(). Since the lambda doesn’t return a value, the operator()() is void. By default, operator()() is const, so that the lambda body doesn’t modify the captured variables. That’s by far the most common case. Should you want to modify the state of a lambda from its body, the lambda can be declared mutable (§11.4.3.4). This corresponds to an operator()() not being declared const.

An object of a class generated from a lambda is called a closure object (or simply a closure). We can now write the original function like this:

Click here to view code image

void print_modulo(const vector<int>& v, ostream& os, int m)
      // output v[i] to os if v[i]%m==0
{
     for_each(begin(v),end(v),Modulo_print{os,m});
}
If a lambda potentially captures every local variable by reference (using the capture list [&]), the closure may be optimized to simply contain a pointer to the enclosing stack frame.

11.4.2. Alternatives to Lambdas
That final version of print_modulo() is actually quite attractive, and naming nontrivial operations is generally a good idea. A separately defined class also leaves more room for comments than does a lambda embedded in some argument list.

However, many lambdas are small and used only once. For such uses, the realistic equivalent involves a local class defined immediately before its (only) use. For example:

Click here to view code image

 void print_modulo(const vector<int>& v, ostream& os, int m)
      // output v[i] to os if v[i]%m==0
{
     class Modulo_print
{
          ostream& os;  // members to hold the capture list
          int m;
     public:
          Modulo_print (ostream& s, int mm) :os(s), m(mm) {}  // capture
          void operator()(int x) const
               { if (x%m==0) os << x << '\n'; }
     };

     for_each(begin(v),end(v),Modulo_print{os,m});
}
Compared to that, the version using the lambda is a clear winner. If we really want a name, we can just name the lambda:

Click here to view code image

void print_modulo(const vector<int>& v, ostream& os, int m)
      // output v[i] to os if v[i]%m==0
{
     auto Modulo_print = [&os,m] (int x) { if (x%m==0) os << x << '\n'; };

     for_each(begin(v),end(v),Modulo_print);
}
Naming the lambda is often a good idea. Doing so forces us to consider the design of the operation a bit more carefully. It also simplifies code layout and allows for recursion (§11.4.5).

Writing a for-loop is an alternative to using a lambda with a for_each(). Consider:

Click here to view code image

void print_modulo(const vector<int>& v, ostream& os, int m)
      // output v[i] to os if v[i]%m==0 
{
     for (auto x : v)
          if (x%m==0)
               os << x << '\n';
}
Many would find this version much clearer than any of the lambda versions. However, for_each is a rather special algorithm, and vector<int> is a very specific container. Consider generalizing print_modulo() to handle more containers:

Click here to view code image

template<typename C, typename Fct>
void print_modulo(const C& v, ostream& os, int m, Fct f)
     // output v[i] to os if p(v[i])%m==0
{
     for (auto x : v)
          if (f(x)%m==0)
                 os << x << '\n';
}
This version works nicely for a map as well as for a vector:

Click here to view code image

void test(vector<int>& v,map<string,int>& m)
{
     print_modulo(v,cout,99,[](int x){ return x; });
     print_modulo(m,cout,77,[](const pair<const string,int>& x){ return x.second; });
}
Here, I used a lambda to deal with the problem that the value type of a map is a pair (§31.4.3.1).

The C++ range-for-statement specifically caters to the special case of traversing a sequence from its beginning to its end. The STL containers make such traversals easy and general. However, we can define an arbitrary traversal over a data structure as a function visiting elements in an apropriate order invoking a function on each. For example:

Click here to view code image

depth_first(c,[&os,m](int x) { if (x%m==0) os << x << '\n'; }); // like for_each (§32.4.1)
breadth_first(c,[&os,m](int x) { if (x%m==0) os << x << '\n'; });
every_second_element(c,[&os,m](int x) { if (x%m==0) os << x << '\n'; });
Thus, a lambda can be used as “the body” for a generalized loop/traversal construct represented as an algorithm. Using for_each rather than breadth_first would give depth-first traversal.

The performance of a lambda as an argument to a traversal algorithm is equivalent (typically identical) to that of the equivalent loop. I have found that to be quite consistent across implementations and platforms. The implication is that we have to base our choice between “algorithm plus lambda” and “for-statement with body” on stylistic grounds and on estimates of extensibility and maintainability.

11.4.3. Capture
The main use of lambdas is for specifying code to be passed as arguments. Lambdas allow that to be done “inline” without having to name a function (or function object) and use it elsewhere. Some lambdas require no access to their local environment. Such lambdas are defined with the empty lambda introducer []. For example:

Click here to view code image

void algo(vector<int>& v)
{
     sort(v.begin(),v.end());   // sort values
      //...
     sort(v.begin(),v.end(),[](int x, int y) { return abs(x)<abs(y); });     // sort absolute values
      //...
}
If we want to access local names, we have to say so or get an error:

Click here to view code image

void f(vector<int>& v)
{
     bool sensitive = true;
      //...
     sort(v.begin(),v.end(),
          [](int x, int y) { return sensitive ? x<y : abs(x)<abs(y); }   // error: can't access sensitive
     );
}
I used the lambda introducer []. This is the simplest lambda introducer and does not allow the lambda to refer to names in the calling environment. The first character of a lambda expression is always [. A lambda introducer can take various forms:

• []: an empty capture list. This implies that no local names from the surrounding context can be used in the lambda body. For such lambda expressions, data is obtained from arguments or from nonlocal variables.

• [&]: implicitly capture by reference. All local names can be used. All local variables are accessed by reference.

• [=]: implicitly capture by value. All local names can be used. All names refer to copies of the local variables taken at the point of call of the lambda expression.

• [capture-list]: explicit capture; the capture-list is the list of names of local variables to be captured (i.e., stored in the object) by reference or by value. Variables with names preceded by & are captured by reference. Other variables are captured by value. A capture list can also contain this and names followed by ... as elements.

• [&, capture-list]: implicitly capture by reference all local variables with names not mentioned in the list. The capture list can contain this. Listed names cannot be preceded by &. Variables named in the capture list are captured by value.

• [=, capture-list]: implicitly capture by value all local variables with names not mentioned in the list. The capture list cannot contain this. The listed names must be preceded by &. Variables named in the capture list are captured by reference.

Note that a local name preceded by & is always captured by reference and a local name not preceded by & is always captured by value. Only capture by reference allows modification of variables in the calling environment.

The capture-list cases are used for fine-grained control over what names from the call environment are used and how. For example:

Click here to view code image

void f(vector<int>& v)
{
     bool sensitive = true;
      //...
     sort(v.begin(),v.end()
          [sensitive](int x, int y) { return sensitive ? x<y : abs(x)<abs(y); }
     );
}
By mentioning sensitive in the capture list, we make it accessible from within the lambda. By not specifying otherwise, we ensure that the capture of sensitive is done “by value”; just as for argument passing, passing a copy is the default. Had we wanted to capture sensitive “by reference,” we could have said so by adding a & before sensitive in the capture list: [&sensitive].

The choice between capturing by value and by reference is basically the same as the choice for function arguments (§12.2). We use a reference if we need to write to the captured object or if it is large. However, for lambdas, there is the added concern that a lambda might outlive its caller (§11.4.3.1). When passing a lambda to another thread, capturing by value ([=]) is typically best: accessing another thread’s stack through a reference or a pointer can be most disruptive (to performance or correctness), and trying to access the stack of a terminated thread can lead to extremely difficult-to-find errors.

If you need to capture a variadic template (§28.6) argument, use .... For example:

Click here to view code image

template<typename ... Var>
void algo(int s, Var... v)
{
     auto helper = [&s,&v...] { return s*(h1(v...)+h2(v...)); }
      //...
}
Beware that is it easy to get too clever about capture. Often, there is a choice between capture and argument passing. When that’s the case, capture is usually the least typing but has the greatest potential for confusion.

11.4.3.1. Lambda and Lifetime
A lambda might outlive its caller. This can happen if we pass a lambda to a different thread or if the callee stores away the lambda for later use. For example:

Click here to view code image

void setup(Menu& m)
{
      //...
     Point p1, p2, p3;
      // compute positions of p1, p2, and p3
     m.add("draw triangle",[&]{ m.draw(p1,p2,p3); });   // probable disaster
      //...
}
Assume that add() a (name,action) pair to a menu and that the draw() operation makes sense, we are left with a time bomb: the setup() completes and later – maybe minutes later – a user presses the draw triangle button and the lambda tries to access the long-gone local variables. A lambda that wrote to a variable caught by reference would be even worse in that situation.

If a lambda might outlive its caller, we must make sure that all local information (if any) is copied into the closure object and that values are returned through the return mechanism (§12.1.4) or through suitable arguments. For the setup() example, that is easily done:

m.add("draw triangle",[=]{m.draw(p1,p2,p3);});
Think of the capture list as the initializer list for the closure object and [=] and [&] as short-hand notation (§11.4.1).

11.4.3.2. Namespace Names
We don’t need to “capture” namespace variables (including global variables) because they are always accessible (provided they are in scope). For example:

Click here to view code image

template<typename U, typename V>
ostream& operator<<(ostream& os, const pair<U,V>& p)
{
     return os << '{' << p.first << ',' << p.second << '}';
}

void print_all(const map<string,int>& m, const string& label)
{
     cout << label << ":\n{\n";
     for_each(m.begin(),m.end(),
          [](const pair<string,int>& p) { cout << p << '\n'; }
     );
     cout << "}\n";
}
Here, we don’t need to capture cout or the output operator for pair.

11.4.3.3. Lambda and this
How do we access members of a class object from a lambda used in a member function? We can include class members in the set of names potentially captured by adding this to the capture list. This is used when we want to use a lambda in the implementation of a member function. For example, we might have a class for building up requests and retrieving results:

Click here to view code image

class Request {
     function<map<string,string>(const map<string,string>&)> oper;          // operation
     map<string,string> values;            // arguments
     map<string,string> results;           // targets
public:
     Request(const string& s);             // parse and store request
     future<void< execute() // execute asynchronously (§5.3.5, §42.4.6)
     {
          return async([this]() { results=oper(values); });   // do oper to values yielding results
     }
};
Members are always captured by reference. That is, [this] implies that members are accessed through this rather than copied into the lambda. Unfortunately, [this] and [=] are incompatible. This implies that incautious use can lead to race conditions in multi-threaded programs (§42.4.6).

11.4.3.4. mutable Lambdas
Usually, we don’t want to modify the state of the function object (the closure), so by default we can’t. That is, the operator()() for the generated function object (§11.4.1) is a const member function. In the unlikely event that we want to modify the state (as opposed to modifying the state of some variable captured by reference; §11.4.3), we can declare the lambda mutable. For example:

Click here to view code image

void algo(vector<int>& v)
{
     int count = v.size();
     std::generate(v.begin(),v.end(),
          [count]()mutable{ return ––count; }
     );
}
The ––count decrements the copy of v’s size stored in the closure.

11.4.4. Call and Return
The rules for passing arguments to a lambda are the same as for a function (§12.2), and so are the rules for returning results (§12.1.4). In fact, with the exception of the rules for capture (§11.4.3) most rules for lambdas are borrowed from the rules for functions and classes. However, two irregularities should be noted:

[1] If a lambda expression does not take any arguments, the argument list can be omitted. Thus, the minimal lambda expression is []{}.

[2] A lambda expression’s return type can be deduced from its body. Unfortunately, that is not also done for a function.

If a lambda body does not have a return-statement, the lambda’s return type is void. If a lambda body consists of just a single return-statement, the lambda’s return type is the type of the return’s expression. If neither is the case, we have to explicitly supply a return type. For example:

Click here to view code image

void g(double y)
{
     auto z0 = [&]{ f(y); };                                                                        // return type is void
     auto z1 = [=](int x){ return x+y; };                                                 // return type is double
     auto z2 = [y]{ if (y) return 1; else return 2; };                              // error: body too complicated
                                                // for return type deduction
     auto z3 =[y]() { return (y) ? 1 : 2; };                                           // return type is int
     auto z4 = [y]()–>int { if (y) return 1; else return 2; };     // OK: explicit return type
}
When the suffix return type notation is used, we cannot omit the argument list.

11.4.5. The Type of a Lambda
To allow for optimized versions of lambda expressions, the exact type of a lambda expression is not defined. This type, called the closure type, is unique to the lambda, so no two lambdas have the same type. Had two lambdas had the same type, the template instantiation mechanism might have gotten confused. Think of a lambda expression as a function object in the style presented in §11.4.1. A lambda is of a local class type with a constructor and a const member function operator()(). In addition to using a lambda as an argument, we can use it to initialize a variable declared auto or std::function<R(AL)> where R is the lambda’s return type and AL is its argument list of types (§33.5.3).

For example, I might try to write a lambda to reverse the characters in a C-style string:

Click here to view code image

auto rev = [&rev](char* b, char* e)
               { if (1<e–b) { swap(*b,*––e); rev(++b,e); } };       // error
However, that’s not possible because I cannot use an auto variable before its type has been deduced. Instead, I can introduce a name and then use it:

Click here to view code image

void f(string& s1, string& s2)
{
     function<void(char* b, char* e)> rev =
          [](char* b, char* e) { if (1<e–b) { swap(*b,*––e); rev(++b,e); } };

          rev(&s1[0],&s1[0]+s1.size());
          rev(&s2[0],&s2[0]+s2.size());
}
Now, the type of rev is specified before it is used.

If we just want to name a lambda, rather than using it recursively, auto can simplify things:

Click here to view code image

void g(string& vs1, string& vs2)
{
     auto rev = [](char* b, char* e) { while (1<e–b) swap(*b++,*––e); };

     rev(&s1[0],&s1[0]+s1.size());
     rev(&s2[0],&s2[0]+s2.size());
}
A lambda that captures nothing can be assigned to a pointer to function of an appropriate type. For example:

Click here to view code image

double (*p1)(double) = [](double a) { return sqrt(a); };
double (*p2)(double) = [&](double a) { return sqrt(a); };       // error: the lambda captures
double (p3)(int) = [](double a) { return sqrt(a); };            // error: argument types do not match
11.5. Explicit Type Conversion
Sometimes, we have to convert a value of one type into a value of another. Many (arguably too many) such conversions are done implicitly according to the language rules (§2.2.2, §10.5). For example:

Click here to view code image

double d = 1234567890;   // integer to floating-point
int i = d;               // floating-point to integer
In other cases, we have to be explicit.

For logical and historical reasons, C++ offers explicit type conversion operations of varying convenience and safety:

• Construction, using the {} notation, providing type-safe construction of new values (§11.5.1)

• Named conversions, providing conversions of various degrees of nastiness:

• const_cast for getting write access to something declared const (§7.5)

• static_cast for reversing a well-defined implicit conversion (§11.5.2)

• reinterpret_cast for changing the meaning of bit patterns (§11.5.2)

• dynamic_cast for dynamically checked class hierarchy navigation (§22.2.1)

• C-style casts, providing any of the named conversions and some combinations of those (§11.5.3)

• Functional notation, providing a different notation for C-style casts (§11.5.4)

I have ordered these conversions in my order of preference and safety of use.

Except for the {} construction notation, I can’t say I like any of those, but at least dynamic_cast is run-time checked. For conversion between two scalar numeric types, I tend to use a homemade explicit conversion function, narrow_cast, where a value might be narrowed:

Click here to view code image

template<typename Target, typename Source>
Target narrow_cast(Source v)
{
    auto r = static_cast<Target>(v);        // convert the value to the target type
    if (static_cast<Source>(r)!=v)
          throw runtime_error("narrow_cast<>() failed");
    return r;
}
That is, if I can convert a value to the target type, convert the result back to the source type, and get back the original value, I’m happy with the result. That is a generalization of the rule the language applies to values in {} initialization (§6.3.5.2). For example:

Click here to view code image

void test(double d, int i, char* p)
{
     auto c1 = narrow_cast<char>(64);
     auto c2 = narrow_cast<char>(–64);           // will throw if chars are unsigned
     auto c3 = narrow_cast<char>(264);           // will throw if chars are 8-bit

     auto d1 = narrow_cast<double>(1/3.0F);      // OK
     auto f1 = narrow_cast<float>(1/3.0);        // will probably throw

     auto c4 = narrow_cast<char>(i);             // may throw
     auto f2 = narrow_cast<float>(d);            // may throw

     auto p1 = narrow_cast<char* >(i);           // compile-time error
     auto i1 = narrow_cast<int>(p);              // compile-time error

     auto d2 = narrow_cast<double>(i);           // may throw (but probably will not)
     auto i2 = narrow_cast<int>(d);              // may throw
}
Depending on your use of floating-point numbers, it may be worthwhile to use a range test for floating-point conversions, rather than !=. That is easily done using specializations (§25.3.4.1) or type traits (§35.4.1).

11.5.1. Construction
The construction of a value of type T from a value e can be expressed by the notation T{e} (§iso.8.5.4). For example:

Click here to view code image

auto d1 = double{2};        // d1==2.0
double d2 {double{2}/4};    // d1==0.5
Part of the attraction of the T{v} notation is that it will perform only “well-behaved” conversions. For example:

Click here to view code image

void f(int);
void f(double);
void g(int i, double d)
{
     f(i);                             // call f(int)
     f(double{i});                     // error: {} doesn't do int to floating conversion

     f(d);                             // call f(double)
     f(int{d});                        // error: {} doesn't truncate
     f(static_cast<int>(d));           // call f(int) with a truncated value

     f(round(d));                      // call f(double) with a rounded value
     f(static_cast<int>(lround(d)));   // call f(int) with a rounded value
                                       // if the round(d) overflows the int, this still truncates
}
I don’t consider truncation of floating-point numbers (e.g., 7.9 to 7) “well behaved,” so having to be explicit when you want it is a good thing. If rounding is desirable, we can use the standard-library function round(); it performs “conventional 4/5 rounding,” such as 7.9 to 8 and 7.4 to 7.

It sometimes comes as a surprise that {}-construction doesn’t allow int to double conversion, but if (as is not uncommon) the size of an int is the same as the size of a double, then some such conversions must lose information. Consider:

Click here to view code image

static_assert(sizeof(int)==sizeof(double),"unexpected sizes");

int x = numeric_limits<int>::max();  // largest possible integer
double d = x;
int y = x;
We will not get x==y. However, we can still initialize a double with an integer literal that can be represented exactly. For example:

double d { 1234 };  // fine
Explicit qualification with the desired type does not enable ill-behaved conversions. For example:

Click here to view code image

void g2(char* p)
{
     int x = int{p};            // error: no char* to int conversion
     using Pint = int*;
     int* p2 = Pint{p};         // error: no char* to int* conversion
      //...
}
For T{v}, “reasonably well behaved” is defined as having a “non-narrowing” (§10.5) conversion from v to T or having an appropriate constructor for T (§17.3).

The constructor notation T{} is used to express the default value of type T. For example:

Click here to view code image

template<typename T> void f(const T&);

void g3()
{
     f(int{});               // default int value
     f(complex<double>{});   // default complex value
      //...
}
The value of an explicit use of the constructor for a built-in type is 0 converted to that type (§6.3.5). Thus, int{} is another way of writing 0. For a user-defined type T, T{} is defined by the default constructor (§3.2.1.1, §17.6), if any, otherwise by default construction, MT{}, of each member.

Explicitly constructed unnamed objects are temporary objects, and (unless bound to a reference) their lifetime is limited to the full expression in which they are used (§6.4.2). In this, they differ from unnamed objects created using new (§11.2).

11.5.2. Named Casts
Some type conversions are not well behaved or easy to type check; they are not simple constructions of values from a well-defined set of argument values. For example:

IO_device* d1 = reinterpret_cast<IO_device* >(0Xff00);  // device at 0Xff00
There is no way a compiler can know whether the integer 0Xff00 is a valid address (of an I/O device register). Consequently, the correctness of the conversions is completely in the hands of the programmer. Explicit type conversion, often called casting, is occasionally essential. However, traditionally it is seriously overused and a major source of errors.

Another classical example of the need for explicit type conversion is dealing with “raw memory,” that is, memory that holds or will hold objects of a type not known to the compiler. For example, a memory allocator (such as operator new(); §11.2.3) may return a void* pointing to newly allocated memory:

Click here to view code image

void* my_allocator(size_t);

void f()
{
     int* p = static_cast<int* >(my_allocator(100));    // new allocation used as ints
      //...
}
A compiler does not know the type of the object pointed to by the void*.

The fundamental idea behind the named casts is to make type conversion more visible and to allow the programmer to express the intent of a cast:

• static_cast converts between related types such as one pointer type to another in the same class hierarchy, an integral type to an enumeration, or a floating-point type to an integral type. It also does conversions defined by constructors (§16.2.6, §18.3.3, §iso.5.2.9) and conversion operators (§18.4).

• reinterpret_cast handles conversions between unrelated types such as an integer to a pointer or a pointer to an unrelated pointer type (§iso.5.2.10).

• const_cast converts between types that differ only in const and volatile qualifiers (§iso.5.2.11).

• dynamic_cast does run-time checked conversion of pointers and references into a class hierarchy (§22.2.1, §iso.5.2.7).

These distinctions among the named casts allow the compiler to apply some minimal type checking and make it easier for a programmer to find the more dangerous conversions represented as reinterpret_casts. Some static_casts are portable, but few reinterpret_casts are. Hardly any guarantees are made for reinterpret_cast, but generally it produces a value of a new type that has the same bit pattern as its argument. If the target has at least as many bits as the original value, we can reinterpret_cast the result back to its original type and use it. The result of a reinterpret_cast is guaranteed to be usable only if its result is converted back to the exact original type. Note that reinterpret_cast is the kind of conversion that must be used for pointers to functions (§12.5). Consider:

Click here to view code image

char x = 'a';
int* p1 = &x;                                // error: no implicit char* to int* conversion
int* p2 = static_cast<int* >(&x);            // error: no implicit char* to int* conversion
int* p3 = reinterpret_cast<int* >(&x);       // OK: on your head be it

struct B { /* ... */ };
struct D : B { /* ... */ };                  // see §3.2.2 and §20.5.2

B* pb = new D;                               // OK: implicit conversion from D* to B*
D* pd = pb;                                  // error: no implicit conversion from B* to D*
D* pd = static_cast<D >(pb);                 // OK
Conversions among class pointers and among class reference types are discussed in §22.2.

If you feel tempted to use an explicit type conversion, take the time to consider if it is really necessary. In C++, explicit type conversion is unnecessary in most cases when C needs it (§1.3.3) and also in many cases in which earlier versions of C++ needed it (§1.3.2, §44.2.3). In many programs, explicit type conversion can be completely avoided; in others, its use can be localized to a few routines.

11.5.3. C-Style Cast
From C, C++ inherited the notation (T)e, which performs any conversion that can be expressed as a combination of static_casts, reinterpret_casts, and const_casts to make a value of type T from the expression e (§44.2.3). Unfortunately, the C-style cast can also cast from a pointer to a class to a pointer to a private base of that class. Never do that, and hope for a warning from the compiler if you do it by mistake. This C-style cast is far more dangerous than the named conversion operators because the notation is harder to spot in a large program and the kind of conversion intended by the programmer is not explicit. That is, (T)e might be doing a portable conversion between related types, a nonportable conversion between unrelated types, or removing the const modifier from a pointer type. Without knowing the exact types of T and e, you cannot tell.

11.5.4. Function-Style Cast
The construction of a value of type T from a value e can be expressed by the functional notation T(e). For example:

Click here to view code image

void f(double d)
{
     int i = int(d);          // truncate d
     complex z = complex(d);  // make a complex from d
      //...
}
The T(e) construct is sometimes referred to as a function-style cast. Unfortunately, for a built-in type T, T(e) is equivalent to (T)e (§11.5.3). This implies that for many built-in types T(e) is not safe.

Click here to view code image

void f(double d, char* p)
{
     int a = int(d);   // truncates
     int b = int(p);   // not portable
      //...
}
Even explicit conversion of a longer integer type to a shorter (such as long to char) can result in nonportable implementation-defined behavior.

Prefer T{v} conversions for well-behaved construction and the named casts (e.g., static_cast) for other conversions.

11.6. Advice
[1] Prefer prefix ++ over suffix ++; §11.1.4.

[2] Use resource handles to avoid leaks, premature deletion, and double deletion; §11.2.1.

[3] Don’t put objects on the free store if you don’t have to; prefer scoped variables; §11.2.1.

[4] Avoid “naked new” and “naked delete”; §11.2.1.

[5] Use RAII; §11.2.1.

[6] Prefer a named function object to a lambda if the operation requires comments; §11.4.2.

[7] Prefer a named function object to a lambda if the operation is generally useful; §11.4.2.

[8] Keep lambdas short; §11.4.2.

[9] For maintainability and correctness, be careful about capture by reference; §11.4.3.1.

[10] Let the compiler deduce the return type of a lambda; §11.4.4.

[11] Use the T{e} notation for construction; §11.5.1.

[12] Avoid explicit type conversion (casts); §11.5.

[13] When explicit type conversion is necessary, prefer a named cast; §11.5.

[14] Consider using a run-time checked cast, such as narrow_cast<>(), for conversion between numeric types; §11.5.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


11. Select Operations
12. Functions
13. Exception Handling
47h 26m remaining
12. Functions
Death to all fanatics!

– Paradox

• Function Declarations

Why Functions?; Parts of a Function Declaration; Function Definitions; Returning Values; inline Functions; constexpr Functions; [[noreturn]] Functions; Local Variables

• Argument Passing

Reference Arguments; Array Arguments; List Arguments; Unspecified Number of Arguments; Default Arguments

• Overloaded Functions

Automatic Overload Resolution; Overloading and Return Type; Overloading and Scope; Resolution for Multiple Arguments; Manual Overload Resolution

• Pre- and Postconditions

• Pointer to Function

• Macros

Conditional Compilation; Predefined Macros; Pragmas

• Advice

12.1. Function Declarations
The main way of getting something done in a C++ program is to call a function to do it. Defining a function is the way you specify how an operation is to be done. A function cannot be called unless it has been previously declared.

A function declaration gives the name of the function, the type of the value returned (if any), and the number and types of the arguments that must be supplied in a call. For example:

Click here to view code image

Elem* next_elem();       // no argument; return an Elem*
void exit(int);          // int argument; return nothing
double sqrt(double);     // double argument; return a double
The semantics of argument passing are identical to the semantics of copy initialization (§16.2.6). Argument types are checked and implicit argument type conversion takes place when necessary. For example:

Click here to view code image

double s2 = sqrt(2);           // call sqrt() with the argument double{2}
double s3 = sqrt("three");     // error: sqrt() requires an argument of type double
The value of such checking and type conversion should not be underestimated.

A function declaration may contain argument names. This can be a help to the reader of a program, but unless the declaration is also a function definition, the compiler simply ignores such names. As a return type, void means that the function does not return a value (§6.2.7).

The type of a function consists of the return type and the argument types. For class member functions (§2.3.2, §16.2), the name of the class is also part of the function type. For example:

Click here to view code image

double f(int i, const Info&);       // type: double(int,const Info&)
char& String::operator[](int);      // type: char& String::(int)
12.1.1. Why Functions?
There is a long and disreputable tradition of writing very long functions – hundreds of lines long. I once encountered a single (handwritten) function with more than 32,768 lines of code. Writers of such functions seem to fail to appreciate one of the primary purposes of functions: to break up complicated computations into meaningful chunks and name them. We want our code to be comprehensible, because that is the first step on the way to maintainability. The first step to comprehensibility is to break computational tasks into comprehensible chunks (represented as functions and classes) and name those. Such functions then provide the basic vocabulary of computation, just as the types (built-in and user-defined) provide the basic vocabulary of data. The C++ standard algorithms (e.g., find, sort, and iota) provide a good start (Chapter 32). Next, we can compose functions representing common or specialized tasks into larger computations.

The number of errors in code correlates strongly with the amount of code and the complexity of the code. Both problems can be addressed by using more and shorter functions. Using a function to do a specific task often saves us from writing a specific piece of code in the middle of other code; making it a function forces us to name the activity and document its dependencies. Also, function call and return saves us from using error-prone control structures, such as gotos (§9.6) and continues (§9.5.5). Unless they are very regular in structure, nested loops are an avoidable source of errors (e.g., use a dot product to express a matrix algorithm rather than nesting loops; §40.6).

The most basic advice is to keep a function of a size so that you can look at it in total on a screen. Bugs tend to creep in when we can view only part of an algorithm at a time. For many programmers that puts a limit of about 40 lines on a function. My ideal is a much smaller size still, maybe an average of 7 lines.

In essentially all cases, the cost of a function call is not a significant factor. Where that cost could be significant (e.g., for frequently used access functions, such as vector subscripting) inlining can eliminate it (§12.1.5). Use functions as a structuring mechanism.

12.1.2. Parts of a Function Declaration
In addition to specifying a name, a set of arguments, and a return type, a function declaration can contain a variety of specifiers and modifiers. In all we can have:

• The name of the function; required

• The argument list, which may be empty (); required

• The return type, which may be void and which may be prefix or suffix (using auto); required

• inline, indicating a desire to have function calls implemented by inlining the function body (§12.1.5)

• constexpr, indicating that it should be possible to evaluate the function at compile time if given constant expressions as arguments (§12.1.6)

• noexcept, indicating that the function may not throw an exception (§13.5.1.1)

• A linkage specification, for example, static (§15.2)

• [[noreturn]], indicating that the function will not return using the normal call/return mechanism (§12.1.4)

In addition, a member function may be specified as:

• virtual, indicating that it can be overridden in a derived class (§20.3.2)

• override, indicating that it must be overriding a virtual function from a base class (§20.3.4.1)

• final, indicating that it cannot be overriden in a derived class (§20.3.4.2)

• static, indicating that it is not associated with a particular object (§16.2.12)

• const, indicating that it may not modify its object (§3.2.1.1, §16.2.9.1)

• volatile indicating that it may be applied to a volatile object (§41.4)

If you feel inclined to give readers a headache, you may write something like:

Click here to view code image

struct S {
     [[noreturn]] virtual inline auto f(const unsigned long int *const) –> void const noexcept;
};
12.1.3. Function Definitions
Every function that is called must be defined somewhere (once only; §15.2.3). A function definition is a function declaration in which the body of the function is presented. For example:

Click here to view code image

void swap(int*, int*);         // a declaration

void swap(int* p, int* q)      // a definition
{
     int t = *p;
     *p = *q;
     *q = t;
}
The definition and all declarations for a function must specify the same type. Unfortunately, to preserve C compatibility, a const is ignored at the highest level of an argument type. For example, this is two declarations of the same function:

Click here to view code image

void f(int);           // type is void(int)
void f(const int);     // type is void(int)
That function, f(), could be defined as:

void f(int x) { /*we can modify x here */ }
Alternatively, we could define f() as:

void f(const int x) { /*we cannot modify x here */ }
In either case, the argument that f() can or cannot modify is a copy of what a caller provided, so there is no danger of an obscure modification of the calling context.

Function argument names are not part of the function type and need not be identical in different declarations. For example:

Click here to view code image

int& max(int& a, int& b, int& c);  // return a reference to the larger of a, b, and c

int& max(int& x1, int& x2, int& x3)
{
     return (x1>x2)? ((x1>x3)?x1:x3) : ((x2>x3)?x2:x3);
}
Naming arguments in declarations that are not definitions is optional and commonly used to simplify documentation. Conversely, we can indicate that an argument is unused in a function definition by not naming it. For example:

Click here to view code image

void search(table* t, const char* key, const char*)
{
      // no use of the third argument
}
Typically, unnamed arguments arise from the simplification of code or from planning ahead for extensions. In both cases, leaving the argument in place, although unused, ensures that callers are not affected by the change.

In addition to functions, there are a few other things that we can call; these follow most rules defined for functions, such as the rules for argument passing (§12.2):

• Constructors (§2.3.2, §16.2.5) are technically not functions; in particular, they don’t return a value, can initialize bases and members (§17.4), and can’t have their address taken.

• Destructors (§3.2.1.2, §17.2) can’t be overloaded and can’t have their address taken.

• Function objects (§3.4.3, §19.2.2) are not functions (they are objects) and can’t be overloaded, but their operator()s are functions.

• Lambda expressions (§3.4.3, §11.4) are basically a shorthand for defining function objects.

12.1.4. Returning Values
Every function declaration contains a specification of the function’s return type (except for constructors and type conversion functions). Traditionally, in C and C++, the return type comes first in a function declaration (before the name of the function). However, a function declaration can also be written using a syntax that places the return type after the argument list. For example, the following two declarations are equivalent:

Click here to view code image

string to_string(int a);              // prefix return type
auto to_string(int a) –> string;      // suffix return type
That is, a prefix auto indicates that the return type is placed after the argument list. The suffix return type is preceded by –>.

The essential use for a suffix return type comes in function template declarations in which the return type depends on the arguments. For example:

Click here to view code image

template<typename T, typename U>
auto product(const vector<T>& x, const vector<U>& y) –> decltype(x*y);
However, the suffix return syntax can be used for any function. There is an obvious similarity between the suffix return syntax for a function and the lambda expression syntax (§3.4.3, §11.4); it is a pity those two constructs are not identical.

A function that does not return a value has a “return type” of void.

A value must be returned from a function that is not declared void (however, main() is special; see §2.2.1). Conversely, a value cannot be returned from a void function. For example:

Click here to view code image

int f1() { }                 // error: no value returned
void f2() { }                // OK

int f3() { return 1; }       // OK
void f4() { return 1; }      // error: return value in void function

int f5() { return; }         // error: return value missing
void f6() { return; }        // OK
A return value is specified by a return-statement. For example:

int fac(int n)
{
      return (n>1) ? n*fac(n–1) : 1;
}
A function that calls itself is said to be recursive.

There can be more than one return-statement in a function:

int fac2(int n)
{
      if (n > 1)
            return n*fac2(n–1);
      return 1;
}
Like the semantics of argument passing, the semantics of function value return are identical to the semantics of copy initialization (§16.2.6). A return-statement initializes a variable of the returned type. The type of a return expression is checked against the type of the returned type, and all standard and user-defined type conversions are performed. For example:

double f() { return 1; }         //1 is implicitly converted to double{1}
Each time a function is called, a new copy of its arguments and local (automatic) variables is created. The store is reused after the function returns, so a pointer to a local non-static variable should never be returned. The contents of the location pointed to will change unpredictably:

int* fp()
{
      int local = 1;
      // ...
      return &local;  // bad
}
An equivalent error can occur when using references:

int& fr()
{
     int local = 1;
     // ...
     return local;    // bad
}
Fortunately, a compiler can easily warn about returning references to local variables (and most do).

There are no void values. However, a call of a void function may be used as the return value of a void function. For example:

Click here to view code image

void g(int* p);

void h(int* p)
{
     // ...
     return g(p);     // OK: equivalent to "g(p); return;"
}
This form of return is useful to avoid special cases when writing template functions where the return type is a template parameter.

A return-statement is one of five ways of exiting a function:

• Executing a return-statement.

• “Falling off the end” of a function; that is, simply reaching the end of the function body. This is allowed only in functions that are not declared to return a value (i.e., void functions) and in main(), where falling off the end indicates successful completion (§12.1.4).

• Throwing an exception that isn’t caught locally (§13.5).

• Terminating because an exception was thrown and not caught locally in a noexcept function (§13.5.1.1).

• Directly or indirectly invoking a system function that doesn’t return (e.g., exit(); §15.4).

A function that does not return normally (i.e., through a return or “falling off the end”) can be marked [[noreturn]] (§12.1.7).

12.1.5. inline Functions
A function can be defined to be inline. For example:

inline int fac(int n)
{
     return (n<2) ? 1 : n*fac(n–1);
}
The inline specifier is a hint to the compiler that it should attempt to generate code for a call of fac() inline rather than laying down the code for the function once and then calling through the usual function call mechanism. A clever compiler can generate the constant 720 for a call fac(6). The possibility of mutually recursive inline functions, inline functions that recurse or not depending on input, etc., makes it impossible to guarantee that every call of an inline function is actually inlined. The degree of cleverness of a compiler cannot be legislated, so one compiler might generate 720, another 6*fac(5), and yet another an un-inlined call fac(6). If you want a guarantee that a value is computed at compile time, declare it constexpr and make sure that all functions used in its evaluation are constexpr (§12.1.6).

To make inlining possible in the absence of unusually clever compilation and linking facilities, the definition – and not just the declaration – of an inline function must be in scope (§15.2). An inline specifier does not affect the semantics of a function. In particular, an inline function still has a unique address, and so do static variables (§12.1.8) of an inline function.

If an inline function is defined in more than one translation unit (e.g., typically because it was defined in a header; §15.2.2), its definitions in the different translation units must be identical (§15.2.3).

12.1.6. constexpr Functions
In general, a function cannot be evaluated at compile time and therefore cannot be called in a constant expression (§2.2.3, §10.4). By specifying a function constexpr, we indicate that we want it to be usable in constant expressions if given constant expressions as arguments. For example:

Click here to view code image

constexpr int fac(int n)
{
    return (n>1) ? n*fac(n–1) : 1;
}

constexpr int f9 = fac(9);           // must be evaluated at compile time
When constexpr is used in a function definition, it means “should be usable in a constant expression when given constant expressions as arguments.” When used in an object definition, it means “evaluate the initializer at compile time.” For example:

Click here to view code image

void f(int n)
{
     int f5 = fac(5);                // may be evaluated at compile time
     int fn = fac(n);                // evaluated at run time (n is a variable)

     constexpr int f6 = fac(6);      // must be evaluated at compile time
     constexpr int fnn = fac(n);     // error: can't guarantee compile-time evaluation (n is a variable)

     char a[fac(4)];                 // OK: array bounds must be constants and fac() is constexpr
     char a2[fac(n)];                // error: array bounds must be constants and n is a variable

     // ...
}
To be evaluated at compile time, a function must be suitably simple: a constexpr function must consist of a single return-statement; no loops and no local variables are allowed. Also, a constexpr function may not have side effects. That is, a constexpr function is a pure function. For example:

Click here to view code image

int glob;

constexpr void bad1(int a)      // error: constexpr function cannot be void
{
     glob = a;            // error: side effect in constexpr function
}

constexpr int bad2(int a)
{
     if (a>=0) return a; else return –a;     // error: if-statement in constexpr function
}

constexpr int bad3(int a)
{
     int sum = 0;                                // error: local variable in constexpr function
     for (int i=0; i<a; ++i) sum +=fac(i); return sum;   // error: loop in constexpr function
     return sum;
}
The rules for a constexpr constructor are suitably different (§10.4.3); there, only simple initialization of members is allowed.

A constexpr function allows recursion and conditional expressions. This implies that you can express just about anything as a constexpr function if you really want to. However, you’ll find the debugging gets unnecessarily difficult and compile times longer than you would like unless you restrict the use of constexpr functions to the relatively simple tasks for which they are intended.

By using literal types (§10.4.3), constexpr functions can be defined to use user-defined types.

Like inline functions, constexpr functions obey the ODR (“one-definition rule”), so that definitions in the different translation units must be identical (§15.2.3). You can think of constexpr functions as a restricted form of inline functions (§12.1.5).

12.1.6.1. constexpr and References
A constexpr function cannot have side effects, so writing to nonlocal objects is not possible. However, a constexpr function can refer to nonlocal objects as long as it does not write to them.

Click here to view code image

constexpr int ftbl[] { 0, 1, 1, 2, 3, 5, 8, 13 };

constexpr int fib(int n)
{
    return (n<sizeof(ftbl)/sizeof(*ftbl)) ? ftbl[n] : fib(n-2)+fib(n-1);
}
A constexpr function can take reference arguments. Of course, it cannot write through such references, but const reference parameters are as useful as ever. For example, in the standard library (§40.4) we find:

Click here to view code image

template<> class complex<float> {
public:
// ...
     explicit constexpr complex(const complex<double>&);
     // ...
};
This allows us to write:

constexpr complex<float> z {2.0};
The temporary variable that is logically constructed to hold the const reference argument simply becomes a value internal to the compiler.

It is possible for a constexpr function to return a reference or a pointer. For example:

constexpr const int* addr(const int& r) { return &r; }    // OK
However, doing so brings us away from the fundamental role of constexpr functions as parts of constant expression evaluation. In particular, it can be quite tricky to determine whether the result of such a function is a constant expression. Consider:

Click here to view code image

static const int x = 5;
constexpr const int* p1 = addr(x);       // OK
constexpr int xx = *p1;                  // OK

static int y;
constexpr const int* p2 = addr(y);       // OK
constexpr int yy = *p2;                   // error: attempt to read a variable

constexpr const int* tp = addr(5);       // error: address of temporary
12.1.6.2. Conditional Evaluation
A branch of a conditional expression that is not taken in a constexpr function is not evaluated. This implies that a branch not taken can require run-time evaluation. For example:

Click here to view code image

constexpr int low = 0;
constexpr int high = 99;

constexpr int check(int i)
{
    return (low<=i && i<high) ? i : throw out_of_range();
}

constexpt int val0 = check(50);         // OK
constexpr int val1 = check(f(x,y,z));   // maybe OK
constexpr int val2 = check(200);        // throws
You might imagine low and high to be configuration parameters that are known at compile time, but not at design time, and that f(x,y,z) computes some implementation-dependent value.

12.1.7. [[noreturn]] Functions
A construct [[...]] is called an attribute and can be placed just about anywhere in the C++ syntax. In general, an attribute specifies some implementation-dependent property about the syntactic entity that precedes it. In addition, an attribute can be placed in front of a declaration. There are only two standard attributes (§iso.7.6), and [[noreturn]] is one of them. The other is [[carries_dependency]] (§41.3).

Placing [[noreturn]] at the start of a function declaration indicates that the function is not expected to return. For example:

[[noreturn]] void exit(int);      // exit will never return
Knowing that a function does not return is useful for both comprehension and code generation. What happens if the function returns despite a [[noreturn]] attribute is undefined.

12.1.8. Local Variables
A name defined in a function is commonly referred to as a local name. A local variable or constant is initialized when a thread of execution reaches its definition. Unless a variable is declared static, each invocation of the function has its own copy of it. If a local variable is declared static, a single, statically allocated object (§6.4.2) will be used to represent that variable in all calls of the function. It will be initialized only the first time a thread of execution reaches its definition. For example:

Click here to view code image

void f(int a)
{
     while (a––) {
          static int n = 0;      // initialized once
          int x = 0;             // initialized 'a' times in each call of f()

          cout << "n == " << n++ << ", x == " << x++ << '\n';
     }
}

int main()
{
     f(3);
}
This prints:

n == 0, x == 0
n == 1, x == 0
n == 2, x == 0
A static local variable allows the function to preserve information between calls without introducing a global variable that might be accessed and corrupted by other functions (see also §16.2.12).

Initialization of a static local variable does not lead to a data race (§5.3.1) unless you enter the function containing it recursively or a deadlock occurs (§iso.6.7). That is, the C++ implementation must guard the initialization of a local static variable with some kind of lock-free construct (e.g., a call_once; §42.3.3). The effect of initializing a local static recursively is undefined. For example:

Click here to view code image

int fn(int n)
{
      static int n1 = n;              // OK
      static int n2 = fn(n–1)+1;      // undefined
      return n;
}
A static local variable is useful for avoiding order dependencies among nonlocal variables (§15.4.1).

There are no local functions; if you feel you need one, use a function object or a lambda expression (§3.4.3, §11.4).

The scope of a label (§9.6), should you be foolhardy enough to use one, is the complete function, independent of which nested scope it may be in.

12.2. Argument Passing
When a function is called (using the suffix (), known as the call operator or application operator), store is set aside for its formal arguments (also known as its parameters), and each formal argument is initialized by its corresponding actual argument. The semantics of argument passing are identical to the semantics of initialization (copy initialization, to be precise; §16.2.6). In particular, the type of an actual argument is checked against the type of the corresponding formal argument, and all standard and user-defined type conversions are performed. Unless a formal argument (parameter) is a reference, a copy of the actual argument is passed to the function. For example:

Click here to view code image

int* find(int* first, int* last, int v)    // find x in [first:last)
{
     while (first!=last && *first!=v)
          ++first;
     return first;
}

void g(int* p, int* q)
{
     int* pp = find(p,q,'x');
     // ...
}
Here, the caller’s copy of the argument, p, is not modified by the operations on find()’s copy, called first. The pointer is passed by value.

There are special rules for passing arrays (§12.2.2), a facility for passing unchecked arguments (§12.2.4), and a facility for specifying default arguments (§12.2.5). The use of initializer lists is described in §12.2.3 and the ways of passing arguments to template functions in §23.5.2 and §28.6.2.

12.2.1. Reference Arguments
Consider:

void f(int val, int& ref)
{
     ++val;
     ++ref;
}
When f() is called, ++val increments a local copy of the first actual argument, whereas ++ref increments the second actual argument. Consider:

void g()
{
     int i = 1;
     int j = 1;
     f(i,j);
}
The call f(i,j) will increment j but not i. The first argument, i, is passed by value; the second argument, j, is passed by reference. As mentioned in §7.7, functions that modify call-by-reference arguments can make programs hard to read and should most often be avoided (but see §18.2.5). It can, however, be noticeably more efficient to pass a large object by reference than to pass it by value. In that case, the argument might be declared a const reference to indicate that the reference is used for efficiency reasons only and not to enable the called function to change the value of the object:

Click here to view code image

void f(const Large& arg)
{
      // the value of "arg" cannot be changed
      //(except by using explicit type conversion; §11.5)
}
The absence of const in the declaration of a reference argument is taken as a statement of intent to modify the variable:

void g(Large& arg);      // assume that g() modifies arg
Similarly, declaring a pointer argument const tells readers that the value of an object pointed to by that argument is not changed by the function. For example:

Click here to view code image

int strlen(const char*);                      // number of characters in a C-style string
char* strcpy(char* to, const char* from);     // copy a C-style string
int strcmp(const char*, const char*);         // compare C-style strings
The importance of using const arguments increases with the size of a program.

Note that the semantics of argument passing are different from the semantics of assignment. This is important for const arguments, reference arguments, and arguments of some user-defined types.

Following the rules for reference initialization, a literal, a constant, and an argument that requires conversion can be passed as a const T& argument, but not as a plain (non-const) T& argument. Allowing conversions for a const T& argument ensures that such an argument can be given exactly the same set of values as a T argument by passing the value in a temporary, if necessary. For example:

Click here to view code image

float fsqrt(const float&);  // Fortran-style sqrt taking a reference argument

void g(double d)
{
     float r = fsqrt(2.0f);       // pass reference to temp holding 2.0f
     r = fsqrt(r);                // pass reference to r
     r = fsqrt(d);                // pass reference to temp holding static_cast<float>(d)
}
Disallowing conversions for non-const reference arguments (§7.7) avoids the possibility of silly mistakes arising from the introduction of temporaries. For example:

Click here to view code image

void update(float& i);

void g(double d, float r)
{
     update(2.0f);           // error: const argument
     update(r);              // pass reference to r
     update(d);              // error: type conversion required
}
Had these calls been allowed, update() would quietly have updated temporaries that immediately were deleted. Usually, that would come as an unpleasant surprise to the programmer.

If we wanted to be precise, pass-by-reference would be pass-by-lvalue-reference because a function can also take rvalue references. As described in §7.7, an rvalue can be bound to an rvalue reference (but not to an lvalue reference) and an lvalue can be bound to an lvalue reference (but not to an rvalue reference). For example:

Click here to view code image

void f(vector<int>&);               //(non-const) lvalue reference argument
void f(const vector<int>&);         // const lvalue reference argument
void f(vector<int>&&);              // rvalue reference argument

void g(vector<int>& vi, const vector<int>& cvi)
{
     f(vi);                     // call f(vector<int>&)
     f(cvi);                    // call f(const vector<int>&)
     f(vector<int>{1,2,3,4});   // call f(vector<int>&&);
}
We must assume that a function will modify an rvalue argument, leaving it good only for destruction or reassignment (§17.5). The most obvious use of rvalue references is to define move constructors and move assignments (§3.3.2, §17.5.2). I’m sure someone will find a clever use for const-rvalue-reference arguments, but so far, I have not seen a genuine use case.

Please note that for a template argument T, the template argument type deduction rules give T&& a significantly different meaning from X&& for a type X (§23.5.2.1). For template arguments, an rvalue reference is most often used to implement “perfect forwarding” (§23.5.2.1, §28.6.3).

How do we choose among the ways of passing arguments? My rules of thumb are:

[1] Use pass-by-value for small objects.

[2] Use pass-by-const-reference to pass large values that you don’t need to modify.

[3] Return a result as a return value rather than modifying an object through an argument.

[4] Use rvalue references to implement move (§3.3.2, §17.5.2) and forwarding (§23.5.2.1).

[5] Pass a pointer if “no object” is a valid alternative (and represent “no object” by nullptr).

[6] Use pass-by-reference only if you have to.

The “when you have to” in the last rule of thumb refers to the observation that passing pointers is often a less obscure mechanism for dealing with objects that need modification (§7.7.1, §7.7.4) than using references.

12.2.2. Array Arguments
If an array is used as a function argument, a pointer to its initial element is passed. For example:

int strlen(const char*);

void f()
{
     char v[] = "Annemarie";
     int i = strlen(v);
     int j = strlen("Nicholas");
}
That is, an argument of type T[] will be converted to a T* when passed as an argument. This implies that an assignment to an element of an array argument changes the value of an element of the argument array. In other words, arrays differ from other types in that an array is not passed by value. Instead, a pointer is passed (by value).

A parameter of array type is equivalent to a parameter of pointer type. For example:

void odd(int* p);
void odd(int a[]);
void odd(int buf[1020]);
These three declarations are equivalent and declare the same function. As usual, the argument names do not affect the type of the function (§12.1.3). The rules and techniques for passing multidimensional arrays can be found in §7.4.3.

The size of an array is not available to the called function. This is a major source of errors, but there are several ways of circumventing this problem. C-style strings are zero-terminated, so their size can be computed (e.g., by a potentially expensive call of strlen(); §43.4). For other arrays, a second argument specifying the size can be passed. For example:

void compute1(int* vec_ptr, int vec_size);     // one way
At best, this is a workaround. It is usually preferable to pass a reference to some container, such as vector (§4.4.1, §31.4), array (§34.2.1), or map (§4.4.3, §31.4.3).

If you really want to pass an array, rather than a container or a pointer to the first element of an array, you can declare a parameter of type reference to array. For example:

Click here to view code image

void f(int(&r)[4]);

void g()
{
     int a1[] = {1,2,3,4};
     int a2[] = {1,2};

     f(a1);       // OK
     f(a2);       // error : wrong number of elements
}
Note that the number of elements is part of a reference-to-array type. That makes such references far less flexible than pointers and containers (such as vector). The main use of references to arrays is in templates, where the number of elements is then deduced. For example:

Click here to view code image

template<typename T, int N> void f(T(&r)[N])
{
     // ...
}

int a1[10];
double a2[100];

void g()
{
     f(a1);          // T is int; N is 10
     f(a2);          // T is double; N is 100
}
This typically gives rise to as many function definitions as there are calls to f() with distinct array types.

Multidimensional arrays are tricky (see §7.3), but often arrays of pointers can be used instead, and they need no special treatment. For example:

Click here to view code image

const char* day[] = {
    "mon", "tue", "wed", "thu", "fri", "sat", "sun"
};
As ever, vector and similar types are alternatives to the built-in, low-level arrays and pointers.

12.2.3. List Arguments
A {}-delimited list can be used as an argument to a parameter of:

[1] Type std::initializer_list<T>, where the values of the list can be implicitly converted to T

[2] A type that can be initialized with the values provided in the list

[3] A reference to an array of T, where the values of the list can be implicitly converted to T

Technically, case [2] covers all examples, but I find it easier to think of the three cases separately. Consider:

Click here to view code image

template<typename T>
void f1(initializer_list<T>);

struct S {
     int a;
     string s;
};
void f2(S);

template<typename T, int N>
void f3(T (&r)[N]);

void f4(int);

void g()
{
     f1({1,2,3,4});   // T is int and the initializer_list has size() 4
     f2({1,"MKS"});   // f2(S{1,"MKS"})
     f3({1,2,3,4});   // T is int and N is 4
     f4({1});         // f4(int{1});
}
If there is a possible ambiguity, an initializer_list parameter takes priority. For example:

Click here to view code image

template<typename T>
void f(initializer_list<T>);

struct S {
     int a;
     string s;

};
void f(S);

template<typename T, int N>
void f(T (&r)[N]);

void f(int);

void g()
{
     f({1,2,3,4});    // T is int and the initializer_list has size() 4
     f({1,"MKS"});    // calls f(S)
     f({1});          // T is int and the initializer_list has size() 1
}
The reason that a function with an initializer_list argument takes priority is that it could be very confusing if different functions were chosen based on the number of elements of a list. It is not possible to eliminate every form of confusion in overload resolution (for example, see §4.4, §17.3.4.1), but giving initializer_list parameters priority for {}-list arguments seems to minimize confusion.

If there is a function with an initializer-list argument in scope, but the argument list isn’t a match for that, another function can be chosen. The call f({1,"MKS"}) was an example of that.

Note that these rules apply to std::initializer_list<T> arguments only. There are no special rules for std::initializer_list<T>& or for other types that just happen to be called initializer_list (in some other scope).

12.2.4. Unspecified Number of Arguments
For some functions, it is not possible to specify the number and type of all arguments expected in a call. To implement such interfaces, we have three choices:

[1] Use a variadic template (§28.6): this allows us to handle an arbitrary number of arbitrary types in a type-safe manner by writing a small template metaprogram that interprets the argument list to determine its meaning and take appropriate actions.

[2] Use an initializer_list as the argument type (§12.2.3). This allows us to handle an arbitrary number of arguments of a single type in a type-safe manner. In many contexts, such homogeneous lists are the most common and important case.

[3] Terminate the argument list with the ellipsis (...), which means “and maybe some more arguments.” This allows us to handle an arbitrary number of (almost) arbitrary types by using some macros from <cstdarg>. This solution is not inherently type-safe and can be hard to use with sophisticated user-defined types. However, this mechanism has been used from the earliest days of C.

The first two mechanisms are described elsewhere, so I describe only the third mechanism (even though I consider it inferior to the others for most uses). For example:

int printf(const char* ...);
This specifies that a call of the standard-library function printf() (§43.3) must have at least one argument, a C-style string, but may or may not have others. For example:

Click here to view code image

printf("Hello, world!\n");
printf("My name is %s %s\n", first_name, second_name);
printf("%d + %d = %d\n",2,3,5);
Such a function must rely on information not available to the compiler when interpreting its argument list. In the case of printf(), the first argument is a format string containing special character sequences that allow printf() to handle other arguments correctly; %s means “expect a char* argument” and %d means “expect an int argument.” However, the compiler cannot in general ensure that the expected arguments are really provided in a call or that an argument is of the expected type. For example:

Click here to view code image

#include <cstdio>

int main()
{
     std::printf("My name is %s %s\n",2);
}
This is not valid code, but most compilers will not catch this error. At best, it will produce some strange-looking output (try it!).

Clearly, if an argument has not been declared, the compiler does not have the information needed to perform the standard type checking and type conversion for it. In that case, a char or a short is passed as an int and a float is passed as a double. This is not necessarily what the programmer expects.

A well-designed program needs at most a few functions for which the argument types are not completely specified. Overloaded functions, functions using default arguments, functions taking initializer_list arguments, and variadic templates can be used to take care of type checking in most cases when one would otherwise consider leaving argument types unspecified. Only when both the number of arguments and the types of arguments vary and a variadic template solution is deemed undesirable is the ellipsis necessary.

The most common use of the ellipsis is to specify an interface to C library functions that were defined before C++ provided alternatives:

Click here to view code image

int fprintf(FILE*, const char* ...);        // from <cstdio>
int execl(const char* ...);                 // from UNIX header
A standard set of macros for accessing the unspecified arguments in such functions can be found in <cstdarg>. Consider writing an error function that takes one integer argument indicating the severity of the error followed by an arbitrary number of strings. The idea is to compose the error message by passing each word as a separate C-style string argument. The list of string arguments should be terminated by the null pointer:

Click here to view code image

extern void error(int ...);
extern char* itoa(int, char[]);   // int to alpha

int main(int argc, char* argv[])
{
     switch (argc) {
     case 1:
          error(0,argv[0],nullptr);
          break;
     case 2:
          error(0,argv[0],argv[1],nullptr);
          break;
     default:
          char buffer[8];
          error(1,argv[0],"with",itoa(argc–1,buffer),"arguments",nullptr);
     }
     // ...
}
The function itoa() returns a C-style string representing its int argument. It is popular in C, but not part of the C standard.

I always pass argv[0] because that, conventionally, is the name of the program.

Note that using the integer 0 as the terminator would not have been portable: on some implementations, the integer 0 and the null pointer do not have the same representation (§6.2.8). This illustrates the subtleties and extra work that face the programmer once type checking has been suppressed using the ellipsis.

The error() function could be defined like this:

Click here to view code image

#include <cstdarg>

void error(int severity ...)  //"severity" followed by a zero-terminated list of char*s
{
     va_list ap;
     va_start(ap,severity);     // arg startup

     for (;;) {
            char* p = va_arg(ap,char*);
            if (p == nullptr) break;
            cerr << p << ' ';
     }

     va_end(ap);                // arg cleanup

     cerr << '\n';
     if (severity) exit(severity);
}
First, a va_list is defined and initialized by a call of va_start(). The macro va_start takes the name of the va_list and the name of the last formal argument as arguments. The macro va_arg() is used to pick the unnamed arguments in order. In each call, the programmer must supply a type; va_arg() assumes that an actual argument of that type has been passed, but it typically has no way of ensuring that. Before returning from a function in which va_start() has been used, va_end() must be called. The reason is that va_start() may modify the stack in such a way that a return cannot successfully be done; va_end() undoes any such modifications.

Alternatively, error() could have been defined using a standard-library initializer_list:

Click here to view code image

void error(int severity, initializer_list<string> err)
{
     for (auto& s : err)
           cerr << s << ' ';
     cerr << '\n';
     if (severity) exit(severity);
}
It would then have to be called using the list notation. For example:

Click here to view code image

switch (argc) {
case 1:
     error(0,{argv[0]});
     break;
case 2:
     error(0,{argv[0],argv[1]});
     break;
default:
     error(1,{argv[0],"with",to_string(argc–1),"arguments"});
}
The int-to-string conversion function to_string() is provided by the standard library (§36.3.5).

If I didn’t have to mimic C style, I would further simplify the code by passing a container as a single argument:

Click here to view code image

void error(int severity, const vector<string>& err)  // almost as before
{
     for (auto& s : err)
           cerr << s << ' ';
     cerr << '\n';
     if (severity) exit(severity);
}

vector<string> arguments(int argc, char* argv[])  // package arguments
{
     vector<string> res;
     for (int i = 0; i!=argc; ++i)
           res.push_back(argv[i]);
     return res;
}

int main(int argc, char* argv[])
{
     auto args = arguments(argc,argv);
     error((args.size()<2)?0:1,args);
     // ...
}
The helper function, arguments(), is trivial, and main() and error() are simple. The interface between main() and error() is more general in that it now passes all arguments. That would allow later improvements of error(). The use of the vector<string> is far less error-prone than any use of an unspecified number of arguments.

12.2.5. Default Arguments
A general function often needs more arguments than are necessary to handle simple cases. In particular, functions that construct objects (§16.2.5) often provide several options for flexibility. Consider class complex from §3.2.1.1:

Click here to view code image

class complex {
     double re, im;
public:
     complex(double r, double i) :re{r}, im{i} {}      // construct complex from two scalars
     complex(double r) :re{r}, im{0} {}                // construct complex from one scalar
     complex() :re{0}, im{0} {}
 // default complex: {0,0}
     // ...
};
The actions of complex’s constructors are quite trivial, but logically there is something odd about having three functions (here, constructors) doing essentially the same task. Also, for many classes, constructors do more work and the repetitiveness is common. We could deal with the repetitiveness by considering one of the constructors “the real one” and forward to that (§17.4.3):

Click here to view code image

complex(double r, double i) :re{r}, im{i} {}     // construct complex from two scalars
complex(double r) :complex{r,0} {}               // construct complex from one scalar
complex() :complex{0,0} {}                       // default complex: {0,0}
Say we wanted to add some debugging, tracing, or statistics-gathering code to complex; we now have a single place to do so. However, this can be abbreviated further:

complex(double r ={}, double i ={}) :re{r}, im{i} {}   // construct complex from two scalars
This makes it clear that if a user supplies fewer than the two arguments needed, the default is used. The intent of having a single constructor plus some shorthand notation is now explicit.

A default argument is type checked at the time of the function declaration and evaluated at the time of the call. For example:

Click here to view code image

class X {
public:
     static int def_arg;
     void f(int =def_arg);
     // ...
};

int X::def_arg = 7;

void g(X& a)
{
     a.f();          // maybe f(7)
     a.def_arg = 9;
     a.f();          // f(9)
}
Default arguments that can change value are most often best avoided because they introduce subtle context dependencies.

Default arguments may be provided for trailing arguments only. For example:

Click here to view code image

int f(int, int =0, char* =nullptr); // OK
int g(int =0, int =0, char*);            // error
int h(int =0, int, char* =nullptr);      // error
Note that the space between the * and the = is significant (*= is an assignment operator; §10.3):

int nasty(char*=nullptr);                // syntax error
A default argument cannot be repeated or changed in a subsequent declaration in the same scope. For example:

Click here to view code image

void f(int x = 7);
void f(int = 7);           // error: cannot repeat default argument
void f(int = 8);           // error: different default arguments

void g()
{
     void f(int x = 9);    // OK: this declaration hides the outer one
     // ...
}
Declaring a name in a nested scope so that the name hides a declaration of the same name in an outer scope is error-prone.

12.3. Overloaded Functions
Most often, it is a good idea to give different functions different names, but when different functions conceptually perform the same task on objects of different types, it can be more convenient to give them the same name. Using the same name for operations on different types is called overloading. The technique is already used for the basic operations in C++. That is, there is only one name for addition, +, yet it can be used to add values of integer and floating-point types and combinations of such types. This idea is easily extended to functions defined by the programmer. For example:

Click here to view code image

void print(int);            // print an int
void print(const char*);    // print a C-style string
As far as the compiler is concerned, the only thing functions of the same name have in common is that name. Presumably, the functions are in some sense similar, but the language does not constrain or aid the programmer. Thus, overloaded function names are primarily a notational convenience. This convenience is significant for functions with conventional names such as sqrt, print, and open. When a name is semantically significant, this convenience becomes essential. This happens, for example, with operators such as +, *, and <<, in the case of constructors (§16.2.5, §17.1), and in generic programming (§4.5, Chapter 32).

Templates provide a systematic way of defining sets of overloaded functions (§23.5).

12.3.1. Automatic Overload Resolution
When a function fct is called, the compiler must determine which of the functions named fct to invoke. This is done by comparing the types of the actual arguments with the types of the parameters of all functions in scope called fct. The idea is to invoke the function that is the best match to the arguments and give a compile-time error if no function is the best match. For example:

Click here to view code image

void print(double);
void print(long);

void f()
{
     print(1L);       // print(long)
     print(1.0);      // print(double)
     print(1);        // error, ambiguous: print(long(1)) or print(double(1))?
}
To approximate our notions of what is reasonable, a series of criteria are tried in order:

[1] Exact match; that is, match using no or only trivial conversions (for example, array name to pointer, function name to pointer to function, and T to const T)

[2] Match using promotions; that is, integral promotions (bool to int, char to int, short to int, and their unsigned counterparts; §10.5.1) and float to double

[3] Match using standard conversions (e.g., int to double, double to int, double to long double, Derived* to Base* (§20.2), T* to void* (§7.2.1), int to unsigned int (§10.5))

[4] Match using user-defined conversions (e.g., double to complex<double>; §18.4)

[5] Match using the ellipsis ... in a function declaration (§12.2.4)

If two matches are found at the highest level where a match is found, the call is rejected as ambiguous. The resolution rules are this elaborate primarily to take into account the elaborate C and C++ rules for built-in numeric types (§10.5). For example:

Click here to view code image

void print(int);
void print(const char*);
void print(double);
void print(long);
void print(char);

void h(char c, int i, short s, float f)
{
     print(c);          // exact match: invoke print(char)
     print(i);          // exact match: invoke print(int)
     print(s);          // integral promotion: invoke print(int)
     print(f);          // float to double promotion: print(double)

     print('a');        // exact match: invoke print(char)
     print(49);         // exact match: invoke print(int)
     print(0);          // exact match: invoke print(int)
     print("a");        // exact match: invoke print(const char*)
     print(nullptr);    // nullptr_t to const char* promotion: invoke print(const char*)
}
The call print(0) invokes print(int) because 0 is an int. The call print('a') invokes print(char) because 'a' is a char (§6.2.3.2). The reason to distinguish between conversions and promotions is that we want to prefer safe promotions, such as char to int, over unsafe conversions, such as int to char. See also §12.3.5.

Overload resolution is independent of the order of declaration of the functions considered.

Function templates are handled by applying the overload resolution rules to the result of specialization based on a set of arguments (§23.5.3). There are separate rules for overloading when a {}-list is used (initializer lists take priority; §12.2.3, §17.3.4.1) and for rvalue reference template arguments (§23.5.2.1).

Overloading relies on a relatively complicated set of rules, and occasionally a programmer will be surprised by which function is called. So, why bother? Consider the alternative to overloading. Often, we need similar operations performed on objects of several types. Without overloading, we must define several functions with different names:

Click here to view code image

void print_int(int);
void print_char(char);
void print_string(const char*);        // C-style string

void g(int i, char c, const char* p, double d)
{
     print_int(i);          // OK
     print_char(c);         // OK
     print_string(p);       // OK

     print_int(c);          // OK? calls print_int(int(c)), prints a number
     print_char(i);         // OK? calls print_char(char(i)), narrowing
     print_string(i);       // error
     print_int(d);          // OK? calls print_int(int(d)), narrowing
}
Compared to the overloaded print(), we have to remember several names and remember to use those correctly. This can be tedious, defeats attempts to do generic programming (§4.5), and generally encourages the programmer to focus on relatively low-level type issues. Because there is no overloading, all standard conversions apply to arguments to these functions. It can also lead to errors. In the previous example, this implies that only one of the four calls with doubtful semantics is caught by the compiler. In particular, two calls rely on error-prone narrowing (§2.2.2, §10.5). Thus, overloading can increase the chances that an unsuitable argument will be rejected by the compiler.

12.3.2. Overloading and Return Type
Return types are not considered in overload resolution. The reason is to keep resolution for an individual operator (§18.2.1, §18.2.5) or function call context-independent. Consider:

Click here to view code image

float sqrt(float);
double sqrt(double);

void f(double da, float fla)
{
     float fl = sqrt(da);  // call sqrt(double)
     double d = sqrt(da);  // call sqrt(double)
     fl = sqrt(fla);       // call sqrt(float)
     d = sqrt(fla);        // call sqrt(float)
}
If the return type were taken into account, it would no longer be possible to look at a call of sqrt() in isolation and determine which function was called.

12.3.3. Overloading and Scope
Overloading takes place among the members of an overload set. By default, that means the functions of a single scope; functions declared in different non-namespace scopes do not overload. For example:

void f(int);

void g()
{
     void f(double);
     f(1);           // call f(double)
}
Clearly, f(int) would have been the best match for f(1), but only f(double) is in scope. In such cases, local declarations can be added or subtracted to get the desired behavior. As always, intentional hiding can be a useful technique, but unintentional hiding is a source of surprises.

A base class and a derived class provide different scopes so that overloading between a base class function and a derived class function doesn’t happen by default. For example:

Click here to view code image

struct Base {
     void f(int);
};

struct Derived : Base {
     void f(double);
};

void g(Derived& d)
{
     d.f(1);   // call Derived::f(double);
}
When overloading across class scopes (§20.3.5) or namespace scopes (§14.4.5) is wanted, using-declarations or using-directives can be used (§14.2.2). Argument-dependent lookup (§14.2.4) can also lead to overloading across namespaces.

12.3.4. Resolution for Multiple Arguments
We can use the overload resolution rules to select the most appropriate function when the efficiency or precision of computations differs significantly among types. For example:

Click here to view code image

int pow(int, int);
double pow(double, double);
complex pow(double, complex);
complex pow(complex, int); 
complex pow(complex, complex);

void k(complex z)
{ 
     int i = pow(2,2);             // invoke pow(int,int)
     double d = pow(2.0,2.0);      // invoke pow(double,double)
     complex z2 = pow(2,z);        // invoke pow(double,complex)
     complex z3 = pow(z,2);        // invoke pow(complex,int)
     complex z4 = pow(z,z);        // invoke pow(complex,complex)
}
In the process of choosing among overloaded functions with two or more arguments, a best match is found for each argument using the rules from §12.3. A function that is the best match for one argument and a better or equal match for all other arguments is called. If no such function exists, the call is rejected as ambiguous. For example:

Click here to view code image

void g()
{
     double d = pow(2.0,2);     // error: pow(int(2.0),2) or pow(2.0,double(2))?
}
The call is ambiguous because 2.0 is the best match for the first argument of pow(double,double) and 2 is the best match for the second argument of pow(int,int).

12.3.5. Manual Overload Resolution
Declaring too few (or too many) overloaded versions of a function can lead to ambiguities. For example:

Click here to view code image

void f1(char);
void f1(long);

void f2(char*);
void f2(int*);

void k(int i)
{
     f1(i);      // ambiguous: f1(char) or f1(long)?
     f2(0);      // ambiguous: f2(char*) or f2(int*)?
}
Where possible, consider the set of overloaded versions of a function as a whole and see if it makes sense according to the semantics of the function. Often the problem can be solved by adding a version that resolves ambiguities. For example, adding

inline void f1(int n) { f1(long(n)); }
would resolve all ambiguities similar to f1(i) in favor of the larger type long int.

One can also add an explicit type conversion to resolve a specific call. For example:

f2(static_cast<int*>(0));
However, this is most often simply an ugly stopgap. Soon another similar call will be made and have to be dealt with.

Some C++ novices get irritated by the ambiguity errors reported by the compiler. More experienced programmers appreciate these error messages as useful indicators of design errors.

12.4. Pre- and Postconditions
Every function has some expectations on its arguments. Some of these expectations are expressed in the argument types, but others depend on the actual values passed and on relationships among argument values. The compiler and linker can ensure that arguments are of the right types, but it is up to the programmer to decide what to do about “bad” argument values. We call logical criteria that are supposed to hold when a function is called preconditions, and logical criteria that are supposed to hold when a function returns its postconditions. For example:

Click here to view code image

int area(int len, int wid)
/*
      calculate the area of a rectangle

      precondition: len and wid are positive

      postcondition: the return value is positive

      postcondition: the return value is the area of a rectangle with sides len and wid
*/
{
      return len*wid;
}
Here, the statements of the pre- and postconditions are longer than the function body. This may seem excessive, but the information provided is useful to the implementer, to the users of area(), and to testers. For example, we learn that 0 and –12 are not considered valid arguments. Furthermore, we note that we could pass a couple of huge values without violating the precondition, but if len*wid overflows either or both of the postconditions are not met.

What should we do about a call area(numeric_limits<int>::max(),2)?

[1] Is it the caller’s task to avoid it? Yes, but what if the caller doesn’t?

[2] Is it the implementer’s task to avoid it? If so, how is an error to be handled?

There are several possible answers to these questions. It is easy for a caller to make a mistake and fail to establish a precondition. It is also difficult for an implementer to cheaply, efficiently, and completely check preconditions. We would like to rely on the caller to get the preconditions right, but we need a way to test for correctness. For now, just note that some pre- and postconditions are easy to check (e.g., len is positive and len*wid is positive). Others are semantic in nature and hard to test directly. For example, how do we test “the return value is the area of a rectangle with sides len and wid”? This is a semantic constraint because we have to know the meaning of “area of a rectangle,” and just trying to multiply len and wid again with a precision that precluded overflow could be costly.

It seems that writing out the pre- and postconditions for area() uncovered a subtle problem with this very simple function. This is not uncommon. Writing out pre- and postconditions is a great design tool and provides good documentation. Mechanisms for documenting and enforcing conditions are discussed in §13.4.

If a function depends only on its arguments, its preconditions are on its arguments only. However, we have to be careful about functions that depend on non-local values (e.g., a member function that depends on the state of its object). In essence, we have to consider every nonlocal value read as an implicit argument to a function. Similarly, the postcondition of a function without side effects simply states that a value is correctly computed, but if a function writes to nonlocal objects, its effect must be considered and documented.

The writer of a function has several alternatives, including:

[1] Make sure that every input has a valid result (so that we don’t have a precondition).

[2] Assume that the precondition holds (rely on the caller not to make mistakes).

[3] Check that the precondition holds and throw an exception if it does not.

[4] Check that the precondition holds and terminate the program if it does not.

If a postconditon fails, there was either an unchecked precondition or a programming error. §13.4 discusses ways to represent alternative strategies for checking.

12.5. Pointer to Function
Like a (data) object, the code generated for a function body is placed in memory somewhere, so it has an address. We can have a pointer to a function just as we can have a pointer to an object. However, for a variety of reasons – some related to machine architecture and others to system design – a pointer to function does not allow the code to be modified. There are only two things one can do to a function: call it and take its address. The pointer obtained by taking the address of a function can then be used to call the function. For example:

Click here to view code image

void error(string s) { /* ... */ }

void (*efct)(string);         // pointer to function taking a string argument and returning nothing

void f()
{
     efct = &error;           // efct points to error
     efct("error");           // call error through efct
}
The compiler will discover that efct is a pointer and call the function pointed to. That is, dereferencing a pointer to function using * is optional. Similarly, using & to get the address of a function is optional:

Click here to view code image

void (*f1)(string) = &error;     // OK: same as = error
void (*f2)(string) = error;      // OK: same as = &error

void g()
{ 
     f1("Vasa");                 // OK: same as (*f1)("Vasa")
     (*f1)("Mary Rose");         // OK: as f1("Mary Rose")
}
Pointers to functions have argument types declared just like the functions themselves. In pointer assignments, the complete function type must match exactly. For example:

Click here to view code image

void (*pf)(string);    // pointer to void(string)
void f1(string);       // void(string)
int f2(string);        // int(string)
void f3(int*);         // void(int*)
void f()
{
     pf = &f1;              // OK
     pf = &f2;              // error: bad return type
     pf = &f3;              // error: bad argument type

     pf("Hera");            // OK
     pf(1);                 // error: bad argument type

     int i = pf("Zeus");    // error: void assigned to int
}
The rules for argument passing are the same for calls directly to a function and for calls to a function through a pointer.

You can convert a pointer to function to a different pointer-to-function type, but you must cast the resulting pointer back to its original type or strange things may happen:

Click here to view code image

using P1 = int(*)(int*);
using P2 = void(*)(void);

void f(P1 pf)
{
     P2 pf2 = reinterpret_cast<P2>(pf)
     pf2();                                   // likely serious problem
     P1 pf1 = reinterpret_cast<P1>(pf2);      // convert pf2 "back again"
     int x = 7;
     int y = pf1(&x);                         // OK
     // ...
}
We need the nastiest of casts, reinterpret_cast, to do conversion of pointer-to-function types. The reason is that the result of using a pointer to function of the wrong type is so unpredictable and system-dependent. For example, in the example above, the called function may write to the object pointed to by its argument, but the call pf2() didn’t supply any argument!

Pointers to functions provide a way of parameterizing algorithms. Because C does not have function objects (§3.4.3) or lambda expressions (§11.4), pointers to functions are widely used as function arguments in C-style code. For example, we can provide the comparison operation needed by a sorting function as a pointer to function:

Click here to view code image

using CFT = int(const void*, const void*);

void ssort(void* base, size_t n, size_t sz, CFT cmp)
/*
     Sort the "n" elements of vector "base" into increasing order
     using the comparison function pointed to by "cmp".
     The elements are of size "sz".

     Shell sort (Knuth, Vol3, pg84)
*/

{
     for (int gap=n/2; 0<gap; gap/=2)
           for (int i=gap; i!=n; i++)
                 for (int j=i-gap; 0<=j; j-=gap) {
                       char* b = static_cast<char*>(base);      // necessary cast
                       char* pj = b+j*sz;                 // &base[j]
                       char* pjg = b+(j+gap)*sz;          // &base[j+gap]
                       if (cmp(pjg,pj)<0) {          // swap base[j] and base[j+gap]:
                            for (int k=0; k!=sz; k++) {
                                  char temp = pj[k];
                                  pj[k] = pjg[k];
                                  pjg[k] = temp;
                            }
                       }
                 }
}
The ssort() routine does not know the type of the objects it sorts, only the number of elements (the array size), the size of each element, and the function to call to perform a comparison. The type of ssort() was chosen to be the same as the type of the standard C library sort routine, qsort(). Real programs use qsort(), the C++ standard-library algorithm sort (§32.6), or a specialized sort routine. This style of code is common in C, but it is not the most elegant way of expressing this algorithm in C++ (see §23.5, §25.3.4.1).

Such a sort function could be used to sort a table such as this:

Click here to view code image

struct User {
     const char* name;
     const char* id;
     int dept;
};

vector<User> heads = {
     "Ritchie D.M.",    "dmr",   11271,
     "Sethi R.",        "ravi",  11272,
     "Szymanski T.G.",  "tgs",   11273,
     "Schryer N.L.",    "nls",   11274,
     "Schryer N.L.",    "nls",   11275,
     "Kernighan B.W.",  "bwk",   11276
};

void print_id(vector<User>& v)
{
     for (auto& x : v)
           cout << x.name << '\t' << x.id << '\t' << x.dept << '\n';
}
To be able to sort, we must first define appropriate comparison functions. A comparison function must return a negative value if its first argument is less than the second, zero if the arguments are equal, and a positive number otherwise:

Click here to view code image

int cmp1(const void* p, const void* q)   // Compare name strings
{
     return strcmp(static_cast<const User*>(p)–>name,static_cast<const User*>(q)–>name);
}

int cmp2(const void* p, const void* q)   // Compare dept numbers
{
     return static_cast<const User*>(p)–>dept – static_cast<const User*>(q)–>dept;
}
There is no implicit conversion of argument or return types when pointers to functions are assigned or initialized. This means that you cannot avoid the ugly and error-prone casts by writing:

Click here to view code image

int cmp3(const User* p, const User* q)  // Compare ids
{
     return strcmp(p–>id,q–>id);
}
The reason is that accepting cmp3 as an argument to ssort() would violate the guarantee that cmp3 will be called with arguments of type const User* (see also §15.2.6).

This program sorts and prints:

Click here to view code image

int main()
{
     cout << "Heads in alphabetical order:\n";
     ssort(&heads[0],6,sizeof(User),cmp1);
     print_id(heads);
     cout << '\n';

     cout << "Heads in order of department number:\n";
     ssort(&heads[0],6,sizeof(User),cmp2);
     print_id(heads);
}
To compare, we can equivalently write:

Click here to view code image

int main()
{
     cout << "Heads in alphabetical order:\n";
     sort(heads.begin(), heads.send(),
          [](const User& x, const User& y) { return x.name<y.name; }
     );
     print_id(heads);
     cout << '\n';

     cout << "Heads in order of department number:\n";
     sort(heads.begin(), heads.end(),
          [](const User& x, const User& y) { return x.dept<y.dept; }
     );
     print_id(heads);
}
No mention of sizes is needed nor any helper functions. If the explicit use of begin() and end() is annoying, it can be eliminated by using a version of sort() that takes a container (§4.5.6):

sort(heads,[](const User& x, const User& y) { return x.name<y.name; });
You can take the address of an overloaded function by assigning to or initializing a pointer to function. In that case, the type of the target is used to select from the set of overloaded functions. For example:

Click here to view code image

void f(int);
int f(char);

void (*pf1)(int) = &f;      // void f(int)
int (*pf2)(char) = &f;      // int f(char)
void (*pf3)(char) = &f;     // error: no void f(char)
It is also possible to take the address of member functions (§20.6), but a pointer to member function is quite different from a pointer to (nonmember) function.

A pointer to a noexcept function can be declared noexcept. For example:

Click here to view code image

void f(int) noexcept;
void g(int);

void (*p1)(int) = f;             // OK: but we throw away useful information
void (*p2)(int) noexcept = f;    // OK: we preserve the noexcept information
void (*p3)(int) noexcept = g;    // error: we don't know that g doesn't throw
A pointer to function must reflect the linkage of a function (§15.2.6). Neither linkage specification nor noexcept may appear in type aliases:

Click here to view code image

using Pc = extern "C" void(int);    // error: linkage specification in alias
using Pn = void(int) noexcept;      // error: noexcept in alias
12.6. Macros
Macros are very important in C but have far fewer uses in C++. The first rule about macros is: don’t use them unless you have to. Almost every macro demonstrates a flaw in the programming language, in the program, or in the programmer. Because they rearrange the program text before the compiler proper sees it, macros are also a major problem for many programming support tools. So when you use macros, you should expect inferior service from tools such as debuggers, cross-reference tools, and profilers. If you must use macros, please read the reference manual for your own implementation of the C++ preprocessor carefully and try not to be too clever. Also, to warn readers, follow the convention to name macros using lots of capital letters. The syntax of macros is presented in §iso.16.3.

I recommend using macros only for conditional compilation (§12.6.1) and in particular for include guards (§15.3.3).

A simple macro is defined like this:

#define NAME rest of line
Where NAME is encountered as a token, it is replaced by rest of line. For example:

named = NAME
will expand into

named = rest of line
A macro can also be defined to take arguments. For example:

#define MAC(x,y) argument1: x argument2: y
When MAC is used, two argument strings must be presented. They will replace x and y when MAC() is expanded. For example:

expanded = MAC(foo bar, yuk yuk)
will be expanded into

expanded = argument1: foo bar argument2: yuk yuk
Macro names cannot be overloaded, and the macro preprocessor cannot handle recursive calls:

Click here to view code image

#define PRINT(a,b) cout<<(a)<<(b)
#define PRINT(a,b,c) cout<<(a)<<(b)<<(c)     /* trouble?: redefines, does not overload */

#define FAC(n) (n>1)?n*FAC(n–1):1            /* trouble: recursive macro */
Macros manipulate character strings and know little about C++ syntax and nothing about C++ types or scope rules. Only the expanded form of a macro is seen by the compiler, so an error in a macro will be reported when the macro is expanded, not when it is defined. This leads to very obscure error messages.

Here are some plausible macros:

#define CASE break;case
#define FOREVER for(;;)
Here are some completely unnecessary macros:

#define PI 3.141593
#define BEGIN {
#define END }
Here are some dangerous macros:

#define SQUARE(a) a*a
#define INCR_xx (xx)++
To see why they are dangerous, try expanding this:

Click here to view code image

int xx = 0;      // global counter

void f(int xx)
{
     int y = SQUARE(xx+2);     // y=xx+2*xx+2; that is, y=xx+(2*xx)+2
     INCR_xx;                  // increments argument xx (not the global xx)
}
If you must use a macro, use the scope resolution operator, ::, when referring to global names (§6.3.4) and enclose occurrences of a macro argument name in parentheses whenever possible. For example:

#define MIN(a,b) (((a)<(b))?(a):(b))
This handles the simpler syntax problems (which are often caught by compilers), but not the problems with side effects. For example:

Click here to view code image

int x = 1;
int y = 10;
int z = MIN(x++,y++);         // x becomes 3; y becomes 11
If you must write macros complicated enough to require comments, it is wise to use / ** / comments because old C preprocessors that do not know about // comments are sometimes used as part of C++ tools. For example:

#define M2(a) something(a)   /* thoughtful comment */
Using macros, you can design your own private language. Even if you prefer this “enhanced language” to plain C++, it will be incomprehensible to most C++ programmers. Furthermore, the preprocessor is a very simple-minded macro processor. When you try to do something nontrivial, you are likely to find it either impossible or unnecessarily hard to do. The auto, constexpr, const, decltype, enum, inline, lambda expressions, namespace, and template mechanisms can be used as better-behaved alternatives to many traditional uses of preprocessor constructs. For example:

Click here to view code image

const int answer = 42;

template<typename T>
inline const T& min(const T& a, const T& b)
{
     return (a<b)?a:b;
}
When writing a macro, it is not unusual to need a new name for something. A string can be created by concatenating two strings using the ## macro operator. For example:

#define NAME2(a,b) a##b

int NAME2(hack,cah)();
will produce

int hackcah();
A single # before a parameter name in a replacement string means a string containing the macro argument. For example:

Click here to view code image

#define printx(x) cout << #x " = " << x << '\n';

int a = 7;
string str = "asdf";

void f()
{
     printx(a);       // cout << "a" " = " << a << '\n';
     printx(str);     // cout << "str" " = " << str << '\n';
}
Writing #x " = " rather than #x << " = " is obscure “clever code” rather than an error. Adjacent string literals are concatenated (§7.3.2).

The directive

#undef X
ensures that no macro called X is defined – whether or not one was before the directive. This affords some protection against undesired macros. However, it is not always easy to know what the effects of X on a piece of code were supposed to be.

The argument list (“replacement list”) of a macro can be empty:

Click here to view code image

#define EMPTY() std::cout<<"empty\n"
EMPTY();      // print "empty\n"
EMPTY;        // error: macro replacement list missing
I have a hard time thinking of uses of an empty macro argument list that are not error-prone or malicious.

Macros can even be variadic. For example:

Click here to view code image

#define err_print(...) fprintf(stderr,"error: %s %d\n", __VA_ARGS__)
err_print("The answer",54);
The ellipsis (...) means that __VA_ARGS__ represents the arguments actually passed as a string, so the output is:

error: The answer 54
12.6.1. Conditional Compilation
One use of macros is almost impossible to avoid. The directive

#ifdef IDENTIFIER
does nothing if IDENTIFIER is defined, but if it is not, the directive causes all input to be ignored until a #endif directive is seen. For example:

int f(int a
#ifdef arg_two
,int b
#endif
);
Unless a macro called arg_two has been #defined, this produces:

int f(int a
);
This example confuses tools that assume sane behavior from the programmer.

Most uses of #ifdef are less bizarre, and when used with restraint, #ifdef and its complement #ifndef do little harm. See also §15.3.3.

Names of the macros used to control #ifdef should be chosen carefully so that they don’t clash with ordinary identifiers. For example:

struct Call_info {
     Node* arg_one;
     Node* arg_two;
     // ...
};
This innocent-looking source text will cause some confusion should someone write:

#define arg_two x
Unfortunately, common and unavoidable headers contain many dangerous and unnecessary macros.

12.6.2. Predefined Macros
A few macros are predefined by the compiler (§iso.16.8, §iso.8.4.1):

• __cplusplus: defined in a C++ compilation (and not in a C compilation). Its value is 201103L in a C++11 program; previous C++ standards have lower values.

• __DATE__: date in “Mmm dd yyyy” format, e.g. Aug 18 2013.

• __TIME__: time in “hh:mm:ss” format.

• __FILE__: name of current source file.

• __LINE__: source line number within the current source file.

• __func__: an implementation-defined C-style string naming the current function (not a macro, but a const variable).

• __STDC_HOSTED__: 1 if the implementation is hosted (§6.1.1); otherwise 0.

In addition, a few macros are conditionally defined by the implementation:

• __STDC__: defined in a C compilation (and not in a C++ compilation)

• __STDC_MB_MIGHT_NEQ_WC__: 1 if, in the encoding for wchar_t, a member of the basic character set (§6.1) might have a code value that differs from its value as an ordinary character literal

• __STDCPP_STRICT_POINTER_SAFETY__: 1 if the implementation has strict pointer safety (§34.5); otherwise undefined.

• __STDCPP_THREADS__: 1 if a program can have more than one thread of execution; otherwise undefined.

For example:

cout << __func__ << "() in file " << __FILE__ << " on line " << __LINE__ << "\n";
In addition, most C++ implementations allow a user to define arbitrary macros on the command line or in some other form of compile-time environment. For example, NDEBUG is defined unless the compilation is done in (some implementation-specific) “debug mode” and is used by the assert() macro (§13.4). This can be useful, but it does imply that you can’t be sure of the meaning of a program just by reading its source text.

12.6.3. Pragmas
Implementations often provide facilities that differ from or go beyond what the standard offers. Obviously, the standard cannot specify how such facilities are provided, but one standard syntax is a line of tokens prefixed with the preprocessor directive #pragma. For example:

#pragma foo bar 666 foobar
If possible, #pragmas are best avoided.

12.7. Advice
[1] “Package” meaningful operations as carefully named functions; §12.1.

[2] A function should perform a single logical operation; §12.1.

[3] Keep functions short; §12.1.

[4] Don’t return pointers or references to local variables; §12.1.4.

[5] If a function may have to be evaluated at compile time, declare it constexpr; §12.1.6.

[6] If a function cannot return, mark it [[noreturn]]; §12.1.7.

[7] Use pass-by-value for small objects; §12.2.1.

[8] Use pass-by-const-reference to pass large values that you don’t need to modify; §12.2.1.

[9] Return a result as a return value rather than modifying an object through an argument; §12.2.1.

[10] Use rvalue references to implement move and forwarding; §12.2.1.

[11] Pass a pointer if “no object” is a valid alternative (and represent “no object” by nullptr); §12.2.1.

[12] Use pass-by-non-const-reference only if you have to; §12.2.1.

[13] Use const extensively and consistently; §12.2.1.

[14] Assume that a char* or a const char* argument points to a C-style string; §12.2.2.

[15] Avoid passing arrays as pointers; §12.2.2.

[16] Pass a homogeneous list of unknown length as an initializer_list<T> (or as some other container); §12.2.3.

[17] Avoid unspecified numbers of arguments (...); §12.2.4.

[18] Use overloading when functions perform conceptually the same task on different types; §12.3.

[19] When overloading on integers, provide functions to eliminate common ambiguities; §12.3.5.

[20] Specify preconditions and postconditions for your functions; §12.4.

[21] Prefer function objects (including lambdas) and virtual functions to pointers to functions; §12.5.

[22] Avoid macros; §12.6.

[23] If you must use macros, use ugly names with lots of capital letters; §12.6.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


12. Functions
13. Exception Handling
14. Namespaces
47h 26m remaining
13. Exception Handling
Don’t interrupt me while I’m interrupting.

– Winston S. Churchill

• Error Handling

Exceptions; Traditional Error Handling; Muddling Through; Alternative Views of Exceptions; When You Can’t Use Exceptions; Hierarchical Error Handling; Exceptions and Efficiency

• Exception Guarantees

• Resource Management

Finally

• Enforcing Invariants

• Throwing and Catching Exceptions

Throwing Exceptions; Catching Exceptions; Exceptions and Threads

• A vector Implementation

A Simple vector; Representing Memory Explicitly; Assignment; Changing Size

• Advice

13.1. Error Handling
This chapter presents error handling using exceptions. For effective error handling, the language mechanisms must be used based on a strategy. Consequently, this chapter presents the exception-safety guarantees that are central to recovery from run-time errors and the Resource Acquisition Is Initialization (RAII) technique for resource management using constructors and destructors. Both the exception-safety guarantees and RAII depend on the specification of invariants, so mechanisms for enforcement of assertions are presented.

The language facilities and techniques presented here address problems related to the handling of errors in software; the handling of asynchronous events is a different topic.

The discussion of errors focuses on errors that cannot be handled locally (within a single small function), so that they require separation of error-handling activities into different parts of a program. Such parts of a program are often separately developed. Consequently, I often refer to a part of a program that is invoked to perform a task as “a library.” A library is just ordinary code, but in the context of a discussion of error handling it is worth remembering that a library designer often cannot even know what kind of programs the library will become part of:

• The author of a library can detect a run-time error but does not in general have any idea what to do about it.

• The user of a library may know how to cope with a run-time error but cannot easily detect it (or else it would have been handled in the user’s code and not left for the library to find).

The discussion of exceptions focuses on problems that need to be handled in long-running systems, systems with stringent reliability requirements, and libraries. Different kinds of programs have different requirements, and the amount of care and effort we expend should reflect that. For example, I would not apply every technique recommended here to a two-page program written just for myself. However, many of the techniques presented here simplify code, so I would use those.

13.1.1. Exceptions
The notion of an exception is provided to help get information from the point where an error is detected to a point where it can be handled. A function that cannot cope with a problem throws an exception, hoping that its (direct or indirect) caller can handle the problem. A function that wants to handle a kind of problem indicates that by catching the corresponding exception (§2.4.3.1):

• A calling component indicates the kinds of failures that it is willing to handle by specifying those exceptions in a catch-clause of a try-block.

• A called component that cannot complete its assigned task reports its failure to do so by throwing an exception using a throw-expression.

Consider a simplified and stylized example:

Click here to view code image

void taskmaster()
{
     try {
          auto result = do_task();
           // use result
     }
     catch (Some_error) {
          // failure to do_task: handle problem
     }
}

int do_task()
{
      //...
     if (/* could perform the task */)
            return result;
     else
           throw Some_error{};
}
The taskmaster() asks do_task() to do a job. If do_task() can do that job and return a correct result, all is fine. Otherwise, do_task() must report a failure by throwing some exception. The taskmaster() is prepared to handle a Some_error, but some other kind of exception may be thrown. For example, do_task() may call other functions to do a lot of subtasks, and one of those may throw because it can’t do its assigned subtask. An exception different from Some_error indicates a failure of taskmaster() to do its job and must be handled by whatever code invoked taskmaster().

A called function cannot just return with an indication that an error happened. If the program is to continue working (and not just print an error message and terminate), the returning function must leave the program in a good state and not leak any resources. The exception-handling mechanism is integrated with the constructor/destructor mechanisms and the concurrency mechanisms to help ensure that (§5.2). The exception-handling mechanism:

• Is an alternative to traditional techniques when they are insufficient, inelegant, or error-prone

• Is complete; it can be used to handle all errors detected by ordinary code

• Allows the programmer to explicitly separate error-handling code from “ordinary code,” thus making the program more readable and more amenable to tools

• Supports a more regular style of error handling, thus simplifying cooperation between separately written program fragments

An exception is an object thrown to represent the occurrence of an error. It can be of any type that can be copied, but it is strongly recommended to use only user-defined types specifically defined for that purpose. That way, we minimize the chances of two unrelated libraries using the same value, say 17, to represent different errors, thereby throwing our recovery code into chaos.

An exception is caught by code that has expressed interest in handling a particular type of exception (a catch-clause). Thus, the simplest way of defining an exception is to define a class specifically for a kind of error and throw that. For example:

Click here to view code image

struct Range_error {};

void f(int n)
{
     if (n<0 || max<n) throw Range_error {};
      //...
}
If that gets tedious, the standard library defines a small hierarchy of exception classes (§13.5.2).

An exception can carry information about the error it represents. Its type represents the kind of error, and whatever data it holds represents the particular occurrence of that error. For example, the standard-library exceptions contain a string value, which can be used to transmit information such as the location of the throw (§13.5.2).

13.1.2. Traditional Error Handling
Consider the alternatives to exceptions for a function detecting a problem that cannot be handled locally (e.g., an out-of-range access) so that an error must be reported to a caller. Each conventional approach has problems, and none are general:

• Terminate the program. This is a pretty drastic approach. For example:

if (something_wrong) exit(1);
For most errors, we can and must do better. For example, in most situations we should at least write out a decent error message or log the error before terminating. In particular, a library that doesn’t know about the purpose and general strategy of the program in which it is embedded cannot simply exit() or abort(). A library that unconditionally terminates cannot be used in a program that cannot afford to crash.

• Return an error value. This is not always feasible because there is often no acceptable “error value.” For example:

int get_int();    // get next integer from input
For this input function, every int is a possible result, so there can be no integer value representing an input failure. At a minimum, we would have to modify get_int() to return a pair of values. Even where this approach is feasible, it is often inconvenient because every call must be checked for the error value. This can easily double the size of a program (§13.1.7). Also, callers often ignore the possibility of errors or simply forget to test a return value. Consequently, this approach is rarely used systematically enough to detect all errors. For example, printf() (§43.3) returns a negative value if an output or encoding error occurred, but programmers essentially never test for that. Finally, some operations simply do not have return values; a constructor is the obvious example.

• Return a legal value and leave the program in an “error state.” This has the problem that the calling function may not notice that the program has been put in an error state. For example, many standard C library functions set the nonlocal variable errno to indicate an error (§43.4, §40.3):

double d = sqrt(–1.0);
Here, the value of d is meaningless and errno is set to indicate that –1.0 isn’t an acceptable argument for a floating-point square root function. However, programs typically fail to set and test errno and similar nonlocal state consistently enough to avoid consequential errors caused by values returned from failed calls. Furthermore, the use of nonlocal variables for recording error conditions doesn’t work well in the presence of concurrency.

• Call an error-handler function. For example:

if (something_wrong) something_handler();   // and possibly continue here
This must be some other approach in disguise because the problem immediately becomes “What does the error-handling function do?” Unless the error-handling function can completely resolve the problem, the error-handling function must in turn either terminate the program, return with some indication that an error had occurred, set an error state, or throw an exception. Also, if the error-handling function can handle the problem without bothering the ultimate caller, why do we consider it an error?

Traditionally, an unsystematic combination of these approaches co-exists in a program.

13.1.3. Muddling Through
One aspect of the exception-handling scheme that will appear novel to some programmers is that the ultimate response to an unhandled error (an uncaught exception) is to terminate the program. The traditional response has been to muddle through and hope for the best. Thus, exception handling makes programs more “brittle” in the sense that more care and effort must be taken to get a program to run acceptably. This is preferable, though, to getting wrong results later in the development process – or after the development process is considered complete and the program is handed over to innocent users. Where termination is unacceptable, we can catch all exceptions (§13.5.2.2). Thus, an exception terminates a program only if a programmer allows it to terminate. Typically, this is preferable to the unconditional termination that happens when a traditional incomplete recovery leads to a catastrophic error. Where termination is an acceptable response, an uncaught exception will achieve that because it turns into a call of terminate() (§13.5.2.5). Also, a noexcept specifier (§13.5.1.1) can make that desire explicit.

Sometimes, people try to alleviate the unattractive aspects of “muddling through” by writing out error messages, putting up dialog boxes asking the user for help, etc. Such approaches are primarily useful in debugging situations in which the user is a programmer familiar with the structure of the program. In the hands of nondevelopers, a library that asks the (possibly absent) user/operator for help is unacceptable. A good library doesn’t “blabber” in this way. If a user has to be informed, an exception handler can compose a suitable message (e.g., in Finnish for Finnish users or in XML for an error-logging system). Exceptions provide a way for code that detects a problem from which it cannot recover to pass the problem on to a part of the system that might be able to recover. Only a part of the system that has some idea of the context in which the program runs has any chance of composing a meaningful error message.

Please recognize that error handling will remain a difficult task and that the exception-handling mechanism – although more formalized than the techniques it replaces – is still relatively unstructured compared with language features involving only local control flow. The C++ exception-handling mechanism provides the programmer with a way of handling errors where they are most naturally handled, given the structure of a system. Exceptions make the complexity of error handling visible. However, exceptions are not the cause of that complexity. Be careful not to blame the messenger for bad news.

13.1.4. Alternative Views of Exceptions
“Exception” is one of those words that means different things to different people. The C++ exception-handling mechanism is designed to support handling of errors that cannot be handled locally (“exceptional conditions”). In particular, it is intended to support error handling in programs composed of independently developed components. Given that there is nothing particularly exceptional about a part of a program being unable to perform its given task, the word “exception” may be considered a bit misleading. Can an event that happens most times a program is run be considered exceptional? Can an event that is planned for and handled be considered an error? The answer to both questions is “yes.” “Exceptional” does not mean “almost never happens” or “disastrous.”

13.1.4.1. Asynchronous Events
The mechanism is designed to handle only synchronous exceptions, such as array range checks and I/O errors. Asynchronous events, such as keyboard interrupts and power failures, are not necessarily exceptional and are not handled directly by this mechanism. Asynchronous events require mechanisms fundamentally different from exceptions (as defined here) to handle them cleanly and efficiently. Many systems offer mechanisms, such as signals, to deal with asynchrony, but because these tend to be system-dependent, they are not described here.

13.1.4.2. Exceptions That Are Not Errors
Think of an exception as meaning “some part of the system couldn’t do what it was asked to do” (§13.1.1, §13.2).

Exception throws should be infrequent compared to function calls or the structure of the system has been obscured. However, we should expect most large programs to throw and catch at least some exceptions in the course of a normal and successful run.

If an exception is expected and caught so that it has no bad effects on the behavior of the program, then how can it be an error? Only because the programmer thinks of it as an error and of the exception-handling mechanisms as tools for handling errors. Alternatively, one might think of the exception-handling mechanisms as simply another control structure, an alternative way of returning a value to a caller. Consider a binary tree search function:

Click here to view code image

void fnd(Tree* p, const string& s)
{
     if (s == p–>str) throw p;        // found s
     if (p–>left) fnd(p–>left,s);
     if (p–>right) fnd(p–>right,s);
}

Tree* find(Tree* p, const string& s)
{
     try {
          fnd(p,s);
     }
     catch (Tree* q) {     // q->str==s
          return q;
     }
     return 0;
}
This actually has some charm, but it should be avoided because it is likely to cause confusion and inefficiencies. When at all possible, stick to the “exception handling is error handling” view. When this is done, code is clearly separated into two categories: ordinary code and error-handling code. This makes code more comprehensible. Furthermore, the implementations of the exception mechanisms are optimized based on the assumption that this simple model underlies the use of exceptions.

Error handling is inherently difficult. Anything that helps preserve a clear model of what is an error and how it is handled should be treasured.

13.1.5. When You Can’t Use Exceptions
Use of exceptions is the only fully general and systematic way of dealing with errors in a C++ program. However, we must reluctantly conclude that there are programs that for practical and historical reasons cannot use exceptions. For example:

• A time-critical component of an embedded system where an operation must be guaranteed to complete in a specific maximum time. In the absence of tools that can accurately estimate the maximum time for an exception to propagate from a throw to a catch, alternative error-handling methods must be used.

• A large old program in which resource management is an ad hoc mess (e.g., free store is unsystematically “managed” using “naked” pointers, news, and deletes), rather than relying on some systematic scheme, such as resource handles (e.g., string and vector; §4.2, §4.4).

In such cases, we are thrown back onto “traditional” (pre-exception) techniques. Because such programs arise in a great variety of historical contexts and in response to a variety of constraints, I cannot give a general recommendation for how to handle them. However, I can point to two popular techniques:

• To mimic RAII, give every class with a constructor an invalid() operation that returns some error_code. A useful convention is for error_code==0 to represent success. If the constructor fails to establish the class invariant, it ensures that no resource is leaked and invalid() returns a nonzero error_code. This solves the problem of how to get an error condition out of a constructor. A user can then systematically test invalid() after each construction of an object and engage in suitable error handling in case of failure. For example:

void f(int n)
{
     my_vector<int> x(n);
     if (x.invalid()) {
            //... deal with error ...
     }
      //...
}
• To mimic a function either returning a value or throwing an exception, a function can return a pair<Value,Error_code> (§5.4.3). A user can then systematically test the error_code after each function call and engage in suitable error handling in case of failure. For example:

Click here to view code image

void g(int n)
{
     auto v = make_vector(n);  // return a pair
     if (v.second) {
             //... deal with error ...
     }
     auto val = v.first;
      //...
}
Variations of this scheme have been reasonably successful, but they are clumsy compared to using exceptions in a systematic manner.

13.1.6. Hierarchical Error Handling
The purpose of the exception-handling mechanisms is to provide a means for one part of a program to inform another part that a requested task could not be performed (that an “exceptional circumstance” has been detected). The assumption is that the two parts of the program are written independently and that the part of the program that handles the exception often can do something sensible about the error.

To use handlers effectively in a program, we need an overall strategy. That is, the various parts of the program must agree on how exceptions are used and where errors are dealt with. The exception-handling mechanisms are inherently nonlocal, so adherence to an overall strategy is essential. This implies that the error-handling strategy is best considered in the earliest phases of a design. It also implies that the strategy must be simple (relative to the complexity of the total program) and explicit. Something complicated would not be consistently adhered to in an area as inherently tricky as error recovery.

Successful fault-tolerant systems are multilevel. Each level copes with as many errors as it can without getting too contorted and leaves the rest to higher levels. Exceptions support that view. Furthermore, terminate() supports this view by providing an escape if the exception-handling mechanism itself is corrupted or if it has been incompletely used, thus leaving exceptions uncaught. Similarly, noexcept provides a simple escape for errors where trying to recover seems infeasible.

Not every function should be a firewall. That is, not every function can test its preconditions well enough to ensure that no errors could possibly stop it from meeting its postcondition. The reasons that this will not work vary from program to program and from programmer to programmer. However, for larger programs:

[1] The amount of work needed to ensure this notion of “reliability” is too great to be done consistently.

[2] The overhead in time and space is too great for the system to run acceptably (there will be a tendency to check for the same errors, such as invalid arguments, over and over again).

[3] Functions written in other languages won’t obey the rules.

[4] This purely local notion of “reliability” leads to complexities that actually become a burden to overall system reliability.

However, separating the program into distinct subsystems that either complete successfully or fail in well-defined ways is essential, feasible, and economical. Thus, major libraries, subsystems, and key interface functions should be designed in this way. Furthermore, in most systems, it is feasible to design every function to ensure that it always either completes successfully or fails in a well-defined manner.

Usually, we don’t have the luxury of designing all of the code of a system from scratch. Therefore, to impose a general error-handling strategy on all parts of a program, we must take into account program fragments implemented using strategies different from ours. To do this we must address a variety of concerns relating to the way a program fragment manages resources and the state in which it leaves the system after an error. The aim is to have the program fragment appear to follow the general error-handling strategy even if it internally follows a different strategy.

Occasionally, it is necessary to convert from one style of error reporting to another. For example, we might check errno and possibly throw an exception after a call to a C library or, conversely, catch an exception and set errno before returning to a C program from a C++ library:


Click here to view code image

void callC()     // Call a C function from C++; convert errno to a throw
{
     errno = 0;
     c_function();
     if (errno) {
            //... local cleanup, if possible and necessary ...
           throw C_blewit(errno);
     }
}

extern "C" void call_from_C() noexcept        // Call a C++ function from C; convert a throw to errno
{
     try {
          c_plus_plus_function();
     }
     catch (...) {
           //... local cleanup, if possible and necessary ...
          errno = E_CPLPLFCTBLEWIT;
     }
}
In such cases, it is important to be systematic enough to ensure that the conversion of error-reporting styles is complete. Unfortunately, such conversions are often most desirable in “messy code” without a clear error-handling strategy and therefore difficult to be systematic about.

Error handling should be – as far as possible – hierarchical. If a function detects a run-time error, it should not ask its caller for help with recovery or resource acquisition. Such requests set up cycles in the system dependencies. That in turn makes the program hard to understand and introduces the possibility of infinite loops in the error-handling and recovery code.

13.1.7. Exceptions and Efficiency
In principle, exception handling can be implemented so that there is no run-time overhead when no exception is thrown. In addition, this can be done so that throwing an exception isn’t all that expensive compared to calling a function. Doing so without adding significant memory overhead while maintaining compatibility with C calling sequences, debugger conventions, etc., is possible, but hard. However, please remember that the alternatives to exceptions are not free either. It is not unusual to find traditional systems in which half of the code is devoted to error handling.

Consider a simple function f() that appears to have nothing to do with exception handling:

void f()
{
     string buf;
     cin>>buf;
      //...
     g(1);
     h(buf);
}
However, g() or h() may throw an exception, so f() must contain code ensuring that buf is destroyed correctly in case of an exception.

Had g() not thrown an exception, it would have had to report its error some other way. Consequently, the comparable code using ordinary code to handle errors instead of exceptions isn’t the plain code above, but something like:

bool g(int);
bool h(const char*);
char* read_long_string();

bool f()
{
     char* s = read_long_string();
      //...
     if (g(1)) {
           if (h(s)) {
                 free(s);
                 return true;
           }
           else {
                 free(s);
                 return false;
           }
     }
     else {
           free(s);
           return false;
     }
}
Using a local buffer for s would simplify the code by eliminating the calls to free(), but then we’d have range-checking code instead. Complexity tends to move around rather than just disappear.

People don’t usually handle errors this systematically, though, and it is not always critical to do so. However, when careful and systematic handling of errors is necessary, such housekeeping is best left to a computer, that is, to the exception-handling mechanisms.

The noexcept specifier (§13.5.1.1) can be most helpful in improving generated code. Consider:

void g(int) noexcept;
void h(const string&) noexcept;
Now, the code generated for f() can possibly be improved.

No traditional C function throws an exception, so most C functions can be declared noexcept. In particular, a standard-library implementer knows that only a few standard C library functions (such as atexit() and qsort()) can throw, and can take advantage of that fact to generate better code.

Before declaring a “C function” noexcept, take a minute to consider if it could possibly throw an exception. For example, it might have been converted to use the C++ operator new, which can throw bad_alloc, or it might call a C++ library that throws an exception.

As ever, discussions about efficiency are meaningless in the absence of measurements.

13.2. Exception Guarantees
To recover from an error – that is, to catch an exception and continue executing a program – we need to know what can be assumed about the state of the program before and after the attempted recovery action. Only then can recovery be meaningful. Therefore, we call an operation exception-safe if that operation leaves the program in a valid state when the operation is terminated by throwing an exception. However, for that to be meaningful and useful, we have to be precise about what we mean by “valid state.” For practical design using exceptions, we must also break down the overly general “exception-safe” notion into a few specific guarantees.

When reasoning about objects, we assume that a class has a class invariant (§2.4.3.2, §17.2.1). We assume that this invariant is established by its constructor and maintained by all functions with access to the object’s representation until the object is destroyed. So, by valid state we mean that a constructor has completed and the destructor has not yet been entered. For data that isn’t easily viewed as an object, we must reason similarly. That is, if two pieces of nonlocal data are assumed to have a specific relationship, we must consider that an invariant and our recovery action must preserve it. For example:

Click here to view code image

namespace Points {      //(vx[i],vy[i]) is a point for all i
   vector<int> vx;
   vector<int> vy;
};
Here it is assumed that vx.size()==vy.size() is (always) true. However, that was only stated in a comment, and compilers do not read comments. Such implicit invariants can be very hard to discover and maintain.

Before a throw, a function must place all constructed objects in valid states. However, such a valid state may be one that doesn’t suit the caller. For example, a string may be left as the empty string or a container may be left unsorted. Thus, for complete recovery, an error handler may have to produce values that are more appropriate/desirable for the application than the (valid) ones existing at the entry to a catch-clause.

The C++ standard library provides a generally useful conceptual framework for design for exception-safe program components. The library provides one of the following guarantees for every library operation:

• The basic guarantee for all operations: The basic invariants of all objects are maintained, and no resources, such as memory, are leaked. In particular, the basic invariants of every built-in and standard-library type guarantee that you can destroy an object or assign to it after every standard-library operation (§iso.17.6.3.1).

• The strong guarantee for key operations: in addition to providing the basic guarantee, either the operation succeeds, or it has no effect. This guarantee is provided for key operations, such as push_back(), single-element insert() on a list, and uninitialized_copy().

• The nothrow guarantee for some operations: in addition to providing the basic guarantee, some operations are guaranteed not to throw an exception. This guarantee is provided for a few simple operations, such as swap() of two containers and pop_back().

Both the basic guarantee and the strong guarantee are provided on the condition that

• user-supplied operations (such as assignments and swap() functions) do not leave container elements in invalid states,

• user-supplied operations do not leak resources, and

• destructors do not throw exceptions (§iso.17.6.5.12).

Violating a standard-library requirement, such as having a destructor exit by throwing an exception, is logically equivalent to violating a fundamental language rule, such as dereferencing a null pointer. The practical effects are also equivalent and often disastrous.

Both the basic guarantee and the strong guarantee require the absence of resource leaks. This is necessary for every system that cannot afford resource leaks. In particular, an operation that throws an exception must not only leave its operands in well-defined states but must also ensure that every resource that it acquired is (eventually) released. For example, at the point where an exception is thrown, all memory allocated must be either deallocated or owned by some object, which in turn must ensure that the memory is properly deallocated. For example:

Click here to view code image

void f(int i)
{
     int* p = new int[10];
      //...
     if (i<0) {
            delete[] p;     // delete before the throw or leak
            throw Bad();
     }
      //...
}
Remember that memory isn’t the only kind of resource that can leak. I consider anything that has to be acquired from another part of the system and (explicitly or implicitly) given back to be a resource. Files, locks, network connections, and threads are examples of system resources. A function may have to release those or hand them over to some resource handler before throwing an exception.

The C++ language rules for partial construction and destruction ensure that exceptions thrown while constructing subobjects and members will be handled correctly without special attention from standard-library code (§17.2.3). This rule is an essential underpinning for all techniques dealing with exceptions.

In general, we must assume that every function that can throw an exception will throw one. This implies that we must structure our code so that we don’t get lost in a rat’s nest of complicated control structures and brittle data structures. When analyzing code for potential errors, simple, highly structured, “stylized” code is the ideal; §13.6 includes a realistic example of such code.

13.3. Resource Management
When a function acquires a resource – that is, it opens a file, allocates some memory from the free store, acquires a mutex, etc. – it is often essential for the future running of the system that the resource be properly released. Often that “proper release” is achieved by having the function that acquired it release it before returning to its caller. For example:


void use_file(const char* fn)  // naive code
{
     FILE* f = fopen(fn,"r");

      //... use f ...

     fclose(f);
}
This looks plausible until you realize that if something goes wrong after the call of fopen() and before the call of fclose(), an exception may cause use_file() to be exited without fclose() being called. Exactly the same problem can occur in languages that do not support exception handling. For example, the standard C library function longjmp() can cause the same problem. Even an ordinary return-statement could exit use_file without closing f.

A first attempt to make use_file() fault-tolerant looks like this:

Click here to view code image

void use_file(const char* fn)   // clumsy code
{
     FILE* f = fopen(fn,"r");
     try {
           //... use f ...
     }
     catch (...) {         // catch every possible exception
          fclose(f);
          throw;
     }
     fclose(f);
}
The code using the file is enclosed in a try-block that catches every exception, closes the file, and rethrows the exception.

The problem with this solution is that it is verbose, tedious, and potentially expensive. Worse still, such code becomes significantly more complex when several resources must be acquired and released. Fortunately, there is a more elegant solution. The general form of the problem looks like this:

void acquire()
{
      // acquire resource 1
      //...
      // acquire resource n

      //... use resources ...

      // release resource n
      //...
      // release resource 1
}
It is typically important that resources are released in the reverse order of their acquisition. This strongly resembles the behavior of local objects created by constructors and destroyed by destructors. Thus, we can handle such resource acquisition and release problems using objects of classes with constructors and destructors. For example, we can define a class File_ptr that acts like a FILE*:

Click here to view code image

class File_ptr {
     FILE* p;
public:
     File_ptr(const char* n, const char* a)    // open file n
          : p{fopen(n,a)}
     {
          if (p==nullptr) throw runtime_error{"File_ptr: Can't open file"};
     }

     File_ptr(const string& n, const char* a)  // open file n
          :File_ptr{n.c_str(),a}
     { }

     explicit File_ptr(FILE* pp)               // assume ownership of pp
          :p{pp}
     {
          if (p==nullptr) throw runtime_error("File_ptr: nullptr"};
     }

      //... suitable move and copy operations ...

     ~File_ptr() { fclose(p); }

     operator FILE*() { return p; }
};
We can construct a File_ptr given either a FILE* or the arguments required for fopen(). In either case, a File_ptr will be destroyed at the end of its scope and its destructor will close the file. File_ptr throws an exception if it cannot open a file because otherwise every operation on the file handle would have to test for nullptr. Our function now shrinks to this minimum:

void use_file(const char* fn)
{
     File_ptr f(fn,"r");
      //... use f ...
}
The destructor will be called independently of whether the function is exited normally or exited because an exception is thrown. That is, the exception-handling mechanisms enable us to remove the error-handling code from the main algorithm. The resulting code is simpler and less error-prone than its traditional counterpart.

This technique for managing resources using local objects is usually referred to as “Resource Acquisition Is Initialization” (RAII; §5.2). This is a general technique that relies on the properties of constructors and destructors and their interaction with exception handling.

It is often suggested that writing a “handle class” (a RAII class) is tedious so that providing a nicer syntax for the catch(...) action would provide a better solution. The problem with that approach is that you need to remember to “catch and correct” the problem wherever a resource is acquired in an undisciplined way (typically dozens or hundreds of places in a large program), whereas the handle class needs to be written only once.

An object is not considered constructed until its constructor has completed. Then and only then will stack unwinding (§13.5.1) call the destructor for the object. An object composed of subobjects is constructed to the extent that its subobjects have been constructed. An array is constructed to the extent that its elements have been constructed (and only fully constructed elements are destroyed during unwinding).

A constructor tries to ensure that its object is completely and correctly constructed. When that cannot be achieved, a well-written constructor restores – as far as possible – the state of the system to what it was before creation. Ideally, a well-designed constructor always achieves one of these alternatives and doesn’t leave its object in some “half-constructed” state. This can be simply achieved by applying the RAII technique to the members.

Consider a class X for which a constructor needs to acquire two resources: a file x and a mutex y (§5.3.4). This acquisition might fail and throw an exception. Class X’s constructor must never complete having acquired the file but not the mutex (or the mutex and not the file, or neither). Furthermore, this should be achieved without imposing a burden of complexity on the programmer. We use objects of two classes, File_ptr and std::unique_lock (§5.3.4), to represent the acquired resources. The acquisition of a resource is represented by the initialization of the local object that represents the resource:

Click here to view code image

class Locked_file_handle {
     unique_lock<mutex> lck;
     File_ptr p;
public:
     X(const char* file, mutex& m)
         lck{m}               // acquire "m"
         : p{file,"rw"},      // acquire "file"
     {}
      //...
};
Now, as in the local object case, the implementation takes care of all of the bookkeeping. The user doesn’t have to keep track at all. For example, if an exception occurs after p has been constructed but before lck has been, then the destructor for p but not for lck will be invoked.

This implies that where this simple model for acquisition of resources is adhered to, the author of the constructor need not write explicit exception-handling code.

The most common resource is memory, and string, vector, and the other standard containers use RAII to implicitly manage acquisition and release. Compared to ad hoc memory management using new (and possibly also delete), this saves lots of work and avoids lots of errors.

When a pointer to an object, rather than a local object, is needed, consider using the standard-library types unique_ptr and shared_ptr (§5.2.1, §34.3) to avoid leaks.

13.3.1. Finally
The discipline required to represent a resource as an object of a class with a destructor has bothered some. Again and again, people have invented “finally” language constructs for writing arbitrary code to clean up after an exception. Such techniques are generally inferior to RAII because they are ad hoc, but if you really want ad hoc, RAII can supply that also. First, we define a class that will execute an arbitrary action from its destructor.

template<typename F>
struct Final_action {
      Final_action(F f): clean{f} {}
      ~Final_action() { clean(); }
      F clean;
      Final_action(const Final_action&) =delete;       // not meant to be copied (§3.3.4, §17.6.4)
      Final_action& operator=(const Final_action&) =delete;
};
The “finally action” is provided as an argument to the constructor.

Next, we define a function that conveniently deduces the type of an action:

template<typename F>
Final_action<F> finally(F f)
{
     return Final_action<F>(f);
}
Finally, we can test finally():

Click here to view code image

void test()
      // handle undisciplined resource acquisition
      // demonstrate that arbitrary actions are possible
{
     int* p = new int{7};                               // probably should use a unique_ptr (§5.2)
     int* buf = (int*)malloc(100*sizeof(int));          // C-style allocation

     auto act1 = finally([&]{   delete p;
                                free(buf);              // C-style deallocation
                                cout<< "Goodby, Cruel world!\n";
                           }
                     );

     int var = 0;
     cout << "var = " << var << '\n';

      // nested block:
     {
           var = 1;
           auto act2 = finally([&]{ cout<< "finally!\n"; var=7; });
           cout << "var = " << var << '\n';
     }  // act2 is invoked here

     cout << "var = " << var << '\n';
} // act1 is invoked here
This produced:

var = 0
var = 1
finally!
var = 7
Goodby, Cruel world!
In addition, the memory allocated and pointed to by p and buf is appropriately deleted and free()d.

It is generally a good idea to place a guard close to the definition of whatever it is guarding. That way, we can at a glance see what is considered a resource (even if ad hoc) and what is to be done at the end of its scope. The connection between finally() actions and the resources they manipulate is still ad hoc and implicit compared to the use of RAII for resource handles, but using finally() is far better than scattering cleanup code around in a block.

Basically, finally() does for a block what the increment part of a for-statement does for the for-statement (§9.5.2): it specifies the final action at the top of a block where it is easy to be seen and where it logically belongs from a specification point of view. It says what is to be done upon exit from a scope, saving the programmer from trying to write code at each of the potentially many places from which the thread of control might exit the scope.

13.4. Enforcing Invariants
When a precondition for a function (§12.4) isn’t met, the function cannot correctly perform its task. Similarly, when a constructor cannot establish its class invariant (§2.4.3.2, §17.2.1), the object is not usable. In those cases, I typically throw exceptions. However, there are programs for which throwing an exception is not an option (§13.1.5), and there are people with different views of how to deal with the failure of a precondition (and similar conditions):

• Just don’t do that: It is the caller’s job to meet preconditions, and if the caller doesn’t do that, let bad results occur – eventually those errors will be eliminated from the system through improved design, debugging, and testing.

• Terminate the program: Violating a precondition is a serious design error, and the program must not proceed in the presence of such errors. Hopefully, the total system can recover from the failure of one component (that program) – eventually such failures may be eliminated from the system through improved design, debugging, and testing.

Why would anyone choose one of these alternatives? The first approach often relates to the need for performance: systematically checking preconditions can lead to repeated tests of logically unnecessary conditions (for example, if a caller has correctly validated data, millions of tests in thousands of called functions may be logically redundant). The cost in performance can be significant. It may be worthwhile to suffer repeated crashes during testing to gain that performance. Obviously, this assumes that you eventually get all critical precondition violations out of the system. For some systems, typically systems completely under the control of a single organization, that can be a realistic aim.

The second approach tends to be used in systems where complete and timely recovery from a precondition failure is considered infeasible. That is, making sure that recovery is complete imposes unacceptable complexity on the system design and implementation. On the other hand, termination of a program is considered acceptable. For example, it is not unreasonable to consider program termination acceptable if it is easy to rerun the program with inputs and parameters that make repeated failure unlikely. Some distributed systems are like this (as long as the program that terminates is only a part of the complete system), and so are many of the small programs we write for our own consumption.

Realistically, many systems use a mix of exceptions and these two alternative approaches. All three share a common view that preconditions should be defined and obeyed; what differs is how enforcement is done and whether recovery is considered feasible. Program structure can be radically different depending on whether (localized) recovery is an aim. In most systems, some exceptions are thrown without real expectation of recovery. For example, I often throw an exception to ensure some error logging or to produce a decent error message before terminating or re-initializing a process (e.g., from a catch(...) in main()).

A variety of techniques are used to express checks of desired conditions and invariants. When we want to be neutral about the logical reason for the check, we typically use the word assertion, often abbreviated to an assert. An assertion is simply a logical expression that is assumed to be true. However, for an assertion to be more than a comment, we need a way of expressing what happens if it is false. Looking at a variety of systems, I see a variety of needs when it comes to expressing assertions:

• We need to choose between compile-time asserts (evaluated by the compiler) and run-time asserts (evaluated at run time).

• For run-time asserts we need a choice of throw, terminate, or ignore.

• No code should be generated unless some logical condition is true. For example, some runtime asserts should not be evaluated unless the logical condition is true. Usually, the logical condition is something like a debug flag, a level of checking, or a mask to select among asserts to enforce.

• Asserts should not be verbose or complicated to write (because they can be very common).

Not every system has a need for or supports every alternative.

The standard offers two simple mechanisms:

• In <cassert>, the standard library provides the assert(A) macro, which checks its assertion, A, at run time if and only if the macro NDEBUG (“not debugging”) is not defined (§12.6.2). If the assertion fails, the compiler writes out an error message containing the (failed) assertion, the source file name, and the source file line number and terminates the program.

• The language provides static_assert(A,message), which unconditionally checks its assertion, A, at compile time (§2.4.3.3). If the assertion fails, the compiler writes out the message and the compilation fails.

Where assert() and static_assert() are insufficient, we could use ordinary code for checking. For example:

Click here to view code image

void f(int n)
      // n should be in [1:max)
{
     if (2<debug_level && (n<=0 || max<n))
           throw Assert_error("range problem");
      //...
}
However, using such “ordinary code” tends to obscure what is being tested. Are we:

• Evaluating the conditions under which we test? (Yes, the 2<debug_level part.)

• Evaluating a condition that is expected to be true for some calls and not for others? (No, because we are throwing an exception – unless someone is trying to use exceptions as simply another return mechanism; §13.1.4.2.)

• Checking a precondition which should never fail? (Yes, the exception is simply our chosen response.)

Worse, the precondition testing (or invariant testing) can easily get dispersed in other code and thus be harder to spot and easier to get wrong. What we would like is a recognizable mechanism for checking assertions. What follows here is a (possibly slightly overelaborate) mechanism for expressing a variety of assertions and a variety of responses to failures. First, I define mechanisms for deciding when to test and deciding what to do if an assertion fails:

Click here to view code image

namespace Assert {
    enum class Mode { throw_, terminate_, ignore_ };
    constexpr Mode current_mode = CURRENT_MODE;
    constexpr int current_level = CURRENT_LEVEL;
    constexpr int default_level = 1;

    constexpr bool level(int n)
        { return n<=current_level; }

    struct Error : runtime_error {
         Error(const string& p) :runtime_error(p) {}
    };

     //...
}
The idea is to test whenever an assertion has a “level” lower than or equal to current_level. If an assertion fails, current_mode is used to choose among three alternatives. The current_level and current_mode are constants because the idea is to generate no code whatsoever for an assertion unless we have made a decision to do so. Imagine CURRENT_MODE and CURRENT_LEVEL to be set in the build environment for a program, possibly as compiler options.

The programmer will use Assert::dynamic() to make assertions:

Click here to view code image

namespace Assert {
    //...

   string compose(const char* file, int line, const string& message)
         // compose message including file name and line number
   {
        ostringstream os ("(");
        os << file << "," << line << "):" << message;
        return os.str();
   }

   template<bool condition =level(default_level), typename Except = Error>
   void dynamic(bool assertion, const string& message ="Assert::dynamic failed")
   {
        if (assertion)
              return;
        if (current_mode == Assert_mode::throw_)
              throw Except{message};
        if (current_mode == Assert_mode::terminate_)
              std::terminate();
   }

   template<>
   void dynamic<false,Error>(bool, const string&)     // do nothing
   {
   }

   void dynamic(bool b, const string& s)        // default action
   {
        dynamic<true,Error>(b,s);
   }

   void dynamic(bool b)                         // default message
   {
        dynamic<true,Error>(b);
   }
}

I chose the name Assert::dynamic (meaning “evaluate at run time”) to contrast with static_assert (meaning “evaluate at compile time”; §2.4.3.3).

Further implementation trickery could be used to minimize the amount of code generated. Alternatively, we could do more of the testing at run time if more flexibility is needed. This Assert is not part of the standard and is presented primarily as an illustration of the problems and the implementation techniques. I suspect that the demands on an assertion mechanism vary too much for a single one to be used everywhere.

We can use Assert::dynamic like this:

Click here to view code image

void f(int n)
      // n should be in [1:max)
{
     Assert::dynamic<Assert::level(2),Assert::Error>(
         (1<=n && n<max), Assert::compose(__FILE__,__LINE__,"range problem"));
      //...
}
The __FILE__ and __LINE__ are macros that expand at their point of appearance in the source code (§12.6.2). I can’t hide them from the user’s view by placing them inside the implementation of Assert where they belong.

Assert::Error is the default exception, so we need not mention it explicitly. Similarly, if we are willing to use the default assertion level, we don’t need to mention the level explicitly:

Click here to view code image

void f(int n)
      // n should be in [1:max)
{
     Assert::dynamic((1<=n && n<max), Assert::compose(__FILE__,__LINE__,"range problem"));
      //...
}
I do not recommend obsessing about the amount of text needed to express an assertion, but by using a namespace directive (§14.2.3) and the default message, we can get to a minimum:

void f(int n)
      // n should be in [1:max)
{
     dynamic(1<=n && n<max);
      //...
}
It is possible to control the testing done and the response to testing through build options (e.g., controlling conditional compilation) and/or through options in the program code. That way, you can have a debug version of a system that tests extensively and enters the debugger and a production version that does hardly any testing.

I personally favor leaving at least some tests in the final (shipping) version of a program. For example, with Assert the obvious convention is that assertions marked as level zero will always be checked. We never find the last bug in a large program under continuous development and maintenance. Also, even if all else works perfectly, having a few “sanity checks” left to deal with hardware failures can be wise.

Only the builder of the final complete system can decide whether a failure is acceptable or not. The writer of a library or reusable component usually does not have the luxury of terminating unconditionally. I interpret that to mean that for general library code, reporting an error – preferably by throwing an exception – is essential.

As usual, destructors should not throw, so don’t use a throwing Assert() in a destructor.

13.5. Throwing and Catching Exceptions
This section presents exceptions from a language-technical point of view.

13.5.1. Throwing Exceptions
We can throw an exception of any type that can be copied or moved. For example:

Click here to view code image

class No_copy {
     No_copy(const No_copy&) = delete;     // prohibit copying (§17.6.4)
};

class My_error {
      //...
};

void f(int n)
{
     switch (n) {
     case 0:   throw My_error{};       // OK
     case 1:   throw No_copy{};        // error: can't copy a No_copy
     case 2:   throw My_error;         // error: My_error is a type, rather than an object
     }
}
The exception object caught (§13.5.2) is in principle a copy of the one thrown (though an optimizer is allowed to minimize copying); that is, a throw x; initializes a temporary variable of x’s type with x. This temporary may be further copied several times before it is caught: the exception is passed (back) from called function to calling function until a suitable handler is found. The type of the exception is used to select a handler in the catch-clause of some try-block. The data in the exception object – if any – is typically used to produce error messages or to help recovery. The process of passing the exception “up the stack” from the point of throw to a handler is called stack unwinding . In each scope exited, the destructors are invoked so that every fully constructed object is properly destroyed. For example:

void f()
{
     string name {"Byron"};
     try {
          string s = "in";
          g();
     }
     catch (My_error) {
           //...
     }
}

void g()
{
     string s = "excess";
     {
          string s = "or";
          h();
     }
}

void h()
{
     string s = "not";
     throw My_error{};
     string s2 = "at all";
}
After the throw in h(), all the strings that were constructed are destroyed in the reverse order of their construction: "not", "or", "excess", "in", but not "at all", which the thread of control never reached, and not "Byron", which was unaffected.

Because an exception is potentially copied several times before it is caught, we don’t usually put huge amounts of data in it. Exceptions containing a few words are very common. The semantics of exception propagation are those of initialization, so objects of types with move semantics (e.g., strings) are not expensive to throw. Some of the most common exceptions carry no information; the name of the type is sufficient to report the error. For example:

struct Some_error { };

void fct()
{
      //...
     if (something_wrong)
           throw Some_error{};
}
There is a small standard-library hierarchy of exception types (§13.5.2) that can be used either directly or as base classes. For example:

Click here to view code image

struct My_error2 : std::runtime_error {
     const char* what() const noexcept { return "My_error2"; }
};
The standard-library exception classes, such as runtime_error and out_of_range, take a string argument as a constructor argument and have a virtual function what() that will regurgitate that string. For example:

Click here to view code image

void g(int n)    // throw some exception
{
     if (n)
           throw std::runtime_error{"I give up!"};
     else
           throw My_error2{};
}

void f(int n)    // see what exception g() throws
{
     try {
            void g(n);
     }
     catch (std::exception& e) {
          cerr << e.what() << '\n';
     }
}
13.5.1.1. noexcept Functions
Some functions don’t throw exceptions and some really shouldn’t. To indicate that, we can declare such a function noexcept. For example:

double compute(double) noexcept;  // may not throw an exception
Now no exception will come out of compute().

Declaring a function noexcept can be most valuable for a programmer reasoning about a program and for a compiler optimizing a program. The programmer need not worry about providing try-clauses (for dealing with failures in a noexcept function) and an optimizer need not worry about control paths from exception handling.

However, noexcept is not completely checked by the compiler and linker. What happens if the programmer “lied” so that a noexcept function deliberately or accidentally threw an exception that wasn’t caught before leaving the noexcept function? Consider:

double compute(double x) noexcept;
{
     string s = "Courtney and Anya";
     vector<double> tmp(10);
      //...
}
The vector constructor may fail to acquire memory for its ten doubles and throw a std::bad_alloc. In that case, the program terminates. It terminates unconditionally by invoking std::terminate() (§30.4.1.3). It does not invoke destructors from calling functions. It is implementation-defined whether destructors from scopes between the throw and the noexcept (e.g., for s in compute()) are invoked. The program is just about to terminate, so we should not depend on any object anyway. By adding a noexcept specifier, we indicate that our code was not written to cope with a throw.

13.5.1.2. The noexcept Operator
It is possible to declare a function to be conditionally noexcept. For example:

Click here to view code image

template<typename T>
void my_fct(T& x) noexcept(Is_pod<T>());
The noexcept(Is_pod<T>()) means that my_fct may not throw if the predicate Is_pod<T>() is true but may throw if it is false. I may want to write this if my_fct() copies its argument. I know that copying a POD does not throw, whereas other types (e.g., a string or a vector) may.

The predicate in a noexcept() specification must be a constant expression. Plain noexcept means noexcept(true).

The standard library provides many type predicates that can be useful for expressing the conditions under which a function may throw an exception (§35.4).

What if the predicate we want to use isn’t easily expressed using type predicates only? For example, what if the critical operation that may or may not throw is a function call f(x)? The noexcept() operator takes an expression as its argument and returns true if the compiler “knows” that it cannot throw and false otherwise. For example:

Click here to view code image

template<typename T>
void call_f(vector<T>& v) noexcept(noexcept(f(v[0]))
{
     for (auto x : v)
           f(x);
}
The double mention of noexcept looks a bit odd, but noexcept is not a common operator.

The operand of noexcept() is not evaluated, so in the example we do not get a run-time error if we pass call_f() with an empty vector.

A noexcept(expr) operator does not go to heroic lengths to determine whether expr can throw; it simply looks at every operation in expr and if they all have noexcept specifications that evaluate to true, it returns true. A noexcept(expr) does not look inside definitions of operations used in expr.

Conditional noexcept specifications and the noexcept() operator are common and important in standard-library operations that apply to containers. For example (§iso.20.2.2):

Click here to view code image

template<typename T, size_t N>
void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));
13.5.1.3. Exception Specifications
In older C++ code, you may find exception specifications. For example:

Click here to view code image

void f(int) throw(Bad,Worse);   // may only throw Bad or Worse exceptions
void g(int) throw();            // may not throw
An empty exception specification throw() is defined to be equivalent to noexcept (§13.5.1.1). That is, if an exception is thrown, the program terminates.

The meaning of a nonempty exception specification, such as throw(Bad,Worse), is that if the function (here f()) throws any exception that is not mentioned in the list or publicly derived from an exception mentioned there, an unexpected handler is called. The default effect of an unexpected exception is to terminate the program (§30.4.1.3). A nonempty throw specification is hard to use well and implies potentially expensive run-time checks to determine if the right exception is thrown. This feature has not been a success and is deprecated. Don’t use it.

If you want to dynamically check which exceptions are thrown, use a try-block.

13.5.2. Catching Exceptions
Consider:

void f()
{
     try {
          throw E{};
     }
     catch(H) {
          // when do we get here?
     }
}
The handler is invoked:

[1] If H is the same type as E

[2] If H is an unambiguous public base of E

[3] If H and E are pointer types and [1] or [2] holds for the types to which they refer

[4] If H is a reference and [1] or [2] holds for the type to which H refers

In addition, we can add const to the type used to catch an exception in the same way that we can add it to a function parameter. This doesn’t change the set of exceptions we can catch; it only restricts us from modifying the exception caught.

In principle, an exception is copied when it is thrown (§13.5). The implementation may apply a wide variety of strategies for storing and transmitting exceptions. It is guaranteed, however, that there is sufficient memory to allow new to throw the standard out-of-memory exception, bad_alloc (§11.2.3).

Note the possibility of catching an exception by reference. Exception types are often defined as part of class hierarchies to reflect relationships among the kinds of errors they represent. For examples, see §13.5.2.3 and §30.4.1.1. The technique of organizing exception classes into hierarchies is common enough for some programmers to prefer to catch every exception by reference.

The {} in both the try-part and a catch-clause of a try-block are real scopes. Consequently, if a name is to be used in both parts of a try-block or outside it, that name must be declared outside the try-block. For example:

Click here to view code image

void g()
{
     int x1;
     try {
          int x2 = x1;
           //...
     }
     catch (Error) {
          ++x1;      // OK
          ++x2;      // error: x2 not in scope
          int x3 = 7;
           //...
     }
     catch(...) {
          ++x3;      // error: x3 not in scope
           //...
     }

     ++x1;           // OK
     ++x2;           // error: x2 not in scope
     ++x3;           // error: x3 not in scope
}
The “catch everything” clause, catch(...), is explained in §13.5.2.2.

13.5.2.1. Rethrow
Having caught an exception, it is common for a handler to decide that it can’t completely handle the error. In that case, the handler typically does what can be done locally and then throws the exception again. Thus, an error can be handled where it is most appropriate. This is the case even when the information needed to best handle the error is not available in a single place, so that the recovery action is best distributed over several handlers. For example:

Click here to view code image

void h()
{
     try {
           //... code that might throw an exception ...
     }
     catch (std::exception& err) {
          if (can_handle_it_completely) {
                 //... handle it ...
                return;
          }
          else {
                 //... do what can be done here ...
                throw;       // rethrow the exception
          }
     }
}
A rethrow is indicated by a throw without an operand. A rethrow may occur in a catch-clause or in a function called from a catch-clause. If a rethrow is attempted when there is no exception to rethrow, std::terminate() (§13.5.2.5) will be called. A compiler can detect and warn about some, but not all, such cases.

The exception rethrown is the original exception caught and not just the part of it that was accessible as an exception. For example, had an out_of_range been thrown, h() would catch it as a plain exception, but throw; would still rethrow it as an out_of_range. Had I written throw err; instead of the simpler throw;, the exception would have been sliced (§17.5.1.4) and h()’s caller could not have caught it as an out_of_range.

13.5.2.2. Catch Every Exception
In <stdexcept>, the standard library provides a small hierarchy of exception classes with a common base exception (§30.4.1.1). For example:

Click here to view code image

void m()
{
     try {
           //... do something ...
     }
     catch (std::exception& err) {       // handle every standard-library exception
           //... cleanup ...
          throw;
     }
}
This catches every standard-library exception. However, the standard-library exceptions are just one set of exception types. Consequently, you cannot catch every exception by catching std::exception. If someone (unwisely) threw an int or an exception from some application-specific hierarchy, it would not be caught by the handler for std::exception&.

However, we often need to deal with every kind of exception. For example, if m() is supposed to leave some pointers in the state in which it found them, then we can write code in the handler to give them acceptable values. As for functions, the ellipsis, ..., indicates “any argument” (§12.2.4), so catch(...) means “catch any exception.” For example:

Click here to view code image

void m()
{
     try {
           //... something ...
     }
     catch (...) {           // handle every exception
           //... cleanup ...
          throw;
     }
}
13.5.2.3. Multiple Handlers
A try-block may have multiple catch-clauses (handlers). Because a derived exception can be caught by handlers for more than one exception type, the order in which the handlers are written in a try-statement is significant. The handlers are tried in order. For example:

Click here to view code image

void f()
{
     try {
           //...
     }
     catch (std::ios_base::failure) {
           //... handle any iostream error (§30.4.1.1) ...
     }
     catch (std::exception& e) {
           //... handle any standard-library exception (§30.4.1.1) ...
     }
     catch (...) {
           //... handle any other exception (§13.5.2.2) ...
     }
}
The compiler knows the class hierarchy, so it can warn about many logical mistakes. For example:

Click here to view code image

void g()
{
     try {
           //...
     }
     catch (...) {
           //... handle every exception (§13.5.2.2) ...
     }
     catch (std::exception& e) {
           //... handle any standard library exception (§30.4.1.1) ...
     }

     catch (std::bad_cast) {
           //... handle dynamic_cast failure (§22.2.1) ...
     }
}
Here, the exception is never considered. Even if we removed the “catch-all” handler, bad_cast wouldn’t be considered because it is derived from exception. Matching exception types to catch-clauses is a (fast) run-time operation and is not as general as (compile-time) overload resolution.

13.5.2.4. Function try-Blocks
The body of a function can be a try-block. For example:

int main()
try
{
      //... do something ...
}
catch (...} {
      //... handle exception ...
}
For most functions, all we gain from using a function try-block is a bit of notational convenience. However, a try-block allows us to deal with exceptions thrown by base-or-member initializers in constructors (§17.4). By default, if an exception is thrown in a base-or-member initializer, the exception is passed on to whatever invoked the constructor for the member’s class. However, the constructor itself can catch such exceptions by enclosing the complete function body – including the member initializer list – in a try-block. For example:

Click here to view code image

class X {
     vector<int> vi;
     vector<string> vs;

      //...
public:
     X(int,int);
      //...
};

X::X(int sz1, int sz2)
try
     :vi(sz1),  // construct vi with sz1 ints
     vs(sz2),   // construct vs with sz2 strings
{
      //...
}
catch (std::exception& err) {  // exceptions thrown for vi and vs are caught here
      //...
}
So, we can catch exceptions thrown by member constructors. Similarly, we can catch exceptions thrown by member destructors in a destructor (though a destructor should never throw). However, we cannot “repair” the object and return normally as if the exception had not happened: an exception from a member constructor means that the member may not be in a valid state. Also, other member objects will either not be constructed or already have had their destructors invoked as part of the stack unwinding.

The best we can do in a catch-clause of a function try-block for a constructor or destructor is to throw an exception. The default action is to rethrow the original exception when we “fall off the end” of the catch-clause (§iso.15.3).

There are no such restrictions for the try-block of an ordinary function.

13.5.2.5. Termination
There are cases where exception handling must be abandoned for less subtle error-handling techniques. The guiding principles are:

• Don’t throw an exception while handling an exception.

• Don’t throw an exception that can’t be caught.

If the exception-handling implementation catches you doing either, it will terminate your program.

If you managed to have two exceptions active at one time (in the same thread, which you can’t), the system would have no idea which of the exceptions to try to handle: your new one or the one it was already trying to handle. Note that an exception is considered handled immediately upon entry into a catch-clause. Rethrowing an exception (§13.5.2.1) or throwing a new exception from within a catch-clause is considered a new throw done after the original exception has been handled. You can throw an exception from within a destructor (even during stack unwinding) as long as you catch it before it leaves the destructor.

The specific rules for calling terminate() are (§iso.15.5.1)

• When no suitable handler was found for a thrown exception

• When a noexcept function tries to exit with a throw

• When a destructor invoked during stack unwinding tries to exit with a throw

• When code invoked to propagate an exception (e.g., a copy constructor) tries to exit with a throw

• When someone tries to rethrow (throw;) when there is no current exception being handled

• When a destructor for a statically allocated or thread-local object tries to exit with a throw

• When an initializer for a statically allocated or thread-local object tries to exit with a throw

• When a function invoked as an atexit() function tries to exit with a throw

In such cases, the function std::terminate() is called. In addition, a user can call terminate() if less drastic approaches are infeasible.

By “tries to exit with a throw,” I mean that an exception is thrown somewhere and not caught so that the run-time system tries to propagate it from a function to its caller.

By default, terminate() will call abort() (§15.4.3). This default is the correct choice for most users – especially during debugging. If that is not acceptable, the user can provide a terminate handler function by a call std::set_terminate() from <exception>:

Click here to view code image

using terminate_handler = void(*)();   // from <exception>

[[noreturn]] void my_handler()         // a terminate handler cannot return
{
      // handle termination my way
}

void dangerous()   // very!
{
     terminate_handler old = set_terminate(my_handler);
      //...
     set_terminate(old);  // restore the old terminate handler
}
The return value is the previous function given to set_terminate().

For example, a terminate handler could be used to abort a process or maybe to re-initialize a system. The intent is for terminate() to be a drastic measure to be applied when the error recovery strategy implemented by the exception-handling mechanism has failed and it is time to go to another level of a fault tolerance strategy. If a terminate handler is entered, essentially nothing can be assumed about a program’s data structures; they must be assumed to be corrupted. Even writing an error message using cerr must be assumed to be hazardous. Also, note that as dangerous() is written, it is not exception-safe. A throw or even a return before set_terminate(old) will leave my_handler in place when it wasn’t meant to be. If you must mess with terminate(), at least use RAII (§13.3).

A terminate handler cannot return to its caller. If it tries to, terminate() will call abort().

Note that abort() indicates abnormal exit from the program. The function exit() can be used to exit a program with a return value that indicates to the surrounding system whether the exit is normal or abnormal (§15.4.3).

It is implementation-defined whether destructors are invoked when a program is terminated because of an uncaught exception. On some systems, it is essential that the destructors are not called so that the program can be resumed from the debugger. On other systems, it is architecturally close to impossible not to invoke the destructors while searching for a handler.

If you want to ensure cleanup when an otherwise uncaught exception happens, you can add a catch-all handler (§13.5.2.2) to main() in addition to handlers for exceptions you really care about. For example:

int main()
try {
      //...
}
catch (const My_error& err) {
      //... handle my error ...
}
catch (const std::range_error&)
{
     cerr << "range error: Not again!\n";
}
catch (const std::bad_alloc&)
{
     cerr << "new ran out of memory\n";
}
catch (...) {
      //...
}
This will catch every exception, except those thrown by construction and destruction of namespace and thread-local variables (§13.5.3). There is no way of catching exceptions thrown during initialization or destruction of namespace and thread-local variables. This is another reason to avoid global variables whenever possible.

When an exception is caught, the exact point where it was thrown is generally not known. This represents a loss of information compared to what a debugger might know about the state of a program. In some C++ development environments, for some programs, and for some people, it might therefore be preferable not to catch exceptions from which the program isn’t designed to recover.

See Assert (§13.4) for an example of how one might encode the location of a throw into the thrown exception.

13.5.3. Exceptions and Threads
If an exception is not caught on a thread (§5.3.1, §42.2), std::terminate() (§13.5.2.5) is called. So, if we don’t want an error in a thread to stop the whole program, we must catch all errors from which we would like to recover and somehow report them to a part of the program that is interested in the results of the thread. The “catch-all” construct catch(...) (§13.5.2.2) comes in handy for that.

We can transfer an exception thrown on one thread to a handler on another thread using the standard-library function current_exception() (§30.4.1.2). For example:

Click here to view code image

try {
      //... do the work ...
}
catch(...) {
     prom.set_exception(current_exception());
}
This is the basic technique used by packaged_task to handle exceptions from user code (§5.3.5.2).

13.6. A vector Implementation
The standard vector provides splendid examples of techniques for writing exception-safe code: its implementation illustrates problems that occur in many contexts and solutions that apply widely.

Obviously, a vector implementation relies on many language facilities provided to support the implementation and use of classes. If you are not (yet) comfortable with C++’s classes and templates, you may prefer to delay studying this example until you have read Chapter 16, Chapter 25, and Chapter 26. However, a good understanding of the use of exceptions in C++ requires a more extensive example than the code fragments so far in this chapter.

The basic tools available for writing exception-safe code are:

• The try-block (§13.5).

• The support for the “Resource Acquisition Is Initialization” technique (§13.3).

The general principles to follow are to

• Never let go of a piece of information before its replacement is ready for use.

• Always leave objects in valid states when throwing or rethrowing an exception.

That way, we can always back out of an error situation. The practical difficulty in following these principles is that innocent-looking operations (such as <, =, and sort()) might throw exceptions. Knowing what to look for in an application takes experience.

When you are writing a library, the ideal is to aim at the strong exception-safety guarantee (§13.2) and always to provide the basic guarantee. When writing a specific program, there may be less concern for exception safety. For example, if I write a simple data analysis program for my own use, I’m usually quite willing to have the program terminate in the unlikely event of memory exhaustion.

Correctness and basic exception safety are closely related. In particular, the techniques for providing basic exception safety, such as defining and checking invariants (§13.4), are similar to the techniques that are useful to get a program small and correct. It follows that the overhead of providing the basic exception-safety guarantee (§13.2) – or even the strong guarantee – can be minimal or even insignificant.

13.6.1. A Simple vector
A typical implementation of vector (§4.4.1, §31.4) will consist of a handle holding pointers to the first element, one-past-the-last element, and one-past-the-last allocated space (§31.2.1) (or the equivalent information represented as a pointer plus offsets):



In addition, it holds an allocator (here, alloc), from which the vector can acquire memory for its elements. The default allocator (§34.4.1) uses new and delete to acquire and release memory.

Here is a declaration of vector simplified to present only what is needed to discuss exception safety and avoidance of resource leaks:

Click here to view code image

template<typename T, class A = allocator<T>>
class vector {
private:
     T* elem;        // start of allocation
     T* space;       // end of element sequence, start of space allocated for possible expansion
     T* last;        // end of allocated space
     A alloc;        // allocator

public:
     using size_type = typename A::size_type;                 // type used for vector sizes

     explicit vector(size_type n, const T& val = T(), const A& = A());

     vector(const vector& a);                        // copy constructor
     vector& operator=(const vector& a);             // copy assignment

     vector(vector&& a);                             // move constructor
     vector& operator=(vector&& a);                  // move assignment

     ~vector();

     size_type size() const { return space–elem; }
     size_type capacity() const { return last–elem; }
     void reserve(size_type n);                      // increase capacity to n

     void resize(size_type n, const T& = {});        // change size to n
     void push_back(const T&);                       // add an element at the end

      //...
};
Consider first a naive implementation of the constructor that initializes a vector to n elements initialized to val:

Click here to view code image

template<typename T, typename A>
vector<T,A>::vector(size_type n, const T& val, const A& a)  // warning: naive implementation
    :alloc{a}                       // copy the allocator
{
    elem = alloc.allocate(n);       // get memory for elements (§34.4)
    space = last = elem+n;
    for (T* p = elem; p!=last; ++p)
          a.construct(p,val);       // construct copy of val in *p (§34.4)
}
There are two potential sources of exceptions here:

[1] allocate() may throw an exception if no memory is available.

[2] T’s copy constructor may throw an exception if it can’t copy val.

What about the copy of the allocator? We can imagine that it throws, but the standard specifically requires that it does not do that (§iso.17.6.3.5). Anyway, I have written the code so that it wouldn’t matter if it did.

In both cases of a throw, no vector object is created, so vector’s destructor is not called (§13.3).

When allocate() fails, the throw will exit before any resources are acquired, so all is well.

When T’s copy constructor fails, we have acquired some memory that must be freed to avoid memory leaks. Worse still, the copy constructor for T might throw an exception after correctly constructing a few elements but before constructing them all. These T objects may own resources that then would be leaked.

To handle this problem, we could keep track of which elements have been constructed and destroy those (and only those) in case of an error:

Click here to view code image

template<typename T, typename A>
vector<T,A>::vector(size_type n, const T& val, const A& a)        // elaborate implementation
    :alloc{a}                            // copy the allocator
{
    elem = alloc.allocate(n);            // get memory for elements

    iterator p;

    try {
         iterator end = elem+n;
         for (p=elem; p!=end; ++p)
               alloc.construct(p,val);         // construct element (§34.4)
         last = space = p;
    }
    catch (...) {
         for (iterator q = elem; q!=p; ++q)
               alloc.destroy(q);               // destroy constructed elements
         alloc.deallocate(elem,n);             // free memory
         throw;                                // rethrow
    }
}
Note that the declaration of p is outside the try-block; otherwise, we would not be able to access it in both the try-part and the catch-clause.

The overhead here is the overhead of the try-block. In a good C++ implementation, this overhead is negligible compared to the cost of allocating memory and initializing elements. For implementations where entering a try-block incurs a cost, it may be worthwhile to add a test if (n) before the try to explicitly handle the (very common) empty vector case.

The main part of this constructor is a repeat of the implementation of std::uninitialized_fill():

Click here to view code image

template<typename For, typename T>
void uninitialized_fill(For beg, For end, const T& x)
{
     For p;
     try {
          for (p=beg; p!=end; ++p)
                ::new(static_cast<void* >(&*p)) T(x);     // construct copy of x in *p (§11.2.4)
     }
     catch (...) {
          for (For q = beg; q!=p; ++q)
               (&*q)–>~T();                              // destroy element (§11.2.4)
          throw;                                         // rethrow (§13.5.2.1)
     }
}
The curious construct &p takes care of iterators that are not pointers. In that case, we need to take the address of the element obtained by dereference to get a pointer. Together with the explicitly global ::new, the explicit cast to void* ensures that the standard-library placement function (§17.2.4) is used to invoke the constructor, and not some user-defined operator new() for T*s. The calls to alloc.construct() in the vector constructors are simply syntactic sugar for this placement new. Similarly, the alloc.destroy() call simply hides explicit destruction (like (&*xq)–>~T()). This code is operating at a rather low level where writing truly general code can be difficult.

Fortunately, we don’t have to invent or implement uninitialized_fill(), because the standard library provides it (§32.5.6). It is often essential to have initialization operations that either complete successfully, having initialized every element, or fail, leaving no constructed elements behind. Consequently, the standard library provides uninitialized_fill(), uninitialized_fill_n(), and uninitialized_copy() (§32.5.6), which offer the strong guarantee (§13.2).

The uninitialized_fill() algorithm does not protect against exceptions thrown by element destructors or iterator operations (§32.5.6). Doing so would be prohibitively expensive and probably impossible.

The uninitialized_fill() algorithm can be applied to many kinds of sequences. Consequently, it takes a forward iterator (§33.1.2) and cannot guarantee to destroy elements in the reverse order of their construction.

Using uninitialized_fill(), we can simplify our constructor:

Click here to view code image

template<typename T, typename A>
vector<T,A>::vector(size_type n, const T& val, const A& a)     // still a bit messy
     :alloc(a)                                  // copy the allocator
{
     elem = alloc.allocate(n);                  // get memory for elements
     try {
          uninitialized_fill(elem,elem+n,val);  // copy elements
          space = last = elem+n;
     }
     catch (...) {
          alloc.deallocate(elem,n);             // free memory
          throw;                                // rethrow
     }
}
This is a significant improvement on the first version of this constructor, but the next section demonstrates how to further simplify it.

The constructor rethrows a caught exception. The intent is to make vector transparent to exceptions so that the user can determine the exact cause of a problem. All standard-library containers have this property. Exception transparency is often the best policy for templates and other “thin” layers of software. This is in contrast to major parts of a system (“modules”) that generally need to take responsibility for all exceptions thrown. That is, the implementer of such a module must be able to list every exception that the module can throw. Achieving this may involve grouping exceptions into hierarchies (§13.5.2) and using catch(...) (§13.5.2.2).

13.6.2. Representing Memory Explicitly
Experience shows that writing correct exception-safe code using explicit try-blocks is more difficult than most people expect. In fact, it is unnecessarily difficult because there is an alternative: The “Resource Acquisition Is Initialization” technique (§13.3) can be used to reduce the amount of code that must be written and to make the code more stylized. In this case, the key resource required by the vector is memory to hold its elements. By providing an auxiliary class to represent the notion of memory used by a vector, we can simplify the code and decrease the chances of accidentally forgetting to release it:

Click here to view code image

template<typename T, typename A = allocator<T>>
struct vector_base {                     // memory structure for vector
     A alloc;        // allocator
     T* elem;        // start of allocation
     T* space;       // end of element sequence, start of space allocated for possible expansion
     T* last;        // end of allocated space

     vector_base(const A& a, typename A::size_type n, typename A::size_type m =0)
         : alloc{a}, elem{alloc.allocate(n+m)}, space{elem+n}, last{elem+n+m} { }
     ~vector_base() { alloc.deallocate(elem,last–elem); }

     vector_base(const vector_base&) = delete;              // no copy operations
     vector_base& operator=(const vector_base&) = delete;

     vector_base(vector_base&&);                            // move operations
     vector_base& operator=(vector_base&&);
};
As long as elem and last are correct, vector_base can be destroyed. Class vector_base deals with memory for a type T, not objects of type T. Consequently, a user of vector_base must construct all objects explicitly in the allocated space and later destroy all constructed objects in a vector_base before the vector_base itself is destroyed.

The vector_base is designed exclusively to be part of the implementation of vector. It is always hard to predict where and how a class will be used, so I made sure that a vector_base can’t be copied and also that a move of a vector_base properly transfers ownership of the memory allocated for elements:

Click here to view code image

template<typename T, typename A>
vector_base<T,A>::vector_base(vector_base&& a)
     : alloc{a.alloc},
     elem{a.elem},
     space{a.space},
     last{a.last}
{
     a.elem = a.space = a.last = nullptr;  // no longer owns any memory
}

template<typename T, typename A>
vector_base<T,A>& vector_base<T,A>::operator=(vector_base&& a)
{
     swap(alloc,a.alloc); swap(elem,a.elem); swap(space ,a.space); swap(last,a.last);
     return *this;
}
This definition of the move assignment uses swap() to transfer ownership of any memory allocated for elements. There are no objects of type T to destroy: vector_base deals with memory and leaves concerns about objects of type T to vector.

Given vector_base, vector can be defined like this:

Click here to view code image

template<typename T, typename A = allocator<T> >
class vector {
     vector_base<T,A> vb;                      // the data is here
     void destroy_elements();
public:
     using size_type = typename A::size_type ;

     explicit vector(size_type n, const T& val = T{}, const A& a = A{});

     vector(const vector& a);                  // copy constructor
     vector& operator=(const vector& a);       // copy assignment

     vector(vector&& a);                       // move constructor
     vector& operator=(vector&& a);            // move assignment

     ~vector() { destroy_elements(); }

     size_type size() const { return vb.space–vb.elem; }
     size_type capacity() const { return vb.last–vb.elem; }

     void reserve(size_type);                  // increase capacity

     void resize(size_type, const T& ={});           // change the number of elements
     void clear() { resize(0); }               // make the vector empty
     void push_back(const T&);                 // add an element at the end

      //...
};

template<typename T, typename A>
void vector<T,A>::destroy_elements() 
{
     for (T* p = vb.elem; p!=vb.space; ++p)
           p–>~T();                 // destroy element (§17.2.4)
     vb.space=vb.elem;
}
The vector destructor explicitly invokes the T destructor for every element. This implies that if an element destructor throws an exception, the vector destruction fails. This can be a disaster if it happens during stack unwinding caused by an exception and terminate() is called (§13.5.2.5). In the case of normal destruction, throwing an exception from a destructor typically leads to resource leaks and unpredictable behavior of code relying on reasonable behavior of objects. There is no really good way to protect against exceptions thrown from destructors, so the library makes no guarantees if an element destructor throws (§13.2).

Now the constructor can be simply defined:

Click here to view code image

template<typename T, typename A>
vector<T,A>::vector(size_type n, const T& val, const A& a)
     :vb{a,n}       // allocate space for n elements
{
     uninitialized_fill(vb.elem,vb.elem+n,val); // make n copies of val
}
The simplification achieved for this constructor carries over to every vector operation that deals with initialization or allocation. For example, the copy constructor differs mostly by using uninitialized_copy() instead of uninitialized_fill():

Click here to view code image

template<typename T, typename A>
vector<T,A>::vector(const vector<T,A>& a)
     :vb{a.vb.alloc,a.size()}
{
     uninitialized_copy(a.begin(),a.end(),vb.elem);
}
This style of constructor relies on the fundamental language rule that when an exception is thrown from a constructor, subobjects (including bases) that have already been completely constructed will be properly destroyed (§13.3). The uninitialized_fill() algorithm and its cousins (§13.6.1) provide the equivalent guarantee for partially constructed sequences.

The move operations are even simpler:

Click here to view code image

template<typename T, typename A>
vector<T,A>::vector(vector&& a)                        // move constructor
     :vb{move(a.vb)}         // transfer ownership
{
}
The vector_base move constructor will set the argument’s representation to “empty.”

For the move assignment, we must take care of the old value of the target:

Click here to view code image

template<typename T, typename A>
vector<T,A>& vector<T,A>::operator=(vector&& a)           // move assignment
{
     clear();            // destroy elements
     swap(vb,a.vb);      // transfer ownership
     return *this;
}
The clear() is strictly speaking redundant because I could assume that the rvalue a would be destroyed immediately after the assignment. However, I don’t know if some programmer has been playing games with std::move().

13.6.3. Assignment
As usual, assignment differs from construction in that an old value must be taken care of. First consider a straightforward implementation:


Click here to view code image

template<typename T, typename A>
vector<T,A>& vector<T,A>::operator=(const vector& a)         // offers the strong guarantee (§13.2)
{
     vector_base<T,A> b {a.vb.alloc,a.size()};            // get memory
     uninitialized_copy(a.begin(),a.end(),b.elem);  // copy elements
     destroy_elements();                            // destroy old elements
     swap(vb,b);                                    // transfer ownership
     return *this;                                  // implicitly destroy the old value
}
This vector assignment provides the strong guarantee, but it repeats a lot of code from constructors and destructors. We can avoid repetition:

Click here to view code image

template<typename T, typename A>
vector<T,A>& vector<T,A>::operator=(const vector& a)         // offers the strong guarantee (§13.2)
{
     vector temp {a};             // copy allocator
     swap(*this,temp);       // swap representations
     return *this;
}
The old elements are destroyed by temp’s destructor, and the memory used to hold them is deallocated by temp’s vector_base’s destructor.

The reason that the standard-library swap() (§35.5.2) works for vector_bases is that we defined vector_base move operations for swap() to use.

The performance of the two versions ought to be equivalent. Essentially, they are just two different ways of specifying the same set of operations. However, the second implementation is shorter and doesn’t replicate code from related vector functions, so writing the assignment that way ought to be less error-prone and lead to simpler maintenance.

Note that I did not test for self-assignment, such as v=v. This implementation of = works by first constructing a copy and then swapping representations. This obviously handles self-assignment correctly. I decided that the efficiency gained from the test in the rare case of self-assignment was more than offset by its cost in the common case where a different vector is assigned.

In either case, two potentially significant optimizations are missing:

[1] If the capacity of the vector assigned to is large enough to hold the assigned vector, we don’t need to allocate new memory.

[2] An element assignment may be more efficient than an element destruction followed by an element construction.

Implementing these optimizations, we get:

Click here to view code image

template<typename T, typename A>
vector<T,A>& vector<T,A>::operator=(const vector& a)           // optimized, basic guarantee (§13.2) only
{
     if (capacity() < a.size()) {  // allocate new vector representation:
           vector temp {a};               // copy allocator
           swap(*this,temp);              // swap representations
           return *this;                  // implicitly destroy the old value
     }
     if (this == &a) return *this;                             // optimize self assignment

     size_type sz = size();
     size_type asz = a.size();
     vb.alloc = a.vb.alloc;                                    // copy the allocator
     if (asz<=sz) {
           copy(a.begin(),a.begin()+asz,vb.elem);
           for (T* p = vb.elem+asz; p!=vb.space; ++p)          // destroy surplus elements (§16.2.6)
                 p–>~T();
     }
     else {
           copy(a.begin(),a.begin()+sz,vb.elem);
           uninitialized_copy(a.begin()+sz,a.end(),vb.space);  // construct extra elements
     }
     vb.space = vb.elem+asz;
     return *this;
}
These optimizations are not free. Obviously, the complexity of the code is far higher. Here, I also test for self-assignment. However, I do so mostly to show how it is done because here it is only an optimization.

The copy() algorithm (§32.5.1) does not offer the strong exception-safety guarantee. Thus, if T::operator=() throws an exception during copy(), the vector being assigned to need not be a copy of the vector being assigned, and it need not be unchanged. For example, the first five elements might be copies of elements of the assigned vector and the rest unchanged. It is also plausible that an element – the element that was being copied when T::operator=() threw an exception – ends up with a value that is neither the old value nor a copy of the corresponding element in the vector being assigned. However, if T::operator=() leaves its operands in valid states before it throws (as it should), the vector is still in a valid state – even if it wasn’t the state we would have preferred.

The standard-library vector assignment offers the (weaker) basic exception-safety guarantee of this last implementation – and its potential performance advantages. If you need an assignment that leaves the vector unchanged if an exception is thrown, you must either use a library implementation that provides the strong guarantee or provide your own assignment operation. For example:

Click here to view code image

template<typename T, typename A>
void safe_assign(vector<T,A>& a, const vector<T,A>& b)       // simple a = b
{
     vector<T,A> temp{b};          // copy the elements of b into a temporary
     swap(a,temp);
}
Alternatively, we could simply use call-by-value (§12.2):

Click here to view code image

template<typename T, typename A>
void safe_assign(vector<T,A>& a, vector<T,A> b)        // simple a = b (note: b is passed by value)
{
     swap(a,b);
}
I never can decide if this last version is simply beautiful or too clever for real (maintainable) code.

13.6.4. Changing Size
One of the most useful aspects of vector is that we can change its size to suit our needs. The most popular functions for changing size are v.push_back(x), which adds an x at the end of v, and v.resize(s), which makes s the number of elements in v.

13.6.4.1. reserve()
The key to a simple implementation of such functions is reserve(), which adds free space at the end for the vector to grow into. In other words, reserve() increases the capacity() of a vector. If the new allocation is larger than the old, reserve() needs to allocate new memory and move the elements into it. We could try the trick from the unoptimized assignment (§13.6.3):

Click here to view code image

template<typename T, typename A>
void vector<T,A>::reserve(size_type newalloc)     // flawed first attempt
{
     if (newalloc<=capacity()) return;        // never decrease allocation
     vector<T,A> v(newalloc);               // make a vector with the new size
     copy(vb.elem,vb.elem+siz e(),v.begin());         // copy elements
     vb.space = v.elem+siz e();         // space is the end of the elements
     swap(*this,v);                           // install new value
}  // implicitly release old value
However, not all types have a default value and we don’t want the extra element slots initialized, so this implementation is flawed. Furthermore, looping over the elements twice, first to default construct and then to copy, is a bit odd. So let us optimize:

Click here to view code image

template<typename T, typename A>
void vector<T,A>::reserve(size_type newalloc)
{
     if (newalloc<=capacity()) return;                       // never decrease allocation
     vector_base<T,A> b {vb.alloc,size(),newalloc-size()};   // get new space
     uninitialized_move(vb.elem,vb.elem+size(),b.elem);      // move elements
     swap(vb,b);                                             // install new base
}  // implicitly release old space
The problem is that the standard library doesn’t offer uninitialized_move(), so we have to write it:

Click here to view code image

template<typename In, typename Out>
Out uninitialized_move(In b, In e, Out oo)
{
     using T = Value_type<Out>;         // assume suitably defined type function (§5.4.2.1, §28.2.4)
     for (; b!=e; ++b,++oo) {
            new(static_cast<void*>(&*oo)) T{move(*b)};  // move construct
            b–>~T();                                    // destroy
     }
     return oo;
}
In general, there is no way of recovering the original state from a failed move, so I don’t try to. This uninitialized_move() offers only the basic guarantee. However, it is simple and for the vast majority of cases it is fast. Also, the standard-library reserve() only offers the basic guarantee.

Whenever reserve() may have moved the elements, any iterators into the vector may have been invalidated (§31.3.3).

Remember that a move operation should not throw. In the rare cases where the obvious implementation of a move might throw, we typically go out of our way to avoid that. A throw from a move operation is rare, unexpected, and damaging to normal reasoning about code. If at all possible avoid it. The standard-library move_if_noexcept() operations may be of help here (§35.5.1).

The explicit use of move() is needed because the compiler doesn’t know that an element (*b) is just about to be destroyed.

13.6.4.2. resize()
The vector’s resize() changes the number of elements. Given reserve(), the implementation of resize() is fairly simple. If the number of elements increases, we must construct the new elements. Conversely, if the number of elements decreases, we must destroy the surplus elements:

Click here to view code image

template<typename T, typename A>
void vector<T,A>::resize(size_type newsize, const T& val)
{
     reserve(newsize);
     if (size()<newsize)
           uninitialized_fill(vb.elem+size(),vb.elem+newsize,val);    // construct new elements
     else
           destroy(vb.elem+newsize,vb.elem+size());                    // destroy surplus elements
     vb.space = vb.elem+newsize;
}
There is no standard destroy(), but that is easily written:

Click here to view code image

template<typename In>
void destroy(In b, In e)
{
     for (; b!=e; ++b)     // destroy [b:e)
            b–>~Value_type<In>();             // assume suitably defined type function (§5.4.2.1, §28.2.4)
}
13.6.4.3. push_back()
From an exception-safety point of view, push_back() is similar to assignment in that we must take care that the vector remains unchanged if we fail to add a new element:

Click here to view code image

template< class T, typename A>
void vector<T,A>::push_back(const T& val)
{
     if (capacity()==size())                         // no more free space; relocate:
           reserve(size()?2*size():8);                // grow or start with 8
     vb.alloc.construct(&vb.elem[size()],val);       // add val at end
     ++vb.space;                                     // increment size
}
Naturally, the copy constructor used to initialize *space might throw an exception. If that happens, the value of the vector remains unchanged, with space left unincremented. However, reserve() may already have reallocated the existing elements. Also, an element move operation that throws can prevent reserve() from providing the correct element for push_back() to use. Av oid throwing move operators as you avoid throwing destructors (§13.2, §17.2.2); they are poisonous to corect, elegant,and efficient code.

This definition of push_back() contains two “magic numbers” (2 and 8). An industrial-strength implementation would not do that, but it would still have values determining the size of the initial allocation (here, 8) and the rate of growth (here, 2, indicating a doubling in size each time the vector would otherwise overflow). As it happens, these are not unreasonable or uncommon values. The assumption is that once we have seen one push_back() for a vector, we will almost certainly see many more. The factor two is larger than the mathematically optimal factor to minimize average memory use (1.618), so as to give better run-time performance for systems where memories are not tiny.

13.6.4.4. Final Thoughts
Note the absence of try-blocks in the vector implementation (except for the one hidden inside uninitialized_copy()). The changes in state were done by carefully ordering the operations so that if an exception is thrown, the vector remains unchanged or at least valid.

The approach of gaining exception safety through ordering and the RAII technique (§13.3) tends to be more elegant and more efficient than explicitly handling errors using try-blocks. More problems with exception safety arise from a programmer ordering code in unfortunate ways than from lack of specific exception-handling code. The basic rule of ordering is not to destroy information before its replacement has been constructed and can be assigned without the possibility of an exception.

Exceptions introduce possibilities for surprises in the form of unexpected control flows. For a piece of code with a simple local control flow, such as the reserve(), safe_assign(), and push_back() examples, the opportunities for surprises are limited. It is relatively simple to look at such code and ask, “Can this line of code throw an exception, and what happens if it does?” For large functions with complicated control structures, such as complicated conditional statements and nested loops, this can be hard. Adding try-blocks increases this local control structure complexity and can therefore be a source of confusion and errors (§13.3). I conjecture that the effectiveness of the ordering approach and the RAII approach compared to more extensive use of try-blocks stems from the simplification of the local control flow. Simple, stylized code is easier to understand, easier to get right, and easier to generate good code for.

This vector implementation is presented as an example of the problems that exceptions can pose and of techniques for addressing those problems. The standard does not require an implementation to be exactly like the one presented here. However, the standard does require the exception-safety guarantees as provided by the example.

13.7. Advice
[1] Develop an error-handling strategy early in a design; §13.1.

[2] Throw an exception to indicate that you cannot perform an assigned task; §13.1.1.

[3] Use exceptions for error handling; §13.1.4.2.

[4] Use purpose-designed user-defined types as exceptions (not built-in types); §13.1.1.

[5] If you for some reason cannot use exceptions, mimic them; §13.1.5.

[6] Use hierarchical error handling; §13.1.6.

[7] Keep the individual parts of error handling simple; §13.1.6.

[8] Don’t try to catch every exception in every function; §13.1.6.

[9] Always provide the basic guarantee; §13.2, §13.6.

[10] Provide the strong guarantee unless there is a reason not to; §13.2, §13.6.

[11] Let a constructor establish an invariant, and throw if it cannot; §13.2.

[12] Release locally owned resources before throwing an exception; §13.2.

[13] Be sure that every resource acquired in a constructor is released when throwing an exception in that constructor; §13.3.

[14] Don’t use exceptions where more local control structures will suffice; §13.1.4.

[15] Use the “Resource Acquisition Is Initialization” technique to manage resources; §13.3.

[16] Minimize the use of try-blocks; §13.3.

[17] Not every program needs to be exception-safe; §13.1.

[18] Use “Resource Acquisition Is Initialization” and exception handlers to maintain invariants; §13.5.2.2.

[19] Prefer proper resource handles to the less structured finally; §13.3.1.

[20] Design your error-handling strategy around invariants; §13.4.

[21] What can be checked at compile time is usually best checked at compile time (using static_assert); §13.4.

[22] Design your error-handling strategy to allow for different levels of checking/enforcement; §13.4.

[23] If your function may not throw, declare it noexcept; §13.5.1.1

[24] Don’t use exception specification; §13.5.1.3.

[25] Catch exceptions that may be part of a hierarchy by reference; §13.5.2.

[26] Don’t assume that every exception is derived from class exception; §13.5.2.2.

[27] Have main() catch and report all exceptions; §13.5.2.2, §13.5.2.4.

[28] Don’t destroy information before you have its replacement ready; §13.6.

[29] Leave operands in valid states before throwing an exception from an assignment; §13.2.

[30] Never let an exception escape from a destructor; §13.2.

[31] Keep ordinary code and error-handling code separate; §13.1.1, §13.1.4.2.

[32] Beware of memory leaks caused by memory allocated by new not being released in case of an exception; §13.3.

[33] Assume that every exception that can be thrown by a function will be thrown; §13.2.

[34] A library shouldn’t unilaterally terminate a program. Instead, throw an exception and let a caller decide; §13.4.

[35] A library shouldn’t produce diagnostic output aimed at an end user. Instead, throw an exception and let a caller decide; §13.1.3.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


13. Exception Handling
14. Namespaces
15. Source Files and Programs
47h 26m remaining
14. Namespaces
The year is 787!

A.D.?

– Monty Python

• Composition Problems

• Namespaces

Explicit Qualification; using-Declarations; using-Directives; Argument-Dependent Lookup; Namespaces Are Open

• Modularization and Interfaces

Namespaces as Modules; Implementations; Interfaces and Implementations

• Composition Using Namespaces

Convenience vs. Safety; Namespace Aliases; Namespace Composition; Composition and Selection; Namespaces and Overloading; Versioning; Nested Namespaces; Unnamed Namespaces; C Headers

• Advice

14.1. Composition Problems
Any realistic program consists of a number of separate parts. Functions (§2.2.1, Chapter 12) and classes (§3.2, Chapter 16) provide relatively fine-grained separation of concerns, whereas “libraries,” source files, and translation units (§2.4, Chapter 15) provide coarser grain. The logical ideal is modularity, that is, to keep separate things separate and to allow access to a “module” only through a well-specified interface. C++ does not provide a single language feature supporting the notion of a module; there is no module construct. Instead, modularity is expressed through combinations of other language facilities, such as functions, classes, and namespaces, and source code organization.

This chapter and the next deal with the coarse structure of a program and its physical representation as source files. That is, these two chapters are more concerned with programming in the large than with the elegant expression of individual types, algorithms, and data structures.

Consider some of the problems that can arise when people fail to design for modularity. For example, a graphics library may provide different kinds of graphical Shapes and functions to help use them:

Click here to view code image

 // Graph_lib:

class Shape { /* ... */ };
class Line : public Shape { /* ... */ };
class Poly_line: public Shape { /* ... */ };    // connected sequence of lines
class Text : public Shape { /* ... */ };        // text label

Shape operator+(const Shape&, const Shape&);    // compose

Graph_reader open(const char*);                 // open file of Shapes
Now someone comes along with another library, providing facilities for text manipulation:

Click here to view code image

 // Text_lib:

class Glyph { /* ... */ };
class Word { /* ... */ };         // sequence of Glyphs
class Line { /* ... */ };         // sequence of Words
class Text { /* ... */ };         // sequence of Lines

File* open(const char*);                     // open text file

Word operator+(const Line&, const Line&);    // concatenate
For the moment, let us ignore the specific design issues for graphics and text manipulation and just consider the problems of using Graph_lib and Text_lib together in a program.

Assume (realistically enough) that the facilities of Graph_lib are defined in a header (§2.4.1), Graph_lib.h, and the facilities of Text_lib are defined in another header, Text_lib.h. Now, I can “innocently” #include both and try to use facilities from the two libraries:

#include "Graph_lib.h"
#include "Text_lib.h"
// ...
Just #includeing those headers causes a slurry of error messages: Line, Text, and open() are defined twice in ways that a compiler cannot disambiguate. Trying to use the libraries would give further error messages.

There are many techniques for dealing with such name clashes. For example, some such problems can be addressed by placing all the facilities of a library inside a few classes, by using supposedly uncommon names (e.g., Text_box rather than Text), or by systematically using a prefix for names from a library (e.g., gl_shape and gl_line). Each of these techniques (also known as “workarounds” and “hacks”) works in some cases, but they are not general and can be inconvenient to use. For example, names tend to become long, and the use of many different names inhibits generic programming (§3.4).

14.2. Namespaces
The notion of a namespace is provided to directly represent the notion of a set of facilities that directly belong together, for example, the code of a library. The members of a namespace are in the same scope and can refer to each other without special notation, whereas access from outside the namespace requires explicit notation. In particular, we can avoid name clashes by separating sets of declarations (e.g., library interfaces) into namespaces. For example, we might call the graph library Graph_lib:

Click here to view code image

namespace Graph_lib {
    class Shape { /* ... */ };
    class Line : public Shape { /* ... */ };
    class Poly_line: public Shape { /* ... */ };     // connected sequence of lines
    class Text : public Shape { /* ... */ };         // text label

    Shape operator+(const Shape&, const Shape&);     // compose

    Graph_reader open(const char*);                  // open file of Shapes
}
Similarly, the obvious name for our text library is Text_lib:

Click here to view code image

namespace Text_lib {
    class Glyph { /* ... */ };
    class Word { /* ... */ };         // sequence of Glyphs
    class Line { /* ... */ };         // sequence of Words
    class Text { /* ... */ };         // sequence of Lines

    File* open(const char*);                     // open text file

    Word operator+(const Line&, const Line&);    // concatenate
}
As long as we manage to pick distinct namespace names, such as Graph_lib and Text_lib (§14.4.2), we can now compile the two sets of declarations together without name clashes.

A namespace should express some logical structure: the declarations within a namespace should together provide facilities that unite them in the eyes of their users and reflect a common set of design decisions. They should be seen as a logical unit, for example, “the graphics library” or “the text manipulation library,” similar to the way we consider the members of a class. In fact, the entities declared in a namespace are referred to as the members of the namespace.

A namespace is a (named) scope. You can access members defined earlier in a namespace from later declarations, but you cannot (without special effort) refer to members from outside the namespace. For example:

Click here to view code image

class Glyph { /* ... */ };
class Line { /* ... */ };

namespace Text_lib {
    class Glyph { /* ... */ };
    class Word { /* ... */ };     // sequence of Glyphs

    class Line { /* ... */ }; // sequence of Words
    class Text { /* ... */ }; // sequence of Lines

    File* open(const char*);               // open text file

    Word operator+(const Line&, const Line&);    // concatenate
}

Glyph glyph(Line& ln, int i);    // ln[i]
Here, the Word and Line in the declaration of Text_lib::operator+() refer to Text_lib::Word and Text_lib::Line. That local name lookup is not affected by the global Line. Conversely, the Glyph and Line in the declaration of the global glyph() refer to the global ::Glyph and ::Line. That (nonlocal) lookup is not affected by Text_lib’s Glyph and Line.

To refer to a member of a namespace, we can use its fully qualified name. For example, if we want a glyph() that uses definitions from Text_lib, we can write:

Text_lib::Glyph glyph(Text_lib::Line& ln, int i);     // ln[i]
Other ways of referring to members from outside their namespace are using-declarations (§14.2.2), using-directives (§14.2.3), and argument-dependent lookup (§14.2.4).

14.2.1. Explicit Qualification
A member can be declared within a namespace definition and defined later using the namespace-name :: member-name notation.

Members of a namespace must be introduced using this notation:

namespace namespace–name {
     // declaration and definitions
}
For example:

Click here to view code image

namespace Parser {
    double expr(bool);          // declaration
    double term(bool);
    double prim(bool);
}

double val = Parser::expr(true);    // use

double Parser::expr(bool b)     // definition
{
    // ...
}
We cannot declare a new member of a namespace outside a namespace definition using the qualifier syntax (§iso.7.3.1.2). The idea is to catch errors such as misspellings and type mismatches, and also to make it reasonably easy to find all names in a namespace declaration. For example:

Click here to view code image

void Parser::logical(bool);    // error: no logical() in Parser
double Parser::trem(bool);     // error: no trem() in Parser (misspelling)
double Parser::prim(int);      // error: Parser::prim() takes a bool argument (wrong type)
A namespace is a scope. The usual scope rules hold for namespaces. Thus, “namespace” is a very fundamental and relatively simple concept. The larger a program is, the more useful namespaces are to express logical separations of its parts. The global scope is a namespace and can be explicitly referred to using ::. For example:

Click here to view code image

int f();        // global function

int g()
{
     int f;     // local variable; hides the global function
     f();       // error: we can't call an int
     ::f();     // OK: call the global function
}
Classes are namespaces (§16.2).

14.2.2. using-Declarations
When a name is frequently used outside its namespace, it can be a bother to repeatedly qualify it with its namespace name. Consider:

Click here to view code image

#include<string>
#include<vector>
#include<sstream>

std::vector<std::string> split(const std::string& s)
     // split s into its whitespace-separated substrings
{
    std::vector<std::string> res;
    std::istringstream iss(s);
    for (std::string buf; iss>>buf; )
          res.push_back(buf);
    return res;
}
The repeated qualification std is tedious and distracting. In particular, we repeat std::string four times in this small example. To alleviate that we can use a using-declaration to say that in this code string means std::string:

Click here to view code image

using std::string;    // use "string" to mean "std::string"

std::vector<string> split(const string& s)
      // split s into its whitespace-separated substrings
{
    std::vector<string> res;
    std::istringstream iss(s);
    for (string buf; iss>>buf; )
          res.push_back(buf);
    return res;
}
A using-declaration introduces a synonym into a scope. It is usually a good idea to keep local synonyms as local as possible to avoid confusion.

When used for an overloaded name, a using-declaration applies to all the overloaded versions. For example:

namespace N {
    void f(int);
    void f(string);
};

void g()
{
     using N::f;
     f(789);            // N::f(int)
     f("Bruce");        // N::f(string)
}
For the use of using-declarations within class hierarchies, see §20.3.5.

14.2.3. using-Directives
In the split() example (§14.2.2), we still had three uses of std:: left after introducing a synonym for std::string. Often, we like to use every name from a namespace without qualification. That can be achieved by providing a using-declaration for each name from the namespace, but that’s tedious and requires extra work each time a new name is added to or removed from the namespace. Alternatively, we can use a using-directive to request that every name from a namespace be accessible in our scope without qualification. For example:

Click here to view code image

using namespace std;    // make every name from std accessible

vector<string> split(const string& s)
     // split s into its whitespace-separated substrings
{
    vector<string> res;
    istringstream iss(s);
    for (string buf; iss>>buf;)
          res.push_back(buf);
    return res;
}
A using-directive makes names from a namespace available almost as if they had been declared outside their namespace (see also §14.4). Using a using-directive to make names from a frequently used and well-known library available without qualification is a popular technique for simplifying code. This is the technique used to access standard-library facilities throughout this book. The standard-library facilities are defined in namespace std.

Within a function, a using-directive can be safely used as a notational convenience, but care should be taken with global using-directives because overuse can lead to exactly the name clashes that namespaces were introduced to avoid. For example:

Click here to view code image

namespace Graph_lib {
    class Shape { /* ... */ };
    class Line : public Shape { /* ... */ };
    class Poly_line: public Shape { /* ... */ };    // connected sequence of lines
    class Text : public Shape { /* ... */ };        // text label

    Shape operator+(const Shape&, const Shape&);    // compose

    Graph_reader open(const char*);    // open file of Shapes

}

namespace Text_lib {
    class Glyph { /* ... */ };
    class Word { /* ... */ };   // sequence of Glyphs
    class Line { /* ... */ };         // sequence of Words
    class Text { /* ... */ };         // sequence of Lines

    File* open(const char*);    // open text file

    Word operator+(const Line&, const Line&);   // concatenate

}

using namespace Graph_lib;
using namespace Text_lib;

Glyph gl;               // Text_lib::Glyph
vector<Shape*> vs;       // Graph_lib::Shape
So far, so good. In particular, we can use names that do not clash, such as Glyph and Shape. However, name clashes now occur as soon as we use one of the names that clash – exactly as if we had not used namespaces. For example:

Click here to view code image

Text txt;                                   // error: ambiguous
File* fp = open("my_precious_data");        // error: ambiguous
Consequently, we must be careful with using-directives in the global scope. In particular, don’t place a using-directive in the global scope in a header file except in very specialized circumstances (e.g., to aid transition) because you never know where a header might be #included.

14.2.4. Argument-Dependent Lookup
A function taking an argument of user-defined type X is more often than not defined in the same namespace as X. Consequently, if a function isn’t found in the context of its use, we look in the namespaces of its arguments. For example:

Click here to view code image

namespace Chrono {
    class Date { /* ... */ };

    bool operator==(const Date&, const std::string&);

    std::string format(const Date&);    // make string representation
    // ... 
}

void f(Chrono::Date d, int i)
{
    std::string s = format(d);      // Chrono::format()
    std::string t = format(i);      // error: no format() in scope
}
This lookup rule (called argument-dependent lookup or simply ADL) saves the programmer a lot of typing compared to using explicit qualification, yet it doesn’t pollute the namespace the way a using-directive (§14.2.3) can. It is especially useful for operator operands (§18.2.5) and template arguments (§26.3.5), where explicit qualification can be quite cumbersome.

Note that the namespace itself needs to be in scope and the function must be declared before it can be found and used.

Naturally, a function can take arguments from more than one namespace. For example:

void f(Chrono::Date d, std::string s)
{
     if (d == s) {
           // ...
     }
     else if (d == "August 4, 1914") {
            //...
     }
}
In such cases, we look for the function in the scope of the call (as ever) and in the namespaces of every argument (including each argument’s class and base classes) and do the usual overload resolution (§12.3) of all functions we find. In particular, for the call d==s, we look for operator== in the scope surrounding f(), in the std namespace (where == is defined for string), and in the Chrono namespace. There is a std::operator==(), but it doesn’t take a Date argument, so we use Chrono::operator==(), which does. See also §18.2.5.

When a class member invokes a named function, other members of the same class and its base classes are preferred over functions potentially found based on the argument types (operators follow a different rule; §18.2.1, §18.2.5). For example:

Click here to view code image

namespace N {
    struct S { int i; };
    void f(S);
    void g(S);
    void h(int);
}

struct Base {
    void f(N::S);
};

struct D : Base {
    void mf(N::S);

    void g(N::S x)
    {
         f(x);       // call Base::f()
         mf(x);      // call D::mf()
         h(1);       // error: no h(int) available
    }
};
In the standard, the rules for argument-dependent lookup are phrased in terms of associated namespaces (§iso.3.4.2). Basically:

• If an argument is a class member, the associated namespaces are the class itself (including its base classes) and the class’s enclosing namespaces.

• If an argument is a member of a namespace, the associated namespaces are the enclosing namespaces.

• If an argument is a built-in type, there are no associated namespaces.

Argument-dependent lookup can save a lot of tedious and distracting typing, but occasionally it can give surprising results. For example, the search for a declaration of a function f() does not have a preference for functions in a namespace in which f() is called (the way it does for functions in a class in which f() is called):

namespace N {
    template<typename T>
        void f(T, int);   // N::f()
    class X { };
}

namespace N2 {
    N::X x;

    void f(N::X, unsigned);

    void g()
    {
         f(x,1);     // calls N::f(X,int)
    }
}
It may seem obvious to choose N2::f(), but that is not done. Overload resolution is applied and the best match is found: N::f() is the best match for f(x,1) because 1 is an int rather than an unsigned. Conversely, examples have been seen where a function in the caller’s namespace is chosen but the programmer expected a better function from a known namespace to be used (e.g., a standard-library function from std). This can be most confusing. See also §26.3.6.

14.2.5. Namespaces Are Open
A namespace is open; that is, you can add names to it from several separate namespace declarations. For example:

Click here to view code image

namespace A {
    int f();     // now A has member f()
}
namespace A {
    int g();     // now A has two members, f() and g()
}
That way, the members of a namespace need not be placed contiguously in a single file. This can be important when converting older programs to use namespaces. For example, consider a header file written without the use of namespaces:

 // my header:

      void mf();      // my function
      void yf();      // your function
      int mg();       // my function
      // ...
Here, we have (unwisely) just added the declarations needed without concerns of modularity. This can be rewritten without reordering the declarations:

Click here to view code image

 // my header:

      namespace Mine {
          void mf();    // my function
           //...
      }

      void yf();        // your function (not yet put into a namespace)

      namespace Mine {
          int mg();     // my function
           //...
      }
When writing new code, I prefer to use many smaller namespaces (see §14.4) rather than putting really major pieces of code into a single namespace. However, that is often impractical when converting major pieces of software to use namespaces.

Another reason to define the members of a namespace in several separate namespace declarations is that sometimes we want to distinguish parts of a namespace used as an interface from parts used to support easy implementation; §14.3 provides an example.

A namespace alias (§14.4.2) cannot be used to re-open a namespace.

14.3. Modularization and Interfaces
Any realistic program consists of a number of separate parts. For example, even the simple “Hello, world!” program involves at least two parts: the user code requests Hello, world! to be printed, and the I/O system does the printing.

Consider the desk calculator example from §10.2. It can be viewed as composed of five parts:

[1] The parser, doing syntax analysis: expr(), term(), and prim()

[2] The lexer, composing tokens out of characters: Kind, Token, Token_stream, and ts

[3] The symbol table, holding (string,value) pairs: table

[4] The driver: main() and calculate()

[5] The error handler: error() and number_of_errors

This can be represented graphically:



where an arrow means “using.” To simplify the picture, I have not represented the fact that every part relies on error handling. In fact, the calculator was conceived as three parts, with the driver and error handler added for completeness.

When one module uses another, it doesn’t need to know everything about the module used. Ideally, most of the details of a module are unknown to its users. Consequently, we make a distinction between a module and its interface. For example, the parser directly relies on the lexer’s interface (only), rather than on the complete lexer. The lexer simply implements the services advertised in its interface. This can be presented graphically like this:



A dashed line means “implements.” I consider this to be the real structure of the program, and our job as programmers is to represent this faithfully in code. That done, the code will be simple, efficient, comprehensible, maintainable, etc., because it will directly reflect our fundamental design.

The following subsections show how the logical structure of the desk calculator program can be made clear, and §15.3 shows how the program source text can be physically organized to take advantage of it. The calculator is a tiny program, so in “real life” I wouldn’t bother using namespaces and separate compilation (§2.4.1, §15.1) to the extent done here. Making the structure of the calculator explicit is simply an illustration of techniques useful for larger programs without drowning in code. In real programs, each “module” represented by a separate namespace will often have hundreds of functions, classes, templates, etc.

Error handling permeates the structure of a program. When breaking up a program into modules or (conversely) when composing a program out of modules, we must take care to minimize dependencies between modules caused by error handling. C++ provides exceptions to decouple the detection and reporting of errors from the handling of errors (§2.4.3.1, Chapter 13).

There are many more notions of modularity than the ones discussed in this chapter and the next. For example, we might use concurrently executing and communicating tasks (§5.3, Chapter 41) or processes to represent important aspects of modularity. Similarly, the use of separate address spaces and the communication of information between address spaces are important topics not discussed here. I consider these notions of modularity largely independent and orthogonal. Interestingly, in each case, separating a system into modules is easy. The hard problem is to provide safe, convenient, and efficient communication across module boundaries.

14.3.1. Namespaces as Modules
A namespace is a mechanism for expressing logical grouping. That is, if some declarations logically belong together according to some criteria, they can be put in a common namespace to express that fact. So we can use namespaces to express the logical structure of our calculator. For example, the declarations of the parser from the desk calculator (§10.2.1) may be placed in a namespace Parser:

namespace Parser {
    double expr(bool);
    double prim(bool get) { /* ... */ }
    double term(bool get) { /* ... */ }
    double expr(bool get) { /* ... */ }
}
The function expr() must be declared first and then later defined to break the dependency loop described in §10.2.1.

The input part of the desk calculator could also be placed in its own namespace:

namespace Lexer {
    enum class Kind : char { /* ... */ };
    class Token { /* ... */ };
    class Token_stream { /* ... */ };

    Token_stream ts;
}
The symbol table is extremely simple:

namespace Table {
    map<string,double> table;
}
The driver cannot be completely put into a namespace because the language rules require main() to be a global function:

namespace Driver {
    void calculate() { /* ... */ }
}

int main() { /* ... */ }
The error handler is also trivial:

Click here to view code image

namespace Error {
    int no_of_errors;
    double error(const string& s) { /* ... */ }
}
This use of namespaces makes explicit what the lexer and the parser provide to a user. Had I included the source code for the functions, this structure would have been obscured. If function bodies are included in the declaration of a realistically sized namespace, you typically have to wade through screenfuls of information to find what services are offered, that is, to find the interface.

An alternative to relying on separately specified interfaces is to provide a tool that extracts an interface from a module that includes implementation details. I don’t consider that a good solution. Specifying interfaces is a fundamental design activity, a module can provide different interfaces to different users, and often an interface is designed long before the implementation details are made concrete.

Here is a version of the Parser with the interface separated from the implementation:

Click here to view code image

namespace Parser {
    double prim(bool);
    double term(bool);
    double expr(bool);
}

double Parser::prim(bool get) { /* ... */ }
double Parser::term(bool get) { /* ... */ }
double Parser::expr(bool get) { /* ... */ }
Note that as a result of separating the implementation from the interface, each function now has exactly one declaration and one definition. Users will see only the interface containing declarations. The implementation – in this case, the function bodies – will be placed “somewhere else” where a user need not look.

Ideally, every entity in a program belongs to some recognizable logical unit (“module”). Therefore, every declaration in a nontrivial program should ideally be in some namespace named to indicate its logical role in the program. The exception is main(), which must be global in order for the compiler to recognize it as special (§2.2.1, §15.4).

14.3.2. Implementations
What will the code look like once it has been modularized? That depends on how we decide to access code in other namespaces. We can always access names from “our own” namespace exactly as we did before we introduced namespaces. However, for names in other namespaces, we have to choose among explicit qualification, using-declarations, and using-directives.

Parser::prim() provides a good test case for the use of namespaces in an implementation because it uses each of the other namespaces (except Driver). If we use explicit qualification, we get:

Click here to view code image

double Parser::prim(bool get)       // handle primaries
{
    if (get) Lexer::ts.get();


    switch (Lexer::ts.current().kind) {
    case Lexer::Kind::number:             // floating-point constant
    {    double v = Lexer::ts.current().number_value;
         Lexer::ts.get();
         return v;
    }
    case Lexer::Kind::name:
    {    double& v = Table::table[Lexer::ts.current().string_value];
         if (Lexer::ts.get().kind == Lexer::Kind::assign) v = expr(true);  //'=' seen: assignment
         return v;
    }
    case Lexer::Kind::minus:       // unary minus
         return -prim(true);
    case Lexer::Kind::lp:
    {    double e = expr(true);
         if (Lexer::ts.current().kind != Lexer::Kind::rp) return Error::error(" ')' expected");
         Lexer::ts.get();      // eat ')'
         return e;
    }
    default:
        return Error::error("primary expected");
    }
}
I count 14 occurrences of Lexer::, and (despite theories to the contrary) I don’t think the more explicit use of modularity has improved readability. I didn’t use Parser:: because that would be redundant within namespace Parser.

If we use using-declarations, we get:

Click here to view code image

using Lexer::ts;          // saves eight occurrences of "Lexer::"
using Lexer::Kind;        // saves six occurrences of "Lexer::"
using Error::error;       // saves two occurrences of "Error::"
using Table::table;       // saves one occurrence of "Table::"

double Parser::prim(bool get)     // handle primaries
{
    if (get) ts.get();


    switch (ts.current().kind) {
    case Kind::number:         // floating-point constant
    {    double v = ts.current().number_value;
         ts.get();
         return v;
    }
    case Kind::name:
    {    double& v = table[ts.current().string_value];
         if (ts.get().kind == Kind::assign) v = expr(true);     //'=' seen: assignment
         return v;
    }
    case Kind::minus:         // unary minus
         return -prim(true);
    case Kind::lp:
    {    double e = expr(true);
         if (ts.current().kind != Kind::rp) return error("')' expected");
         ts.get();          // eat ')'
         return e;
    }
    default:
        return error("primary expected");
    }
}
My guess is that the using-declarations for Lexer:: were worth it, but that the value of the others was marginal.

If we use using-directives, we get:

Click here to view code image

using namespace Lexer;      // saves fourteen occurrences of "Lexer::"
using namespace Error;      // saves two occurrences of "Error::"
using namespace Table;      // saves one occurrence of "Table::"

double Parser::prim(bool get)             // handle primaries
{
     // as before
}
The using-declarations for Error and Table don’t buy much notationally, and it can be argued that they obscure the origins of the formerly qualified names.

So, the tradeoff among explicit qualification, using-declarations, and using-directives must be made on a case-by-case basis. The rules of thumb are:

[1] If some qualification is really common for several names, use a using-directive for that namespace.

[2] If some qualification is common for a particular name from a namespace, use a using-declaration for that name.

[3] If a qualification for a name is uncommon, use explicit qualification to make it clear from where the name comes.

[4] Don’t use explicit qualification for names in the same namespace as the user.

14.3.3. Interfaces and Implementations
It should be clear that the namespace definition we used for Parser is not the ideal interface for Parser to present to its users. Instead, Parser declares the set of declarations that is needed to write the individual parser functions conveniently. The Parser’s interface to its users should be far simpler:

namespace Parser { // user interface
    double expr(bool);
}
We see the namespace Parser used to provide two things:

[1] The common environment for the functions implementing the parser

[2] The external interface offered by the parser to its users

Thus, the driver code, main(), should see only the user interface.

The functions implementing the parser should see whichever interface we decided on as the best for expressing those functions’ shared environment. That is:

Click here to view code image

namespace Parser {          // implementer interface
    double prim(bool);
    double term(bool);


    using namespace Lexer;        // use all facilities offered by lexer
    using Error::error;
    using Table::table;
}
or graphically:



The arrows represent “relies on the interface provided by” relations.

We could give the user’s interface and the implementer’s interface different names, but (because namespaces are open; §14.2.5) we don’t have to. The lack of separate names need not lead to confusion because the physical layout of the program (see §15.3.2) naturally provides separate (file) names. Had we decided to use a separate implementation namespace, the design would not have looked different to users:

Click here to view code image

namespace Parser { // user interface
    double expr(bool);
}

namespace Parser_impl {                // implementer interface
    using namespace Parser;

    double prim(bool);
    double term(bool);

    using namespace Lexer;  // use all facilities offered by Lexer
    using Error::error;
    using Table::table;
}
or graphically:



For larger programs, I lean toward introducing _impl interfaces.

The interface offered to implementers is larger than the interface offered to users. Had this interface been for a realistically sized module in a real system, it would change more often than the interface seen by users. It is important that the users of a module (in this case, Driver using Parser) be insulated from such changes.

14.4. Composition Using Namespaces
In larger programs, we tend to use many namespaces. This section examines technical aspects of composing code out of namespaces.

14.4.1. Convenience vs. Safety
A using-declaration adds a name to a local scope. A using-directive does not; it simply renders names accessible in the scope in which they were declared. For example:

Click here to view code image

namespace X {
    int i, j, k;
}

int k;


void f1()
{
     int i = 0;
     using namespace X;      // make names from X accessible
     i++;                    // local i
     j++;                    // X::j
     k++;                    // error: X's k or the global k?
     ::k++;                  // the global k
     X::k++;                 // X's k
}


void f2()
{
     int i = 0;
     using X::i;     // error: i declared twice in f2()
     using X::j;
     using X::k;     // hides global k


     i++;
     j++;            // X::j
     k++;            // X::k
}
A locally declared name (declared either by an ordinary declaration or by a using-declaration) hides nonlocal declarations of the same name, and any illegal overloading of the name is detected at the point of declaration.

Note the ambiguity error for k++ in f1(). Global names are not given preference over names from namespaces made accessible in the global scope. This provides significant protection against accidental name clashes, and – importantly – ensures that there are no advantages to be gained from polluting the global namespace.

When libraries declaring many names are made accessible through using-directives, it is a significant advantage that clashes of unused names are not considered errors.

14.4.2. Namespace Aliases
If users give their namespaces short names, the names of different namespaces will clash:

Click here to view code image

namespace A { // short name, will clash (eventually)
      //...
}

A::String s1 = "Grieg";
A::String s2 = "Nielsen";
However, long namespace names can be impractical in real code:

Click here to view code image

namespace American_Telephone_and_Telegraph {      // too long
     //...
}

American_Telephone_and_Telegraph::String s3 = "Grieg";
American_Telephone_and_Telegraph::String s4 = "Nielsen";
This dilemma can be resolved by providing a short alias for a longer namespace name:

Click here to view code image

 // use namespace alias to shorten names:


namespace ATT = American_Telephone_and_Telegraph;


ATT::String s3 = "Grieg";
ATT::String s4 = "Nielsen";
Namespace aliases also allow a user to refer to “the library” and have a single declaration defining what library that really is. For example:

Click here to view code image

namespace Lib = Foundation_library_v2r11;

 //...

Lib::set s;
Lib::String s5 = "Sibelius";
This can immensely simplify the task of replacing one version of a library with another. By using Lib rather than Foundation_library_v2r11 directly, you can update to version “v3r02” by changing the initialization of the alias Lib and recompiling. The recompile will catch source-level incompatibilities. On the other hand, overuse of aliases (of any kind) can lead to confusion.

14.4.3. Namespace Composition
Often, we want to compose an interface out of existing interfaces. For example:

Click here to view code image

namespace His_string {
    class String { /* ... */ };
    String operator+(const String&, const String&);
    String operator+(const String&, const char*);
    void fill(char);
     //...
}

namespace Her_vector {
    template<typename T>
        class Vector { /* ... */ };
     //...
}

namespace My_lib {
    using namespace His_string;
    using namespace Her_vector;
    void my_fct(String&);
}
Given this, we can now write the program in terms of My_lib:

Click here to view code image

void f()
{
     My_lib::String s = "Byron";     // finds My_lib::His_string::String
      //...
}

using namespace My_lib;

void g(Vector<String>& vs)
{
      //...
     my_fct(vs[5]);
      //...
}
If an explicitly qualified name (such as My_lib::String) isn’t declared in the namespace mentioned, the compiler looks in namespaces mentioned in using-directives (such as His_string).

Only if we need to define something do we need to know the real namespace of an entity:

Click here to view code image

void My_lib::fill(char c)       // error: no fill() declared in My_lib
{
      //...
}

void His_string::fill(char c)   // OK: fill() declared in His_string
{
      //...
}

void My_lib::my_fct(String& v) // OK: String is My_lib::String, meaning His_string::String
{
      //...
}
Ideally, a namespace should

[1] express a logically coherent set of features,

[2] not give users access to unrelated features, and

[3] not impose a significant notational burden on users.

Together with the #include mechanism (§15.2.2), the composition techniques presented here and in the following subsections provide strong support for this.

14.4.4. Composition and Selection
Combining composition (by using-directives) with selection (by using-declarations) yields the flexibility needed for most real-world examples. With these mechanisms, we can provide access to a variety of facilities in such a way that we resolve name clashes and ambiguities arising from their composition. For example:

Click here to view code image

namespace His_lib {
    class String { /* ... */ };
    template<typename T>
        class Vector { /* ... */ };
     //...
}

namespace Her_lib {
    template<typename T>
        class Vector { /* ... */ };
    class String { /* ... */ };
     //...
}

namespace My_lib {
    using namespace His_lib;         // everything from His_lib
    using namespace Her_lib;         // everything from Her_lib

    using His_lib::String;           // resolve potential clash in favor of His_lib
    using Her_lib::Vector;           // resolve potential clash in favor of Her_lib

    template<typename T>
         class List { /* ... */ };   // additional stuff
     //...
}
When looking into a namespace, names explicitly declared there (including names declared by using-declarations) take priority over names made accessible in another scope by a using-directive (see also §14.4.1). Consequently, a user of My_lib will see the name clashes for String and Vector resolved in favor of His_lib::String and Her_lib::Vector. Also, My_lib::List will be used by default independently of whether His_lib or Her_lib is providing a List.

Usually, I prefer to leave a name unchanged when including it into a new namespace. Then, I don’t have to remember two different names for the same entity. However, sometimes a new name is needed or simply nice to have. For example:

Click here to view code image

namespace Lib2 {
    using namespace His_lib;     // everything from His_lib
    using namespace Her_lib;     // everything from Her_lib

    using His_lib::String;       // resolve potential clash in favor of His_lib
    using Her_lib::Vector;       // resolve potential clash in favor of Her_lib

    using Her_string = Her_lib::String;                 // rename
    template<typename T>
        using His_vec = His_lib::Vector<T>;       // rename


    template<typename T>
         class List { /* ... */ };      // additional stuff
     //...
}
There is no general language mechanism for renaming, but for types and templates, we can introduce aliases with using (§3.4.5, §6.5).

14.4.5. Namespaces and Overloading
Function overloading (§12.3) works across namespaces. This is essential to allow us to migrate existing libraries to use namespaces with minimal source code changes. For example:

 // old A.h:
       void f(int);
        //...

 // old B.h:
       void f(char);
        //...

 // old user.c:
       #include "A.h"
       #include "B.h"

       void g()
       {
            f('a');  // calls the f() from B.h
       }
This program can be upgraded to a version using namespaces without changing the actual code:

Click here to view code image

 // new A.h:


      namespace A {
          void f(int);
           //...
      }

 // new B.h:


      namespace B {
          void f(char);
           //...
      }

 // new user.c:


      #include "A.h"
      #include "B.h"


      using namespace A;
      using namespace B;


      void g()
      {
           f('a');      // calls the f() from B.h
      }
Had we wanted to keep user.c completely unchanged, we would have placed the using-directives in the header files. However, it is usually best to avoid using-directives in header files, because putting them there greatly increases the chances of name clashes.

This overloading rule also provides a mechanism for extending libraries. For example, people often wonder why they have to explicitly mention a sequence to manipulate a container using a standard-library algorithm. For example:

sort(v.begin(),v.end());
Why not write:

sort(v);
The reason is the need for generality (§32.2), but manipulating a container is by far the most common case. We can accommodate that case like this:

Click here to view code image

#include<algorithm>

namespace Estd {
    using namespace std;
    template<typename C>
        void sort(C& c) { std::sort(c.begin(),c.end()); }
    template<typename C, typename P>
        void sort(C& c, P p) { std::sort(c.begin(),c.end(),p); }
}
Estd (my “extended std”) provides the frequently wanted container versions of sort(). Those are of course implemented using std::sort() from <algorithm>. We can use it like this:

Click here to view code image

using namespace Estd;

template<typename T>
void print(const vector<T>& v)
{
     for (auto& x : v)
           cout << x << ' ';
     cout << '\n';
}

void f()
{
     std::vector<int> v {7, 3, 9, 4, 0, 1};

     sort(v);
     print(v);
     sort(v,[](int x, int y) { return x>y; });
     print(v);
     sort(v.begin(),v.end());
     print(v);
     sort(v.begin(),v.end(),[](int x, int y) { return x>y; });
     print(v);
}
The namespace lookup rules and the overloading rules for templates ensure that we find and invoke the correct variants of sort() and get the expected output:

0 1 3 4 7 9
9 7 4 3 1 0
0 1 3 4 7 9
9 7 4 3 1 0
If we removed the using namespace std; from Estd, this example would still work because std’s sort()s would be found by argument-dependent lookup (§14.2.4). However, we would then not find the standard sort()s for our own containers defined outside std.

14.4.6. Versioning
The toughest test for many kinds of interfaces is to cope with a sequence of new releases (versions). Consider a widely used interface, say, an ISO C++ standard header. After some time, a new version is defined, say, the C++11 version of the C++98 header. Functions may have been added, classes renamed, proprietary extensions (that should never have been there) removed, types changed, templates modified. To make life “interesting” for the implementer, hundreds of millions of lines of code are “out there” using the old header, and the implementer of the new version cannot ever see or modify them. Needless to say, breaking such code will cause howls of outrage, as will the absence of a new and better version. The namespace facilities described so far can be used to handle this problem with very minor exceptions, but when large amounts of code are involved, “very minor” still means a lot of code. Consequently, there is a way of selecting between two versions that simply and obviously guarantees that a user sees exactly one particular version. This is called an inline namespace:

Click here to view code image

namespace Popular {

    inline namespace V3_2 {  // V3_2 provides the default meaning of Popular
          double f(double);
          int f(int);
          template<typename T>
              class C { /* ... */ };
    }
    namespace V3_0 {
         //...
    }
    namespace V2_4_2 {
        double f(double);
        template<typename T>
             class C { /* ... */ };
    }
}
Here, Popular contains three subnamespaces, each defining a version. The inline specifies that V3_2 is the default meaning of Popular. So we can write:

Click here to view code image

using namespace Popular;

void f()
{
     f(1);            // Popular::V3_2::f(int)
     V3_0::f(1);            // Popular::V3_0::f(double)
     V2_4_2::f(1);    // Popular::V2_4_2::f(double)
}

template<typename T>
Popular::C<T*> { /* ... */ };
This inline namespace solution is intrusive; that is, to change which version (subnamespace) is the default requires modification of the header source code. Also, naively using this way of handling versioning would involve a lot of replication (of common code in the different versions). However, that replication can be minimized using #include tricks. For example:

Click here to view code image

// file V3_common.h:
        // ... lots of declarations ...

// file V3_2.h:

        namespace V3_2 {
            double f(double);
            int f(int);
            template<typename T>
                class C {
                    // ...
                };
            #include "V3_common"
        }

// file V3_0.h:

        namespace V3_0 {
            #include "V3_common"
        }

 // file Popular.h:

        namespace Popular {
            inline
            #include "V3_2.h"
            #include "V3_0.h"
            #include "V2_4_2.h"
        }
I do not recommend such intricate use of header files unless it is really necessary. The example above repeatedly violates the rules against including into a nonlocal scope and against having a syntactic construct span file boundaries (the use of inline); see §15.2.2. Sadly, I have seen worse.

In most cases, we can achieve versioning by less intrusive means. The only example I can think of that is completely impossible to do by other means is the specialization of a template explicitly using the namespace name (e.g., Popular::C<T*>). However, in many important cases “in most cases” isn’t good enough. Also, a solution based on a combination of other techniques is less obviously completely right.

14.4.7. Nested Namespaces
One obvious use of namespaces is to wrap a complete set of declarations and definitions in a separate namespace:

namespace X {
     //... all my declarations ...
}
The list of declarations will, in general, contain namespaces. Thus, nested namespaces are allowed. This is allowed for practical reasons, as well as for the simple reason that constructs ought to nest unless there is a strong reason for them not to. For example:

void h();

namespace X {
    void g();
     //...
    namespace Y {
        void f();
        void ff();
         //...
    }
}
The usual scope and qualification rules apply:

void X::Y::ff()
{
     f(); g(); h();
}

void X::g()
{
     f();       // error: no f() in X
     Y::f();    // OK
}

void h()
{
     f();            // error: no global f()
     Y::f();         // error: no global Y
     X::f();         // error: no f() in X
     X::Y::f();      // OK
}
For examples of nested namespaces in the standard library, see chrono (§35.2) and rel_ops (§35.5.3).

14.4.8. Unnamed Namespaces
It is sometimes useful to wrap a set of declarations in a namespace simply to protect against the possibility of name clashes. That is, the aim is to preserve locality of code rather than to present an interface to users. For example:

#include "header.h"
namespace Mine {
    int a;
    void f() { /* ... */ }
    int g() { /* ... */ }
}
Since we don’t want the name Mine to be known outside a local context, it simply becomes a bother to invent a redundant global name that might accidentally clash with someone else’s names. In that case, we can simply leave the namespace without a name:

#include "header.h"
namespace {
    int a;
    void f() { /* ... */ }
    int g() { /* ... */ }
}
Clearly, there has to be some way of accessing members of an unnamed namespace from outside the unnamed namespace. Consequently, an unnamed namespace has an implied using-directive. The previous declaration is equivalent to

namespace $$$ {
    int a;
    void f() { /* ... */ }
    int g() { /* ... */ }
}
using namespace $$$;
where $$$ is some name unique to the scope in which the namespace is defined. In particular, unnamed namespaces in different translation units are different. As desired, there is no way of naming a member of an unnamed namespace from another translation unit.

14.4.9. C Headers
Consider the canonical first C program:

#include <stdio.h>

int main()
{
     printf("Hello, world!\n");
}
Breaking this program wouldn’t be a good idea. Making standard libraries special cases isn’t a good idea either. Consequently, the language rules for namespaces are designed to make it relatively easy to take a program written without namespaces and turn it into a more explicitly structured one using namespaces. In fact, the calculator program (§10.2) is an example of this.

One way to provide the standard C I/O facilities in a namespace would be to place the declarations from the C header stdio.h in a namespace std:

 // cstdio:

       namespace std {
           int printf(const char* ... );
            //...
       }
Given this <cstdio>, we could provide backward compatibility by adding a using-directive:

 // stdio.h:

      #include<cstdio>
      using namespace std;
This <stdio.h> makes the Hello, world! program compile. Unfortunately, the using-directive makes every name from namespace std accessible in the global namespace. For example:

Click here to view code image

#include<vector>     // carefully avoids polluting the global namespace
vector v1;           // error: no "vector" in global scope
#include<stdio.h>    // contains a "using namespace std;"
vector v2;           // oops: this now works
So the standard requires that <stdio.h> place only names from <cstdio> in the global scope. This can be done by providing a using-declaration for each declaration in <cstdio>:

 // stdio.h:

       #include<cstdio>
       using std::printf;
       // ...
Another advantage is that the using-declaration for printf() prevents a user from (accidentally or deliberately) defining a nonstandard printf() in the global scope. I consider nonlocal using-directives primarily a transition tool. I also use them for essential foundation libraries, such as the ISO C++ standard library (std). Most code referring to names from other namespaces can be expressed more clearly with explicit qualification and using-declarations.

The relationship between namespaces and linkage is described in §15.2.5.

14.5. Advice
[1] Use namespaces to express logical structure; §14.3.1.

[2] Place every nonlocal name, except main(), in some namespace; §14.3.1.

[3] Design a namespace so that you can conveniently use it without accidentally gaining access to unrelated namespaces; §14.3.3.

[4] Avoid very short names for namespaces; §14.4.2.

[5] If necessary, use namespace aliases to abbreviate long namespace names; §14.4.2.

[6] Avoid placing heavy notational burdens on users of your namespaces; §14.2.2, §14.2.3.

[7] Use separate namespaces for interfaces and implementations; §14.3.3.

[8] Use the Namespace::member notation when defining namespace members; §14.4.

[9] Use inline namespaces to support versioning; §14.4.6.

[10] Use using-directives for transition, for foundational libraries (such as std), or within a local scope; §14.4.9.

[11] Don’t put a using-directive in a header file; §14.2.3.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


14. Namespaces
15. Source Files and Programs
Part III: Abstraction Mechanisms
47h 26m remaining
15. Source Files and Programs
Form must follow function.

– Le Corbusier

• Separate Compilation

• Linkage

File-Local Names; Header Files; The One-Definition Rule; Standard-Library Headers; Linkage to Non-C++ Code; Linkage and Pointers to Functions

• Using Header Files

Single-Header Organization; Multiple-Header Organization; Include Guards

• Programs

Initialization of Nonlocal Variables; Initialization and Concurrency; Program Termination

• Advice

15.1. Separate Compilation
Any realistic program consists of many logically separate components (e.g., namespaces; Chapter 14). To better manage these components, we can represent the program as a set of (source code) files where each file contains one or more logical components. Our task is to devise a physical structure (set of files) for the program that represents the logical components in a consistent, comprehensible, and flexible manner. In particular, we aim for a clean separation of interfaces (e.g., function declarations) and implementations (e.g., function definitions). A file is the traditional unit of storage (in a file system) and the traditional unit of compilation. There are systems that do not store, compile, and present C++ programs to the programmer as sets of files. However, the discussion here will concentrate on systems that employ the traditional use of files.

Having a complete program in one file is usually impossible. In particular, the code for the standard libraries and the operating system is typically not supplied in source form as part of a user’s program. For realistically sized applications, even having all of the user’s own code in a single file is both impractical and inconvenient. The way a program is organized into files can help emphasize its logical structure, help a human reader understand the program, and help the compiler enforce that logical structure. Where the unit of compilation is a file, all of the file must be recompiled whenever a change (however small) has been made to it or to something on which it depends. For even a moderately sized program, the amount of time spent recompiling can be significantly reduced by partitioning the program into files of suitable size.

A user presents a source file to the compiler. The file is then preprocessed; that is, macro processing (§12.6) is done and #include directives bring in headers (§2.4.1, §15.2.2). The result of preprocessing is called a translation unit. This unit is what the compiler proper works on and what the C++ language rules describe. In this book, I differentiate between source file and translation unit only where necessary to distinguish what the programmer sees from what the compiler considers.

To enable separate compilation, the programmer must supply declarations providing the type information needed to analyze a translation unit in isolation from the rest of the program. The declarations in a program consisting of many separately compiled parts must be consistent in exactly the same way the declarations in a program consisting of a single source file must be. Your system has tools to help ensure this. In particular, the linker can detect many kinds of inconsistencies. The linker is the program that binds together the separately compiled parts. A linker is sometimes (confusingly) called a loader. Linking can be done completely before a program starts to run. Alternatively, new code can be added to the running program (“dynamically linked”) later.

The organization of a program into source files is commonly called the physical structure of a program. The physical separation of a program into separate files should be guided by the logical structure of the program. The same dependency concerns that guide the composition of programs out of namespaces guide its composition into source files. However, the logical and physical structures of a program need not be identical. For example, it can be helpful to use several source files to store the functions from a single namespace, to store a collection of namespace definitions in a single file, or to scatter the definition of a namespace over several files (§14.3.3).

Here, we will first consider some technicalities relating to linking and then discuss two ways of breaking the desk calculator (§10.2, §14.3.1) into files.

15.2. Linkage
Names of functions, classes, templates, variables, namespaces, enumerations, and enumerators must be used consistently across all translation units unless they are explicitly specified to be local.

It is the programmer’s task to ensure that every namespace, class, function, etc., is properly declared in every translation unit in which it appears and that all declarations referring to the same entity are consistent. For example, consider two files:

 // file1.cpp:
       int x = 1;
       int f() { /* do something */ }

 // file2.cpp:
       extern int x;
       int f();
       void g() { x = f(); }
The x and f() used by g() in file2.cpp are the ones defined in file1.cpp. The keyword extern indicates that the declaration of x in file2.cpp is (just) a declaration and not a definition (§6.3). Had x been initialized, extern would simply be ignored because a declaration with an initializer is always a definition. An object must be defined exactly once in a program. It may be declared many times, but the types must agree exactly. For example:

 // file1.cpp:
       int x = 1;
       int b = 1;
       extern int c;

 // file2.cpp:
       int x;              // means "int x = 0;"
       extern double b;
       extern int c;
There are three errors here: x is defined twice, b is declared twice with different types, and c is declared twice but not defined. These kinds of errors (linkage errors) cannot be detected by a compiler that looks at only one file at a time. Many, however, are detectable by the linker. For example, all implementations I know of correctly diagnose the double definition of x. However, the inconsistent declarations of b are uncaught on popular implementations, and the missing definition of c is typically only caught if c is used.

Note that a variable defined without an initializer in the global or a namespace scope is initialized by default (§6.3.5.1). This is not the case for non-static local variables or objects created on the free store (§11.2).

Outside a class body, an entity must be declared before it is used (§6.3.4). For example:

Click here to view code image

 // file1.cpp:
       int g() { return f()+7; }  // error: f() not (yet) declared
       int f() { return x; }      // error: x not (yet) declared
       int x;
A name that can be used in translation units different from the one in which it was defined is said to have external linkage. All the names in the previous examples have external linkage. A name that can be referred to only in the translation unit in which it is defined is said to have internal linkage. For example:

Click here to view code image

static int x1 = 1;        // internal linkage: not accessible from other translation units
const char x2 = 'a';      // internal linkage: not accessible from other translation units
When used in namespace scope (including the global scope; §14.2.1), the keyword static (some-what illogically) means “not accessible from other source files” (i.e., internal linkage). If you wanted x1 to be accessible from other source files (“have external linkage”), you should remove the static. The keyword const implies default internal linkage, so if you wanted x2 to have external linkage, you need to precede its definitions with extern:

Click here to view code image

int x1 = 1;                  // external linkage: accessible from other translation units
extern const char x2 = 'a';  // external linkage: accessible from other translation units
Names that a linker does not see, such as the names of local variables, are said to have no linkage.

An inline function (§12.1.3, §16.2.8) must be defined identically in every translation unit in which it is used (§15.2.3). Consequently, the following example isn’t just bad taste; it is illegal:

 // file1.cpp:
       inline int f(int i) { return i; }

 // file2.cpp:
       inline int f(int i) { return i+1; }
Unfortunately, this error is hard for an implementation to catch, and the following – otherwise perfectly logical – combination of external linkage and inlining is banned to make life simpler for compiler writers:

Click here to view code image

 // file1.cpp:
       extern inline int g(int i);
       int h(int i) { return g(i); }  // error: g() undefined in this translation unit

 // file2.cpp:
       extern inline int g(int i) { return i+1; }
        //...
We keep inline function definitions consistent by using header files(§15.2.2). For example:

Click here to view code image

 // h.h:
    inline int next(int i) { return i+1; }

 // file1.cpp:
    #include "h.h"
    int h(int i) { return next(i); }    // fine

 // file2.cpp:
    #include "h.h"
     //...
By default, const objects (§7.5), constexpr objects (§10.4), type aliases (§6.5), and anything declared static (§6.3.4) in a namespace scope have internal linkage. Consequently, this example is legal (although potentially confusing):

 // file1.cpp:
       using T = int;
       const int x = 7;
       constexpr T c2 = x+1;

 // file2.cpp:
       using T = double;
       const int x = 8;
       constexpr T c2 = x+9;
To ensure consistency, place aliases, consts, constexprs, and inlines in header files (§15.2.2).

A const can be given external linkage by an explicit declaration:

 // file1.cpp:
       extern const int a = 77;

 // file2.cpp:
       extern const int a;

       void g()
       {
           cout << a << '\n';
       }
Here, g() will print 77.

The techniques for managing template definitions are described in §23.7.

15.2.1. File-Local Names
Global variables are in general best avoided because they cause maintenance problems. In particular, it is hard to know where in a program they are used, and they can be a source of data races in multi-threaded programs (§41.2.4), leading to very obscure bugs.

Placing variables in a namespace helps a bit, but such variables are still subject to data races.

If you must use global variables, at least restrict their use to a single source file. This restriction can be achieved in one of two ways:

[1] Place declarations in an unnamed namespace.

[2] Declare an entity static.

An unnamed namespace (§14.4.8) can be used to make names local to a compilation unit. The effect of an unnamed namespace is very similar to that of internal linkage. For example:

 // file 1.cpp:
       namespace {
           class X { /* ... */ };
           void f();
           int i;
            //...
       }

 // file2.cpp:
       class X { /* ... */ };
       void f();
       int i;
        //...
The function f() in file1.cpp is not the same function as the f() in file2.cpp. Having a name local to a translation unit and also using that same name elsewhere for an entity with external linkage is asking for trouble.

The keyword static (confusingly) means “use internal linkage” (§44.2.3). That’s an unfortunate leftover from the earliest days of C.

15.2.2. Header Files
The types in all declarations of the same object, function, class, etc., must be consistent. Consequently, the source code submitted to the compiler and later linked together must be consistent. One imperfect but simple method of achieving consistency for declarations in different translation units is to #include header files containing interface information in source files containing executable code and/or data definitions.

The #include mechanism is a text manipulation facility for gathering source program fragments together into a single unit (file) for compilation. Consider:

#include "to_be_included"
The #include-directive replaces the line in which the #include appears with the contents of the file to_be_included. The content of to_be_included should be C++ source text because the compiler will proceed to read it.

To include standard-library headers, use the angle brackets, < and >, around the name instead of quotes. For example:

Click here to view code image

#include <iostream>      // from standard include directory
#include "myheader.h"    // from current directory
Unfortunately, spaces are significant within the < > or " " of an include directive:

#include < iostream >        // will not find <iostream>
It seems extravagant to recompile a source file each time it is included somewhere, but the text can be a reasonably dense encoding for program interface information, and the compiler need only analyze details actually used (e.g., template bodies are often not completely analyzed until instantiation time; §26.3). Furthermore, most modern C++ implementations provide some form of (implicit or explicit) precompiling of header files to minimize the work needed to handle repeated compilation of the same header.

As a rule of thumb, a header may contain:

Named namespaces

namespace N { /* ... */}

inline namespaces

inline namespace N { /* ... */}

Type definitions

struct Point { int x, y; };

Template declarations

template<typename T> class Z;

Template definitions

template<typename T> class V { /* ... */};

Function declarations

extern int strlen(const char*);

inline function definitions

inline char get(char* p) { /* ... */}

constexpr function definitions

constexpr int fac(int n) { return (n<2) ? 1 : n*fac(n-1); }

Data declarations

extern int a;

const definitions

const float pi = 3.141593;

constexpr definitions

constexpr float pi2 = pi* pi;

Enumerations

enum class Light { red, yellow, green };

Name declarations

class Matrix;

Type aliases

using valuetype = long;

Compile-time assertions

static_assert(4<=sizeof(int),"small ints");

Include directives

#include<algorithm>

Macro definitions

#define VERSION 12.03

Conditional compilation directives

#ifdef cplusplus

Comments

/* check for end of file */

This rule of thumb for what may be placed in a header is not a language requirement. It is simply a reasonable way of using the #include mechanism to express the physical structure of a program. Conversely, a header should never contain:

Ordinary function definitions

char get(char* p) {return *p++; }

Data definitions

int a;

Aggregate definitions

short tbl[] = { 1, 2, 3 };

Unnamed namespaces

namespace { /* ... */}

using-directives

using namespace Foo;

Including a header containing such definitions will lead to errors or (in the case of the using-directive) to confusion. Header files are conventionally suffixed by .h, and files containing function or data definitions are suffixed by .cpp. They are therefore often referred to as “.h files” and “.cpp files,” respectively. Other conventions, such as .c, .C, .cxx, .cc, .hh, and .hpp are also found. The manual for your compiler will be quite specific about this issue.

The reason for recommending that the definition of simple constants, but not the definition of aggregates, be placed in header files is that it is hard for implementations to avoid replication of aggregates presented in several translation units. Furthermore, the simple cases are far more common and therefore more important for generating good code.

It is wise not to be too clever about the use of #include. My recommendations are:

• #include only as headers (don’t #include “ordinary source code containing variable definitions and non-inline functions”).

• #include only complete declarations and definitions.

• #include only in the global scope, in linkage specification blocks, and in namespace definitions when converting old code (§15.2.4).

• Place all #includes before other code to minimize unintended dependencies.

• Avoid macro magic.

• Minimize the use of names (especially aliases) not local to a header in a header.

One of my least favorite activities is tracking down an error caused by a name being macro-substituted into something completely different by a macro defined in an indirectly #included header that I have never even heard of.

15.2.3. The One-Definition Rule
A given class, enumeration, template, etc., must be defined exactly once in a program.

From a practical point of view, this means that there must be exactly one definition of, say, a class residing in a single file somewhere. Unfortunately, the language rule cannot be that simple. For example, the definition of a class may be composed through macro expansion (ugh!), and a definition of a class may be textually included in two source files by #include directives (§15.2.2). Worse, a “file” isn’t a concept that is part of the C++ language definition; there exist implementations that do not store programs in source files.

Consequently, the rule in the standard that says that there must be a unique definition of a class, template, etc., is phrased in a somewhat more complicated and subtle manner. This rule is commonly referred to as the one-definition rule (“the ODR”). That is, two definitions of a class, template, or inline function are accepted as examples of the same unique definition if and only if

[1] they appear in different translation units, and

[2] they are token-for-token identical, and

[3] the meanings of those tokens are the same in both translation units.

For example:

 // file1.cpp:
       struct S { int a; char b; };
       void f(S*);

 // file2.cpp:
       struct S { int a; char b; };
       void f(S* p) { /* ... */ }
The ODR says that this example is valid and that S refers to the same class in both source files. However, it is unwise to write out a definition twice like that. Someone maintaining file2.cpp will naturally assume that the definition of S in file2.cpp is the only definition of S and so feel free to change it. This could introduce a hard-to-detect error.

The intent of the ODR is to allow inclusion of a class definition in different translation units from a common source file. For example:

 // s.h:
       struct S { int a; char b; };
       void f(S*);

 // file1.cpp:
       #include "s.h"
        // use f() here

 // file2.cpp:
       #include "s.h"
       void f(S* p) { /* ... */ }
or graphically:



Here are examples of the three ways of violating the ODR:

Click here to view code image

 // file1.cpp:
       struct S1 { int a; char b; };

       struct S1 { int a; char b; };     // error: double definition
This is an error because a struct may not be defined twice in a single translation unit.

Click here to view code image

 // file1.cpp:
       struct S2 { int a; char b; };

 // file2.cpp:
       struct S2 { int a; char bb; };    // error
This is an error because S2 is used to name classes that differ in a member name.

 // file1.cpp:
       typedef int X;
       struct S3 { X a; char b; };

 // file2.cpp:
       typedef char X;
       struct S3 { X a; char b; };  // error
Here the two definitions of S3 are token-for-token identical, but the example is an error because the meaning of the name X has sneakily been made to differ in the two files.

Checking against inconsistent class definitions in separate translation units is beyond the ability of most C++ implementations. Consequently, declarations that violate the ODR can be a source of subtle errors. Unfortunately, the technique of placing shared definitions in headers and #includeing them doesn’t protect against this last form of ODR violation. Local type aliases and macros can change the meaning of #included declarations:

 // s.h:
       struct S { Point a; char b; };

 // file1.cpp:
       #define Point int
       #include "s.h"
        //...

 // file2.cpp:
       class Point { /* ... */ };
       #include "s.h"
        //...
The best defense against this kind of hackery is to make headers as self-contained as possible. For example, if class Point had been declared in the s.h header, the error would have been detected.

A template definition can be #included in several translation units as long as the ODR is adhered to. This applies even to function template definitions and to class templates containing member function definitions.

15.2.4. Standard-Library Headers
The facilities of the standard library are presented through a set of standard headers (§4.1.2, §30.2). No suffix is needed for standard-library headers; they are known to be headers because they are included using the #include<...> syntax rather than #include"...". The absence of a .h suffix does not imply anything about how the header is stored. A header such as <map> is usually stored as a text file called map.h in some standard directory. On the other hand, standard headers are not required to be stored in a conventional manner. An implementation is allowed to take advantage of knowledge of the standard-library definition to optimize the standard-library implementation and the way standard headers are handled. For example, an implementation might have knowledge of the standard math library (§40.3) built in and treat #include<cmath> as a switch that makes the standard math functions available without actually reading any file.

For each C standard-library header <X.h>, there is a corresponding standard C++ header <cX>. For example, #include<cstdio> provides what #include<stdio.h> does. A typical stdio.h will look something like this:

Click here to view code image

#ifdef __cplusplus       // for C++ compilers only (§15.2.5)
namespace std {          // the standard library is defined in namespace std (§4.1.2)
extern "C" {             // stdio functions have C linkage (§15.2.5)
#endif
     /* ... */
     int printf(const char*, ...);
     /* ... */
#ifdef __cplusplus
}
}
 //...
using std::printf;  // make printf available in global namespace
 //...
#endif
That is, the actual declarations are (most likely) shared, but linkage and namespace issues must be addressed to allow C and C++ to share a header. The macro __cplusplus is defined by the C++ compiler (§12.6.2) and can be used to distinguish C++ code from code intended for a C compiler.

15.2.5. Linkage to Non-C++ Code
Typically, a C++ program contains parts written in other languages (e.g., C or Fortran). Similarly, it is common for C++ code fragments to be used as parts of programs written mainly in some other language (e.g., Python or Matlab). Cooperation can be difficult between program fragments written in different languages and even between fragments written in the same language but compiled with different compilers. For example, different languages and different implementations of the same language may differ in their use of machine registers to hold arguments, the layout of arguments put on a stack, the layout of built-in types such as strings and integers, the form of names passed by the compiler to the linker, and the amount of type checking required from the linker. To help, one can specify a linkage convention to be used in an extern declaration. For example, this declares the C and C++ standard-library function strcpy() and specifies that it should be linked according to the (system-specific) C linkage conventions:

extern "C" char* strcpy(char*, const char*);
The effect of this declaration differs from the effect of the “plain” declaration

extern char* strcpy(char*, const char*);
only in the linkage convention used for calling strcpy().

The extern "C" directive is particularly useful because of the close relationship between C and C++. Note that the C in extern "C" names a linkage convention and not a language. Often, extern "C" is used to link to Fortran and assembler routines that happen to conform to the conventions of a C implementation.

An extern "C" directive specifies the linkage convention (only) and does not affect the semantics of calls to the function. In particular, a function declared extern "C" still obeys the C++ type-checking and argument conversion rules and not the weaker C rules. For example:

Click here to view code image

extern "C" int f();

int g()
{
    return f(1);       // error: no argument expected
}
Adding extern "C" to a lot of declarations can be a nuisance. Consequently, there is a mechanism to specify linkage to a group of declarations. For example:

Click here to view code image

extern "C" {
    char* strcpy(char*, const char*);
    int strcmp(const char*, const char*);
    int strlen(const char*);
     //...
}
This construct, commonly called a linkage block, can be used to enclose a complete C header to make a header suitable for C++ use. For example:

extern "C" {
#include <string.h>
}
This technique is commonly used to produce a C++ header from a C header. Alternatively, conditional compilation (§12.6.1) can be used to create a common C and C++ header:

Click here to view code image

#ifdef __cplusplus
extern "C" {
#endif
    char* strcpy(char*, const char*);
    int strcmp(const char*, const char*);
    int strlen(const char*);
     //...
#ifdef __cplusplus
}
#endif
The predefined macro name __cplusplus (§12.6.2) is used to ensure that the C++ constructs are edited out when the file is used as a C header.

Any declaration can appear within a linkage block:

Click here to view code image

extern "C" {         // any declaration here, for example:
    int g1;          // definition
    extern int g2;   // declaration, not definition
}
In particular, the scope and storage class (§6.3.4, §6.4.2) of variables are not affected, so g1 is still a global variable – and is still defined rather than just declared. To declare but not define a variable, you must apply the keyword extern directly in the declaration. For example:

Click here to view code image

extern "C" int g3;         // declaration, not definition
extern "C" { int g4; }     // definition
This looks odd at first glance. However, it is a simple consequence of keeping the meaning unchanged when adding "C" to an extern-declaration and the meaning of a file unchanged when enclosing it in a linkage block.

A name with C linkage can be declared in a namespace. The namespace will affect the way the name is accessed in the C++ program, but not the way a linker sees it. The printf() from std is a typical example:

Click here to view code image

#include<cstdio>

void f()
{
    std::printf("Hello, ");      // OK
    printf("world!\n");          // error: no global printf()
}
Even when called std::printf, it is still the same old C printf() (§43.3).

Note that this allows us to include libraries with C linkage into a namespace of our choice rather than polluting the global namespace. Unfortunately, the same flexibility is not available to us for headers defining functions with C++ linkage in the global namespace. The reason is that linkage of C++ entities must take namespaces into account so that the object files generated will reflect the use or lack of use of namespaces.

15.2.6. Linkage and Pointers to Functions
When mixing C and C++ code fragments in one program, we sometimes want to pass pointers to functions defined in one language to functions defined in the other. If the two implementations of the two languages share linkage conventions and function call mechanisms, such passing of pointers to functions is trivial. However, such commonality cannot in general be assumed, so care must be taken to ensure that a function is called the way it expects to be called.

When linkage is specified for a declaration, the specified linkage applies to all function types, function names, and variable names introduced by the declaration(s). This makes all kinds of strange – and occasionally essential – combinations of linkage possible. For example:

Click here to view code image

typedef int (*FT)(const void*, const void*);                   // FT has C++ linkage

extern "C" {
    typedef int (*CFT)(const void*, const void*);              // CFT has C linkage
    void qsort(void* p, size_t n, size_t sz, CFT cmp);         // cmp has C linkage
}

void isort(void* p, size_t n, size_t sz, FT cmp);              // cmp has C++ linkage
void xsort(void* p, size_t n, size_t sz, CFT cmp);             // cmp has C linkage
extern "C" void ysort(void* p, size_t n, size_t sz, FT cmp);   // cmp has C++ linkage

int compare(const void*, const void*);                         // compare() has C++ linkage
extern "C" int ccmp(const void*, const void*);                 // ccmp() has C linkage

void f(char* v, int sz)
{
    qsort(v,sz,1,&compare);  // error
    qsort(v,sz,1,&ccmp);            // OK

    isort(v,sz,1,&compare);  // OK
    isort(v,sz,1,&ccmp);     // error
}
An implementation in which C and C++ use the same calling conventions might accept the declarations marked error as a language extension. However, even for compatible C and C++ implementations, std::function (§33.5.3) or lambdas with any form of capture (§11.4.3) cannot cross the language barrier.

15.3. Using Header Files
To illustrate the use of headers, I present a few alternative ways of expressing the physical structure of the calculator program (§10.2, §14.3.1).

15.3.1. Single-Header Organization
The simplest solution to the problem of partitioning a program into several files is to put the definitions in a suitable number of .cpp files and to declare the types, functions, classes, etc., needed for them to cooperate in a single .h file that each .cpp file #includes. That’s the initial organization I would use for a simple program for my own use; if something more elaborate turned out to be needed, I would reorganize later.

For the calculator program, we might use five .cpp files – lexer.cpp, parser.cpp, table.cpp, error.cpp, and main.cpp – to hold function and data definitions. The header dc.h holds the declarations of every name used in more than one .cpp file:

Click here to view code image

// dc.h:

#include <map>
#include<string>
#include<iostream>
using namespace std;   // dc.h is not meant to be a self-contained header

namespace Parser {
    double expr(bool);
    double term(bool);
    double prim(bool);
}

namespace Lexer {
    enum class Kind : char {
        name, number, end,
        plus='+', minus='-', mul='*', div='/', print=';', assign='=', lp='(', rp=')'
    };

    struct Token {
        Kind kind;
        string string_value;
        double number_value;
    };

    class Token_stream {
    public:
        Token(istream& s) : ip{&s}, owns(false}, ct{Kind::end} { }
        Token(istream*  p) : ip{p}, owns{true}, ct{Kind::end} { }

        ~Token() { close(); }

        Token get();           // read and return next token
        Token& current();      // most recently read token

        void set_input(istream& s) { close(); ip = &s; owns=false; }
        void set_input(istream*  p) { close(); ip = p; owns = true; }
    private:
        void close() { if (owns) delete ip; }

        istream*  ip;      // pointer to an input stream
        bool owns;                   // does the Token_stream own the istream?
        Token ct {Kind::end};        // current_token
    };

    extern Token_stream ts;
}
namespace Table {
    extern map<string,double> table;
}

namespace Error {
    extern int no_of_errors;
    double error(const string& s);
}

namespace Driver {
    void calculate();
}
The keyword extern is used for every variable declaration to ensure that multiple definitions do not occur as we #include dc.h in the various .cpp files. The corresponding definitions are found in the appropriate .cpp files.

I added standard-library headers as needed for the declarations in dc.h, but I did not add declarations (such as using-declarations) needed only for the convenience of an individual .cpp file.

Leaving out the actual code, lexer.cpp will look something like this:

Click here to view code image

 // lexer.cpp:

#include "dc.h"
#include <cctype>
#include <iostream>    // redundant: in dc.h

Lexer::Token_stream ts;

Lexer::Token Lexer::Token_stream::get() { /* ... */ }
Lexer::Token& Lexer::Token_stream::current() { /* ... */ }
I used explicit qualification, Lexer::, for the definitions rather than simply enclosing them all in

namespace Lexer { /* ... */ }
That avoids the possibility of accidentally adding new members to Lexer. On the other hand, had I wanted to add members to Lexer that were not part of its interface, I would have had to reopen the namespace (§14.2.5).

Using headers in this manner ensures that every declaration in a header will at some point be included in the file containing its definition. For example, when compiling lexer.cpp the compiler will be presented with:

Click here to view code image

namespace Lexer {  // from dc.h
     //...
    class Token_stream {
    public:
         Token get();
          //...
    };
}
 //...

Lexer::Token Lexer::Token_stream::get() { /* ... */ }
This ensures that the compiler will detect any inconsistencies in the types specified for a name. For example, had get() been declared to return a Token, but defined to return an int, the compilation of lexer.cpp would have failed with a type-mismatch error. If a definition is missing, the linker will catch the problem. If a declaration is missing, some .cpp files will fail to compile.

File parser.cpp will look like this:

 // parser.cpp:

#include "dc.h"

double Parser::prim(bool get) { /* ... */ }
double Parser::term(bool get) { /* ... */ }
double Parser::expr(bool get) { /* ... */ }
File table.cpp will look like this:

Click here to view code image

 // table.cpp:

#include "dc.h"

std::map<std::string,double> Table::table;
The symbol table is a standard-library map.

File error.cpp becomes:

Click here to view code image

 // error.cpp:

#include "dc.h" 
 // any more #includes or declarations

int Error::no_of_errors;
double Error::error(const string& s) { /* ... */ }
Finally, file main.cpp will look like this:

Click here to view code image

 // main.cpp:

#include "dc.h"
#include <sstream>
#include <iostream>    // redundant: in dc.h

void Driver::calculate() { /* ... */ }

int main(int argc, char* argv[]) { /* ... */ }
To be recognized as the main() of the program, main() must be a global function (§2.2.1, §15.4), so no namespace is used here.

The physical structure of the system can be presented like this:



The headers on the top are all headers for standard-library facilities. For many forms of program analysis, these libraries can be ignored because they are well known and stable. For tiny programs, the structure can be simplified by moving all #include directives to the common header. Similarly, for a small program, separating out error.cpp and table.cpp from main.cpp would often be excessive.

This single-header style of physical partitioning is most useful when the program is small and its parts are not intended to be used separately. Note that when namespaces are used, the logical structure of the program is still represented within dc.h. If namespaces are not used, the structure is obscured, although comments can be a help.

For larger programs, the single-header-file approach is unworkable in a conventional file-based development environment. A change to the common header forces recompilation of the whole program, and updates of that single header by several programmers are error-prone. Unless strong emphasis is placed on programming styles relying heavily on namespaces and classes, the logical structure deteriorates as the program grows.

15.3.2. Multiple-Header Organization
An alternative physical organization lets each logical module have its own header defining the facilities it provides. Each .cpp file then has a corresponding .h file specifying what it provides (its interface). Each .cpp file includes its own .h file and usually also other .h files that specify what it needs from other modules in order to implement the services advertised in the interface. This physical organization corresponds to the logical organization of a module. The interface for users is put into its .h file, the interface for implementers is put into a file suffixed _impl.h, and the module’s definitions of functions, variables, etc., are placed in .cpp files. In this way, the parser is represented by three files. The parser’s user interface is provided by parser.h:

Click here to view code image

 // parser.h:

namespace Parser {           // interface for users
    double expr(bool get);
}
The shared environment for the functions expr(), prim(), and term(), implementing the parser is presented by parser_impl.h:

Click here to view code image

 // parser_impl.h:

#include "parser.h"
#include "error.h"
#include "lexer.h"

using Error::error;
using namespace Lexer;

namespace Parser {            // interface for implementers
    double prim(bool get);
    double term(bool get);
    double expr(bool get);
}
The distinction between the user interface and the interface for implementers would be even clearer had we used a Parser_impl namespace (§14.3.3).

The user’s interface in header parser.h is #included to give the compiler a chance to check consistency (§15.3.1).

The functions implementing the parser are stored in parser.cpp together with #include directives for the headers that the Parser functions need:

Click here to view code image

 // parser.cpp:

#include "parser_impl.h"
#include "table.h"

using Table::table;

double Parser::prim(bool get) { /* ... */ }
double Parser::term(bool get) { /* ... */ }
double Parser::expr(bool get) { /* ... */ }
Graphically, the parser and the driver’s use of it look like this:



As intended, this is a rather close match to the logical structure described in §14.3.1. To simplify this structure, we could have #included table.h in parser_impl.h rather than in parser.cpp. However, table.h is an example of something that is not necessary to express the shared context of the parser functions; it is needed only by their implementation. In fact, it is used by just one function, prim(), so if we were really keen on minimizing dependencies we could place prim() in its own .cpp file and #include table.h there only:



Such elaboration is not appropriate except for larger modules. For realistically sized modules, it is common to #include extra files where needed for individual functions. Furthermore, it is not uncommon to have more than one _impl.h, since different subsets of the module’s functions need different shared contexts.

Please note that the _impl.h notation is not a standard or even a common convention; it is simply the way I like to name things.

Why bother with this more complicated scheme of multiple header files? It clearly requires far less thought simply to throw every declaration into a single header, as was done for dc.h.

The multiple-header organization scales to modules several magnitudes larger than our toy parser and to programs several magnitudes larger than our calculator. The fundamental reason for using this type of organization is that it provides a better localization of concerns. When analyzing and modifying a large program, it is essential for a programmer to focus on a relatively small chunk of code. The multiple-header organization makes it easy to determine exactly what the parser code depends on and to ignore the rest of the program. The single-header approach forces us to look at every declaration used by any module and decide if it is relevant. The simple fact is that maintenance of code is invariably done with incomplete information and from a local perspective. The multiple-header organization allows us to work successfully “from the inside out” with only a local perspective. The single-header approach – like every other organization centered around a global repository of information – requires a top-down approach and will forever leave us wondering exactly what depends on what.

The better localization leads to less information needed to compile a module, and thus to faster compiles. The effect can be dramatic. I have seen compile times drop by a factor of 1000 as the result of a simple dependency analysis leading to a better use of headers.

15.3.2.1. Other Calculator Modules
The remaining calculator modules can be organized similarly to the parser. However, those modules are so small that they don’t require their own _impl.h files. Such files are needed only where the implementation of a logical module consists of many functions that need a shared context (in addition to what is provided to users).

The error handler provides its interface in error.h:

Click here to view code image

 // error.h:

#include<string>

namespace Error {
    extern int number_of_errors;
    double error(const std::string&);
}
The implementation is found in error.cpp:

Click here to view code image

 // error.cpp:

#include "error.h"

int Error::number_of_errors;
double Error::error(const std::string&s) { /* ... */ }
The lexer provides a rather large and messy interface:

 // lexer.h:

#include<string>
#include<iostream>

namespace Lexer {

    enum class Kind : char {/* ... */ };

    class Token { /* ... */ };
    class Token_stream { /* ... */ };

    extern Token_stream ts;
}
In addition to lexer.h, the implementation of the lexer depends on error.h and on the character-classification functions in <cctype> (§36.2):

Click here to view code image

 // lexer.cpp:

#include "lexer.h"
#include "error.h"
#include <iostream>      // redundant: in lexer.h
#include <cctype>

Lexer::Token_stream ts {cin};  // defaults to "read from cin"

Lexer::Token Lexer::Token_stream::get() { /* ... */ };
Lexer::Token& Lexer::Token_stream::current() { /* ... */ };
We could have factored out the #include directive for error.h as the Lexer’s _impl.h file. However, I considered that excessive for this tiny program.

As usual, we #include the interface offered by the module – in this case, lexer.h – in the module’s implementation to give the compiler a chance to check consistency.

The symbol table is essentially self-contained, although the standard-library header <map> could drag in all kinds of interesting stuff to implement an efficient map template class:

Click here to view code image

 // table.h:

#include <map>
#include <string>

namespace Table {
    extern std::map<std::string,double> table;
}
Because we assume that every header may be #included in several .cpp files, we must separate the declaration of table from its definition:

Click here to view code image

 // table.cpp:

#include "table.h"

std::map<std::string,double> Table::table;
I just stuck the driver into main.cpp:

Click here to view code image

 // main.cpp:

#include "parser.h"
#include "lexer.h"     // to be able to set ts
#include "error.h"
#include "table.h"     // to be able to predefine names
#include <sstream>     // to be able to put main()'s arguments into a string stream

namespace Driver {
   void calculate() { /* ... */ }
} 

int main(int argc, char* argv[]) { /* ... */ }
For a larger system, it is usually worthwhile to separate out the driver and minimize what is done in main(). That way main() calls a driver function placed in a separate source file. This is particularly important for code intended to be used as a library. Then, we cannot rely on code in main() and must be prepared for the driver to be called from a variety of functions.

15.3.2.2. Use of Headers
The number of headers to use for a program is a function of many factors. Many of these factors have more to do with the way files are handled on your system than with C++. For example, if your editor/IDE does not make it convenient to look at several files simultaneously, then using many headers becomes less attractive.

A word of caution: a few dozen headers plus the standard headers for the program’s execution environment (which can often be counted in the hundreds) are usually manageable. However, if you partition the declarations of a large program into the logically minimal-size headers (putting each structure declaration in its own file, etc.), you can easily get an unmanageable mess of hundreds of files even for minor projects. I find that excessive.

For large projects, multiple headers are unavoidable. In such projects, hundreds of files (not counting standard headers) are the norm. The real confusion starts when they begin to be counted in the thousands. At that scale, the basic techniques discussed here still apply, but their management becomes a Herculean task. Tools, such as dependency analysers, can be of great help, but there is little they can do for compiler and linker performance if the program is an unstructured mess. Remember that for realistically sized programs, the single-header style is not an option. Such programs will have multiple headers. The choice between the two styles of organization occurs (repeatedly) for the parts that make up the program.

The single-header style and the multiple-header style are not really alternatives. They are complementary techniques that must be considered whenever a significant module is designed and must be reconsidered as a system evolves. It’s crucial to remember that one interface doesn’t serve all equally well. It is usually worthwhile to distinguish between the implementers’ interface and the users’ interface. In addition, many larger systems are structured so that providing a simple interface for the majority of users and a more extensive interface for expert users is a good idea. The expert users’ interfaces (“complete interfaces”) tend to #include many more features than the average user would ever want to know about. In fact, the average users’ interface can often be identified by eliminating features that require the inclusion of headers that define facilities that would be unknown to the average user. The term “average user” is not derogatory. In the fields in which I don’t have to be an expert, I strongly prefer to be an average user. In that way, I minimize hassles.

15.3.3. Include Guards
The idea of the multiple-header approach is to represent each logical module as a consistent, self-contained unit. Viewed from the program as a whole, many of the declarations needed to make each logical module complete are redundant. For larger programs, such redundancy can lead to errors, as a header containing class definitions or inline functions gets #included twice in the same compilation unit (§15.2.3).

We have two choices. We can

[1] reorganize our program to remove the redundancy, or

[2] find a way to allow repeated inclusion of headers.

The first approach – which led to the final version of the calculator – is tedious and impractical for realistically sized programs. We also need that redundancy to make the individual parts of the program comprehensible in isolation.

The benefits of an analysis of redundant #includes and the resulting simplifications of the program can be significant both from a logical point of view and by reducing compile times. However, it can rarely be complete, so some method of allowing redundant #includes must be applied. Preferably, it must be applied systematically, since there is no way of knowing how thorough an analysis a user will find worthwhile.

The traditional solution is to insert include guards in headers. For example:

 // error.h:

#ifndef CALC_ERROR_H
#define CALC_ERROR_H

namespace Error {
     //...
}

#endif    // CALC_ERROR_H
The contents of the file between the #ifndef and #endif are ignored by the compiler if CALC_ERROR_H is defined. Thus, the first time error.h is seen during a compilation, its contents are read and CALC_ERROR_H is given a value. Should the compiler be presented with error.h again during the compilation, the contents are ignored. This is a piece of macro hackery, but it works and it is pervasive in the C and C++ worlds. The standard headers all have include guards.

Header files are included in essentially arbitrary contexts, and there is no namespace protection against macro name clashes. Consequently, I choose rather long and ugly names for my include guards.

Once people get used to headers and include guards, they tend to include lots of headers directly and indirectly. Even with C++ implementations that optimize the processing of headers, this can be undesirable. It can cause unnecessarily long compile time, and it can bring lots of declarations and macros into scope. The latter might affect the meaning of the program in unpredictable and adverse ways. Headers should be included only when necessary.

15.4. Programs
A program is a collection of separately compiled units combined by a linker. Every function, object, type, etc., used in this collection must have a unique definition (§6.3, §15.2.3). A program must contain exactly one function called main() (§2.2.1). The main computation performed by the program starts with the invocation of the global function main() and ends with a return from main(). The return type of main() is int, and the following two versions of main() are supported by all implementations:

int main() { /* ... */ }
int main(int argc, char* argv[]) { /* ... */ }
A program can only provide one of those two alternatives. In addition, an implementation can allow other versions of main(). The argc, argv version is used to transmit arguments from the program’s environment; see §10.2.7.

The int returned by main() is passed to whatever system invoked main() as the result of the program. A nonzero return value from main() indicates an error.

This simple story must be elaborated on for programs that contain global variables (§15.4.1) or that throw an uncaught exception (§13.5.2.5).

15.4.1. Initialization of Nonlocal Variables
In principle, a variable defined outside any function (that is, global, namespace, and class static variables) is initialized before main() is invoked. Such nonlocal variables in a translation unit are initialized in their definition order. If such a variable has no explicit initializer, it is by default initialized to the default for its type (§17.3.3). The default initializer value for built-in types and enumerations is 0. For example:

double x = 2;       // nonlocal variables
double y;
double sqx = sqrt(x+y);
Here, x and y are initialized before sqx, so sqrt(2) is called.

There is no guaranteed order of initialization of global variables in different translation units. Consequently, it is unwise to create order dependencies between initializers of global variables in different compilation units. In addition, it is not possible to catch an exception thrown by the initializer of a global variable (§13.5.2.5). It is generally best to minimize the use of global variables and in particular to limit the use of global variables requiring complicated initialization.

Several techniques exist for enforcing an order of initialization of global variables in different translation units. However, none are both portable and efficient. In particular, dynamically linked libraries do not coexist happily with global variables that have complicated dependencies.

Often, a function returning a reference is a good alternative to a global variable. For example:

int& use_count()
{
    static int uc = 0;
    return uc;
}
A call use_count() now acts as a global variable except that it is initialized at its first use (§7.7). For example:

Click here to view code image

void f()
{
    cout << ++use_count();  // read and increment
     //...
}
Like other uses of static, this technique is not thread-safe. The initialization of a local static is thread-safe (§42.3.3). In this case, the initialization is even with a constant expression (§10.4), so that it is done at link time and not subject to data races (§42.3.3). However, the ++ can lead to a data race.

The initialization of nonlocal (statically allocated) variables is controlled by whatever mechanism an implementation uses to start up a C++ program. This mechanism is guaranteed to work properly only if main() is executed. Consequently, one should avoid nonlocal variables that require run-time initialization in C++ code intended for execution as a fragment of a non-C++ program.

Note that variables initialized by constant expressions (§10.4) cannot depend on the value of objects from other translation units and do not require run-time initialization. Such variables are therefore safe to use in all cases.

15.4.2. Initialization and Concurrency
Consider:

int x = 3;
int y = sqrt(++x);
What could be the values of x and y? The obvious answer is “3 and 2!” Why? The initialization of a statically allocated object with a constant expression is done at link time, so x becomes 3. However, y’s initializer is not a constant expression (sqrt() is no constexpr), so y is not initialized until run time. However, the order of initialization of statically allocated objects in a single translation unit is well defined: they are initialized in definition order (§15.4.1). So, y becomes 2.

The flaw in this argument is that if multiple threads are used (§5.3.1, §42.2), each will do the run-time initialization. No mutual exclusion is implicitly provided to prevent a data race. Then, sqrt(++x) in one thread may happen before or after the other thread manages to increment x. So, the value of y may be sqrt(4) or sqrt(5).

To avoid such problems, we should (as usual):

• Minimize the use of statically allocated objects and keep their initialization as simple as possible.

• Avoid dependencies on dynamically initialized objects in other translation units (§15.4.1).

In addition, to avoid data races in initialization, try these techniques in order:

[1] Initialize using constant expressions (note that built-in types without initializers are initialized to zero and that standard containers and strings are initialized to empty by link-time initialization).

[2] Initialize using expressions without side effects.

[3] Initialize in a known single-threaded “startup phase” of computation.

[4] Use some form of mutual exclusion (§5.3.4, §42.3).

15.4.3. Program Termination
A program can terminate in several ways:

[1] By returning from main()

[2] By calling exit()

[3] By calling abort()

[4] By throwing an uncaught exception

[5] By violating noexcept

[6] By calling quick_exit()

In addition, there are a variety of ill-behaved and implementation-dependent ways of making a program crash (e.g., dividing a double by zero).

If a program is terminated using the standard-library function exit(), the destructors for constructed static objects are called (§15.4.1, §16.2.12). However, if the program is terminated using the standard-library function abort(), they are not. Note that this implies that exit() does not terminate a program immediately. Calling exit() in a destructor may cause an infinite recursion. The type of exit() is:

void exit(int);
Like the return value of main() (§2.2.1), exit()’s argument is returned to “the system” as the value of the program. Zero indicates successful completion.

Calling exit() means that the local variables of the calling function and its callers will not have their destructors invoked. Throwing an exception and catching it ensures that local objects are properly destroyed (§13.5.1). Also, a call of exit() terminates the program without giving the caller of the function that called exit() a chance to deal with the problem. It is therefore often best to leave a context by throwing an exception and letting a handler decide what to do next. For example, main() may catch every exception (§13.5.2.2).

The C (and C++) standard-library function atexit() offers the possibility to have code executed at program termination. For example:

Click here to view code image

void my_cleanup();

void somewhere()
{
    if (atexit(&my_cleanup)==0) {
          // my_cleanup will be called at normal termination
    }
    else {
          // oops: too many atexit functions
    }
}
This strongly resembles the automatic invocation of destructors for global variables at program termination (§15.4.1, §16.2.12). An argument to atexit() cannot take arguments or return a result, and there is an implementation-defined limit to the number of atexit functions. A nonzero value returned by atexit() indicates that the limit is reached. These limitations make atexit() less useful than it appears at first glance. Basically, atexit() is a C workaround for the lack of destructors.

The destructor of a constructed statically allocated object (§6.4.2) created before a call of atexit(f) will be invoked after f is invoked. The destructor of such an object created after a call of atexit(f) will be invoked before f is invoked.

The quick_exit() function is like exit() except that it does not invoke any destructors. You register functions to be invoked by quick_exit() using at_quick_exit().

The exit(), abort(), quick_exit(), atexit(), and at_quick_exit() functions are declared in <cstdlib>.

15.5. Advice
[1] Use header files to represent interfaces and to emphasize logical structure; §15.1, §15.3.2.

[2] #include a header in the source file that implements its functions; §15.3.1.

[3] Don’t define global entities with the same name and similar-but-different meanings in different translation units; §15.2.

[4] Avoid non-inline function definitions in headers; §15.2.2.

[5] Use #include only at global scope and in namespaces; §15.2.2.

[6] #include only complete declarations; §15.2.2.

[7] Use include guards; §15.3.3.

[8] #include C headers in namespaces to avoid global names; §14.4.9, §15.2.4.

[9] Make headers self-contained; §15.2.3.

[10] Distinguish between users’ interfaces and implementers’ interfaces; §15.3.2.

[11] Distinguish between average users’ interfaces and expert users’ interfaces; §15.3.2.

[12] Avoid nonlocal objects that require run-time initialization in code intended for use as part of non-C++ programs; §15.4.1.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


15. Source Files and Programs
Part III: Abstraction Mechanisms
16. Classes
47h 26m remaining
Part III: Abstraction Mechanisms
This part describes C++’s facilities for defining and using new types. Techniques commonly called object-oriented programming and generic programming are presented.

Chapters

16 Classes

17 Construction, Cleanup, Copy, and Move

18 Operator Overloading

19 Special Operators

20 Derived Classes

21 Class Hierarchies

22 Run-Time Type Information

23 Templates

24 Generic Programming

25 Specialization

26 Instantiation

27 Templates and Hierarchies

28 Metaprogramming

29 A Matrix Design

“... there is nothing more difficult to carry out, nor more doubtful of success, nor more dangerous to handle, than to initiate a new order of things. For the reformer makes enemies of all those who profit by the old order, and only lukewarm defenders in all those who would profit by the new order...”

– Niccolò Machiavelli (“The Prince” §vi)


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


Part III: Abstraction Mechanisms
16. Classes
17. Construction, Cleanup, Copy, and Move
47h 26m remaining
16. Classes
Those types are not “abstract”; they are as real as int and float.

– Doug McIlroy

• Introduction

• Class Basics

Member Functions; Default Copying; Access Control; class and struct; Constructors; explicit Constructors; In-Class Initializers; In-Class Function Definitions; Mutability; Self-Reference; Member Access; static Members; Member Types

• Concrete Classes

Member Functions; Helper Functions; Overloaded Operators; The Significance of Concrete Classes

• Advice

16.1. Introduction
C++ classes are a tool for creating new types that can be used as conveniently as the built-in types. In addition, derived classes (§3.2.4, Chapter 20) and templates (§3.4, Chapter 23) allow the programmer to express (hierachical and parametric) relationships among classes and to take advantage of such relationships.

A type is a concrete representation of a concept (an idea, a notion, etc.). For example, the C++ built-in type float with its operations +, –, *, etc., provides a concrete approximation of the mathematical concept of a real number. A class is a user-defined type. We design a new type to provide a definition of a concept that has no direct counterpart among the built-in types. For example, we might provide a type Trunk_line in a program dealing with telephony, a type Explosion for a video game, or a type list<Paragraph> for a text-processing program. A program that provides types that closely match the concepts of the application tends to be easier to understand, easier to reason about, and easier to modify than a program that does not. A well-chosen set of user-defined types also makes a program more concise. In addition, it makes many sorts of code analysis feasible. In particular, it enables the compiler to detect illegal uses of objects that would otherwise be found only through exhaustive testing.

The fundamental idea in defining a new type is to separate the incidental details of the implementation (e.g., the layout of the data used to store an object of the type) from the properties essential to the correct use of it (e.g., the complete list of functions that can access the data). Such a separation is best expressed by channeling all uses of the data structure and its internal housekeeping routines through a specific interface.

This chapter focuses on relatively simple “concrete” user-defined types that logically don’t differ much from built-in types:

§16.2 Class Basics introduces the basic facilities for defining a class and its members.

§16.3 Concrete Classes discusses the design of elegant and efficient concrete classes.

The following chapters go into greater detail and presents abstract classes and class hierarchies:

Chapter 17

Construction, Cleanup, Copy, and Move presents the variety of ways to control initialization of objects of a class, how to copy and move objects, and how to provide “cleanup actions” to be performed when an object is destroyed (e.g., goes out of scope).

Chapter 18

Operator Overloading explains how to define unary and binary operators (such as +, *, and !) for user-defined types and how to use them.

Chapter 19

Special Operators considers how to define and use operators (such as [], (), –>, new) that are “special” in that they are commonly used in ways that differ from arithmetic and logical operators. In particular, this chapter shows how to define a string class.

Chapter 20

Derived Classes introduces the basic language features supporting object-oriented programming. Base and derived classes, virtual functions, and access control are covered.

Chapter 21

Class Hierarchies focuses on the use of base and derived classes to effectively organize code around the notion of class hierarchies. Most of this chapter is devoted to discussion of programming techniques, but technical aspects of multiple inheritance (classes with more than one base class) are also covered.

Chapter 22

Run-Time Type Information describes the techniques for explicitly navigating class hierarchies. In particular, the type conversion operations dynamic_cast and static_cast are presented, as is the operation for determining the type of an object given one of its base classes (typeid).

16.2. Class Basics
Here is a very brief summary of classes:

• A class is a user-defined type.

• A class consists of a set of members. The most common kinds of members are data members and member functions.

• Member functions can define the meaning of initialization (creation), copy, move, and cleanup (destruction).

• Members are accessed using . (dot) for objects and –> (arrow) for pointers.

• Operators, such as +, !, and [], can be defined for a class.

• A class is a namespace containing its members.

• The public members provide the class’s interface and the private members provide implementation details.

• A struct is a class where members are by default public.

For example:

Click here to view code image

class X {
private:                        // the representation (implementation) is private
     int m;
public:                         // the user interface is public
     X(int i =0) :m{i} { }      // a constructor (initialize the data member m)

     int mf(int i)              // a member function
     {
          int old = m;
          m = i;                // set a new value
          return old;           // return the old value
     }
};

X var {7};  // a variable of type X, initialized to 7

int user(X var, X* ptr)
{
    int x = var.mf(7);          // access using . (dot)
    int y = ptr–>mf(9);         // access using -> (arrow)
    int z = var.m;              // error: cannot access private member
}
The following sections expand on this and give rationale. The style is tutorial: a gradual development of ideas, with details postponed until later.

16.2.1. Member Functions
Consider implementing the concept of a date using a struct (§2.3.1, §8.2) to define the representation of a Date and a set of functions for manipulating variables of this type:

Click here to view code image

struct Date {      // representation
    int d, m, y;
};

void init_date(Date& d, int, int, int);  // initialize d
void add_year(Date& d, int n);           // add n years to d
void add_month(Date& d, int n);          // add n months to d
void add_day(Date& d, int n);            // add n days to d
There is no explicit connection between the data type, Date, and these functions. Such a connection can be established by declaring the functions as members:

Click here to view code image

struct Date {
    int d, m, y;

    void init(int dd, int mm, int yy);  // initialize
    void add_year(int n);               // add n years
    void add_month(int n);              // add n months
    void add_day(int n);                // add n days
};
Functions declared within a class definition (a struct is a kind of class; §16.2.4) are called member functions and can be invoked only for a specific variable of the appropriate type using the standard syntax for structure member access (§8.2). For example:

Date my_birthday;

void f()
{
     Date today;

     today.init(16,10,1996);
     my_birthday.init(30,12,1950);

     Date tomorrow = today;
     tomorrow.add_day(1);
     //...
}
Because different structures can have member functions with the same name, we must specify the structure name when defining a member function:

void Date::init(int dd, int mm, int yy)
{
    d = dd;
    m = mm;
    y = yy;
}
In a member function, member names can be used without explicit reference to an object. In that case, the name refers to that member of the object for which the function was invoked. For example, when Date::init() is invoked for today, m=mm assigns to today.m. On the other hand, when Date::init() is invoked for my_birthday, m=mm assigns to my_birthday.m. A class member function “knows” for which object it was invoked. But see §16.2.12 for the notion of a static member.

16.2.2. Default Copying
By default, objects can be copied. In particular, a class object can be initialized with a copy of an object of its class. For example:

Click here to view code image

Date d1 = my_birthday;  // initialization by copy
Date d2 {my_birthday};  // initialization by copy
By default, the copy of a class object is a copy of each member. If that default is not the behavior wanted for a class X, a more appropriate behavior can be provided (§3.3, §17.5).

Similarly, class objects can by default be copied by assignment. For example:

void f(Date& d)
{
    d = my_birthday;
}
Again, the default semantics is memberwise copy. If that is not the right choice for a class X, the user can define an appropriate assignment operator (§3.3, §17.5).

16.2.3. Access Control
The declaration of Date in the previous subsection provides a set of functions for manipulating a Date. However, it does not specify that those functions should be the only ones to depend directly on Date’s representation and the only ones to directly access objects of class Date. This restriction can be expressed by using a class instead of a struct:

Click here to view code image

class Date {
    int d, m, y;
public:
    void init(int dd, int mm, int yy);  // initialize

    void add_year(int n);               // add n years
    void add_month(int n);              // add n months
    void add_day(int n);                // add n days
};
The public label separates the class body into two parts. The names in the first, private, part can be used only by members. The second, public, part constitutes the public interface to objects of the class. A struct is simply a class whose members are public by default (§16.2.4); member functions can be defined and used exactly as before. For example:

void Date::add_year(int n)
{
    y += n;
}
However, nonmember functions are barred from using private members. For example:

Click here to view code image

void timewarp(Date& d)
{
    d.y –= 200;        // error: Date::y is private
}
The init() function is now essential because making the data private forces us to provide a way of initializing members. For example:

Click here to view code image

Date dx;
dx.m = 3;            // error: m is private
dx.init(25,3,2011);  // OK
There are several benefits to be obtained from restricting access to a data structure to an explicitly declared list of functions. For example, any error causing a Date to take on an illegal value (for example, December 36, 2016) must be caused by code in a member function. This implies that the first stage of debugging – localization – is completed before the program is even run. This is a special case of the general observation that any change to the behavior of the type Date can and must be effected by changes to its members. In particular, if we change the representation of a class, we need only change the member functions to take advantage of the new representation. User code directly depends only on the public interface and need not be rewritten (although it may need to be recompiled). Another advantage is that a potential user need examine only the definitions of the member functions in order to learn to use a class. A more subtle, but most significant, advantage is that focusing on the design of a good interface simply leads to better code because thoughts and time otherwise devoted to debugging are expended on concerns related to proper use.

The protection of private data relies on restriction of the use of the class member names. It can therefore be circumvented by address manipulation (§7.4.1) and explicit type conversion (§11.5). But this, of course, is cheating. C++ protects against accident rather than deliberate circumvention (fraud). Only hardware can offer perfect protection against malicious use of a general-purpose language, and even that is hard to do in realistic systems.

16.2.4. class and struct
The construct

class X { ... };
is called a class definition; it defines a type called X. For historical reasons, a class definition is often referred to as a class declaration. Also, like declarations that are not definitions, a class definition can be replicated in different source files using #include without violating the one-definition rule (§15.2.3).

By definition, a struct is a class in which members are by default public; that is,

struct S { /* ... */ };
is simply shorthand for

class S { public: /* ... */ };
These two definitions of S are interchangeable, though it is usually wise to stick to one style. Which style you use depends on circumstances and taste. I tend to use struct for classes that I think of as “just simple data structures.” If I think of a class as “a proper type with an invariant,” I use class. Constructors and access functions can be quite useful even for structs, but as a shorthand rather than guarantors of invariants (§2.4.3.2, §13.4).

By default, members of a class are private:

Click here to view code image

class Date1 {
    int d, m, y;        // private by default
public:
    Date1(int dd, int mm, int yy);
    void add_year(int n);      // add n years
};
However, we can also use the access specifier private: to say that the members following are private, just as public: says that the members following are public:

Click here to view code image

struct Date2 {
private:
    int d, m, y;
public:
    Date2(int dd, int mm, int yy);
    void add_year(int n);     // add n years
};
Except for the different name, Date1 and Date2 are equivalent.

It is not a requirement to declare data first in a class. In fact, it often makes sense to place data members last to emphasize the functions providing the public user interface. For example:

Click here to view code image

class Date3 {
public:
    Date3(int dd, int mm, int yy);
    void add_year(int n);     // add n years
private:
    int d, m, y;
};
In real code, where both the public interface and the implementation details typically are more extensive than in tutorial examples, I usually prefer the style used for Date3.

Access specifiers can be used many times in a single class declaration. For example:

Click here to view code image

class Date4 {
public:
    Date4(int dd, int mm, int yy);
private:
    int d, m, y;
public:
    void add_year(int n);      // add n years
};
Having more than one public section, as in Date4, tends to be messy, though, and might affect the object layout (§20.5). So does having more than one private section. However, allowing many access specifiers in a class is useful for machine-generated code.

16.2.5. Constructors
The use of functions such as init() to provide initialization for class objects is inelegant and error-prone. Because it is nowhere stated that an object must be initialized, a programmer can forget to do so – or do so twice (often with equally disastrous results). A better approach is to allow the programmer to declare a function with the explicit purpose of initializing objects. Because such a function constructs values of a given type, it is called a constructor. A constructor is recognized by having the same name as the class itself. For example:

Click here to view code image

class Date {
    int d, m, y;
public:
    Date(int dd, int mm, int yy);     // constructor
     //...
};
When a class has a constructor, all objects of that class will be initialized by a constructor call. If the constructor requires arguments, these arguments must be supplied:

Click here to view code image

Date today = Date(23,6,1983);
Date xmas(25,12,1990);     // abbreviated form
Date my_birthday;          // error: initializer missing
Date release1_0(10,12);    // error: third argument missing
Since a constructor defines initialization for a class, we can use the {}-initializer notation:

Click here to view code image

Date today = Date {23,6,1983};
Date xmas {25,12,1990};       // abbreviated form
Date release1_0 {10,12};      // error: third argument missing
I recommend the {} notation over the () notation for initialization because it is explicit about what is being done (initialization), avoids some potential mistakes, and can be used consistently (§2.2.2, §6.3.5). There are cases where () notation must be used (§4.4.1, §17.3.2.1), but they are rare.

By providing several constructors, we can provide a variety of ways of initializing objects of a type. For example:

Click here to view code image

class Date {
    int d, m, y;
public:
     //...

    Date(int, int, int);      // day, month, year
    Date(int, int);           // day, month, today's year
    Date(int);                // day, today's month and year
    Date();                   // default Date: today
    Date(const char*);        // date in string representation
};
Constructors obey the same overloading rules as do ordinary functions (§12.3). As long as the constructors differ sufficiently in their argument types, the compiler can select can select the correct one for each use:

Click here to view code image

Date today {4};                //4, today.m, today.y
Date july4 {"July 4, 1983"};
Date guy {5,11};               //5, November, today.y
Date now;                      // default initialized as today
Date start {};                 // default initialized as today
The proliferation of constructors in the Date example is typical. When designing a class, a programmer is always tempted to add features just because somebody might want them. It takes more thought to carefully decide what features are really needed and to include only those. However, that extra thought typically leads to smaller and more comprehensible programs. One way of reducing the number of related functions is to use default arguments (§12.2.5). For Date, each argument can be given a default value interpreted as “pick the default: today.”

Click here to view code image

class Date {
    int d, m, y;
public:
    Date(int dd =0, int mm =0, int yy =0);
     //...
};

Date::Date(int dd, int mm, int yy)
{
    d = dd ? dd : today.d;
    m = mm ? mm : today.m;
    y = yy ? yy : today.y;

     // ... check that the Date is valid ...
}
When an argument value is used to indicate “pick the default,” the value chosen must be outside the set of possible values for the argument. For day and month, this is clearly so, but for year, zero may not be an obvious choice. Fortunately, there is no year zero on the European calendar; 1AD (year==1) comes immediately after 1BC (year==–1).

Alternatively, we could use the default values directly as default arguments. However, I chose to use 0 to avoid building actual values into Date’s interface. That way, we have the option to later improve the implementation of the default.

Note that by guaranteeing proper initialization of objects, the constructors greatly simplify the implementation of member functions. Given constructors, other member functions no longer have to deal with the possibility of uninitialized data (§16.3.1).

16.2.6. explicit Constructors
By default, a constructor invoked by a single argument acts as an implicit conversion from its argument type to its type. For example:

complex<double> d {1};      // d=={1,0} (§5.6.2)
Such implicit conversions can be extremely useful. Complex numbers are an example: if we leave out the imaginary part, we get a complex number on the real axis. That’s exactly what mathematics requires. However, in many cases, such conversions can be a significant source of confusion and errors. Consider Date:

Click here to view code image

void my_fct(Date d);

void f()
{
    Date d {15};  // plausible: x becomes {15,today.m,today.y}
     //...
    my_fct(15);   // obscure
    d = 15;       // obscure
     //...
}
At best, this is obscure. There is no clear logical connection between the number 15 and a Date independently of the intricacies of our code.

Fortunately, we can specify that a constructor is not used as an implicit conversion. A constructor declared with the keyword explicit can only be used for initialization and explicit conversions. For example:

Click here to view code image

class Date {
    int d, m, y;
public:
    explicit Date(int dd =0, int mm =0, int yy =0);
     //...
};

Date d1 {15};           // OK: considered explicit
Date d2 = Date{15};     // OK: explicit
Date d3 = {15};         // error: = initialization does not do implicit conversions
Date d4 = 15;           // error: = initialization does not do implicit conversions

void f()
{
    my_fct(15);         // error: argument passing does not do implicit conversions
    my_fct({15});       // error: argument passing does not do implicit conversions
    my_fct(Date{15});   // OK: explicit
    //...
}
An initialization with an = is considered a copy initialization. In principle, a copy of the initializer is placed into the initialized object. However, such a copy may be optimized away (elided), and a move operation (§3.3.2, §17.5.2) may be used if the initializer is an rvalue (§6.4.1). Leaving out the = makes the initialization explicit. Explicit initialization is known as direct initialization.

By default, declare a constructor that can be called with a single argument explicit. You need a good reason not to do so (as for complex). If you define an implicit constructor, it is best to document your reason or a maintainer may suspect that you were forgetful (or ignorant).

If a constructor is declared explicit and defined outside the class, that explicit cannot be repeated:

Click here to view code image

class Date {
   int d, m, y;
public:
    explicit Date(int dd);
     //...
};

Date::Date(int dd) { /* ... */ }                // OK
explicit Date::Date(int dd) { /* ... */ }       // error
Most examples where explicit is important involve a single constructor argument. However, explicit can also be useful for constructors with zero or more than one argument. For example:

struct X {
    explicit X();
    explicit X(int,int);
};

X x1 = {};              // error: implicit
X x2 = {1,2};           // error: implicit

X x3 {};                // OK: explicit
X x4 {1,2};             // OK: explicit

int f(X);

int i1 = f({});         // error: implicit
int i2 = f({1,2});      // error: implicit

int i3 = f(X{});        // OK: explicit
int i4 = f(X{1,2});     // OK: explicit
The distinction between direct and copy initialization is maintained for list initialization (§17.3.4.3).

16.2.7. In-Class Initializers
When we use several constructors, member initialization can become repetitive. For example:

Click here to view code image

class Date {
     int d, m, y;
public:
     Date(int, int, int);         // day, month, year
     Date(int, int);              // day, month, today's year
     Date(int);                   // day, today's month and year
     Date();                      // default Date: today
     Date(const char*);           // date in string representation
     //...
};
We can deal with that by introducing default arguments to reduce the number of constructors (§16.2.5) or forward to a constructor that handles the common parts of the initialization (§17.4.3). Alternatively, we can add initializers to data members. Initializing with 0 would still leave most of the common code replicated, so we would prefer to initializing with a "real value" rather than an indicator that a default value is needed. Initializing the members from a Date value is not easy (because that Date value would then itself have to be defined before it is used in the Data constructors; see §16.2.12). So, mostly to show that we can, I introduce a variable specifically to hold default Date initializer values:

Click here to view code image

struct { int d, m, y; } date_initializer = {1, 1, 1970};
class Date {
     int d {date_initializer.d};
     int m {date_initializer.m};
     int y {date_initializer.y};
public:
     Date(int, int, int);         // day, month, year
     Date(int, int);              // day, month, today's year
     Date(int);                   // day, today's month and year
     Date();                      // default Date: today
     Date(const char*);           // date in string representation
      //...
Now, each constructor has the d, m, and y initialized unless it does it itself. For example:

Date::Date(int dd)
     :d{dd}
{
      // ... check that the Date is valid ...
}
This is equivalent to:

Date::Date(int dd)
     :d{dd}, m{date_initializer.m}, y{date_initializer.y}
{
      // ... check that the Date is valid ...
}
Note that date_initializer is simply an ad hoc data structure holding initializer values that will be validated by Date’s constructors. I didn’t even bother to give date_initializer’s type a name.

16.2.8. In-Class Function Definitions
A member function defined within the class definition – rather than simply declared there – is taken to be an inline (§12.1.5) member function. That is, in-class definition of member functions is for small, rarely modified, frequently used functions. Like the class definition it is part of, a member function defined in-class can be replicated in several translation units using #include. Like the class itself, the member function’s meaning must be the same wherever it is #included (§15.2.3).

A member can refer to another member of its class independently of where that member is defined (§6.3.4). Consider:

Click here to view code image

class Date {
public:
    void add_month(int n) { m+=n; }     // increment the Date's m
     //...
private:
    int d, m, y;
};
That is, function and data member declarations are order independent. I could equivalently have written:

Click here to view code image

class Date {
public:
     void add_month(int n);     // increment the Date's m
      //...
private:
     int d, m, y;
};

inline void Date::add_month(int n)  // add n months
{
     m+=n;       // increment the Date's m
}
This latter style is often used to keep class definitions simple and easy to read. It also provides a textual separation of a class’s interface and implementation.

Obviously, I simplified the definition of Date::add_month; just adding n and hoping to hit a good date is too naive (§16.3.1).

16.2.9. Mutability
We can define a named object as a constant or as a variable. In other words, a name can refer to an object that holds an immutable or a mutable value. Since the precise terminology can be a bit clumsy, we end up referring to some variables as being constant or briefer still to const variables. However odd that may sound to a native English speaker, the concept is useful and deeply embedded in the C++ type system. Systematic use of immutable objects leads to more comprehensible code, to more errors being found early, and sometimes to improved performance. In particular, immutability is a most useful property in a multi-threaded program (§5.3, Chapter 41).

To be useful beyond the definition of simple constants of built-in types, we must be able to define functions that operate on const objects of user-defined types. For freestanding functions that means functions that take const T& arguments. For classes it means that we must be able to define member functions that work on const objects.

16.2.9.1. Constant Member Functions
The Date as defined so far provides member functions for giving a Date a value. Unfortunately, we didn’t provide a way of examining the value of a Date. This problem can easily be remedied by adding functions for reading the day, month, and year:

Click here to view code image

class Date {
    int d, m, y;
public:
    int day() const { return d; }
    int month() const { return m; }
    int year() const;

    void add_year(int n);     //add n years
     //...
};
The const after the (empty) argument list in the function declarations indicates that these functions do not modify the state of a Date.

Naturally, the compiler will catch accidental attempts to violate this promise. For example:

Click here to view code image

int Date::year() const
{
     return ++y;     // error: attempt to change member value in const function
}
When a const member function is defined outside its class, the const suffix is required:

Click here to view code image

int Date::year()      // error: const missing in member function type
{
     return y;
}
In other words, const is part of the type of Date::day(), Date::month(), and Date::year().

A const member function can be invoked for both const and non-const objects, whereas a non-const member function can be invoked only for non-const objects. For example:

Click here to view code image

void f(Date& d, const Date& cd)
{
     int i = d.year();     // OK
     d.add_year(1);        // OK

     int j = cd.year();    // OK
     cd.add_year(1);       // error: cannot change value of a const Date
}
16.2.9.2. Physical and Logical Constness
Occasionally, a member function is logically const, but it still needs to change the value of a member. That is, to a user, the function appears not to change the state of its object, but some detail that the user cannot directly observe is updated. This is often called logical constness. For example, the Date class might have a function returning a string representation. Constructing this representation could be a relatively expensive operation. Therefore, it would make sense to keep a copy so that repeated requests would simply return the copy, unless the Date’s value had been changed. Caching values like that is more common for more complicated data structures, but let’s see how it can be achieved for a Date:

Click here to view code image

class Date {
public:
     //...
    string string_rep() const;     // string representation
private:
    bool cache_valid;
    string cache;
    void compute_cache_value();  // fill cache
     //...
};
From a user’s point of view, string_rep doesn’t change the state of its Date, so it clearly should be a const member function. On the other hand, the cache and cache_valid members must change occasionally for the design to make sense.

Such problems could be solved through brute force using a cast, for example, a const_cast (§11.5.2). However, there are also reasonably elegant solutions that do not involve messing with type rules.

16.2.9.3. mutable
We can define a member of a class to be mutable, meaning that it can be modified even in a const object:

Click here to view code image

class Date {
public:
     //...
    string string_rep() const;           // string representation
private:
    mutable bool cache_valid;
    mutable string cache;
    void compute_cache_value() const;    // fill (mutable) cache
     //...
};
Now we can define string_rep() in the obvious way:

string Date::string_rep() const
{
     if (!cache_valid) {
           compute_cache_value();
           cache_valid = true;
     }
     return cache;
}
We can now use string_rep() for both const and non-const objects. For example:

Click here to view code image

void f(Date d, const Date cd)
{
     string s1 = d.string_rep();
     string s2 = cd.string_rep();       // OK!
      //...
}
16.2.9.4. Mutability through Indirection
Declaring a member mutable is most appropriate when only a small part of a representation of a small object is allowed to change. More complicated cases are often better handled by placing the changing data in a separate object and accessing it indirectly. If that technique is used, the string-with-cache example becomes:

Click here to view code image

struct cache {
     bool valid;
     string rep;
};

class Date {
public:
      //...
     string string_rep() const;            // string representation
private:
     cache* c;                             // initialize in constructor
     void compute_cache_value() const;     // fill what cache refers to
      //...
};

string Date::string_rep() const
{
     if (!c–>valid) {
           compute_cache_value();
           c–>valid = true;
     }
     return c–>rep;
}
The programming techniques that support a cache generalize to various forms of lazy evaluation.

Note that const does not apply (transitively) to objects accessed through pointers or references. The human reader may consider such an object as “a kind of subobject,” but the compiler does not know such pointers or references to be any different from any others. That is, a member pointer does not have any special semantics that distinguish it from other pointers.

16.2.10. Self-Reference
The state update functions add_year(), add_month(), and add_day() (§16.2.3) were defined not to return values. For such a set of related update functions, it is often useful to return a reference to the updated object so that the operations can be chained. For example, we would like to write:

Click here to view code image

void f(Date& d)
{
     //...
    d.add_day(1).add_month(1).add_year(1);
     //...
}
to add a day, a month, and a year to d. To do this, each function must be declared to return a reference to a Date:

Click here to view code image

class Date {
     //...
    Date& add_year(int n);   // add n years
    Date& add_month(int n);  // add n months
    Date& add_day(int n);    // add n days
};
Each (non-static) member function knows for which object it was invoked and can explicitly refer to it. For example:

Click here to view code image

Date& Date::add_year(int n)
{
    if (d==29 && m==2 && !leapyear(y+n)) {  // beware of February 29
          d = 1;
          m = 3;
    }
    y += n;
    return *this;
}
The expression *this refers to the object for which a member function is invoked.

In a non-static member function, the keyword this is a pointer to the object for which the function was invoked. In a non-const member function of class X, the type of this is X*. However, this is considered an rvalue, so it is not possible to take the address of this or to assign to this. In a const member function of class X, the type of this is const X* to prevent modification of the object itself (see also §7.5).

Most uses of this are implicit. In particular, every reference to a non-static member from within a class relies on an implicit use of this to get the member of the appropriate object. For example, the add_year function could equivalently, but tediously, have been defined like this:

Click here to view code image

Date& Date::add_year(int n)
{
    if (this–>d==29 && this–>m==2 && !leapyear(this–>y+n)) {
          this–>d = 1;
          this–>m = 3;
    }
    this–>y += n;
    return *this;
}
One common explicit use of this is in linked-list manipulation. For example:

Click here to view code image

struct Link {
    Link* pre;
    Link* suc;
    int data;

    Link* insert(int x)    // insert x before this
    {
        return pre = new Link{pre,this,x};
    }
    void remove()  // remove and destroy this     
    {
        if (pre) pre–>suc = suc;
        if (suc) suc–>pre = pre;
        delete this;
    }

     //...
};
Explicit use of this is required for access to members of base classes from a derived class that is a template (§26.3.7).

16.2.11. Member Access
A member of a class X can be accessed by applying the . (dot) operator to an object of class X or by applying the –> (arrow) operator to a pointer to an object of class X. For example:

Click here to view code image

struct X {
     void f();
     int m;
};

void user(X x, X* px)
{
     m = 1;        // error: there is no m in scope
     x.m = 1;      // OK
     x–>m = 1;     // error: x is not a pointer
     px–>m = 1;    // OK
     px.m = 1;     // error: px is a pointer
}
Obviously, there is a bit of redundancy here: the compiler knows whether a name refers to an X or to an X*, so a single operator would have been sufficient. However, a programmer might be confused, so from the first days of C the rule has been to use separate operators.

From inside a class no operator is needed. For example:

Click here to view code image

void X::f()
{
     m = 1;     // OK: "this->m = 1;" (§16.2.10)
}
That is, an unqualified member name acts as if it had been prefixed by this–>. Note that a member function can refer to the name of a member before it has been declared:

Click here to view code image

struct X {
     int f() { return m; }    // fine: return this X's m
     int m;
};
If we want to refer to a member in general, rather than to a member of a particular object, we qualify by the class name followed by ::. For example:

Click here to view code image

struct S {
     int m;
     int f();
     static int sm;
};
 
int S::f() { return m; }      // define S's f
int S::sm {7};                // initialize S's static member sm (§16.2.12)
int(S::* pmf)() {&S::f};     // pointer to S's member f
That last construct (a pointer to member) is fairly rare and esoteric; see §20.6. I mention it here just to emphasize the generality of the rule for ::.

16.2.12. static Members
The convenience of a default value for Dates was bought at the cost of a significant hidden problem. Our Date class became dependent on the global variable today. This Date class can be used only in a context in which today is defined and correctly used by every piece of code. This is the kind of constraint that causes a class to be useless outside the context in which it was first written. Users get too many unpleasant surprises trying to use such context-dependent classes, and maintenance becomes messy. Maybe “just one little global variable” isn’t too unmanageable, but that style leads to code that is useless except to its original programmer. It should be avoided.

Fortunately, we can get the convenience without the encumbrance of a publicly accessible global variable. A variable that is part of a class, yet is not part of an object of that class, is called a static member. There is exactly one copy of a static member instead of one copy per object, as for ordinary non-static members (§6.4.2). Similarly, a function that needs access to members of a class, yet doesn’t need to be invoked for a particular object, is called a static member function.

Here is a redesign that preserves the semantics of default constructor values for Date without the problems stemming from reliance on a global:

Click here to view code image

class Date {
    int d, m, y;
    static Date default_date;
public:
    Date(int dd =0, int mm =0, int yy =0);
     //...
    static void set_default(int dd, int mm, int yy);  // set default_date to Date(dd,mm,yy)
};
We can now define the Date constructor to use default_date like this:

Date::Date(int dd, int mm, int yy)
{
    d = dd ? dd : default_date.d;
    m = mm ? mm : default_date.m;
    y = yy ? yy : default_date.y;

     //... check that the Date is valid ...
}
Using set_default(), we can change the default date when appropriate. A static member can be referred to like any other member. In addition, a static member can be referred to without mentioning an object. Instead, its name is qualified by the name of its class. For example:

Click here to view code image

void f()
{
     Date::set_default(4,5,1945);   // call Date's static member set_default()
}
If used, a static member – a function or data member – must be defined somewhere. The keyword static is not repeated in the definition of a static member. For example:

Click here to view code image

Date Date::default_date {16,12,1770};          // definition of Date::default_date

void Date::set_default(int d, int m, int y)    // definition of Date::set_default
{
     default_date = {d,m,y};                   // assign new value to default_date
}
Now, the default value is Beethoven’s birth date – until someone decides otherwise.

Note that Date{} serves as a notation for the value of Date::default_date. For example:

Date copy_of_default_date = Date{};

void f(Date);

void g()
{
     f(Date{});
}
Consequently, we don’t need a separate function for reading the default date. Furthermore, where the target type is unambiguously a Date, plain {} is sufficient. For example:

Click here to view code image

void f1(Date);

void f2(Date);
void f2(int);

void g()
{
     f1({});        // OK: equivalent to f1(Date{})
     f2({}):        // error: ambiguous: f2(int) or f2(Date)?
     f2(Date{});    // OK }
In multi-threaded code, static data members require some kind of locking or access discipline to avoid race conditions (§5.3.4, §41.2.4). Since multi-threading is now very common, it is unfortunate that use of static data members was quite popular in older code. Older code tends to use static members in ways that imply race conditions.

16.2.13. Member Types
Types and type aliases can be members of a class. For example:

Click here to view code image

template<typename T>
class Tree {
     using value_type = T;                  // member alias
     enum Policy { rb, splay, treeps };     // member enum
     class Node {                           // member class
          Node* right;
          Node* left;
          value_type value;
     public:
          void f(Tree*);
     };
     Node* top;
public:
     void g(Node*);
      //...
};
A member class (often called a nested class) can refer to types and static members of its enclosing class. It can only refer to non-static members when it is given an object of the enclosing class to refer to. To avoid getting into the intricacies of binary trees, I use purely technical “f() and g()”-style examples.

A nested class has access to members of its enclosing class, even to private members (just as a member function has), but has no notion of a current object of the enclosing class. For example:

Click here to view code image

template<typename T>
void Tree<T>::Node::f(Tree* p)
{
     top = right;                           // error: no object of type Tree specified
     p–>top = right;                        // OK
     value_type v = left–>value;            // OK: value_type is not associated with an object
}
A class does not have any special access rights to the members of its nested class. For example:

Click here to view code image

template<typename T>
void Tree::g(Tree::Node* p)
{
     value_type val = right–>value;            // error: no object of type Tree::Node
     value_type v = p–>right–>value;           // error: Node::right is private
     p–>f(this);                               // OK
}
Member classes are more a notational convenience than a feature of fundamental importance. On the other hand, member aliases are important as the basis of generic programming techniques relying on associated types (§28.2.4, §33.1.3). Member enums are often an alternative to enum classes when it comes to avoiding polluting an enclosing scope with the names of enumerators (§8.4.1).

16.3. Concrete Classes
The previous section discussed bits and pieces of the design of a Date class in the context of introducing the basic language features for defining classes. Here, I reverse the emphasis and discuss the design of a simple and efficient Date class and show how the language features support this design.

Small, heavily used abstractions are common in many applications. Examples are Latin characters, Chinese characters, integers, floating-point numbers, complex numbers, points, pointers, coordinates, transforms, (pointer,offset) pairs, dates, times, ranges, links, associations, nodes, (value,unit) pairs, disk locations, source code locations, currency values, lines, rectangles, scaled fixed-point numbers, numbers with fractions, character strings, vectors, and arrays. Every application uses several of these. Often, a few of these simple concrete types are used heavily. A typical application uses a few directly and many more indirectly from libraries.

C++ directly supports a few of these abstractions as built-in types. However, most are not, and cannot be, directly supported by the language because there are too many of them. Furthermore, the designer of a general-purpose programming language cannot foresee the detailed needs of every application. Consequently, mechanisms must be provided for the user to define small concrete types. Such types are called concrete types or concrete classes to distinguish them from abstract classes (§20.4) and classes in class hierarchies (§20.3, §21.2).

A class is called concrete (or a concrete class) if its representation is part of its definition. This distinguishes it from abstract classes (§3.2.2, §20.4) which provide an interface to a variety of implementations. Having the representation available allows us:

• To place objects on the stack, in statically allocated memory, and in other objects

• To copy and move objects (§3.3, §17.5)

• To refer directly to named objects (as opposed to accessing through pointers and references)

This makes concrete classes simple to reason about and easy for the compiler to generate optimal code for. Thus, we prefer concrete classes for small, frequently used, and performance-critical types, such as complex numbers (§5.6.2), smart pointers (§5.2.1), and containers (§4.4).

It was an early explicit aim of C++ to support the definition and efficient use of such user-defined types very well. They are a foundation of elegant programming. As usual, the simple and mundane is statistically far more significant than the complicated and sophisticated. In this light, let us build a better Date class:

Click here to view code image

namespace Chrono {

    enum class Month { jan=1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec };

    class Date {
    public:        // public interface:
         class Bad_date { };  // exception class

         explicit Date(int dd ={}, Month mm ={}, int yy ={});            //{} means "pick a default"
     // nonmodifying functions for examining the Date:
         int day() const;
         Month month() const;
         int year() const;

         string string_rep() const;                   // string representation
         void char_rep(char s[], int max) const;       // C-style string representation

    //(modifying) functions for changing the Date:
         Date& add_year(int n);                       // add n years
         Date& add_month(int n);                      // add n months
         Date& add_day(int n);                        // add n days
   private:
         bool is_valid();                             // check if this Date represents a date
         int d;                                 // representation Month m; int y; };
   };

   bool is_date(int d, Month m, int y);               // true for valid date
   bool is_leapyear(int y);                           // true if y is a leap year

   bool operator==(Date a, Date b);
   bool operator!=(Date a, Date b);

   const Date& default_date();                      // the default date
   ostream& operator<<(ostream& os, const Date& d);        // print d to os
   istream& operator>>(istream& is, Date& d);              // read Date from is into d
}  // Chrono
This set of operations is fairly typical for a user-defined type:

[1] A constructor specifying how objects/variables of the type are to be initialized (§16.2.5).

[2] A set of functions allowing a user to examine a Date. These functions are marked const to indicate that they don’t modify the state of the object/variable for which they are called.

[3] A set of functions allowing the user to modify Dates without actually having to know the details of the representation or fiddle with the intricacies of the semantics.

[4] Implicitly defined operations that allow Dates to be freely copied (§16.2.2).

[5] A class, Bad_date, to be used for reporting errors as exceptions.

[6] A set of useful helper functions. The helper functions are not members and have no direct access to the representation of a Date, but they are identified as related by the use of the namespace Chrono.

I defined a Month type to cope with the problem of remembering the month/day order, for example, to avoid confusion about whether the 7th of June is written {6,7} (American style) or {7,6} (European style).

I considered introducing separate types Day and Year to cope with possible confusion of Date{1995,Month::jul,27} and Date{27,Month::jul,1995}. However, these types would not be as useful as the Month type. Almost all such errors are caught at run time anyway – the 26th of July year 27 is not a common date in my work. Dealing with historical dates before year 1800 or so is a tricky issue best left to expert historians. Furthermore, the day of the month can’t be properly checked in isolation from its month and year.

To save the user from having to explicitly mention year and month even when they are implied by context, I added a mechanism for providing a default. Note that for Month the {} gives the (default) value 0 just as for integers even though it is not a valid Month (§8.4). However, in this case, that’s exactly what we want: an otherwise illegal value to represent “pick the default.” Providing a default (e.g., a default value for Date objects) is a tricky design problem. For some types, there is a conventional default (e.g., 0 for integers); for others, no default makes sense; and finally, there are some types (such as Date) where the question of whether to provide a default is nontrivial. In such cases, it is best – at least initially – not to provide a default value. I provide one for Date primarily to be able to discuss how to do so.

I omitted the cache technique from §16.2.9 as unnecessary for a type this simple. If needed, it can be added as an implementation detail without affecting the user interface.

Here is a small – and contrived – example of how Dates can be used:

Click here to view code image

void f(Date& d)
{
     Date lvb_day {16,Month::dec,d.year()};

     if (d.day()==29 && d.month()==Month::feb) {
            //...
     }

     if (midnight()) d.add_day(1);

     cout << "day after:" << d+1 << '\n';

     Date dd;  // initialized to the default date
     cin>>dd;
     if (dd==d) cout << "Hurray!\n";
}
This assumes that the addition operator, +, has been declared for Dates. I do that in §16.3.3.

Note the use of explicit qualification of dec and feb by Month. I used an enum class (§8.4.1) specifically to be able to use short names for the months, yet also ensure that their use would not be obscure or ambiguous.

Why is it worthwhile to define a specific type for something as simple as a date? After all, we could just define a simple data structure:

struct Date {
     int day, month, year;
};
Each programmer could then decide what to do with it. If we did that, though, every user would either have to manipulate the components of Dates directly or provide separate functions for doing so. In effect, the notion of a date would be scattered throughout the system, which would make it hard to understand, document, or change. Inevitably, providing a concept as only a simple structure causes extra work for every user of the structure.

Also, even though the Date type seems simple, it takes some thought to get right. For example, incrementing a Date must deal with leap years, with the fact that months are of different lengths, and so on. Also, the day-month-and-year representation is rather poor for many applications. If we decided to change it, we would need to modify only a designated set of functions. For example, to represent a Date as the number of days before or after January 1, 1970, we would need to change only Date’s member functions.

To simplify, I decided to eliminate the notion of changing the default date. Doing so eliminates some opportunities for confusion and the likelihood of race conditions in a multi-threaded program (§5.3.1). I seriously considered eliminating the notion of a default date altogether. That would have forced users to consistently explicitly initialize their Dates. However, that can be inconvenient and surprising, and more importantly common interfaces used for generic code require default construction (§17.3.3). That means that I, as the designer of Date, have to pick the default date. I chose January 1, 1970, because that is the starting point for the C and C++ standard-library time routines (§35.2, §43.6). Obviously, eliminating set_default_date() caused some loss of generality of Date. However, design – including class design – is about making decisions, rather than just deciding to postpone them or to leave all options open for users.

To preserve an opportunity for future refinement, I declared default_date() as a helper function:

const Date& Chrono::default_date();
That doesn’t say anything about how the default date is actually set.

16.3.1. Member Functions
Naturally, an implementation for each member function must be provided somewhere. For example:

Click here to view code image

Date::Date(int dd, Month mm, int yy)
     :d{dd}, m{mm}, y{yy}
{
     if (y == 0) y = default_date().year();
     if (m == Month{}) m = default_date().month();
     if (d == 0) d = default_date().day();

     if (!is_valid()) throw Bad_date();
}
The constructor checks that the data supplied denotes a valid Date. If not, say, for {30,Month::feb,1994}, it throws an exception (§2.4.3.1, Chapter 13), which indicates that something went wrong. If the data supplied is acceptable, the obvious initialization is done. Initialization is a relatively complicated operation because it involves data validation. This is fairly typical. On the other hand, once a Date has been created, it can be used and copied without further checking. In other words, the constructor establishes the invariant for the class (in this case, that it denotes a valid date). Other member functions can rely on that invariant and must maintain it. This design technique can simplify code immensely (see §2.4.3.2, §13.4).

I’m using the value Month{} – which doesn’t represent a month and has the integer value 0 – to represent “pick the default month.” I could have defined an enumerator in Month specifically to represent that. But I decided that it was better to use an obviously anomalous value to represent “pick the default month” rather than give the appearance that there were 13 months in a year. Note that Month{}, meaning 0, can be used because it is within the range guaranteed for the enumeration Month (§8.4).

I use the member initializer syntax (§17.4) to initialize the members. After that, I check for 0 and modify the values as needed. This clearly does not provide optimal performance in the (hopefully rare) case of an error, but the use of member initializers leaves the structure of the code obvious. This makes the style less error-prone and easier to maintain than alternatives. Had I aimed at optimal performance, I would have used three separate constructors rather than a single constructor with default arguments.

I considered making the validation function is_valid() public. However, I found the resulting user code more complicated and less robust than code relying on catching the exception:

Click here to view code image

void fill(vector<Date>& aa)
{
     while (cin) {
           Date d;
           try {
                cin >> d;
           }
           catch (Date::Bad_date) {
                 //... my error handling ...
                continue;
           }
           aa.push_back(d);        // see §4.4.2
     }
}
However, checking that a {d,m,y} set of values is a valid date is not a computation that depends on the representation of a Date, so I implemented is_valid() in terms of a helper function:

bool Date::is_valid()
{
     return is_date(d,m,y);
}
Why have both is_valid() and is_date()? In this simple example, we could manage with just one, but I can imagine systems where is_date() (as here) checks that a (d,m,y)-tuple represents a valid date and where is_valid() does an additional check on whether that date can be reasonably represented. For example, is_valid() might reject dates from before the modern calendar became commonly used.

As is common for such simple concrete types, the definitions of Date’s member functions vary between the trivial and the not-too-complicated. For example:

Click here to view code image

inline int Date::day() const
{
     return d;
}
Date& Date::add_month(int n)
{
     if (n==0) return *this;

     if (n>0) {
           int delta_y = n/12;                    // number of whole years
           int mm = static_cast<int>(m)+n%12;     // number of months ahead
           if (12 < mm) {                         // note: dec is represented by 12
                  ++delta_y;
                  mm –= 12;
           }

            //... handle the cases where the month mm doesn't have day d ...

           y += delta_y;
           m = static_cast<Month>(mm);
           return *this;
     }

      //... handle negative n ...

     return *this;
}
I wouldn’t call the code for add_month() pretty. In fact, if I added all the details, it might even approach the complexity of relatively simple real-world code. This points to a problem: adding a month is conceptually simple, so why is our code getting complicated? In this case, the reason is that the d,m,y representation isn’t as convenient for the computer as it is for us. A better representation (for many purposes) would be simply a number of days since a defined “day zero” (e.g., January 1, 1970). That would make computation on Dates simple at the expense of complexity in providing output fit for humans.

Note that assignment and copy initialization are provided by default (§16.2.2). Also, Date doesn’t need a destructor because a Date owns no resources and requires no cleanup when it goes out of scope (§3.2.1.2).

16.3.2. Helper Functions
Typically, a class has a number of functions associated with it that need not be defined in the class itself because they don’t need direct access to the representation. For example:

Click here to view code image

int diff(Date a, Date b);  // number of days in the range [a,b) or [b,a)

bool is_leapyear(int y);
bool is_date(int d, Month m, int y);

const Date& default_date();
Date next_weekday(Date d);
Date next_saturday(Date d);
Defining such functions in the class itself would complicate the class interface and increase the number of functions that would potentially need to be examined when a change to the representation was considered.

How are such functions “associated” with class Date? In early C++, as in C, their declarations were simply placed in the same file as the declaration of class Date. Users who needed Dates would make them all available by including the file that defined the interface (§15.2.2). For example:

#include "Date.h"
In addition (or alternatively), we can make the association explicit by enclosing the class and its helper functions in a namespace (§14.3.1):

Click here to view code image

namespace Chrono {             // facilities for dealing with time

    class Date { /* ... */};

    int diff(Date a, Date b);
    bool is_leapyear(int y);
    bool is_date(int d, Month m, int y);
    const Date& default_date();
    Date next_weekday(Date d);
    Date next_saturday(Date d);
     //...
}
The Chrono namespace would naturally also contain related classes, such as Time and Stopwatch, and their helper functions. Using a namespace to hold a single class is usually an overelaboration that leads to inconvenience.

Naturally, the helper function must be defined somewhere:

Click here to view code image

bool Chrono::is_date(int d, Month m, int y)
{
     int ndays;

     switch (m) {
     case Month::feb:
          ndays = 28+is_leapyear(y);
          break;
     case Month::apr: case Month::jun: case Month::sep: case Month::nov:
          ndays = 30;
          break;
     case Month::jan: case Month::mar: case Month::may: case Month::jul:
     case Month::aug: case Month::oct: case Month::dec:
          ndays = 31;
          break;
     default:
          return false;
     }

     return 1<=d && d<=ndays;
}
I’m deliberately being a bit paranoid here. A Month shouldn’t be outside the jan to dec range, but it is possible (someone might have been sloppy with a cast), so I check.

The troublesome default_date finally becomes:

const Date& Chrono::default_date()
{
    static Date d {1,Month::jan,1970};
    return d;
}
16.3.3. Overloaded Operators
It is often useful to add functions to enable conventional notation. For example, operator==() defines the equality operator, ==, to work for Dates:

Click here to view code image

inline bool operator==(Date a, Date b)       // equality
{
     return a.day()==b.day() && a.month()==b.month() && a.year()==b.year();
}
Other obvious candidates are:

Click here to view code image

bool operator!=(Date, Date);       // inequality
bool operator<(Date, Date);        // less than
bool operator>(Date, Date);        // greater than
 //...

Date& operator++(Date& d) { return d.add_day(1); }           // increase Date by one day
Date& operator––(Date& d) { return d.add_day(–1); }          // decrease Date by one day

Date& operator+=(Date& d, int n) { return d.add_day(n); }    // add n days
Date& operator–=(Date& d, int n) { return d.add_day(–n); }   // subtract n days

Date operator+(Date d, int n) { return d+=n; }               // add n days
Date operator–(Date d, int n) { return d+=n; }               // subtract n days

ostream& operator<<(ostream&, Date d);                       // output d
istream& operator>>(istream&, Date& d);                      // read into d
These operators are defined in Chrono together with Date to avoid overload problems and to benefit from argument-dependent lookup (§14.2.4).

For Date, these operators can be seen as mere conveniences. However, for many types – such as complex numbers (§18.3), vectors (§4.4.1), and function-like objects (§3.4.3, §19.2.2) – the use of conventional operators is so firmly entrenched in people’s minds that their definition is almost mandatory. Operator overloading is discussed in Chapter 18.

For Date, I was tempted to provide += and –= as member functions instead of add_day(). Had I done so, I would have followed a common idiom (§3.2.1.1).

Note that assignment and copy initialization are provided by default (§16.3, §17.3.3).

16.3.4. The Significance of Concrete Classes
I call simple user-defined types, such as Date, concrete types to distinguish them from abstract classes (§3.2.2) and class hierarchies (§20.4), and also to emphasize their similarity to built-in types such as int and char. Concrete classes are used just like built-in types. Concrete types have also been called value types and their use value-oriented programming. Their model of use and the “philosophy” behind their design are quite different from what is often called object-oriented programming (§3.2.4, Chapter 21).

The intent of a concrete type is to do a single, relatively simple thing well and efficiently. It is not usually the aim to provide the user with facilities to modify the behavior of a concrete type. In particular, concrete types are not intended to display run-time polymorphic behavior (see §3.2.3, §20.3.2).

If you don’t like some detail of a concrete type, you build a new one with the desired behavior. If you want to “reuse” a concrete type, you use it in the implementation of your new type exactly as you would have used an int. For example:

Click here to view code image

class Date_and_time {
private:
     Date d;
     Time t;
public:
     Date_and_time(Date d, Time t);
     Date_and_time(int d, Date::Month m, int y, Time t);
      //...
};
Alternatively, the derived class mechanism discussed in Chapter 20 can be used to define new types from a concrete class by describing the desired differences. The definition of Vec from vector (§4.4.1.2) is an example of this. However, derivation from a concrete class should be done with care and only rarely because of the lack of virtual functions and run-time type information (§17.5.1.4, Chapter 22).

With a reasonably good compiler, a concrete class such as Date incurs no hidden overhead in time or space. In particular, no indirection through pointers is necessary for access to objects of concrete classes, and no “housekeeping” data is stored in objects of concrete classes. The size of a concrete type is known at compile time so that objects can be allocated on the run-time stack (that is, without free-store operations). The layout of an object is known at compile time so that inlining of operations is trivially achieved. Similarly, layout compatibility with other languages, such as C and Fortran, comes without special effort.

A good set of such types can provide a foundation for applications. In particular, they can be used to make interfaces more specific and less error-prone. For example:

Month do_something(Date d);
This is far less likely to be misunderstood or misused than:

int do_something(int d);
Lack of concrete types can lead to obscure programs and time wasted when each programmer writes code to directly manipulate “simple and frequently used” data structures represented as simple aggregates of built-in types. Alternatively, lack of suitable “small efficient types” in an application can lead to gross run-time and space inefficiencies when overly general and expensive classes are used.

16.4. Advice
[1] Represent concepts as classes; §16.1.

[2] Separate the interface of a class from its implementation; §16.1.

[3] Use public data (structs) only when it really is just data and no invariant is meaningful for the data members; §16.2.4.

[4] Define a constructor to handle initialization of objects; §16.2.5.

[5] By default declare single-argument constructors explicit; §16.2.6.

[6] Declare a member function that does not modify the state of its object const; §16.2.9.

[7] A concrete type is the simplest kind of class. Where applicable, prefer a concrete type over more complicated classes and over plain data structures; §16.3.

[8] Make a function a member only if it needs direct access to the representation of a class; §16.3.2.

[9] Use a namespace to make the association between a class and its helper functions explicit; §16.3.2.

[10] Use in-class initializers to avoid repetition in constructors; §16.2.7.

[11] Make a function that needs access to the representation of a class but needn’t be called for a specific object a static member function; §16.2.12.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


16. Classes
17. Construction, Cleanup, Copy, and Move
18. Operator Overloading
47h 26m remaining
17. Construction, Cleanup, Copy, and Move
Ignorance more frequently begets confidence than does knowledge.

– Charles Darwin

• Introduction

• Constructors and Destructors

Constructors and Invariants; Destructors and Resources; Base and Member Destructors; Calling Constructors and Destructors; virtual Destructors

• Class Object Initialization

Initialization Without Constructors; Initialization Using Constructors; Default Constructors; Initializer-List Constructors

• Member and Base Initialization

Member Initialization; Base Initializers; Delegating Constructors; In-Class Initializers; static Member Initialization

• Copy and Move

Copy; Move

• Generating Default Operations

Explicit Defaults; Default Operations; Using Default Operations; deleted Functions

• Advice

17.1. Introduction
This chapter focuses on technical aspects of an object’s “life cycle”: How do we create an object, how do we copy it, how do we move it around, and how do we clean up after it when it goes away? What are proper definitions of “copy” and “move”? For example:

Click here to view code image

string ident(string arg)        // string passed by value (copied into arg)
{
     return arg;                // return string (move the value of arg out of ident() to a caller)
}

int main ()
{
     string s1 {"Adams"};       // initialize string (construct in s1).
     s1 = idet(s1);            // copy s1 into ident()
                                // move the result of ident(s1) into s1;
                                // s1's value is "Adams".
     string s2 {"Pratchett"};   // initialize string (construct in s2)
     s1 = s2;                   // copy the value of s2 into s1
                                // both s1 and s2 have the value "Pratchett".
}
Clearly, after the call of ident(), the value of s1 ought to be "Adams". We copy the value of s1 into the argument arg, then we move the value of arg out of the function call and (back) into s1. Next, we construct s2 with the value "Prachett" and copy it into s1. Finally, at the exit from main() we destroy the variables s1 and s2. The difference between move and copy is that after a copy two objects must have the same value, whereas after a move the source of the move is not required to have its original value. Moves can be used when the source object will not be used again. They are particularly useful for implementing the notion of moving a resource (§3.2.1.2, §5.2).

Several functions are used here:

• A constructor initializing a string with a string literal (used for s1 and s2)

• A copy constructor copying a string (into the function argument arg)

• A move constructor moving the value of a string (from arg out of ident() into a temporary variable holding the result of ident(s1))

• A move assignment moving the value of a string (from the temporary variable holding the result of ident(s1) into s1)

• A copy assignment copying a string (from s2 into s1)

• A destructor releasing the resources owned by s1, s2, and the temporary variable holding the result of ident(s1), and doing nothing to the moved-from function argument

An optimizer can eliminate some of this work. For example, in this simple example the temporary variable is typically eliminated. However, in principle, these operations are executed.

Constructors, copy and move assignment operations, and destructors directly support a view of lifetime and resource management. An object is considered an object of its type after its constructor completes, and it remains an object of its type until its destructor starts executing. The interaction between object lifetime and errors is explored further in §13.2 and §13.3. In particular, this chapter doesn’t discuss the issue of half-constructed and half-destroyed objects.

Construction of objects plays a key role in many designs. This wide variety of uses is reflected in the range and flexibility of the language features supporting initialization.

Constructors, destructors, and copy and move operations for a type are not logically separate. We must define them as a matched set or suffer logical or performance problems. If a class X has a destructor that performs a nontrivial task, such as free-store deallocation or lock release, the class is likely to need the full complement of functions:

Click here to view code image

class X {
     X(Sometype);              public: X(Sometype); // "ordinar y constr uctor": create an object
     X();                      // default constructor
     X(const X&);              // copy constructor
     X(X&&);                   // move constructor
     X& operator=(const X&);   // copy assignment: clean up target and copy
     X& operator=(X&&);        // move assignment: clean up target and move
     ~X();                     // destructor: clean up
      //...
};
There are six situations in which an object is copied or moved:

• As the source of an assignment

• As an object initializer (of named objects, objects on the free store, and temporary objects)

• As a function argument

• As a function return value

• As the source of an explicit type conversion (§11.5)

• As an exception

In all cases, the copy or move constructor will be applied (unless it can be optimized away).

Except for the “ordinary constructor,” these special member functions can be generated by the compiler; see §17.6.

This chapter is full of rules and technicalities. Those are necessary for a full understanding, but most people just learn the general rules from examples.

17.2. Constructors and Destructors
We can specify how an object of a class is to be initialized by defining a constructor (§16.2.5, §17.3). To complement constructors, we can define a destructor to ensure “cleanup” at the point of destruction of an object (e.g., when it goes out of scope). Some of the most effective techniques for resource management in C++ rely on constructor/destructor pairs. So do other techniques relying on a pair of actions, such as do/undo, start/stop, before/after, etc. For example:

Click here to view code image

struct Tracer {
     string mess;
     Tracer(const string& s) :mess{s} { clog << mess; }
     ~Tracer() {clog << "~" << mess; }
};

void f(const vector<int>& v)
{
     Tracer tr {"in f()\n"};
     for (auto x : v) {
          Tracer tr {string{"v loop "}+to<string>(x)+'\n'};  //§25.2.5.1
           //...
     }
}
We could try a call:

f({2,3,5});
This would print to the logging stream:

in_f()
v loop 2
~v loop 2
v loop 3
~v loop 3
v loop 5
~v loop 5
~in_f()
17.2.1. Constructors and Invariants
A member with the same name as its class is called a constructor. For example:

class Vector {
public:
     Vector(int s);
      //...
};
A constructor declaration specifies an argument list (exactly as for a function) but has no return type. The name of a class cannot be used for an ordinary member function, data member, member type, etc., within the class. For example:

Click here to view code image

struct S {
     S();                    // fine
     void S(int);            // error: no type can be specified for a constructor
     int S;                  // error: the class name must denote a constructor
     enum S { foo, bar };    // error: the class name must denote a constructor
};
A constructor’s job is to initialize an object of its class. Often, that initialization must establish a class invariant, that is, something that must hold whenever a member function is called (from outside the class). Consider:

Click here to view code image

class Vector {
public:
     Vector(int s);
      //...
private:
     double* elem;   // elem points to an array of sz doubles
     int sz;         // sz is non-negative
};
Here (as is often the case), the invariant is stated as comments: “elem points to an array of sz doubles” and “sz is non-negative.” The constructor must make that true. For example:

Vector::Vector(int s)
{
     if (s<0) throw Bad_size{s};
     sz = s;
     elem = new double[s];
}
This constructor tries to establish the invariant and if it cannot, it throws an exception. If the constructor cannot establish the invariant, no object is created and the constructor must ensure that no resources are leaked (§5.2, §13.3). A resource is anything we need to acquire and eventually (explicitly or implicitly) give back (release) once we are finished with it. Examples of resources are memory (§3.2.1.2), locks (§5.3.4), file handles (§13.3), and thread handles (§5.3.1).

Why would you define an invariant?

• To focus the design effort for the class (§2.4.3.2)

• To clarify the behavior of the class (e.g., under error conditions; §13.2)

• To simplify the definition of member functions (§2.4.3.2, §16.3.1)

• To clarify the class’s management of resources (§13.3)

• To simplify the documentation of the class

On average, the effort to define an invariant ends up saving work.

17.2.2. Destructors and Resources
A constructor initializes an object. In other words, it creates the environment in which the member functions operate. Sometimes, creating that environment involves acquiring a resource – such as a file, a lock, or some memory – that must be released after use (§5.2, §13.3). Thus, some classes need a function that is guaranteed to be invoked when an object is destroyed in a manner similar to the way a constructor is guaranteed to be invoked when an object is created. Inevitably, such a function is called a destructor. The name of a destructor is ~ followed by the class name, for example ~Vector(). One meaning of ~ is “complement” (§11.1.2), and a destructor for a class complements its constructors. A destructor does not take an argument, and a class can have only one destructor. Destructors are called implicitly when an automatic variable goes out of scope, an object on the free store is deleted, etc. Only in very rare circumstances does the user need to call a destructor explicitly (§17.2.4).

Destructors typically clean up and release resources. For example:

Click here to view code image

class Vector {
public:
     Vector(int s) :elem{new double[s]}, sz{s} { };            // constructor: acquire memory
     ~Vector() { delete[] elem; }                              // destructor: release memory
      //...
private:
     double* elem;    // elem points to an array of sz doubles
     int sz;          // sz is non-negative
};
For example:

Vector* f(int s)
{
     Vector v1(s);
      //...
     return new Vector(s+s);
}

void g(int ss)
{
     Vector* p = f(ss);
      //...
     delete p;
}
Here, the Vector v1 is destroyed upon exit from f(). Also, the Vector created on the free store by f() using new is destroyed by the call of delete. In both cases, Vector’s destructor is invoked to free (deallocate) the memory allocated by the constructor.

What if the constructor failed to acquire enough memory? For example, s*sizeof(double) or (s+s)*sizeof(double) may be larger than the amount of available memory (measured in bytes). In that case, an exception std::bad_alloc (§11.2.3) is thrown by new and the exception-handling mechanism invokes the appropriate destructors so that all memory that has been acquired (and only that) is freed (§13.5.1).

This style of constructor/destructor-based resource management is called Resource Acquisition Is Initialization or simply RAII (§5.2, §13.3).

A matching constructor/destructor pair is the usual mechanism for implementing the notion of a variably sized object in C++. Standard-library containers, such as vector and unordered_map, use variants of this technique for providing storage for their elements.

A type that has no destructor declared, such as a built-in type, is considered to have a destructor that does nothing.

A programmer who declares a destructor for a class must also decide if objects of that class can be copied or moved (§17.6).

17.2.3. Base and Member Destructors
Constructors and destructors interact correctly with class hierarchies (§3.2.4, Chapter 20). A constructor builds a class object “from the bottom up”:

[1] first, the constructor invokes its base class constructors,

[2] then, it invokes the member constructors, and

[3] finally, it executes its own body.

A destructor “tears down” an object in the reverse order:

[1] first, the destructor executes its own body,

[2] then, it invokes its member destructors, and

[3] finally, it invokes its base class destructors.

In particular, a virtual base is constructed before any base that might use it and destroyed after all such bases (§21.3.5.1). This ordering ensures that a base or a member is not used before it has been initialized or used after it has been destroyed. The programmer can defeat this simple and essential rule, but only through deliberate circumvention involving passing pointers to uninitialized variables as arguments. Doing so violates language rules and the results are usually disastrous.

Constructors execute member and base constructors in declaration order (not the order of initializers): if two constructors used a different order, the destructor could not (without serious overhead) guarantee to destroy in the reverse order of construction. See also §17.4.

If a class is used so that a default constructor is needed, and if the class does not have other constructors, the compiler will try to generate a default constructor. For example:

struct S1 {
     string s;
};

S1 x;      // OK: x.s is initialized to ""
Similarly, memberwise initialization can be used if initializers are needed. For example:

struct X { X(int); };

struct S2 {
     X x;
};

S2 x1;      // error: no value for x1.x
S2 x2 {1};  // OK: x2.x is initialized with 1
See also §17.3.1.

17.2.4. Calling Constructors and Destructors
A destructor is invoked implicitly upon exit from a scope or by delete. It is typically not only unnecessary to explicitly call a destructor; doing so would lead to nasty errors. However, there are rare (but important) cases where a destructor must be called explicitly. Consider a container that (like std::vector) maintains a pool of memory into which it can grow and shrink (e.g., using push_back() and pop_back()). When we add an element, the container must invoke its constructor for a specific address:

Click here to view code image

void C::push_back(const X& a)
{
      //...
     new(p) X{a};    // copy construct an X with the value a in address p
      //...
}
This use of a constructor is known as “placement new” (§11.2.4).

Conversely, when we remove an element, the container needs to invoke its destructor:

Click here to view code image

void C::pop_back()
{
      //...
     p–>~X();       // destroy the X in address p
}
The p–>~X() notation invokes X’s destructor for *p. That notation should never be used for an object that is destroyed in the normal way (by its object going out of scope or being deleted).

For a more complete example of explicit management of objects in a memory area, see §13.6.1.

If declared for a class X, a destructor will be implicitly invoked whenever an X goes out of scope or is deleted. This implies that we can prevent destruction of an X by declaring its destructor =delete (§17.6.4) or private.

Of the two alternatives, using private is the more flexible. For example, we can create a class for which objects can be explicitly destroyed, but not implicitly:

Click here to view code image

class Nonlocal {
public:
      //...
     void destroy() { delete this; }      // explicit destruction
private:
      //...
     ~Nonlocal();                         // don't destroy implicitly
};

void user()
{
     Nonlocal x;                    // error: cannot destroy a Nonlocal
     Nonlocal* p = new Nonlocal;    // OK
      //...
     delete p;                      // error: cannot destroy a Nonlocal
     p.destroy();                   // OK
}
17.2.5. virtual Destructors
A destructor can be declared to be virtual, and usually should be for a class with a virtual function. For example:

Click here to view code image

class Shape {
public:
      //...
     virtual void draw() = 0;
     virtual ~Shape();
};

class Circle :public Shape {
public:
      //...
     void draw();
     ~Circle();         // overrides ~Shape()
      //...
};
The reason we need a virtual destructor is that an object usually manipulated through the interface provided by a base class is often also deleted through that interface:

Click here to view code image

void user(Shape* p)
{
     p–>draw();         // invoke the appropriate draw()
      //...
     delete p;          // invoke the appropriate destructor
};
Had Shape’s destructor not been virtual that delete would have failed to invoke the appropriate derived class destructor (e.g., ~Circle()). That failure would cause the resources owned by the deleted object (if any) to be leaked.

17.3. Class Object Initialization
This section discusses how to initialize objects of a class with and without constructors. It also shows how to define constructors to accept arbitrarily sized homogeneous initializer lists (such as {1,2,3} and {1,2,3,4,5,6}).

17.3.1. Initialization Without Constructors
We cannot define a constructor for a built-in type, yet we can initialize it with a value of suitable type. For example:

int a {1};
char* p {nullptr};
Similarly, we can initialize objects of a class for which we have not defined a constructor using

• memberwise initialization,

• copy initialization, or

• default initialization (without an initializer or with an empty initializer list).

For example:

Click here to view code image

struct Work {
     string author;
     string name;
     int year;
};

Work s9 { "Beethoven",
          "Symphony No. 9 in D minor, Op. 125; Choral",
          1824
      };                          // memberwise initialization

Work currently_playing { s9 };    // copy initialization
Work none {};                     // default initialization
The three members of currently_playing are copies of those of s9.

The default initialization of using {} is defined as initialization of each member by {}. So, none is initialized to {{},{},{}}, which is {"","",0} (§17.3.3).

Where no constructor requiring arguments is declared, it is also possible to leave out the initializer completely. For example:

Work alpha;

void f()
{
     Work beta;
      //...
}
For this, the rules are not as clean as we might like. For statically allocated objects (§6.4.2), the rules are exactly as if you had used {}, so the value of alpha is {"","",0}. However, for local variables and free-store objects, the default initialization is done only for members of class type, and members of built-in type are left uninitialized, so the value of beta is {"","",unknown}.

The reason for this complication is to improve performance in rare critical cases. For example:

struct Buf {
     int count;
     char buf[16*1024];
};
You can use a Buf as a local variable without initializing it before using it as a target for an input operation. Most local variable initializations are not performance critical, and uninitialized local variables are a major source of errors. If you want guaranteed initialization or simply dislike surprises, supply an initializer, such as {}. For example:

Click here to view code image

Buf buf0;        // statically allocated, so initialized by default

void f()
{
     Buf buf1;              // leave elements uninitialized
     Buf buf2 {};           // I really want to zero out those elements

     int* p1 = new int;     //*p1 is uninitialized
     int* p2 = new int{};   //*p2 == 0
     int* p3 = new int{7};  //*p3 == 7
    //...
}
Naturally, memberwise initialization works only if we can access the members. For example:

Click here to view code image

template<typename T>
class Checked_pointer {  // control access to T* member
public:
     T& operator*();    // check for nullptr and return value
 //...
};

Checked_pointer<int> p {new int{7}};   // error: can't access p.p
If a class has a private non-static data member, it needs a constructor.

17.3.2. Initialization Using Constructors
Where memberwise copy is not sufficient or desirable, a constructor can be defined to initialize an object. In particular, a constructor is often used to establish an invariant for its class and to acquire resources necessary to do that (§17.2.1).

If a constructor is declared for a class, some constructor will be used for every object. It is an error to try to create an object without a proper initializer as required by the constructors. For example:

Click here to view code image

struct X {
     X(int);
};

X x0;           // error: no initializer
X x1 {};        // error: empty initializer
X x2 {2};       // OK
X x3 {"two"};   // error: wrong initializer type
X x4 {1,2};     // error: wrong number of initializers
X x5 {x4};      // OK: a copy constructor is implicitly defined (§17.6)
Note that the default constructor (§17.3.3) disappears when you define a constructor requiring arguments; after all, X(int) states that an int is required to construct an X. However, the copy constructor does not disappear (§17.3.3); the assumption is that an object can be copied (once properly constructed). Where the latter might cause problems (§3.3.1), you can specifically disallow copying (§17.6.4).

I used the {} notation to make explicit the fact that I am initializing. I am not (just) assigning a value, calling a function, or declaring a function. The {} notation for initialization can be used to provide arguments to a constructor wherever an object can be constructed. For example:

Click here to view code image

struct Y : X {
     X m {0};                      // provide default initializer for member X.m in Y
     Y(int a) :X{a}, m{a} { }     // initialize base and member (§17.4)
     Y() :X{0} { }               // initialize base and member
};

X g {1};     // initialize global variable

void f(int a)
{
     X def {};                     // error: no default value for X
     Y de2 {};                     // OK: use default constructor
     X* p {nullptr}; // initialize local variable
     X var {2};                    // initialize local variable
     p = new X{4};                 // initialize object on free store
     X a[] {1,2,3};                // initialize array elements
     vector<X> v {1,2,3,4};        // initialize vector elements
}
For this reason, {} initialization is sometimes referred to as universal initialization: the notation can be used everywhere. In addition, {} initialization is uniform: wherever you initialize an object of type X with a value v using the {v} notation, the same value of type X (X{v}) is created.

The = and () notations for initialization (§6.3.5) are not universal. For example:

Click here to view code image

struct Y : X {
     X m;
     Y(int a) : X(a), m=a { };  // syntax error: can't use = for member initialization
};

X g(1);    // initialize global variable

void f(int a)
{
     X def();                   // function returning an X (surprise!?)
     X* p {nullptr};
     X var = 2;                 // initialize local variable
     p = new X=4;               // syntax error: can't use = for new
     X a[](1,2,3);              // error: can't use () for array initialization
     vector<X> v(1,2,3,4);      // error: can't use () for list elements
}
The = and () notations for initialization are not uniform either, but fortunately the examples of that are obscure. If you insist on using = or () initialization, you have to remember where they are allowed and what they mean.

The usual overload resolution rules (§12.3) apply for constructors. For example:

Click here to view code image

struct S {
     S(const char*);
     S(double*);
};

S s1 {"Napier"};              // S::S(const char*)
S s2 {new double{1.0}};       // S::S(double*);
S s3 {nullptr};               // ambiguous: S::S(const char*) or S::S(double*)?
Note that the {}-initializer notation does not allow narrowing (§2.2.2). That is another reason to prefer the {} style over () or =.

17.3.2.1. Initialization by Constructors
Using the () notation, you can request to use a constructor in an initialization. That is, you can ensure that for a class, you will get initialization by constructor and not get the memberwise initialization or initializer-list initialization (§17.3.4) that the {} notation also offers. For example:

Click here to view code image

struct S1 {
     int a,b;                                           // no constructor
};

struct S2 {
     int a,b;
     S2(int aa = 0, int b = 0) : a(aa), b(bb) {}         // constructor
};

S1 x11(1,2);     // error: no constructor
S1 x12 {1,2};    // OK: memberwise initialization

S1 x13(1);       // error: no constructor
S1 x14 {1};      // OK: x14.b becomes 0

S2 x21(1,2);     // OK: use constructor
S2 x22 {1,2};    // OK: use constructor

S2 x23(1);       // OK: use constructor and one default argument
S2 x24 {1};      // OK: use constructor and one default argument
The uniform use of {} initialization only became possible in C++11, so older C++ code uses () and = initialization. Consequently, the () and = may be more familiar to you. However, I don’t know any logical reason to prefer the () notation except in the rare case where you need to distinguish between initialization with a list of elements and a list of constructor arguments. For example:

Click here to view code image

vector<int> v1 {77};       // one element with the value 77
vector<int> v2(77);        //77 elements with the default value 0
This problem – and the need to choose – can occur when a type with an initializer-list constructor (§17.3.4), typically a container, also has an “ordinary constructor” accepting arguments of the element type. In particular, we occasionally must use () initialization for vectors of integers and floating-point numbers but never need to for vectors of strings or vectors of pointers:

Click here to view code image

vector<string> v1 {77};        //77 elements with the default value ""
                               //(vector<string>(std::initializer_list<string>) doesn't accept {77})
vector<string> v2(77);         //77 elements with the default value ""

vector<string> v3 {"Booh!"};   // one element with the value "Booh!"
vector<string> v4("Booh!");    // error: no constructor takes a string argument

vector<int*> v5 {100,0};       //100 int*s initialized to nullptr (100 is not an int*)

vector<int*> v6 {0,0};         //2 int*s initialized to nullptr
vector<int*> v7(0,0);          // empty vector (v7.size()==0)
vector<int*> v8;               // empty vector (v7.size()==0)
The v6 and v7 examples are only of interest to language lawyers and testers. A programmer using nullptr, rather than 0, will have fewer surprises.

17.3.3. Default Constructors
A constructor that can be invoked without an argument is called a default constructor. Default constructors are very common. For example:

Click here to view code image

class Vector {
public:
     Vector();      // default constructor: no elements
      //...
};
A default constructor is used if no arguments are specified or if an empty initializer list is provided:

Vector v1;        // OK
Vector v2 {};     // OK
A default argument (§12.2.5) can make a constructor that takes arguments into a default constructor. For example:

Click here to view code image

class String {
public:
     String(const char* p = "");      // default constructor: empty string
      //...
};

String s1;          // OK
String s2 {};       // OK
The standard-library vector and string have such default constructors (§36.3.2, §31.3.2).

The built-in types are considered to have default and copy constructors. However, for a built-in type the default constructor is not invoked for uninitialized non-static variables (§17.3). The default value of a built-in type is 0 for integers, 0.0 for floating-point types, and nullptr for pointers. For example:

Click here to view code image

void f()
{
     int a0;                 // uninitialized
     int a1();               // function declaration (intended?)

     int a {};               // a becomes 0
     double d {};            // d becomes 0.0
     char* p {};             // p becomes nullptr

     int* p1 = new int;      // uninitialized int
     int* p2 = new int{};    // the int is initialized to 0
}
Constructors for built-in types are most often used for template arguments. For example:

Click here to view code image

template<typename T>
struct Handle {
     T* p;
     Handle(T* pp = new T{}) :p{pp} { }
      //...
};

Handle<int> px;      // will generate int{}
The generated int will be initialized to 0.

References and consts must be initialized (§7.7, §7.5). Therefore, a class containing such members cannot be default constructed unless the programmer supplies in-class member initializers (§17.4.4) or defines a default constructor that initializes them (§17.4.1). For example:

Click here to view code image

int glob {9};

struct X {
     const int a1 {7};      // OK
     const int a2;          // error: requires a user-defined constructor
     const int& r {9};      // OK
     int& r1 {glob};        // OK
     int& r2;               // error: requires a user-defined constructor
};

X x;       // error: no default constructor for X
An array, a standard-library vector, and similar containers can be declared to allocate a number of default-initialized elements. In such cases, a default constructor is obviously required for a class used as the element type of a vector or array. For example:

Click here to view code image

struct S1 { S1(); };                  // has default constructor
struct S2 { S2(string); };            // no default constructor

S1 a1[10];                            // OK: 10 default elements
S2 a2[10];                            // error: cannot initialize elements
S2 a3[] { "alpha", "beta" };          // OK: two elements: S2{"alpha"}, S2{"beta"}

vector<S1> v1(10);                    // OK: 10 default elements
vector<S2> v2(10);                    // error: cannot initialize elements
vector<S2> v3 { "alpha", "beta" };    // OK: two elements: S2{"alpha"}, S2{"beta"}

vector<S2> v2(10,"");                 // OK: 10 elements each initialized to S2{""}
vector<S2> v4;                        // OK: no elements
When should a class have a default constructor? A simple-minded technical answer is “when you use it as the element type for an array, etc.” However, a better question is “For what types does it make sense to have a default value?” or even “Does this type have a ‘special’ value we can ‘naturally’ use as a default?” String has the empty string, "", containers have the empty set, {}, and numeric values have zero. The trouble with deciding on a default Date (§16.3) arose because there is no “natural” default date (the Big Bang is too far in the past and not precisely associated with our everyday dates). It is a good idea not to be too clever when inventing default values. For example, the problem with containers of elements without default values is often best solved by not allocating elements until you have proper values for them (e.g., using push_back()).

17.3.4. Initializer-List Constructors
A constructor that takes a single argument of type std::initialize r_list is called an initializer-list constructor. An initializer-list constructor is used to construct objects using a {}-list as its initializer value. Standard-library containers (e.g., vector and map) have initializer-list constructors, assignments, etc. (§31.3.2, §31.4.3). Consider:

Click here to view code image

vector<double> v = { 1, 2, 3.456, 99.99 };

list<pair<string,string>> languages = {
     {"Nygaard","Simula"}, {"Richards","BCPL"}, {"Ritchie","C"}
};

map<vector<string>,vector<int>> years = {
     { {"Maurice","Vincent", "Wilkes"},{1913, 1945, 1951, 1967, 2000} },
     { {"Martin", "Richards"}, {1982, 2003, 2007} },
     { {"David", "John", "Wheeler"}, {1927, 1947, 1951, 2004} }
};
The mechanism for accepting a {}-list is a function (often a constructor) taking an argument of type std::initializer_list<T>. For example:

Click here to view code image

void f(initializer_list<int>);

f({1,2});
f({23,345,4567,56789});
f({});      // the empty list

f{1,2};     // error: function call () missing

years.insert({{"Bjarne","Stroustrup"},{1950, 1975, 1985}});
The initializer list can be of arbitrary length but must be homogeneous. That is, all elements must be of the template argument type, T, or implicitly convertible to T.

17.3.4.1. initializer_list Constructor Disambiguation
When you have several constructors for a class, the usual overload resolution rules (§12.3) are used to select the right one for a given set of arguments. For selecting a constructor, default and initializer lists take precedence. Consider:

Click here to view code image

struct X {
     X(initializer_list<int>);
     X();
     X(int);
};

X x0 {};     // empty list: default constructor or initializer-list constructor? (the default constructor)
X x1 {1};    // one integer: an int argument or a list of one element? (the initializer-list constructor)
The rules are:

• If either a default constructor or an initializer-list constructor could be invoked, prefer the default constructor.

• If both an initializer-list constructor and an “ordinary constructor” could be invoked, prefer the initializer-list constructor.

The first rule, “prefer the default constructor,” is basically common sense: pick the simplest constructor when you can. Furthermore, if you define an initializer-list constructor to do something with an empty list that differs from what the default constructor does, you probably have a design error on your hands.

The second rule, “prefer the initializer-list constructor,” is necessary to avoid different resolutions based on different numbers of elements. Consider std::vector (§31.4):

Click here to view code image

vector<int> v1 {1};          // one element
vector<int> v2 {1,2};        // two elements
vector<int> v3 {1,2,3};      // three elements

vector<string> vs1 {"one"};
vector<string> vs2 {"one", "two"};
vector<string> vs3 {"one", "two", "three"};
In every case, the initializer-list constructor is used. If we really want to invoke the constructor taking one or two integer arguments, we must use the () notation:

Click here to view code image

vector<int> v1(1);     // one element with the default value (0)
vector<int> v2(1,2);   // one element with the value 2
17.3.4.2. Use of initializer_lists
A function with an initialize r_list<T> argument can access it as a sequence using the member functions begin(), end(), and size(). For example:

Click here to view code image

void f(initializer_list<int> args)
{
     for (int i = 0; i!=args.size(); ++i)
           cout << args.begin()[i] << "\n";
}
Unfortunately, initializer_list doesn’t provide subscripting.

An initializer_list<T> is passed by value. That is required by the overload resolution rules (§12.3) and does not impose overhead because an initializer_list<T> object is just a small handle (typically two words) to an array of Ts.

That loop could equivalently have been written:

Click here to view code image

void f(initializer_list<int> args)
{
     for (auto p=args.begin(); p!=args.end(); ++p)
           cout << *p << "\n";
}
or:

void f(initializer_list<int> args)
{
     for (auto x : args)
           cout << x << "\n";
}
To explicitly use an initializer_list you must #include the header file in which it is defined: <initializer_list>. However, since vector, map, etc., use initializer_lists, their headers (<vector>, <map>, etc.) already #include <initializer_list>, so you rarely have to do so directly.

The elements of an initializer_list are immutable. Don’t even think about trying to modify their values. For example:

Click here to view code image

int f(std::initializer_list<int> x, int val)
{
     *x.begin() = val;          // error: attempt to change the value of an initializer-list element
     return *x.begin();    // OK
}

void g()
{
     for (int i=0; i!=10; ++i)
           cout << f({1,2,3},i) << '\n';
}
Had the assignment in f() succeeded, it would have appeared that the value of 1 (in {1,2,3}) could change. That would have done serious damage to some of our most fundamental concepts. Because initializer_list elements are immutable, we cannot apply a move constructor (§3.3.2, §17.5.2) to them.

A container might implement an initializer-list constructor like this:

Click here to view code image

template<typename E>
class Vector {
public:
     Vector(initializer_list<E> s);  // initializer-list constructor
      //...
private:
     int sz;
     E* elem;
};

template<typename E>
Vector::Vector(initializer_list<E> s)
     :sz{s.size()}                                // set vector size
{
     reserve(sz);                                 // get the right amount of space
     uninitialized_copy(s.begin(), s.end(), elem);       // initialize elements in elem[0:s.size())
}
The initializer lists are part of the universal and uniform initialization design (§17.3).

17.3.4.3. Direct and Copy Initialization
The distinction between direct initialization and copy initialization (§16.2.6) is maintained for {} initialization. For a container, this implies that the distinction is applied to both the container and its elements:

• The container’s initializer-list constructor can be explicit or not.

• The constructor of the element type of the initializer list can be explicit or not.

For a vector<vector<double>>, we can see the direct initialization vs. copy initialization distinction applied to elements. For example:

Click here to view code image

vector<vector<double>> vs = {
     {10,11,12,13,14},              // OK: vector of five elements
     {10},                          // OK: vector of one element
     10,                            // error: vector<double>(int) is explicit

     vector<double>{10,11,12,13},   // OK: vector of five elements
     vector<double>{10},            // OK: vector of one element with value 10.0
     vector<double>(10),            // OK: vector of 10 elements with value 0.0
};
A container can have some constructors explicit and some not. The standard-library vector is an example of that. For example, std::vector<int>(int) is explicit, but std::vector<int>(initializer_list<int>) is not:

Click here to view code image

vector<double> v1(7);      // OK: v1 has 7 elements; note: uses () rather than {}
vector<double> v2 = 9;     // error: no conversion from int to vector

void f(const vector<double>&);
void g()
{
     v1 = 9;       // error: no conversion from int to vector
     f(9);         // error: no conversion from int to vector
}
By replacing () with {} we get:

Click here to view code image

vector<double> v1 {7};           // OK: v1 has one element (with the value 7)
vector<double> v2 = {9};         // OK: v2 has one element (with the value 9)

void f(const vector<double>&);
void g()
 {
     v1 = {9};     // OK: v1 now has one element (with the value 9)
     f({9});       // OK: f is called with the list {9}
}
Obviously, the results are dramatically different.

This example was carefully crafted to give an example of the most confusing cases. Note that the apparent ambiguities (in the eyes of the human reader but not the compiler) do not emerge for longer lists. For example:

Click here to view code image

vector<double> v1 {7,8,9};           // OK: v1 has three elements with values {7,8,9}
vector<double> v2 = {9,8,7};         // OK: v2 has three elements with values {9,8,7}
void f(const vector<double>&);
void g()
{
     v1 = {9,10,11};     // OK: v1 now has three elements with values {9,10,11}
     f({9,8,7,6,5,4});   // OK: f is called with the list {9,8,7,6,5,4}
}
Similarly, the potential ambiguities do not occur for lists of elements of nonintegral types:

Click here to view code image

vector<string> v1 { "Anya"};        // OK: v1 has one element (with the value "Anya")
vector<string> v2 = {"Courtney"};   // OK: v2 has one element (with the value "Courtney")

void f(const vector<string>&);
void g()
{
     v1 = {"Gavin"};       // OK: v1 now has one element (with the value "Gavin")
     f({"Norah"});         // OK: f is called with the list {"Norah"}
}
17.4. Member and Base Initialization
Constructors can establish invariants and acquire resources. Generally, they do that by initializing class members and base classes.

17.4.1. Member Initialization
Consider a class that might be used to hold information for a small organization:

class Club {
     string name;
     vector<string> members;
     vector<string> officers;
     Date founded;
      //...
     Club(const string& n, Date fd);
};
The Club’s constructor takes the name of the club and its founding date as arguments. Arguments for a member’s constructor are specified in a member initializer list in the definition of the constructor of the containing class. For example:

Click here to view code image

Club::Club(const string& n, Date fd)
     : name{n}, members{}, officers{}, founded{fd}
{
      //...
}
The member initializer list starts with a colon, and the individual member initializers are separated by commas.

The members’ constructors are called before the body of the containing class’s own constructor is executed (§17.2.3). The constructors are called in the order in which the members are declared in the class rather than the order in which the members appear in the initializer list. To avoid confusion, it is best to specify the initializers in the member declaration order. Hope for a compiler warning if you don’t get the order right. The member destructors are called in the reverse order of construction after the body of the class’s own destructor has been executed.

If a member constructor needs no arguments, the member need not be mentioned in the member initializer list. For example:

Club::Club(const string& n, Date fd)
     : name{n}, founded{fd}
{
      //...
}
This constructor is equivalent to the previous version. In each case, Club::officers and Club::members are initialized to a vector with no elements.

It is usually a good idea to be explicit about initializing members. Note that an “implicitly initialized” member of a built-in type is left uninitialized (§17.3.1).

A constructor can initialize members and bases of its class, but not members or bases of its members or bases. For example:

Click here to view code image

struct B { B(int); /* ... */};
struct BB : B { /* ... */ };
struct BBB : BB {
     BBB(int i) : B(i) { }  // error: trying to initialize base's base
      //...
};
17.4.1.1. Member Initialization and Assignment
Member initializers are essential for types for which the meaning of initialization differs from that of assignment. For example:

Click here to view code image

class X {
     const int i;
     Club cl;
     Club& rc;
      //...
     X(int ii, const string& n, Date d, Club& c) : i{ii}, cl{n,d}, rc{c} { }
};
A reference member or a const member must be initialized (§7.5, §7.7, §17.3.3). However, for most types the programmer has a choice between using an initializer and using an assignment. In that case, I usually prefer to use the member initializer syntax to make it explicit that initialization is being done. Often, there also is an efficiency advantage to using the initializer syntax (compared to using an assignment). For example:

Click here to view code image

class Person {
     string name;
     string address;
      //...
     Person(const Person&);
     Person(const string& n, const string& a);
};

Person::Person(const string& n, const string& a)
     : name{n}
{
     address = a;
}
Here name is initialized with a copy of n. On the other hand, address is first initialized to the empty string and then a copy of a is assigned.

17.4.2. Base Initializers
Bases of a derived class are initialized in the same way non-static data members are. That is, if a base requires an initializer, it must be provided as a base initializer in a constructor. If we want to, we can explicitly specify default construction. For example:

Click here to view code image

class B1 { B1(); };      // has default constructor
class B2 { B2(int); }    // no default constructor

struct D1 : B1, B2 {
     D1(int i) :B1{}, B2{i} {}
};

struct D2 : B1, B2 {
     D2(int i) :B2{i} {}           // B1{} is used implicitly
};

struct D1 : B1, B2 {
     D1(int i) { }                 // error: B2 requires an int initializer
};
As with members, the order of initialization is the declaration order, and it is recommended to specify base initializers in that order. Bases are initialized before members and destroyed after members (§17.2.3).

17.4.3. Delegating Constructors
If you want two constructors to do the same action, you can repeat yourself or define “an init() function” to perform the common action. Both “solutions” are common (because older versions of C++ didn’t offer anything better). For example:

Click here to view code image

class X {
     int a;
     validate(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
public:
     X(int x) { validate(x); }
     X() { validate(42); }
     X(string s) { int x = to<int>(s); validate(x); }  //§25.2.5.1
      //...
};
Verbosity hinders readability and repetition is error-prone. Both get in the way of maintainability. The alternative is to define one constructor in terms of another:

Click here to view code image

class X {
     int a;
public:
     X(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
     X() :X{42} { }
     X(string s) :X{to<int>(s)} { }         //§25.2.5.1
      //...
};
That is, a member-style initializer using the class’s own name (its constructor name) calls another constructor as part of the construction. Such a constructor is called a delegating constructor (and occasionally a forwarding constructor).

You cannot both delegate and explicitly initialize a member. For example:

Click here to view code image

class X {
     int a;
public:
     X(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
     X() :X{42}, a{56} { }      // error
      //...
};
Delegating by calling another constructor in a constructor’s member and base initializer list is very different from explicitly calling a constructor in the body of a constructor. Consider:

Click here to view code image

class X {
     int a;
public:
     X(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
     X() { X{42}; }     // likely error
      //...
};
The X{42} simply creates a new unnamed object (a temporary) and does nothing with it. Such use is more often than not a bug. Hope for a compiler warning.

An object is not considered constructed until its constructor completes (§6.4.2). When using a delegating constructor, the object is considered constructed when the delegated-to constructor completes.

If all you need is to set a member to a default value (that doesn’t depend on a constructor argument), a member initializer (§17.4.4) may be simpler.

17.4.4. In-Class Initializers
We can specify an initializer for a non-static data member in the class declaration. For example:

class A {
public:
     int a {7};
     int b = 77;
};
For pretty obscure technical reasons related to parsing and name lookup, the {} and = initializer notations can be used for in-class member initializers, but the () notation cannot.

By default, a constructor will use such an in-class initializer, so that example is equivalent to:

class A {
public:
     int a;
     int b;
     A() : a{7}, b{77} {}
};
Such use of in-class initializers can save a bit of typing, but the real benefits come in more complicated classes with multiple constructors. Often, several constructors use the same initializer for a member. For example:

Click here to view code image

class A {
public:
     A() :a{7}, b{5}, algorithm{"MD5"}, state{"Constructor run"} {}
     A(int a_val) :a{a_val}, b{5}, algorithm{"MD5"}, state{"Constructor run"} {}
     A(D d) :a{7}, b{g(d)}, algorithm{"MD5"}, state{"Constructor run"} {}
      //...
private:
     int a, b;
     HashFunction algorithm;        // cryptographic hash to be applied to all As
     string state;                  // string indicating state in object life cycle
};
The fact that algorithm and state have the same value in all constructors is lost in the mess of code and can easily become a maintenance problem. To make the common values explicit, we can factor out the unique initializer for data members:

Click here to view code image

class A {
public:
     A() :a{7}, b{5} {}
     A(int a_val) :a{a_val}, b{5} {}
     A(D d) :a{7}, b{g(d)} {}
      //...
private:
     int a, b;
     HashFunction algorithm {"MD5"};       // cryptographic hash to be applied to all As
     string state {"Constructor run"};     // string indicating state in object life cycle
};
If a member is initialized by both an in-class initializer and a constructor, only the constructor’s initialization is done (it “overrides” the default). So we can simplify further:

Click here to view code image

class A {
public:
     A() {}
     A(int a_val) :a{a_val} {}
     A(D d) :b{g(d)} {}
      //...
private:
     int a {7};                            // the meaning of 7 for a is ...
     int b {5};                            // the meaning of 5 for b is ...
     HashFunction algorithm {"MD5"};       // Cryptographic hash to be applied to all As
     string state {"Constructor run"};     // String indicating state in object lifecycle
};
As shown, default in-class initializers provide an opportunity for documentation of common cases.

An in-class member initializer can use names that are in scope at the point of their use in the member declaration. Consider the following headache-inducing technical example:

Click here to view code image

int count = 0;
int count2 = 0;

int f(int i) { return i+count; }

struct S {
     int m1 {count2};          // that is, ::count2
     int m2 {f(m1)};           // that is, this->m1+::count; that is, ::count2+::count
     S() { ++count2; }         // very odd constructor
};

int main()
{
     S s1;      //{0,0}
     ++count;
     S s2;      //{1,2}
}
Member initialization is done in declaration order (§17.2.3), so first m1 is initialized to the value of a global variable count2. The value of the global variable is obtained at the point where the constructor for a new S object is run, so it can (and in this example does) change. Next, m2 is initialized by a call to the global f().

It is a bad idea to hide subtle dependencies on global data in member initializers.

17.4.5. static Member Initialization
A static class member is statically allocated rather than part of each object of the class. Generally, the static member declaration acts as a declaration for a definition outside the class. For example:

Click here to view code image

class Node {
      //...
     static int node_count;           // declaration
};

int Node::node_count = 0;             // definition
However, for a few simple special cases, it is possible to initialize a static member in the class declaration. The static member must be a const of an integral or enumeration type, or a constexpr of a literal type (§10.4.3), and the initializer must be a constant-expression. For example:

Click here to view code image

class Curious {
public:
     static const int c1 = 7;         // OK
     static int c2 = 11;              // error: not const
     const int c3 = 13;               // OK, but not static (§17.4.4)
     static const int c4 = sqrt(9);   // error: in-class initializer not constant
     static const float c5 = 7.0;     // error: in-class not integral (use constexpr rather than const)
      //...
};
If (and only if) you use an initialized member in a way that requires it to be stored as an object in memory, the member must be (uniquely) defined somewhere. The initializer may not be repeated:

Click here to view code image

const int Curious::c1;               // don't repeat initializer here
const int* p = &Curious::c1;         // OK: Curious::c1 has been defined
The main use of member constants is to provide symbolic names for constants needed elsewhere in the class declaration. For example:

template<typename T, int N>
class Fixed {  // fixed-size array
public:
     static constexpr int max = N;
      //...
private:
     T a[max];
};
For integers, enumerators (§8.4) offer an alternative for defining symbolic constants within a class declaration. For example:

Click here to view code image

class X {
     enum { c1 = 7, c2 = 11, c3 = 13, c4 = 17 };
      //...
};
17.5. Copy and Move
When we need to transfer a value from a to b, we usually have two logically distinct options:

• Copy is the conventional meaning of x=y; that is, the effect is that the values of x and y are both equal to y’s value before the assignment.

• Move leaves x with y’s former value and y with some moved-from state. For the most interesting cases, containers, that moved-from state is “empty.”

This simple logical distinction is confounded by tradition and by the fact that we use the same notation for both move and copy.

Typically, a move cannot throw, whereas a copy might (because it may need to acquire a resource), and a move is often more efficient than a copy. When you write a move operation, you should leave the source object in a valid but unspecified state because it will eventually be destroyed and the destructor cannot destroy an object left in an invalid state. Also, standard-library algorithms rely on being able to assign to (using move or copy) a moved-from object. So, design your moves not to throw, and to leave their source objects in a state that allows destruction and assignment.

To save us from tedious repetitive work, copy and move have default definitions (§17.6.2).

17.5.1. Copy
Copy for a class X is defined by two operations:

• Copy constructor: X(const X&)

• Copy assignment: X& operator=(const X&)

You can define these two operations with more adventurous argument types, such as volatile X&, but don’t; you’ll just confuse yourself and others. A copy constructor is supposed to make a copy of an object without modifying it. Similarly, you can use const X& as the return type of the copy assignment. My opinion is that doing so causes more confusion than it is worth, so my discussion of copy assumes that the two operations have the conventional types.

Consider a simple two-dimensional Matrix:

Click here to view code image

template<typename T>
class Matrix {
     array<int,2> dim;        // two dimensions
     T* elem;                 // pointer to dim[0]*dim[1] elements of type T
public:
     Matrix(int d1, int d2) :dim{d1,d2}, elem{new T[d1*d2]} {}            // simplified (no error handling)
     int size() const { return dim[0]*dim[1]; }

     Matrix(const Matrix&);                 // copy constructor
     Matrix& operator=(const Matrix&);      // copy assignment

     Matrix(Matrix&&);                      // move constructor
     Matrix& operator=(Matrix&&);           // move assignment

     ~Matrix() { delete[] elem; }
      //...
};
First we note that the default copy (copy the members) would be disastrously wrong: the Matrix elements would not be copied, the Matrix copy would have a pointer to the same elements as the source, and the Matrix destructor would delete the (shared) elements twice (§3.3.1).

However, the programmer can define any suitable meaning for these copy operations, and the conventional one for a container is to copy the contained elements:

Click here to view code image

template<typename T>
Matrix::Matrix(const Matrix& m)        // copy constructor
     : dim{m.dim},
     elem{new T[m.size()]}
{
     uninitialized_copy(m.elem,m.elem+m.size(),elem);        // initialize elements in elem[0:m.size())
}

template<typename T>
Matrix& Matrix::operator=(const Matrix& m)        // copy assignment
{
     if (dim[0]!=m.dim[0] || dim[1]!=m.dim[1])
           throw runtime_error("bad size in Matrix =");
     copy(m.elem,m.elem+m.size(),elem);      // copy elements
}
A copy constructor and a copy assignment differ in that a copy constructor initializes uninitialized memory, whereas the copy assignment operator must correctly deal with an object that has already been constructed and may own resources.

The Matrix copy assignment operator has the property that if a copy of an element throws an exception, the target of the assignment may be left with a mixture of its old value and the new. That is, that Matrix assignment provided the basic guarantee, but not the strong guarantee (§13.2). If that is not considered acceptable, we can avoid it by the fundamental technique of first making a copy and then swapping representations:

Click here to view code image

Matrix& Matrix::operator=(const Matrix& m)           // copy assignment
{
     Matrix tmp {m};          // make a copy
     swap(tmp,*this);         // swap tmp's representation with *this's
     return *this;
}
The swap() will be done only if the copy was successful. Obviously, this operator=() works only if the implementation swap() does not use assignment (std::swap() does not); see §17.5.2.

Usually a copy constructor must copy every non-static member (§17.4.1). If a copy constructor cannot copy an element (e.g., because it needs to acquire an unavailable resource to do so), it can throw an exception.

Note that I did not protect Matrix’s copy assignment against self-assignment, m=m. The reason I did not test is that self-assignment of the members is already safe: both my implementations of Matrix’s copy assignment will work correctly and reasonably efficiently for m=m. Also, self-assignment is rare, so test for self-assignment in a copy assignment only if you are sure that you need to.

17.5.1.1. Beware of Default Constructors
When writing a copy operation, be sure to copy every base and member. Consider:

Click here to view code image

class X {
     string s;
     string s2;
     vector<string> v;

     X(const X&a)           // copy constructor
         :s{a.s}, v{a.v}   // probably sloppy and probably wrong
     {
     }
      //...
};
Here, I “forgot” to copy s2, so it gets default initialized (to ""). This is unlikely to be right. It is also unlikely that I would make this mistake for a simple class. However, for larger classes the chances of forgetting go up. Worse, when someone long after the initial design adds a member to a class, it is easy to forget to add it to the list of members to be copied. This is one reason to prefer the default (compiler-generated) copy operations (§17.6).

17.5.1.2. Copy of Bases
For the purposes of copying, a base is just a member: to copy an object of a derived class you have to copy its bases. For example:

Click here to view code image

struct B1 {
     B1();
     B1(const B1&);
      //...
};

struct B2 {
     B2(int);
     B2(const B2&);
      //...
};

struct D : B1, B2 {
     D(int i) :B1{}, B2{i}, m1{}, m2{2*i} {}
     D(const D& a) :B1{a}, B2{a}, m1{a.m1}, m2{a.m2} {}
     B1 m1;
     B2 m2;
};

D d {1};      // construct with int argument
D dd {d};     // copy construct
The order of initialization is the usual (base before member), but for copying the order had better not matter.

A virtual base (§21.3.5) may appear as a base of several classes in a hierarchy. A default copy constructor (§17.6) will correctly copy it. If you define your own copy constructor, the simplest technique is to repeatedly copy the virtual base. Where the base object is small and the virtual base occurs only a few times in a hierarchy, that can be more efficient than techniques for avoiding the replicated copies.

17.5.1.3. The Meaning of Copy
What does a copy constructor or copy assignment have to do to be considered “a proper copy operation”? In addition to be declared with a correct type, a copy operation must have the proper copy semantics. Consider a copy operation, x=y, of two objects of the same type. To be suitable for value-oriented programming in general (§16.3.4), and for use with the standard library in particular (§31.2.2), the operation must meet two criteria:

• Equivalence: After x=y, operations on x and y should give the same result. In particular, if == is defined for their type, we should have x==y and f(x)==f(y) for any function f() that depends only on the values of x and y (as opposed to having its behavior depend on the addresses of x and y).

• Independence: After x=y, operations on x should not implicitly change the state of y, that is f(x) does not change the value of y as long as f(x) doesn’t refer to y.

This is the behavior that int and vector offer. Copy operations that provide equivalence and independence lead to simpler and more maintainable code. This is worth stating because code that violates these simple rules is not uncommon, and programmers don’t always realize that such violations are the root cause of some of their nastier problems. A copy that provides equivalence and independence is part of the notion of a regular type (§24.3.1).

First consider the requirement of equivalence. People rarely violate this requirement deliberately, and the default copy operations do not violate it; they do memberwise copy (§17.3.1, §17.6.2). However, tricks, such as having the meaning of copy depend on “options,” occasionally appear and typically cause confusion. Also, it is not uncommon for an object to contain members that are not considered part of its value. For example, a copy of a standard container does not copy its allocator because the allocator is considered part of the container, rather than part of its value. Similarly, counters for statistics gathering and cached values are sometimes not simply copied. Such “non-value” parts of an object’s state should not affect the result of comparison operators. In particular, x=y should imply x==y. Furthermore, slicing (§17.5.1.4) can lead to “copies” that behave differently, and is most often a bad mistake.

Now consider the requirement of independence. Most of the problems related to (lack of) independence have to do with objects that contain pointers. The default meaning of copy is memberwise copy. A default copy operation copies a pointer member, but does not copy the object (if any) that it points to. For example:

Click here to view code image

struct S {
     int* p;     // a pointer
};

S x {new int{0}};
void f()
{
     S y {x};               //"copy" x

     *y.p = 1;              // change y; affects x
     *x.p = 2;              // change x; affects y
     delete y.p;            // affects x and y
     y.p = new int{3};      // OK: change y; does not affect x
     *x.p = 4;              // oops: write to deallocated memory
}
Here I violated the rule of independence. After the “copy” of x into y, we can manipulate part of x’s state through y. This is sometimes called shallow copy and (too) often praised for “efficiency.” The obvious alternative of copying the complete state of an object is called deep copy. Often, the better alternative to deep copy is not a shallow copy, but a move operation, which minimizes copying without adding complexity (§3.3.2, §17.5.2).

A shallow copy leaves two objects (here, x and y) with a shared state, and has a huge potential for confusion and errors. We say that the objects x and y have become entangled when the requirement of independence has been violated. It is not possible to reason about an entangled object in isolation. For example, it is not obvious from the source code that the two assignments to *x.p can have dramatically different effects.

We can represent two entangled objects graphically:



Note that entanglement can arise in a variety of ways. Often, it is not obvious that entanglement has happened until probems arise. For example, a type like S may incautiously be used as a member of an otherwise well-behaved class. The original author of S may be aware of the entanglement and prepared to cope with it, but someone naively assuming that copying an S meant copying its complete value could be surprised, and someone who finds an S deeply nested in other classes could be very surprised.

We can address problems related to the lifetime of a shared subobject by introducing a form of garbage collection. For example:

Click here to view code image

struct S2 {
     shared_ptr<int> p;
};

S2 x {shared_ptr<int>{new int{0}}};
void f()
{
     S2 y {x};                   //"copy" x

     *y.p=1;                     // change y, affects x
     *x.p = 2;                   // change x; affects y
     y.p.reset(new int{3});      // change y; does not affect x
     *x.p = 4;                   // change x; does not affect y
}
In fact, shallow copy and such entangled objects are among the sources of demands for garbage collection. Entangled objects lead to code that is very hard to manage without some form of garbage collection (e.g., shared_ptrs).

However, a shared_ptr is still a pointer, so we cannot consider objects containing a shared_ptr in isolation. Who can update the pointed-to object? How? When? If we are running in a multithreaded system, is synchronization needed for access to the shared data? How can we be sure? Entangled objects (here, resulting from a shallow copy) is a source of complexity and errors that is at best partially solved by garbage collection (in any form).

Note that an immutable shared state is not a problem. Unless we compare addresses, we cannot tell whether two equal values happen to be represented as one or two copies. This is a useful observation because many copies are never modified. For example, objects passed by value are rarely written to. This observation leads to the notion of copy-on-write. The idea is that a copy doesn’t actually need independence until a shared state is written to, so we can delay the copying of the shared state until just before the first write to it. Consider:

Click here to view code image

class Image {
public:
      //...
     Image(const Image& a);          // copy constructor
      //...
     void write_block(Descriptor);
      //...
private:
     Representation* clone();                       // copy *rep
     shared_ptr<Representation> rep;   // potentially share
};
Assume that a Representation can be huge and that a write_block() is expensive compared to testing a shared_ptr’s use count (§5.2.1, §34.3.2). Then, depending on the use of Images, it can make sense to use a shared_ptr to hold the representation (for potential sharing) and implement the copy constructor as a shallow copy:

Click here to view code image

Image::Image(const Image& a)       // do shallow copy
     :rep{a.rep}    // a.rep now has two users
{
}
We protect the argument to that copy constructor by copying the Representation before a write:

Click here to view code image

void Image::write_block(Descriptor d)
{
     if (rep.use_count() > 1)
           rep = shared_ptr<Representation>{clone()};

     // ... now we can safely write to our own copy of rep ...
     }
Every write operation needs to check the use_count() and if necessary clone() the Representation.

Like any other technique, copy-on-write is not a panacea, but it can be an effective combination of the simplicity of true copy and the efficiency of shallow copy.

17.5.1.4. Slicing
A pointer to a derived class implicitly converts to a pointer to its public base class. When applied to a copy operation, this simple and necessary rule (§3.2.4, §20.2) leads to a trap for the unwary. Consider:

Click here to view code image

struct Base {
     int b;
     Base(const Base&);
      //...
};

struct Derived : Base {
     int d;
     Derived(const Derived&);
      //...
};

void naive(Base* p)
{
     Base b2 = *p;     // may slice: invokes Base::Base(const Base&)
      //...
}

void user()
{
     Derived d;
     naive(&d);
     Base bb = d;    // slices: invokes Base::Base(const Base&), not Derived::Derived(const Derived&)
      //...
}
The variables b2 and bb contain copies of the Base part of d, that is, a copy of d.b. The member d.d is not copied. This phenomenon is called slicing. It may be exactly what you intended (e.g., see the copy constructor for D in §17.5.1.2 where we pass selected information to a base class), but typically it is a subtle bug. If you don’t want slicing, you have two major tools to prevent it:

[1] Prohibit copying of the base class: delete the copy operations, and possibly provide a (§17.6.4).

[2] Prevent conversion of a pointer to a derived to a pointer to a base: make the base class a private or protected base (§20.5).

[3] Make the copy operations private or protected, and provide a clone() function to allow a user to request a non-slicing copy (§20.3.6).

Option [1] would make the initializations of b2 and bb errors; option [2] would make the call of naive() and the initialization of bb errors.

17.5.2. Move
The traditional way of getting a value from a to b is to copy it. For an integer in a computer’s memory, that’s just about the only thing that makes sense: that’s what the hardware can do with a single instruction. However, from a general and logical point of view that’s not so. Consider the obvious implementation of swap() exchanging the value of two objects:

Click here to view code image

template<typename T>
void swap(T& a, T& b)
{
     const T tmp = a;     // put a copy of a into tmp
     a = b;               // put a copy of b into a
     b = tmp;             // put a copy of tmp into b
};
After initializing tmp, we have two copies of a’s value. After assigning to a, we have two copies of b’s value. After assigning to b, we have two copies of tmp’s value (that is, the original value of a). Then we destroy tmp. That sounds like a lot of work, and it can be. For example:

Click here to view code image

void f(string& s1, string& s2,
     vector<string>& vs1, vector<string>& vs2,
     Matrix& m1, Matrix& m2)
{

     swap(s1,s2);
     swap(vs1,vs2);
     swap(m1,m2);
}
What if s1 has a thousand characters? What if vs2 has a thousand elements each of a thousand characters? What if m1 is a 1000*1000 matrix of doubles? The cost of copying those data structures could be significant. In fact, the standard-library swap() has always been carefully designed to avoid such overhead for string and vector. That is, effort has been made to avoid copying (taking advantage of the fact that string and vector objects really are just handles to their elements). Similar work must be done to avoid a serious performance problem for swap() of Matrixes. If the only operation we have is copy, similar work must be done for huge numbers of functions and data structures that are not part of the standard.

The fundamental problem is that we really didn’t want to do any copying at all: we just wanted to exchange pairs of values.

We can also look at the issue of copying from a completely different point of view: we don’t usually copy physical things unless we absolutely have to. If you want to borrow my phone, I pass my phone to you rather than making you your own copy. If I lend you my car, I give you a key and you drive away in my car, rather than in your freshly made copy of my car. Once I have given you an object, you have it and I no longer do. Consequently, we talk about “giving away,” “handing over,” “transferring ownership of,” and “moving” physical objects. Many objects in a computer resemble physical objects (which we don’t copy without need and only at considerable cost) more than integer values (which we typically copy because that’s easier and cheaper than alternatives). Examples are locks, sockets, file handles, threads, long strings, and large vectors.

To allow the user to avoid the logical and performance problems of copying, C++ directly supports the notion of moving as well as the notion of copying. In particular, we can define move constructors and move assignments to move rather than copy their argument. Consider again the simple two-dimensional Matrix from §17.5.1:

Click here to view code image

template<typename T>
class Matrix {
     std::array<int,2> dim;
     T elem;  // pointer to dim[0]*dim[1] elements of type T
public:
     Matrix(int d1, int d2) :dim{d1,d2}, elem{new T[d1*d2]} {}
     int size() const { return dim[0]*dim[1]; }

     Matrix(const Matrix&);              // copy constructor
     Matrix(Matrix&&);                   // move constructor (Matrix&& is an rvalue reference; §7.7.2).

     Matrix& operator=(const Matrix&);   // copy assignment
     Matrix& operator=(Matrix&&);        // move assignment

     ~Matrix() { delete[] elem; }        // destructor
      //...
};
The idea behind a move assignment is to handle lvalues separately from rvalues: copy assignment and copy constructors take lvalues whereas move assignment and move constructors take rvalues. For a return value, the move constructor is chosen.

We can define Matrix’s move constructor to simply take the representation from its source and replace it with an empty Matrix (which is cheap to destroy). For example:

Click here to view code image

template<typename T>
Matrix<T>::Matrix(Matrix&& a)       // move constructor
     :dim{a.dim}, elem{a.elem}      // grab a's representation
{
     a.dim = {0,0};                 // clear a's representation
     a.elem = nullptr;
}
For the move assignment, we can simply do a swap. The idea behind using a swap to implement a move assignment is that the source is just about to be destroyed, so we can just let the destructor for the source do the necessary cleanup work for us:

Click here to view code image

template<typename T>
Matrix<T>& Matrix<T>::operator=(Matrix&& a)            // move assignment
{
     swap(dim,a.dim);             // swap representations
     swap(elem,a.elem);
     return *this;
}
Move constructors and move assignments take non-const (rvalue) reference arguments: they can, and usually do, write to their argument. However, the argument of a move operation must always be left in a state that the destructor can cope with (and preferably deal with very cheaply and easily).

For resource handles, move operations tend to be significantly simpler and more efficient than copy operations. In particular, move operations typically do not throw exceptions; they don’t acquire resources or do complicated operations, so they don’t need to. In this, they differ from many copy operations (§17.5).

How does the compiler know when it can use a move operation rather than a copy operation? In a few cases, such as for a return value, the language rules say that it can (because the next action is defined to destroy the element). However, in general we have to tell it by giving an rvalue reference argument. For example:

Click here to view code image

template<typename T>
void swap(T& a, T& b)     //"perfect swap" (almost)
{
     T tmp = std::move(a);
     a = std::move(b);
     b = std::move(tmp);
}
The move() is a standard-library function returning an rvalue reference to its argument (§35.5.1): move(x) means “give me an rvalue reference to x.” That is, std::move(x) does not move anything; instead, it allows a user to move x. It would have been better if move() had been called rval(), but the name move() has been used for this operation for years.

Standard-library containers have move operations (§3.3.2, §35.5.1) and so have other standard-library types, such as pair (§5.4.3, §34.2.4.1) and unique_ptr (§5.2.1, §34.3.1). Furthermore, operations that insert new elements into standard-library containers, such as insert() and push_back(), have versions that take rvalue references (§7.7.2). The net result is that the standard containers and algorithms deliver better performance than they would have been able to if they had to copy.

What if we try to swap objects of a type that does not have a move constructor? We copy and pay the price. In general, a programmer is responsible for avoiding excessive copying. It is not the compiler’s job to decide what is excessive and what is necessary. To get the copy-to-move optimization for your own data structures, you have to provide move operations (either explicitly or implicitly; see §17.6).

Built-in types, such as int and double*, are considered to have move operations that simply copy. As usual, you have to be careful about data structures containing pointers (§3.3.1). In particular, don’t assume that a moved-from pointer is set to nullptr.

Having move operations affects the idiom for returning large objects from functions. Consider:

Click here to view code image

Matrix operator+(const Matrix& a, const Matrix& b)
      // res[i][j] = a[i][j]+b[i][j] for each i and j
{
     if (a.dim[0]!=b.dim[0] || a.dim[1]!=b.dim[1])
            throw std::runtime_error("unequal Matrix sizes in +");

     Matrix res{a.dim[0],a.dim[1]};
     constexpr auto n = a.size();
     for (int i = 0; i!=n; ++i)
           res.elem[i] = a.elem[i]+b.elem[i];
     return res;
}
Matrix has a move constructor so that “return by value” is simple and efficient as well as “natural.” Without move operations, we have performance problems and must resort to workarounds. We might have considered:

Click here to view code image

Matrix& operator+(const Matrix& a, const Matrix& b)         // beware!
{
     Matrix& res = *new Matrix;                // allocate on free store
      // res[i][j] = a[i][j]+b[i][j] for each i and j
     return res;
}
The use of new within operator+() is not obvious and forces the user of + to deal with tricky memory management issues:

• How does the object created by new get deleted?

• Do we need a garbage collector?

• Should we use a pool of Matrixes rather than the general new?

• Do we need use-counted Matrix representations?

• Should we redesign the interface of our Matrix addition?

• Must the caller of operator+() remember to delete the result?

• What happens to the newly allocated memory if the computation throws an exception?

None of the alternatives are elegant or general.

17.6. Generating Default Operations
Writing conventional operations, such as a copy and a destructor, can be tedious and error-prone, so the compiler can generate them for us as needed. By default, a class provides:

• A default constructor: X()

• A copy constructor: X(const X&)

• A copy assignment: X& operator=(const X&)

• A move constructor: X(X&&)

• A move assignment: X& operator=(X&&)

• A destructor: ~X()

By default, the compiler generates each of these operations if a program uses it. However, if the programmer takes control by defining one or more of those operations, the generation of related operations is suppressed:

• If the programmer declares any constructor for a class, the default constructor is not generated for that class.

• If the programmer declares a copy operation, a move operation, or a destructor for a class, no copy operation, move operation, or destructor is generated for that class.

Unfortunately, the second rule is only incompletely enforced: for backward compatibility, copy constructors and copy assignments are generated even if a destructor is defined. However, that generation is deprecated in the ISO standard (§iso.D), and you should expect a modern compiler to warn against it.

If necessary, we can be explicit about which functions are generated (§17.6.1) and which are not (§17.6.4).

17.6.1. Explicit Defaults
Since the generation of otherwise default operations can be suppressed, there has to be a way of getting back a default. Also, some people prefer to see a complete list of operations in the program text even if that complete list is not needed. For example, we can write:

Click here to view code image

class gslice {
     valarray<size_t> size;
     valarray<size_t> stride;
     valarray<size_t> d1;
public:
     gslice() = default;
     ~gslice() = default;
     gslice(const gslice&) = default;
     gslice(gslice&&) = default;
     gslice& operator=(const gslice&) = default;
     gslice& operator=(gslice&&) = default;
      //...
};
This fragment of the implementation of std::gslice (§40.5.6) is equivalent to:

class gslice {
     valarray<size_t> size;
     valarray<size_t> stride;
     valarray<size_t> d1;
public:
      //...
};
I prefer the latter, but I can see the point of using the former in code bases maintained by less experienced C++ programmers: what you don’t see, you might forget about.

Using =default is always better than writing your own implementation of the default semantics. Someone assuming that it is better to write something, rather than nothing, might write:

class gslice {
     valarray<size_t> size;
     valarray<size_t> stride;
     valarray<size_t> d1;
public:
      //...
     gslice(const gslice& a);
};

gslice::gslice(const gslice& a)
     : size{a.size },
     stride{a.stride},
     d1{a.d1}
{
}
This is not only verbose, making it harder to read the definition of gslice, but also opens the opportunity for making mistakes. For example, I might forget to copy one of the members and get it default initialized (rather than copied). Also, when the user provides a function, the compiler no longer knows the semantics of that function and some optimizations become inhibited. For the default operations, those optimizations can be significant.

17.6.2. Default Operations
The default meaning of each generated operation, as implemented when the compiler generates it, is to apply the operation to each base and non-static data member of the class. That is, we get memberwise copy, memberwise default construction, etc. For example:

Click here to view code image

struct S {
     string a;
     int b;
};

S f(S arg)
{
     S s0 {};    // default construction: {"",0}
     S s1 {s0};  // copy construction
     s1 = arg;   // copy assignment
     return s1;  // move construction
}
The copy construction of s1 copies s0.a and s0.b. The return of s1 moves s1.a and s1.b, leaving s1.a as the empty string and s1.b unchanged.

Note that the value of a moved-from object of a built-in type is unchanged. That’s the simplest and fastest thing for the compiler to do. If we want something else done for a member of a class, we have to write our move operations for that class.

The default moved-from state is one for which the default destructor and default copy assignment work correctly. It is not guaranteed (or required) that an arbitrary operation on a moved-from object will work correctly. If you need stronger guarantees, write your own operations.

17.6.3. Using Default Operations
This section presents a few examples demonstrating how copy, move, and destructors are logically linked. If they were not linked, errors that are obvious when you think about them would not be caught by the compiler.

17.6.3.1. Default Constructors
Consider:

Click here to view code image

struct X {
     X(int);      // require an int to initialize an X
};
By declaring a constructor that requires an integer argument, the programmer clearly states that a user needs to provide an int to initialize an X. Had we allowed the default constructor to be generated, that simple rule would have been violated. We have:

X a {1};     // OK
X b {};      // error: no default constructor
If we also want the default constructor, we can define one or declare that we want the default generated by the compiler. For example:

Click here to view code image

struct Y {
     string s;
     int n;
     Y(const string& s);   // initialize Y with a string
     Y() = default;        // allow default initialization with the default meaning
};
The default (i.e., generated) default constructor default constructs each member. Here, Y() sets s to the empty string. The “default initialization” of a built-in member leaves that member uninitialized. Sigh! Hope for a compiler warning.

17.6.3.2. Maintaining Invariants
Often, a class has an invariant. If so, we want copy and move operations to maintain it and the destructor to free any resources involved. Unfortunately, the compiler cannot in every case know what a programmer considers an invariant. Consider a somewhat far-fetched example:

Click here to view code image

struct Z {  // invariant:
            // my_favorite is the index of my favorite element of elem
            // largest points to the element with the highest value in elem
     vector<int> elem;
     int my_favorite;
     int* largest;
};
The programmer stated an invariant in the comment, but the compiler doesn’t read comments. Furthermore, the programmer did not leave a hint about how that invariant is to be established and maintained. In particular, there are no constructors or assignments declared. That invariant is implicit. The result is that a Z can be copied and moved using the default operations:

Click here to view code image

Z v0;                              // no initialization (oops! possibility of undefined values)
Z val {{1,2,3},1,&v0.elem[2]};         // OK, but ugly and error-prone
Z v2 = val;                        // copies: v2.largest points into val
Z v3 = move(val);                  // moves: val.elem becomes empty; v3.my_favorite is out of range
This is a mess. The root problem is that Z is badly designed because critical information is “hidden” in a comment or completely missing. The rules for the generation of default operations are heuristics intended to catch common mistakes and to encourage a systematic approach to construction, copy, move, and destruction. Wherever possible:

[1] Establish an invariant in a constructor (including possibly resource acquisition).

[2] Maintain the invariant with copy and move operations (with the usual names and types).

[3] Do any needed cleanup in the destructor (incl. possibly resource release).

17.6.3.3. Resource Invariants
Many of the most critical and obvious uses of invariants relate to resource management. Consider a simple Handle:

template<typename T> class Handle {
     T* p;
public:
     Handle(T* pp) :p{pp} { }
     T& operator*() { return *p; }
     ~Handle() { delete p; }
};
The idea is that you construct a Handle given a pointer to an object allocated using new. The Handle provides access to the object pointed to and eventually deletes that object. For example:

void f1()
{
     Handle<int> h {new int{99}};
      //...
}
Handle declares a constructor that takes an argument: this suppresses the generation of the default constructor. That’s good because a default constructor could leave Handle<T>::p uninitialized:

Click here to view code image

void f2()
{
     Handle<int> h;  // error: no default constructor
      //...
}
The absence of a default constructor saves us from the possibility of a delete with a random memory address.

Also, Handle declares a destructor: this suppresses the generation of copy and move operations. Again, that saves us from a nasty problem. Consider:

Click here to view code image

void f3()
{
     Handle<int> h1 {new int{7}};
     Handle<int> h2 {h1};            // error: no copy constructor
      //...
}
Had Handle had a default copy constructor, both h1 and h2 would have had a copy of the pointer and both would have deleted it. The results would be undefined and most likely disastrous (§3.3.1). Caveat: the generation of copy operations is only deprecated, not banned, so if you ignore warnings, you might get this example past the compiler. In general, if a class has a pointer member, the default copy and move operations should be considered suspicious. If that pointer member represents ownership, memberwise copy is wrong. If that pointer member does not represent ownership and memberwise copy is appropriate, explicit =default and a comment are most likely a good idea.

If we wanted copy construction, we could define something like:

Click here to view code image

template<typename T>
class Handle {
      //...
     Handle(const Handle& a) :p{new T{*a.p}} { }     // clone
};
17.6.3.4. Partially Specified Invariants
Troublesome examples that rely on invariants but only partially express them through constructors or destructors are rarer but not unheard of. Consider:

Click here to view code image

class Tic_tac_toe {
public:
     Tic_tac_toe(): pos(9) {}     // always 9 positions

     Tic_tac_toe& operator=(const Tic_tac_toe& arg)
     {
         for(int i = 0; i<9; ++i)
               pos.at(i) = arg.pos.at(i);
         return *this;
     }

      //... other operations ...

     enum State { empty, nought, cross };
private:
     vector<State> pos;
};
This was reported to have been part of a real program. It uses the “magic number” 9 to implement a copy assignment that accesses its argument arg without checking that the argument actually has nine elements. Also, it explicitly implements the copy assignment, but not the copy constructor. This is not what I consider good code.

We defined copy assignment, so we must also define the destructor. That destructor can be =default because all it needs to do is to ensure that the member pos is destroyed, which is what would have been done anyway had the copy assignment not been defined. At this point, we notice that the user-defined copy assignment is essentially the one we would have gotten by default, so we can =default that also. Add a copy constructor for completeness and we get:

Click here to view code image

class Tic_tac_toe {
public:
     Tic_tac_toe(): pos(9) {}    // always 9 positions
     Tic_tac_toe(const Tic_tac_toe&) = default;
     Tic_tac_toe& operator=(const Tic_tac_toe& arg) = default;
     ~Tic_tac_toe() = default;

      //... other operations ...

     enum State { empty, nought, cross };
private:
     vector<State> pos;
};
Looking at this, we realize that the net effect of these =defaults is just to eliminate move operations. Is that what we want? Probably not. When we made the copy assignment =default, we eliminated the nasty dependence on the magic constant 9. Unless other operations on Tic_tac_toe, not mentioned so far, are also “hardwired with magic numbers,” we can safely add move operations. The simplest way to do that is to remove the explicit =defaults, and then we see that Tic_tac_toe is really a perfectly ordinary type:

Click here to view code image

class Tic_tac_toe {
public:
      //... other operations ...
     enum State { empty, nought, cross };
private:
     vector<State> pos {Vector<State>(9)};         // always 9 positions
};
One conclusion that I draw from this and other examples where an “odd combination” of the default operations is defined is that we should be highly suspicious of such types: their irregularity often hides design flaws. For every class, we should ask:

[1] Is a default constructor needed (because the default one is not adequate or has been suppressed by another constructor)?

[2] Is a destructor needed (e.g., because some resource needs to be released)?

[3] Are copy operations needed (because the default copy semantics is not adequate, e.g., because the class is meant to be a base class or because it contains pointers to objects that must be deleted by the class)?

[4] Are move operations needed (because the default semantics is not adequate, e.g., because an empty object doesn’t make sense)?

In particular, we should never just consider one of these operations in isolation.

17.6.4. deleted Functions
We can “delete” a function; that is, we can state that a function does not exist so that it is an error to try to use it (implicitly or explicitly). The most obvious use is to eliminate otherwise defaulted functions. For example, it is common to want to prevent the copying of classes used as bases because such copying easily leads to slicing (§17.5.1.4):

Click here to view code image

class Base {
      //...
     Base& operator=(const Base&) = delete; // disallow copying
     Base(const Base&) = delete;

     Base& operator=(Base&&) = delete;           // disallow moving
     Base(Base&&) = delete;
};

Base x1;
Base x2 {x1};   // error: no copy constructor
Enabling and disabling copy and move is typically more conveniently done by saying what we want (using =default; §17.6.1) rather than saying what we don’t want (using =delete). However, we can delete any function that we can declare. For example, we can eliminate a specialization from the set of possible specializations of a function template:

Click here to view code image

template<typename T>
T* clone(T* p)  // return copy of *p
{
     return new T{*p};
};

Foo* clone(Foo*) = delete;          // don't try to clone a Foo

void f(Shape* ps, Foo* pf)
{
     Shape* ps2 = clone(ps);        // fine
     Foo* pf2 = clone(pf);          // error: clone(Foo*) deleted
}
Another application is to eliminate an undesired conversion. For example:

Click here to view code image

struct Z {
      //...
     Z(double);             // can initialize with a double
     Z(int) = delete;       // but not with an integer
};

void f()
{
     Z z1 {1};         // error: Z(int) deleted
     Z z2 {1.0};       // OK
}
A further use is to control where a class can be allocated:

Click here to view code image

class Not_on_stack {
      //...
     ~Not_on_stack() = delete;
};

class Not_on_free_store {
      //...
     void* operator new(size_t) = delete;
};
You can’t have a local variable that can’t be destroyed (§17.2.2), and you can’t allocate an object on the free store when you have =deleted its class’s memory allocation operator (§19.2.5). For example:

Click here to view code image

void f()
{
     Not_on_stack v1;         // error: can't destroy
     Not_on_free_store v2;    // OK

     Not_on_stack* p1 = new Not_on_stack;              // OK
     Not_on_free_store* p2 = new Not_on_free_store;    // error: can't allocate
}
However, we can never delete that Not_on_stack object. The alternative technique of making the destructor private (§17.2.2) can address that problem.

Note the difference between a =deleted function and one that simply has not been declared. In the former case, the compiler notes that the programmer has tried to use a deleted function and gives an error. In the latter case, the compiler looks for an alternative. For a “missing” destructor, it tries to generate one if one is needed. For a “missing” class operator new(), it tries to use a global operator new().

17.7. Advice
[1] Design constructors, assignments, and the destructor as a matched set of operations; §17.1.

[2] Use a constructor to establish an invariant for a class; §17.2.1.

[3] If a constructor acquires a resource, its class needs a destructor to release the resource; §17.2.2.

[4] If a class has a virtual function, it needs a virtual destructor; §17.2.5.

[5] If a class does not have a constructor, it can be initialized by memberwise initialization; §17.3.1.

[6] Prefer {} initialization over = and () initialization; §17.3.2.

[7] Give a class a default constructor if and only if there is a “natural” default value; §17.3.3.

[8] If a class is a container, give it an initializer-list constructor; §17.3.4.

[9] Initialize members and bases in their order of declaration; §17.4.1.

[10] If a class has a reference member, it probably needs copy operations (copy constructor and copy assignment); §17.4.1.1.

[11] Prefer member initialization over assignment in a constructor; §17.4.1.1.

[12] Use in-class initializers to provide default values; §17.4.4.

[13] If a class is a resource handle, it probably needs copy and move operations; §17.5.

[14] When writing a copy constructor, be careful to copy every element that needs to be copied (beware of default initializers); §17.5.1.1.

[15] A copy operation should provide equivalence and independence; §17.5.1.3.

[16] Beware of entangled data structures; §17.5.1.3.

[17] Prefer move semantics and copy-on-write to shallow copy; §17.5.1.3.

[18] If a class is used as a base class, protect against slicing; §17.5.1.4.

[19] If a class needs a copy operation or a destructor, it probably needs a constructor, a destructor, a copy assignment, and a copy constructor; §17.6.

[20] If a class has a pointer member, it probably needs a destructor and non-default copy operations; §17.6.3.3.

[21] If a class is a resource handle, it needs a constructor, a destructor, and non-default copy operations; §17.6.3.3.

[22] If a default constructor, assignment, or destructor is appropriate, let the compiler generate it (don’t rewrite it yourself); §17.6.

[23] Be explicit about your invariants; use constructors to establish them and assignments to maintain them; §17.6.3.2.

[24] Make sure that copy assignments are safe for self-assignment; §17.5.1.

[25] When adding a new member to a class, check to see if there are user-defined constructors that need to be updated to initialize the member; §17.5.1.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


16. Classes
17. Construction, Cleanup, Copy, and Move
18. Operator Overloading
47h 26m remaining
17. Construction, Cleanup, Copy, and Move
Ignorance more frequently begets confidence than does knowledge.

– Charles Darwin

• Introduction

• Constructors and Destructors

Constructors and Invariants; Destructors and Resources; Base and Member Destructors; Calling Constructors and Destructors; virtual Destructors

• Class Object Initialization

Initialization Without Constructors; Initialization Using Constructors; Default Constructors; Initializer-List Constructors

• Member and Base Initialization

Member Initialization; Base Initializers; Delegating Constructors; In-Class Initializers; static Member Initialization

• Copy and Move

Copy; Move

• Generating Default Operations

Explicit Defaults; Default Operations; Using Default Operations; deleted Functions

• Advice

17.1. Introduction
This chapter focuses on technical aspects of an object’s “life cycle”: How do we create an object, how do we copy it, how do we move it around, and how do we clean up after it when it goes away? What are proper definitions of “copy” and “move”? For example:

Click here to view code image

string ident(string arg)        // string passed by value (copied into arg)
{
     return arg;                // return string (move the value of arg out of ident() to a caller)
}

int main ()
{
     string s1 {"Adams"};       // initialize string (construct in s1).
     s1 = idet(s1);            // copy s1 into ident()
                                // move the result of ident(s1) into s1;
                                // s1's value is "Adams".
     string s2 {"Pratchett"};   // initialize string (construct in s2)
     s1 = s2;                   // copy the value of s2 into s1
                                // both s1 and s2 have the value "Pratchett".
}
Clearly, after the call of ident(), the value of s1 ought to be "Adams". We copy the value of s1 into the argument arg, then we move the value of arg out of the function call and (back) into s1. Next, we construct s2 with the value "Prachett" and copy it into s1. Finally, at the exit from main() we destroy the variables s1 and s2. The difference between move and copy is that after a copy two objects must have the same value, whereas after a move the source of the move is not required to have its original value. Moves can be used when the source object will not be used again. They are particularly useful for implementing the notion of moving a resource (§3.2.1.2, §5.2).

Several functions are used here:

• A constructor initializing a string with a string literal (used for s1 and s2)

• A copy constructor copying a string (into the function argument arg)

• A move constructor moving the value of a string (from arg out of ident() into a temporary variable holding the result of ident(s1))

• A move assignment moving the value of a string (from the temporary variable holding the result of ident(s1) into s1)

• A copy assignment copying a string (from s2 into s1)

• A destructor releasing the resources owned by s1, s2, and the temporary variable holding the result of ident(s1), and doing nothing to the moved-from function argument

An optimizer can eliminate some of this work. For example, in this simple example the temporary variable is typically eliminated. However, in principle, these operations are executed.

Constructors, copy and move assignment operations, and destructors directly support a view of lifetime and resource management. An object is considered an object of its type after its constructor completes, and it remains an object of its type until its destructor starts executing. The interaction between object lifetime and errors is explored further in §13.2 and §13.3. In particular, this chapter doesn’t discuss the issue of half-constructed and half-destroyed objects.

Construction of objects plays a key role in many designs. This wide variety of uses is reflected in the range and flexibility of the language features supporting initialization.

Constructors, destructors, and copy and move operations for a type are not logically separate. We must define them as a matched set or suffer logical or performance problems. If a class X has a destructor that performs a nontrivial task, such as free-store deallocation or lock release, the class is likely to need the full complement of functions:

Click here to view code image

class X {
     X(Sometype);              public: X(Sometype); // "ordinar y constr uctor": create an object
     X();                      // default constructor
     X(const X&);              // copy constructor
     X(X&&);                   // move constructor
     X& operator=(const X&);   // copy assignment: clean up target and copy
     X& operator=(X&&);        // move assignment: clean up target and move
     ~X();                     // destructor: clean up
      //...
};
There are six situations in which an object is copied or moved:

• As the source of an assignment

• As an object initializer (of named objects, objects on the free store, and temporary objects)

• As a function argument

• As a function return value

• As the source of an explicit type conversion (§11.5)

• As an exception

In all cases, the copy or move constructor will be applied (unless it can be optimized away).

Except for the “ordinary constructor,” these special member functions can be generated by the compiler; see §17.6.

This chapter is full of rules and technicalities. Those are necessary for a full understanding, but most people just learn the general rules from examples.

17.2. Constructors and Destructors
We can specify how an object of a class is to be initialized by defining a constructor (§16.2.5, §17.3). To complement constructors, we can define a destructor to ensure “cleanup” at the point of destruction of an object (e.g., when it goes out of scope). Some of the most effective techniques for resource management in C++ rely on constructor/destructor pairs. So do other techniques relying on a pair of actions, such as do/undo, start/stop, before/after, etc. For example:

Click here to view code image

struct Tracer {
     string mess;
     Tracer(const string& s) :mess{s} { clog << mess; }
     ~Tracer() {clog << "~" << mess; }
};

void f(const vector<int>& v)
{
     Tracer tr {"in f()\n"};
     for (auto x : v) {
          Tracer tr {string{"v loop "}+to<string>(x)+'\n'};  //§25.2.5.1
           //...
     }
}
We could try a call:

f({2,3,5});
This would print to the logging stream:

in_f()
v loop 2
~v loop 2
v loop 3
~v loop 3
v loop 5
~v loop 5
~in_f()
17.2.1. Constructors and Invariants
A member with the same name as its class is called a constructor. For example:

class Vector {
public:
     Vector(int s);
      //...
};
A constructor declaration specifies an argument list (exactly as for a function) but has no return type. The name of a class cannot be used for an ordinary member function, data member, member type, etc., within the class. For example:

Click here to view code image

struct S {
     S();                    // fine
     void S(int);            // error: no type can be specified for a constructor
     int S;                  // error: the class name must denote a constructor
     enum S { foo, bar };    // error: the class name must denote a constructor
};
A constructor’s job is to initialize an object of its class. Often, that initialization must establish a class invariant, that is, something that must hold whenever a member function is called (from outside the class). Consider:

Click here to view code image

class Vector {
public:
     Vector(int s);
      //...
private:
     double* elem;   // elem points to an array of sz doubles
     int sz;         // sz is non-negative
};
Here (as is often the case), the invariant is stated as comments: “elem points to an array of sz doubles” and “sz is non-negative.” The constructor must make that true. For example:

Vector::Vector(int s)
{
     if (s<0) throw Bad_size{s};
     sz = s;
     elem = new double[s];
}
This constructor tries to establish the invariant and if it cannot, it throws an exception. If the constructor cannot establish the invariant, no object is created and the constructor must ensure that no resources are leaked (§5.2, §13.3). A resource is anything we need to acquire and eventually (explicitly or implicitly) give back (release) once we are finished with it. Examples of resources are memory (§3.2.1.2), locks (§5.3.4), file handles (§13.3), and thread handles (§5.3.1).

Why would you define an invariant?

• To focus the design effort for the class (§2.4.3.2)

• To clarify the behavior of the class (e.g., under error conditions; §13.2)

• To simplify the definition of member functions (§2.4.3.2, §16.3.1)

• To clarify the class’s management of resources (§13.3)

• To simplify the documentation of the class

On average, the effort to define an invariant ends up saving work.

17.2.2. Destructors and Resources
A constructor initializes an object. In other words, it creates the environment in which the member functions operate. Sometimes, creating that environment involves acquiring a resource – such as a file, a lock, or some memory – that must be released after use (§5.2, §13.3). Thus, some classes need a function that is guaranteed to be invoked when an object is destroyed in a manner similar to the way a constructor is guaranteed to be invoked when an object is created. Inevitably, such a function is called a destructor. The name of a destructor is ~ followed by the class name, for example ~Vector(). One meaning of ~ is “complement” (§11.1.2), and a destructor for a class complements its constructors. A destructor does not take an argument, and a class can have only one destructor. Destructors are called implicitly when an automatic variable goes out of scope, an object on the free store is deleted, etc. Only in very rare circumstances does the user need to call a destructor explicitly (§17.2.4).

Destructors typically clean up and release resources. For example:

Click here to view code image

class Vector {
public:
     Vector(int s) :elem{new double[s]}, sz{s} { };            // constructor: acquire memory
     ~Vector() { delete[] elem; }                              // destructor: release memory
      //...
private:
     double* elem;    // elem points to an array of sz doubles
     int sz;          // sz is non-negative
};
For example:

Vector* f(int s)
{
     Vector v1(s);
      //...
     return new Vector(s+s);
}

void g(int ss)
{
     Vector* p = f(ss);
      //...
     delete p;
}
Here, the Vector v1 is destroyed upon exit from f(). Also, the Vector created on the free store by f() using new is destroyed by the call of delete. In both cases, Vector’s destructor is invoked to free (deallocate) the memory allocated by the constructor.

What if the constructor failed to acquire enough memory? For example, s*sizeof(double) or (s+s)*sizeof(double) may be larger than the amount of available memory (measured in bytes). In that case, an exception std::bad_alloc (§11.2.3) is thrown by new and the exception-handling mechanism invokes the appropriate destructors so that all memory that has been acquired (and only that) is freed (§13.5.1).

This style of constructor/destructor-based resource management is called Resource Acquisition Is Initialization or simply RAII (§5.2, §13.3).

A matching constructor/destructor pair is the usual mechanism for implementing the notion of a variably sized object in C++. Standard-library containers, such as vector and unordered_map, use variants of this technique for providing storage for their elements.

A type that has no destructor declared, such as a built-in type, is considered to have a destructor that does nothing.

A programmer who declares a destructor for a class must also decide if objects of that class can be copied or moved (§17.6).

17.2.3. Base and Member Destructors
Constructors and destructors interact correctly with class hierarchies (§3.2.4, Chapter 20). A constructor builds a class object “from the bottom up”:

[1] first, the constructor invokes its base class constructors,

[2] then, it invokes the member constructors, and

[3] finally, it executes its own body.

A destructor “tears down” an object in the reverse order:

[1] first, the destructor executes its own body,

[2] then, it invokes its member destructors, and

[3] finally, it invokes its base class destructors.

In particular, a virtual base is constructed before any base that might use it and destroyed after all such bases (§21.3.5.1). This ordering ensures that a base or a member is not used before it has been initialized or used after it has been destroyed. The programmer can defeat this simple and essential rule, but only through deliberate circumvention involving passing pointers to uninitialized variables as arguments. Doing so violates language rules and the results are usually disastrous.

Constructors execute member and base constructors in declaration order (not the order of initializers): if two constructors used a different order, the destructor could not (without serious overhead) guarantee to destroy in the reverse order of construction. See also §17.4.

If a class is used so that a default constructor is needed, and if the class does not have other constructors, the compiler will try to generate a default constructor. For example:

struct S1 {
     string s;
};

S1 x;      // OK: x.s is initialized to ""
Similarly, memberwise initialization can be used if initializers are needed. For example:

struct X { X(int); };

struct S2 {
     X x;
};

S2 x1;      // error: no value for x1.x
S2 x2 {1};  // OK: x2.x is initialized with 1
See also §17.3.1.

17.2.4. Calling Constructors and Destructors
A destructor is invoked implicitly upon exit from a scope or by delete. It is typically not only unnecessary to explicitly call a destructor; doing so would lead to nasty errors. However, there are rare (but important) cases where a destructor must be called explicitly. Consider a container that (like std::vector) maintains a pool of memory into which it can grow and shrink (e.g., using push_back() and pop_back()). When we add an element, the container must invoke its constructor for a specific address:

Click here to view code image

void C::push_back(const X& a)
{
      //...
     new(p) X{a};    // copy construct an X with the value a in address p
      //...
}
This use of a constructor is known as “placement new” (§11.2.4).

Conversely, when we remove an element, the container needs to invoke its destructor:

Click here to view code image

void C::pop_back()
{
      //...
     p–>~X();       // destroy the X in address p
}
The p–>~X() notation invokes X’s destructor for *p. That notation should never be used for an object that is destroyed in the normal way (by its object going out of scope or being deleted).

For a more complete example of explicit management of objects in a memory area, see §13.6.1.

If declared for a class X, a destructor will be implicitly invoked whenever an X goes out of scope or is deleted. This implies that we can prevent destruction of an X by declaring its destructor =delete (§17.6.4) or private.

Of the two alternatives, using private is the more flexible. For example, we can create a class for which objects can be explicitly destroyed, but not implicitly:

Click here to view code image

class Nonlocal {
public:
      //...
     void destroy() { delete this; }      // explicit destruction
private:
      //...
     ~Nonlocal();                         // don't destroy implicitly
};

void user()
{
     Nonlocal x;                    // error: cannot destroy a Nonlocal
     Nonlocal* p = new Nonlocal;    // OK
      //...
     delete p;                      // error: cannot destroy a Nonlocal
     p.destroy();                   // OK
}
17.2.5. virtual Destructors
A destructor can be declared to be virtual, and usually should be for a class with a virtual function. For example:

Click here to view code image

class Shape {
public:
      //...
     virtual void draw() = 0;
     virtual ~Shape();
};

class Circle :public Shape {
public:
      //...
     void draw();
     ~Circle();         // overrides ~Shape()
      //...
};
The reason we need a virtual destructor is that an object usually manipulated through the interface provided by a base class is often also deleted through that interface:

Click here to view code image

void user(Shape* p)
{
     p–>draw();         // invoke the appropriate draw()
      //...
     delete p;          // invoke the appropriate destructor
};
Had Shape’s destructor not been virtual that delete would have failed to invoke the appropriate derived class destructor (e.g., ~Circle()). That failure would cause the resources owned by the deleted object (if any) to be leaked.

17.3. Class Object Initialization
This section discusses how to initialize objects of a class with and without constructors. It also shows how to define constructors to accept arbitrarily sized homogeneous initializer lists (such as {1,2,3} and {1,2,3,4,5,6}).

17.3.1. Initialization Without Constructors
We cannot define a constructor for a built-in type, yet we can initialize it with a value of suitable type. For example:

int a {1};
char* p {nullptr};
Similarly, we can initialize objects of a class for which we have not defined a constructor using

• memberwise initialization,

• copy initialization, or

• default initialization (without an initializer or with an empty initializer list).

For example:

Click here to view code image

struct Work {
     string author;
     string name;
     int year;
};

Work s9 { "Beethoven",
          "Symphony No. 9 in D minor, Op. 125; Choral",
          1824
      };                          // memberwise initialization

Work currently_playing { s9 };    // copy initialization
Work none {};                     // default initialization
The three members of currently_playing are copies of those of s9.

The default initialization of using {} is defined as initialization of each member by {}. So, none is initialized to {{},{},{}}, which is {"","",0} (§17.3.3).

Where no constructor requiring arguments is declared, it is also possible to leave out the initializer completely. For example:

Work alpha;

void f()
{
     Work beta;
      //...
}
For this, the rules are not as clean as we might like. For statically allocated objects (§6.4.2), the rules are exactly as if you had used {}, so the value of alpha is {"","",0}. However, for local variables and free-store objects, the default initialization is done only for members of class type, and members of built-in type are left uninitialized, so the value of beta is {"","",unknown}.

The reason for this complication is to improve performance in rare critical cases. For example:

struct Buf {
     int count;
     char buf[16*1024];
};
You can use a Buf as a local variable without initializing it before using it as a target for an input operation. Most local variable initializations are not performance critical, and uninitialized local variables are a major source of errors. If you want guaranteed initialization or simply dislike surprises, supply an initializer, such as {}. For example:

Click here to view code image

Buf buf0;        // statically allocated, so initialized by default

void f()
{
     Buf buf1;              // leave elements uninitialized
     Buf buf2 {};           // I really want to zero out those elements

     int* p1 = new int;     //*p1 is uninitialized
     int* p2 = new int{};   //*p2 == 0
     int* p3 = new int{7};  //*p3 == 7
    //...
}
Naturally, memberwise initialization works only if we can access the members. For example:

Click here to view code image

template<typename T>
class Checked_pointer {  // control access to T* member
public:
     T& operator*();    // check for nullptr and return value
 //...
};

Checked_pointer<int> p {new int{7}};   // error: can't access p.p
If a class has a private non-static data member, it needs a constructor.

17.3.2. Initialization Using Constructors
Where memberwise copy is not sufficient or desirable, a constructor can be defined to initialize an object. In particular, a constructor is often used to establish an invariant for its class and to acquire resources necessary to do that (§17.2.1).

If a constructor is declared for a class, some constructor will be used for every object. It is an error to try to create an object without a proper initializer as required by the constructors. For example:

Click here to view code image

struct X {
     X(int);
};

X x0;           // error: no initializer
X x1 {};        // error: empty initializer
X x2 {2};       // OK
X x3 {"two"};   // error: wrong initializer type
X x4 {1,2};     // error: wrong number of initializers
X x5 {x4};      // OK: a copy constructor is implicitly defined (§17.6)
Note that the default constructor (§17.3.3) disappears when you define a constructor requiring arguments; after all, X(int) states that an int is required to construct an X. However, the copy constructor does not disappear (§17.3.3); the assumption is that an object can be copied (once properly constructed). Where the latter might cause problems (§3.3.1), you can specifically disallow copying (§17.6.4).

I used the {} notation to make explicit the fact that I am initializing. I am not (just) assigning a value, calling a function, or declaring a function. The {} notation for initialization can be used to provide arguments to a constructor wherever an object can be constructed. For example:

Click here to view code image

struct Y : X {
     X m {0};                      // provide default initializer for member X.m in Y
     Y(int a) :X{a}, m{a} { }     // initialize base and member (§17.4)
     Y() :X{0} { }               // initialize base and member
};

X g {1};     // initialize global variable

void f(int a)
{
     X def {};                     // error: no default value for X
     Y de2 {};                     // OK: use default constructor
     X* p {nullptr}; // initialize local variable
     X var {2};                    // initialize local variable
     p = new X{4};                 // initialize object on free store
     X a[] {1,2,3};                // initialize array elements
     vector<X> v {1,2,3,4};        // initialize vector elements
}
For this reason, {} initialization is sometimes referred to as universal initialization: the notation can be used everywhere. In addition, {} initialization is uniform: wherever you initialize an object of type X with a value v using the {v} notation, the same value of type X (X{v}) is created.

The = and () notations for initialization (§6.3.5) are not universal. For example:

Click here to view code image

struct Y : X {
     X m;
     Y(int a) : X(a), m=a { };  // syntax error: can't use = for member initialization
};

X g(1);    // initialize global variable

void f(int a)
{
     X def();                   // function returning an X (surprise!?)
     X* p {nullptr};
     X var = 2;                 // initialize local variable
     p = new X=4;               // syntax error: can't use = for new
     X a[](1,2,3);              // error: can't use () for array initialization
     vector<X> v(1,2,3,4);      // error: can't use () for list elements
}
The = and () notations for initialization are not uniform either, but fortunately the examples of that are obscure. If you insist on using = or () initialization, you have to remember where they are allowed and what they mean.

The usual overload resolution rules (§12.3) apply for constructors. For example:

Click here to view code image

struct S {
     S(const char*);
     S(double*);
};

S s1 {"Napier"};              // S::S(const char*)
S s2 {new double{1.0}};       // S::S(double*);
S s3 {nullptr};               // ambiguous: S::S(const char*) or S::S(double*)?
Note that the {}-initializer notation does not allow narrowing (§2.2.2). That is another reason to prefer the {} style over () or =.

17.3.2.1. Initialization by Constructors
Using the () notation, you can request to use a constructor in an initialization. That is, you can ensure that for a class, you will get initialization by constructor and not get the memberwise initialization or initializer-list initialization (§17.3.4) that the {} notation also offers. For example:

Click here to view code image

struct S1 {
     int a,b;                                           // no constructor
};

struct S2 {
     int a,b;
     S2(int aa = 0, int b = 0) : a(aa), b(bb) {}         // constructor
};

S1 x11(1,2);     // error: no constructor
S1 x12 {1,2};    // OK: memberwise initialization

S1 x13(1);       // error: no constructor
S1 x14 {1};      // OK: x14.b becomes 0

S2 x21(1,2);     // OK: use constructor
S2 x22 {1,2};    // OK: use constructor

S2 x23(1);       // OK: use constructor and one default argument
S2 x24 {1};      // OK: use constructor and one default argument
The uniform use of {} initialization only became possible in C++11, so older C++ code uses () and = initialization. Consequently, the () and = may be more familiar to you. However, I don’t know any logical reason to prefer the () notation except in the rare case where you need to distinguish between initialization with a list of elements and a list of constructor arguments. For example:

Click here to view code image

vector<int> v1 {77};       // one element with the value 77
vector<int> v2(77);        //77 elements with the default value 0
This problem – and the need to choose – can occur when a type with an initializer-list constructor (§17.3.4), typically a container, also has an “ordinary constructor” accepting arguments of the element type. In particular, we occasionally must use () initialization for vectors of integers and floating-point numbers but never need to for vectors of strings or vectors of pointers:

Click here to view code image

vector<string> v1 {77};        //77 elements with the default value ""
                               //(vector<string>(std::initializer_list<string>) doesn't accept {77})
vector<string> v2(77);         //77 elements with the default value ""

vector<string> v3 {"Booh!"};   // one element with the value "Booh!"
vector<string> v4("Booh!");    // error: no constructor takes a string argument

vector<int*> v5 {100,0};       //100 int*s initialized to nullptr (100 is not an int*)

vector<int*> v6 {0,0};         //2 int*s initialized to nullptr
vector<int*> v7(0,0);          // empty vector (v7.size()==0)
vector<int*> v8;               // empty vector (v7.size()==0)
The v6 and v7 examples are only of interest to language lawyers and testers. A programmer using nullptr, rather than 0, will have fewer surprises.

17.3.3. Default Constructors
A constructor that can be invoked without an argument is called a default constructor. Default constructors are very common. For example:

Click here to view code image

class Vector {
public:
     Vector();      // default constructor: no elements
      //...
};
A default constructor is used if no arguments are specified or if an empty initializer list is provided:

Vector v1;        // OK
Vector v2 {};     // OK
A default argument (§12.2.5) can make a constructor that takes arguments into a default constructor. For example:

Click here to view code image

class String {
public:
     String(const char* p = "");      // default constructor: empty string
      //...
};

String s1;          // OK
String s2 {};       // OK
The standard-library vector and string have such default constructors (§36.3.2, §31.3.2).

The built-in types are considered to have default and copy constructors. However, for a built-in type the default constructor is not invoked for uninitialized non-static variables (§17.3). The default value of a built-in type is 0 for integers, 0.0 for floating-point types, and nullptr for pointers. For example:

Click here to view code image

void f()
{
     int a0;                 // uninitialized
     int a1();               // function declaration (intended?)

     int a {};               // a becomes 0
     double d {};            // d becomes 0.0
     char* p {};             // p becomes nullptr

     int* p1 = new int;      // uninitialized int
     int* p2 = new int{};    // the int is initialized to 0
}
Constructors for built-in types are most often used for template arguments. For example:

Click here to view code image

template<typename T>
struct Handle {
     T* p;
     Handle(T* pp = new T{}) :p{pp} { }
      //...
};

Handle<int> px;      // will generate int{}
The generated int will be initialized to 0.

References and consts must be initialized (§7.7, §7.5). Therefore, a class containing such members cannot be default constructed unless the programmer supplies in-class member initializers (§17.4.4) or defines a default constructor that initializes them (§17.4.1). For example:

Click here to view code image

int glob {9};

struct X {
     const int a1 {7};      // OK
     const int a2;          // error: requires a user-defined constructor
     const int& r {9};      // OK
     int& r1 {glob};        // OK
     int& r2;               // error: requires a user-defined constructor
};

X x;       // error: no default constructor for X
An array, a standard-library vector, and similar containers can be declared to allocate a number of default-initialized elements. In such cases, a default constructor is obviously required for a class used as the element type of a vector or array. For example:

Click here to view code image

struct S1 { S1(); };                  // has default constructor
struct S2 { S2(string); };            // no default constructor

S1 a1[10];                            // OK: 10 default elements
S2 a2[10];                            // error: cannot initialize elements
S2 a3[] { "alpha", "beta" };          // OK: two elements: S2{"alpha"}, S2{"beta"}

vector<S1> v1(10);                    // OK: 10 default elements
vector<S2> v2(10);                    // error: cannot initialize elements
vector<S2> v3 { "alpha", "beta" };    // OK: two elements: S2{"alpha"}, S2{"beta"}

vector<S2> v2(10,"");                 // OK: 10 elements each initialized to S2{""}
vector<S2> v4;                        // OK: no elements
When should a class have a default constructor? A simple-minded technical answer is “when you use it as the element type for an array, etc.” However, a better question is “For what types does it make sense to have a default value?” or even “Does this type have a ‘special’ value we can ‘naturally’ use as a default?” String has the empty string, "", containers have the empty set, {}, and numeric values have zero. The trouble with deciding on a default Date (§16.3) arose because there is no “natural” default date (the Big Bang is too far in the past and not precisely associated with our everyday dates). It is a good idea not to be too clever when inventing default values. For example, the problem with containers of elements without default values is often best solved by not allocating elements until you have proper values for them (e.g., using push_back()).

17.3.4. Initializer-List Constructors
A constructor that takes a single argument of type std::initialize r_list is called an initializer-list constructor. An initializer-list constructor is used to construct objects using a {}-list as its initializer value. Standard-library containers (e.g., vector and map) have initializer-list constructors, assignments, etc. (§31.3.2, §31.4.3). Consider:

Click here to view code image

vector<double> v = { 1, 2, 3.456, 99.99 };

list<pair<string,string>> languages = {
     {"Nygaard","Simula"}, {"Richards","BCPL"}, {"Ritchie","C"}
};

map<vector<string>,vector<int>> years = {
     { {"Maurice","Vincent", "Wilkes"},{1913, 1945, 1951, 1967, 2000} },
     { {"Martin", "Richards"}, {1982, 2003, 2007} },
     { {"David", "John", "Wheeler"}, {1927, 1947, 1951, 2004} }
};
The mechanism for accepting a {}-list is a function (often a constructor) taking an argument of type std::initializer_list<T>. For example:

Click here to view code image

void f(initializer_list<int>);

f({1,2});
f({23,345,4567,56789});
f({});      // the empty list

f{1,2};     // error: function call () missing

years.insert({{"Bjarne","Stroustrup"},{1950, 1975, 1985}});
The initializer list can be of arbitrary length but must be homogeneous. That is, all elements must be of the template argument type, T, or implicitly convertible to T.

17.3.4.1. initializer_list Constructor Disambiguation
When you have several constructors for a class, the usual overload resolution rules (§12.3) are used to select the right one for a given set of arguments. For selecting a constructor, default and initializer lists take precedence. Consider:

Click here to view code image

struct X {
     X(initializer_list<int>);
     X();
     X(int);
};

X x0 {};     // empty list: default constructor or initializer-list constructor? (the default constructor)
X x1 {1};    // one integer: an int argument or a list of one element? (the initializer-list constructor)
The rules are:

• If either a default constructor or an initializer-list constructor could be invoked, prefer the default constructor.

• If both an initializer-list constructor and an “ordinary constructor” could be invoked, prefer the initializer-list constructor.

The first rule, “prefer the default constructor,” is basically common sense: pick the simplest constructor when you can. Furthermore, if you define an initializer-list constructor to do something with an empty list that differs from what the default constructor does, you probably have a design error on your hands.

The second rule, “prefer the initializer-list constructor,” is necessary to avoid different resolutions based on different numbers of elements. Consider std::vector (§31.4):

Click here to view code image

vector<int> v1 {1};          // one element
vector<int> v2 {1,2};        // two elements
vector<int> v3 {1,2,3};      // three elements

vector<string> vs1 {"one"};
vector<string> vs2 {"one", "two"};
vector<string> vs3 {"one", "two", "three"};
In every case, the initializer-list constructor is used. If we really want to invoke the constructor taking one or two integer arguments, we must use the () notation:

Click here to view code image

vector<int> v1(1);     // one element with the default value (0)
vector<int> v2(1,2);   // one element with the value 2
17.3.4.2. Use of initializer_lists
A function with an initialize r_list<T> argument can access it as a sequence using the member functions begin(), end(), and size(). For example:

Click here to view code image

void f(initializer_list<int> args)
{
     for (int i = 0; i!=args.size(); ++i)
           cout << args.begin()[i] << "\n";
}
Unfortunately, initializer_list doesn’t provide subscripting.

An initializer_list<T> is passed by value. That is required by the overload resolution rules (§12.3) and does not impose overhead because an initializer_list<T> object is just a small handle (typically two words) to an array of Ts.

That loop could equivalently have been written:

Click here to view code image

void f(initializer_list<int> args)
{
     for (auto p=args.begin(); p!=args.end(); ++p)
           cout << *p << "\n";
}
or:

void f(initializer_list<int> args)
{
     for (auto x : args)
           cout << x << "\n";
}
To explicitly use an initializer_list you must #include the header file in which it is defined: <initializer_list>. However, since vector, map, etc., use initializer_lists, their headers (<vector>, <map>, etc.) already #include <initializer_list>, so you rarely have to do so directly.

The elements of an initializer_list are immutable. Don’t even think about trying to modify their values. For example:

Click here to view code image

int f(std::initializer_list<int> x, int val)
{
     *x.begin() = val;          // error: attempt to change the value of an initializer-list element
     return *x.begin();    // OK
}

void g()
{
     for (int i=0; i!=10; ++i)
           cout << f({1,2,3},i) << '\n';
}
Had the assignment in f() succeeded, it would have appeared that the value of 1 (in {1,2,3}) could change. That would have done serious damage to some of our most fundamental concepts. Because initializer_list elements are immutable, we cannot apply a move constructor (§3.3.2, §17.5.2) to them.

A container might implement an initializer-list constructor like this:

Click here to view code image

template<typename E>
class Vector {
public:
     Vector(initializer_list<E> s);  // initializer-list constructor
      //...
private:
     int sz;
     E* elem;
};

template<typename E>
Vector::Vector(initializer_list<E> s)
     :sz{s.size()}                                // set vector size
{
     reserve(sz);                                 // get the right amount of space
     uninitialized_copy(s.begin(), s.end(), elem);       // initialize elements in elem[0:s.size())
}
The initializer lists are part of the universal and uniform initialization design (§17.3).

17.3.4.3. Direct and Copy Initialization
The distinction between direct initialization and copy initialization (§16.2.6) is maintained for {} initialization. For a container, this implies that the distinction is applied to both the container and its elements:

• The container’s initializer-list constructor can be explicit or not.

• The constructor of the element type of the initializer list can be explicit or not.

For a vector<vector<double>>, we can see the direct initialization vs. copy initialization distinction applied to elements. For example:

Click here to view code image

vector<vector<double>> vs = {
     {10,11,12,13,14},              // OK: vector of five elements
     {10},                          // OK: vector of one element
     10,                            // error: vector<double>(int) is explicit

     vector<double>{10,11,12,13},   // OK: vector of five elements
     vector<double>{10},            // OK: vector of one element with value 10.0
     vector<double>(10),            // OK: vector of 10 elements with value 0.0
};
A container can have some constructors explicit and some not. The standard-library vector is an example of that. For example, std::vector<int>(int) is explicit, but std::vector<int>(initializer_list<int>) is not:

Click here to view code image

vector<double> v1(7);      // OK: v1 has 7 elements; note: uses () rather than {}
vector<double> v2 = 9;     // error: no conversion from int to vector

void f(const vector<double>&);
void g()
{
     v1 = 9;       // error: no conversion from int to vector
     f(9);         // error: no conversion from int to vector
}
By replacing () with {} we get:

Click here to view code image

vector<double> v1 {7};           // OK: v1 has one element (with the value 7)
vector<double> v2 = {9};         // OK: v2 has one element (with the value 9)

void f(const vector<double>&);
void g()
 {
     v1 = {9};     // OK: v1 now has one element (with the value 9)
     f({9});       // OK: f is called with the list {9}
}
Obviously, the results are dramatically different.

This example was carefully crafted to give an example of the most confusing cases. Note that the apparent ambiguities (in the eyes of the human reader but not the compiler) do not emerge for longer lists. For example:

Click here to view code image

vector<double> v1 {7,8,9};           // OK: v1 has three elements with values {7,8,9}
vector<double> v2 = {9,8,7};         // OK: v2 has three elements with values {9,8,7}
void f(const vector<double>&);
void g()
{
     v1 = {9,10,11};     // OK: v1 now has three elements with values {9,10,11}
     f({9,8,7,6,5,4});   // OK: f is called with the list {9,8,7,6,5,4}
}
Similarly, the potential ambiguities do not occur for lists of elements of nonintegral types:

Click here to view code image

vector<string> v1 { "Anya"};        // OK: v1 has one element (with the value "Anya")
vector<string> v2 = {"Courtney"};   // OK: v2 has one element (with the value "Courtney")

void f(const vector<string>&);
void g()
{
     v1 = {"Gavin"};       // OK: v1 now has one element (with the value "Gavin")
     f({"Norah"});         // OK: f is called with the list {"Norah"}
}
17.4. Member and Base Initialization
Constructors can establish invariants and acquire resources. Generally, they do that by initializing class members and base classes.

17.4.1. Member Initialization
Consider a class that might be used to hold information for a small organization:

class Club {
     string name;
     vector<string> members;
     vector<string> officers;
     Date founded;
      //...
     Club(const string& n, Date fd);
};
The Club’s constructor takes the name of the club and its founding date as arguments. Arguments for a member’s constructor are specified in a member initializer list in the definition of the constructor of the containing class. For example:

Click here to view code image

Club::Club(const string& n, Date fd)
     : name{n}, members{}, officers{}, founded{fd}
{
      //...
}
The member initializer list starts with a colon, and the individual member initializers are separated by commas.

The members’ constructors are called before the body of the containing class’s own constructor is executed (§17.2.3). The constructors are called in the order in which the members are declared in the class rather than the order in which the members appear in the initializer list. To avoid confusion, it is best to specify the initializers in the member declaration order. Hope for a compiler warning if you don’t get the order right. The member destructors are called in the reverse order of construction after the body of the class’s own destructor has been executed.

If a member constructor needs no arguments, the member need not be mentioned in the member initializer list. For example:

Club::Club(const string& n, Date fd)
     : name{n}, founded{fd}
{
      //...
}
This constructor is equivalent to the previous version. In each case, Club::officers and Club::members are initialized to a vector with no elements.

It is usually a good idea to be explicit about initializing members. Note that an “implicitly initialized” member of a built-in type is left uninitialized (§17.3.1).

A constructor can initialize members and bases of its class, but not members or bases of its members or bases. For example:

Click here to view code image

struct B { B(int); /* ... */};
struct BB : B { /* ... */ };
struct BBB : BB {
     BBB(int i) : B(i) { }  // error: trying to initialize base's base
      //...
};
17.4.1.1. Member Initialization and Assignment
Member initializers are essential for types for which the meaning of initialization differs from that of assignment. For example:

Click here to view code image

class X {
     const int i;
     Club cl;
     Club& rc;
      //...
     X(int ii, const string& n, Date d, Club& c) : i{ii}, cl{n,d}, rc{c} { }
};
A reference member or a const member must be initialized (§7.5, §7.7, §17.3.3). However, for most types the programmer has a choice between using an initializer and using an assignment. In that case, I usually prefer to use the member initializer syntax to make it explicit that initialization is being done. Often, there also is an efficiency advantage to using the initializer syntax (compared to using an assignment). For example:

Click here to view code image

class Person {
     string name;
     string address;
      //...
     Person(const Person&);
     Person(const string& n, const string& a);
};

Person::Person(const string& n, const string& a)
     : name{n}
{
     address = a;
}
Here name is initialized with a copy of n. On the other hand, address is first initialized to the empty string and then a copy of a is assigned.

17.4.2. Base Initializers
Bases of a derived class are initialized in the same way non-static data members are. That is, if a base requires an initializer, it must be provided as a base initializer in a constructor. If we want to, we can explicitly specify default construction. For example:

Click here to view code image

class B1 { B1(); };      // has default constructor
class B2 { B2(int); }    // no default constructor

struct D1 : B1, B2 {
     D1(int i) :B1{}, B2{i} {}
};

struct D2 : B1, B2 {
     D2(int i) :B2{i} {}           // B1{} is used implicitly
};

struct D1 : B1, B2 {
     D1(int i) { }                 // error: B2 requires an int initializer
};
As with members, the order of initialization is the declaration order, and it is recommended to specify base initializers in that order. Bases are initialized before members and destroyed after members (§17.2.3).

17.4.3. Delegating Constructors
If you want two constructors to do the same action, you can repeat yourself or define “an init() function” to perform the common action. Both “solutions” are common (because older versions of C++ didn’t offer anything better). For example:

Click here to view code image

class X {
     int a;
     validate(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
public:
     X(int x) { validate(x); }
     X() { validate(42); }
     X(string s) { int x = to<int>(s); validate(x); }  //§25.2.5.1
      //...
};
Verbosity hinders readability and repetition is error-prone. Both get in the way of maintainability. The alternative is to define one constructor in terms of another:

Click here to view code image

class X {
     int a;
public:
     X(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
     X() :X{42} { }
     X(string s) :X{to<int>(s)} { }         //§25.2.5.1
      //...
};
That is, a member-style initializer using the class’s own name (its constructor name) calls another constructor as part of the construction. Such a constructor is called a delegating constructor (and occasionally a forwarding constructor).

You cannot both delegate and explicitly initialize a member. For example:

Click here to view code image

class X {
     int a;
public:
     X(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
     X() :X{42}, a{56} { }      // error
      //...
};
Delegating by calling another constructor in a constructor’s member and base initializer list is very different from explicitly calling a constructor in the body of a constructor. Consider:

Click here to view code image

class X {
     int a;
public:
     X(int x) { if (0<x && x<=max) a=x; else throw Bad_X(x); }
     X() { X{42}; }     // likely error
      //...
};
The X{42} simply creates a new unnamed object (a temporary) and does nothing with it. Such use is more often than not a bug. Hope for a compiler warning.

An object is not considered constructed until its constructor completes (§6.4.2). When using a delegating constructor, the object is considered constructed when the delegated-to constructor completes.

If all you need is to set a member to a default value (that doesn’t depend on a constructor argument), a member initializer (§17.4.4) may be simpler.

17.4.4. In-Class Initializers
We can specify an initializer for a non-static data member in the class declaration. For example:

class A {
public:
     int a {7};
     int b = 77;
};
For pretty obscure technical reasons related to parsing and name lookup, the {} and = initializer notations can be used for in-class member initializers, but the () notation cannot.

By default, a constructor will use such an in-class initializer, so that example is equivalent to:

class A {
public:
     int a;
     int b;
     A() : a{7}, b{77} {}
};
Such use of in-class initializers can save a bit of typing, but the real benefits come in more complicated classes with multiple constructors. Often, several constructors use the same initializer for a member. For example:

Click here to view code image

class A {
public:
     A() :a{7}, b{5}, algorithm{"MD5"}, state{"Constructor run"} {}
     A(int a_val) :a{a_val}, b{5}, algorithm{"MD5"}, state{"Constructor run"} {}
     A(D d) :a{7}, b{g(d)}, algorithm{"MD5"}, state{"Constructor run"} {}
      //...
private:
     int a, b;
     HashFunction algorithm;        // cryptographic hash to be applied to all As
     string state;                  // string indicating state in object life cycle
};
The fact that algorithm and state have the same value in all constructors is lost in the mess of code and can easily become a maintenance problem. To make the common values explicit, we can factor out the unique initializer for data members:

Click here to view code image

class A {
public:
     A() :a{7}, b{5} {}
     A(int a_val) :a{a_val}, b{5} {}
     A(D d) :a{7}, b{g(d)} {}
      //...
private:
     int a, b;
     HashFunction algorithm {"MD5"};       // cryptographic hash to be applied to all As
     string state {"Constructor run"};     // string indicating state in object life cycle
};
If a member is initialized by both an in-class initializer and a constructor, only the constructor’s initialization is done (it “overrides” the default). So we can simplify further:

Click here to view code image

class A {
public:
     A() {}
     A(int a_val) :a{a_val} {}
     A(D d) :b{g(d)} {}
      //...
private:
     int a {7};                            // the meaning of 7 for a is ...
     int b {5};                            // the meaning of 5 for b is ...
     HashFunction algorithm {"MD5"};       // Cryptographic hash to be applied to all As
     string state {"Constructor run"};     // String indicating state in object lifecycle
};
As shown, default in-class initializers provide an opportunity for documentation of common cases.

An in-class member initializer can use names that are in scope at the point of their use in the member declaration. Consider the following headache-inducing technical example:

Click here to view code image

int count = 0;
int count2 = 0;

int f(int i) { return i+count; }

struct S {
     int m1 {count2};          // that is, ::count2
     int m2 {f(m1)};           // that is, this->m1+::count; that is, ::count2+::count
     S() { ++count2; }         // very odd constructor
};

int main()
{
     S s1;      //{0,0}
     ++count;
     S s2;      //{1,2}
}
Member initialization is done in declaration order (§17.2.3), so first m1 is initialized to the value of a global variable count2. The value of the global variable is obtained at the point where the constructor for a new S object is run, so it can (and in this example does) change. Next, m2 is initialized by a call to the global f().

It is a bad idea to hide subtle dependencies on global data in member initializers.

17.4.5. static Member Initialization
A static class member is statically allocated rather than part of each object of the class. Generally, the static member declaration acts as a declaration for a definition outside the class. For example:

Click here to view code image

class Node {
      //...
     static int node_count;           // declaration
};

int Node::node_count = 0;             // definition
However, for a few simple special cases, it is possible to initialize a static member in the class declaration. The static member must be a const of an integral or enumeration type, or a constexpr of a literal type (§10.4.3), and the initializer must be a constant-expression. For example:

Click here to view code image

class Curious {
public:
     static const int c1 = 7;         // OK
     static int c2 = 11;              // error: not const
     const int c3 = 13;               // OK, but not static (§17.4.4)
     static const int c4 = sqrt(9);   // error: in-class initializer not constant
     static const float c5 = 7.0;     // error: in-class not integral (use constexpr rather than const)
      //...
};
If (and only if) you use an initialized member in a way that requires it to be stored as an object in memory, the member must be (uniquely) defined somewhere. The initializer may not be repeated:

Click here to view code image

const int Curious::c1;               // don't repeat initializer here
const int* p = &Curious::c1;         // OK: Curious::c1 has been defined
The main use of member constants is to provide symbolic names for constants needed elsewhere in the class declaration. For example:

template<typename T, int N>
class Fixed {  // fixed-size array
public:
     static constexpr int max = N;
      //...
private:
     T a[max];
};
For integers, enumerators (§8.4) offer an alternative for defining symbolic constants within a class declaration. For example:

Click here to view code image

class X {
     enum { c1 = 7, c2 = 11, c3 = 13, c4 = 17 };
      //...
};
17.5. Copy and Move
When we need to transfer a value from a to b, we usually have two logically distinct options:

• Copy is the conventional meaning of x=y; that is, the effect is that the values of x and y are both equal to y’s value before the assignment.

• Move leaves x with y’s former value and y with some moved-from state. For the most interesting cases, containers, that moved-from state is “empty.”

This simple logical distinction is confounded by tradition and by the fact that we use the same notation for both move and copy.

Typically, a move cannot throw, whereas a copy might (because it may need to acquire a resource), and a move is often more efficient than a copy. When you write a move operation, you should leave the source object in a valid but unspecified state because it will eventually be destroyed and the destructor cannot destroy an object left in an invalid state. Also, standard-library algorithms rely on being able to assign to (using move or copy) a moved-from object. So, design your moves not to throw, and to leave their source objects in a state that allows destruction and assignment.

To save us from tedious repetitive work, copy and move have default definitions (§17.6.2).

17.5.1. Copy
Copy for a class X is defined by two operations:

• Copy constructor: X(const X&)

• Copy assignment: X& operator=(const X&)

You can define these two operations with more adventurous argument types, such as volatile X&, but don’t; you’ll just confuse yourself and others. A copy constructor is supposed to make a copy of an object without modifying it. Similarly, you can use const X& as the return type of the copy assignment. My opinion is that doing so causes more confusion than it is worth, so my discussion of copy assumes that the two operations have the conventional types.

Consider a simple two-dimensional Matrix:

Click here to view code image

template<typename T>
class Matrix {
     array<int,2> dim;        // two dimensions
     T* elem;                 // pointer to dim[0]*dim[1] elements of type T
public:
     Matrix(int d1, int d2) :dim{d1,d2}, elem{new T[d1*d2]} {}            // simplified (no error handling)
     int size() const { return dim[0]*dim[1]; }

     Matrix(const Matrix&);                 // copy constructor
     Matrix& operator=(const Matrix&);      // copy assignment

     Matrix(Matrix&&);                      // move constructor
     Matrix& operator=(Matrix&&);           // move assignment

     ~Matrix() { delete[] elem; }
      //...
};
First we note that the default copy (copy the members) would be disastrously wrong: the Matrix elements would not be copied, the Matrix copy would have a pointer to the same elements as the source, and the Matrix destructor would delete the (shared) elements twice (§3.3.1).

However, the programmer can define any suitable meaning for these copy operations, and the conventional one for a container is to copy the contained elements:

Click here to view code image

template<typename T>
Matrix::Matrix(const Matrix& m)        // copy constructor
     : dim{m.dim},
     elem{new T[m.size()]}
{
     uninitialized_copy(m.elem,m.elem+m.size(),elem);        // initialize elements in elem[0:m.size())
}

template<typename T>
Matrix& Matrix::operator=(const Matrix& m)        // copy assignment
{
     if (dim[0]!=m.dim[0] || dim[1]!=m.dim[1])
           throw runtime_error("bad size in Matrix =");
     copy(m.elem,m.elem+m.size(),elem);      // copy elements
}
A copy constructor and a copy assignment differ in that a copy constructor initializes uninitialized memory, whereas the copy assignment operator must correctly deal with an object that has already been constructed and may own resources.

The Matrix copy assignment operator has the property that if a copy of an element throws an exception, the target of the assignment may be left with a mixture of its old value and the new. That is, that Matrix assignment provided the basic guarantee, but not the strong guarantee (§13.2). If that is not considered acceptable, we can avoid it by the fundamental technique of first making a copy and then swapping representations:

Click here to view code image

Matrix& Matrix::operator=(const Matrix& m)           // copy assignment
{
     Matrix tmp {m};          // make a copy
     swap(tmp,*this);         // swap tmp's representation with *this's
     return *this;
}
The swap() will be done only if the copy was successful. Obviously, this operator=() works only if the implementation swap() does not use assignment (std::swap() does not); see §17.5.2.

Usually a copy constructor must copy every non-static member (§17.4.1). If a copy constructor cannot copy an element (e.g., because it needs to acquire an unavailable resource to do so), it can throw an exception.

Note that I did not protect Matrix’s copy assignment against self-assignment, m=m. The reason I did not test is that self-assignment of the members is already safe: both my implementations of Matrix’s copy assignment will work correctly and reasonably efficiently for m=m. Also, self-assignment is rare, so test for self-assignment in a copy assignment only if you are sure that you need to.

17.5.1.1. Beware of Default Constructors
When writing a copy operation, be sure to copy every base and member. Consider:

Click here to view code image

class X {
     string s;
     string s2;
     vector<string> v;

     X(const X&a)           // copy constructor
         :s{a.s}, v{a.v}   // probably sloppy and probably wrong
     {
     }
      //...
};
Here, I “forgot” to copy s2, so it gets default initialized (to ""). This is unlikely to be right. It is also unlikely that I would make this mistake for a simple class. However, for larger classes the chances of forgetting go up. Worse, when someone long after the initial design adds a member to a class, it is easy to forget to add it to the list of members to be copied. This is one reason to prefer the default (compiler-generated) copy operations (§17.6).

17.5.1.2. Copy of Bases
For the purposes of copying, a base is just a member: to copy an object of a derived class you have to copy its bases. For example:

Click here to view code image

struct B1 {
     B1();
     B1(const B1&);
      //...
};

struct B2 {
     B2(int);
     B2(const B2&);
      //...
};

struct D : B1, B2 {
     D(int i) :B1{}, B2{i}, m1{}, m2{2*i} {}
     D(const D& a) :B1{a}, B2{a}, m1{a.m1}, m2{a.m2} {}
     B1 m1;
     B2 m2;
};

D d {1};      // construct with int argument
D dd {d};     // copy construct
The order of initialization is the usual (base before member), but for copying the order had better not matter.

A virtual base (§21.3.5) may appear as a base of several classes in a hierarchy. A default copy constructor (§17.6) will correctly copy it. If you define your own copy constructor, the simplest technique is to repeatedly copy the virtual base. Where the base object is small and the virtual base occurs only a few times in a hierarchy, that can be more efficient than techniques for avoiding the replicated copies.

17.5.1.3. The Meaning of Copy
What does a copy constructor or copy assignment have to do to be considered “a proper copy operation”? In addition to be declared with a correct type, a copy operation must have the proper copy semantics. Consider a copy operation, x=y, of two objects of the same type. To be suitable for value-oriented programming in general (§16.3.4), and for use with the standard library in particular (§31.2.2), the operation must meet two criteria:

• Equivalence: After x=y, operations on x and y should give the same result. In particular, if == is defined for their type, we should have x==y and f(x)==f(y) for any function f() that depends only on the values of x and y (as opposed to having its behavior depend on the addresses of x and y).

• Independence: After x=y, operations on x should not implicitly change the state of y, that is f(x) does not change the value of y as long as f(x) doesn’t refer to y.

This is the behavior that int and vector offer. Copy operations that provide equivalence and independence lead to simpler and more maintainable code. This is worth stating because code that violates these simple rules is not uncommon, and programmers don’t always realize that such violations are the root cause of some of their nastier problems. A copy that provides equivalence and independence is part of the notion of a regular type (§24.3.1).

First consider the requirement of equivalence. People rarely violate this requirement deliberately, and the default copy operations do not violate it; they do memberwise copy (§17.3.1, §17.6.2). However, tricks, such as having the meaning of copy depend on “options,” occasionally appear and typically cause confusion. Also, it is not uncommon for an object to contain members that are not considered part of its value. For example, a copy of a standard container does not copy its allocator because the allocator is considered part of the container, rather than part of its value. Similarly, counters for statistics gathering and cached values are sometimes not simply copied. Such “non-value” parts of an object’s state should not affect the result of comparison operators. In particular, x=y should imply x==y. Furthermore, slicing (§17.5.1.4) can lead to “copies” that behave differently, and is most often a bad mistake.

Now consider the requirement of independence. Most of the problems related to (lack of) independence have to do with objects that contain pointers. The default meaning of copy is memberwise copy. A default copy operation copies a pointer member, but does not copy the object (if any) that it points to. For example:

Click here to view code image

struct S {
     int* p;     // a pointer
};

S x {new int{0}};
void f()
{
     S y {x};               //"copy" x

     *y.p = 1;              // change y; affects x
     *x.p = 2;              // change x; affects y
     delete y.p;            // affects x and y
     y.p = new int{3};      // OK: change y; does not affect x
     *x.p = 4;              // oops: write to deallocated memory
}
Here I violated the rule of independence. After the “copy” of x into y, we can manipulate part of x’s state through y. This is sometimes called shallow copy and (too) often praised for “efficiency.” The obvious alternative of copying the complete state of an object is called deep copy. Often, the better alternative to deep copy is not a shallow copy, but a move operation, which minimizes copying without adding complexity (§3.3.2, §17.5.2).

A shallow copy leaves two objects (here, x and y) with a shared state, and has a huge potential for confusion and errors. We say that the objects x and y have become entangled when the requirement of independence has been violated. It is not possible to reason about an entangled object in isolation. For example, it is not obvious from the source code that the two assignments to *x.p can have dramatically different effects.

We can represent two entangled objects graphically:



Note that entanglement can arise in a variety of ways. Often, it is not obvious that entanglement has happened until probems arise. For example, a type like S may incautiously be used as a member of an otherwise well-behaved class. The original author of S may be aware of the entanglement and prepared to cope with it, but someone naively assuming that copying an S meant copying its complete value could be surprised, and someone who finds an S deeply nested in other classes could be very surprised.

We can address problems related to the lifetime of a shared subobject by introducing a form of garbage collection. For example:

Click here to view code image

struct S2 {
     shared_ptr<int> p;
};

S2 x {shared_ptr<int>{new int{0}}};
void f()
{
     S2 y {x};                   //"copy" x

     *y.p=1;                     // change y, affects x
     *x.p = 2;                   // change x; affects y
     y.p.reset(new int{3});      // change y; does not affect x
     *x.p = 4;                   // change x; does not affect y
}
In fact, shallow copy and such entangled objects are among the sources of demands for garbage collection. Entangled objects lead to code that is very hard to manage without some form of garbage collection (e.g., shared_ptrs).

However, a shared_ptr is still a pointer, so we cannot consider objects containing a shared_ptr in isolation. Who can update the pointed-to object? How? When? If we are running in a multithreaded system, is synchronization needed for access to the shared data? How can we be sure? Entangled objects (here, resulting from a shallow copy) is a source of complexity and errors that is at best partially solved by garbage collection (in any form).

Note that an immutable shared state is not a problem. Unless we compare addresses, we cannot tell whether two equal values happen to be represented as one or two copies. This is a useful observation because many copies are never modified. For example, objects passed by value are rarely written to. This observation leads to the notion of copy-on-write. The idea is that a copy doesn’t actually need independence until a shared state is written to, so we can delay the copying of the shared state until just before the first write to it. Consider:

Click here to view code image

class Image {
public:
      //...
     Image(const Image& a);          // copy constructor
      //...
     void write_block(Descriptor);
      //...
private:
     Representation* clone();                       // copy *rep
     shared_ptr<Representation> rep;   // potentially share
};
Assume that a Representation can be huge and that a write_block() is expensive compared to testing a shared_ptr’s use count (§5.2.1, §34.3.2). Then, depending on the use of Images, it can make sense to use a shared_ptr to hold the representation (for potential sharing) and implement the copy constructor as a shallow copy:

Click here to view code image

Image::Image(const Image& a)       // do shallow copy
     :rep{a.rep}    // a.rep now has two users
{
}
We protect the argument to that copy constructor by copying the Representation before a write:

Click here to view code image

void Image::write_block(Descriptor d)
{
     if (rep.use_count() > 1)
           rep = shared_ptr<Representation>{clone()};

     // ... now we can safely write to our own copy of rep ...
     }
Every write operation needs to check the use_count() and if necessary clone() the Representation.

Like any other technique, copy-on-write is not a panacea, but it can be an effective combination of the simplicity of true copy and the efficiency of shallow copy.

17.5.1.4. Slicing
A pointer to a derived class implicitly converts to a pointer to its public base class. When applied to a copy operation, this simple and necessary rule (§3.2.4, §20.2) leads to a trap for the unwary. Consider:

Click here to view code image

struct Base {
     int b;
     Base(const Base&);
      //...
};

struct Derived : Base {
     int d;
     Derived(const Derived&);
      //...
};

void naive(Base* p)
{
     Base b2 = *p;     // may slice: invokes Base::Base(const Base&)
      //...
}

void user()
{
     Derived d;
     naive(&d);
     Base bb = d;    // slices: invokes Base::Base(const Base&), not Derived::Derived(const Derived&)
      //...
}
The variables b2 and bb contain copies of the Base part of d, that is, a copy of d.b. The member d.d is not copied. This phenomenon is called slicing. It may be exactly what you intended (e.g., see the copy constructor for D in §17.5.1.2 where we pass selected information to a base class), but typically it is a subtle bug. If you don’t want slicing, you have two major tools to prevent it:

[1] Prohibit copying of the base class: delete the copy operations, and possibly provide a (§17.6.4).

[2] Prevent conversion of a pointer to a derived to a pointer to a base: make the base class a private or protected base (§20.5).

[3] Make the copy operations private or protected, and provide a clone() function to allow a user to request a non-slicing copy (§20.3.6).

Option [1] would make the initializations of b2 and bb errors; option [2] would make the call of naive() and the initialization of bb errors.

17.5.2. Move
The traditional way of getting a value from a to b is to copy it. For an integer in a computer’s memory, that’s just about the only thing that makes sense: that’s what the hardware can do with a single instruction. However, from a general and logical point of view that’s not so. Consider the obvious implementation of swap() exchanging the value of two objects:

Click here to view code image

template<typename T>
void swap(T& a, T& b)
{
     const T tmp = a;     // put a copy of a into tmp
     a = b;               // put a copy of b into a
     b = tmp;             // put a copy of tmp into b
};
After initializing tmp, we have two copies of a’s value. After assigning to a, we have two copies of b’s value. After assigning to b, we have two copies of tmp’s value (that is, the original value of a). Then we destroy tmp. That sounds like a lot of work, and it can be. For example:

Click here to view code image

void f(string& s1, string& s2,
     vector<string>& vs1, vector<string>& vs2,
     Matrix& m1, Matrix& m2)
{

     swap(s1,s2);
     swap(vs1,vs2);
     swap(m1,m2);
}
What if s1 has a thousand characters? What if vs2 has a thousand elements each of a thousand characters? What if m1 is a 1000*1000 matrix of doubles? The cost of copying those data structures could be significant. In fact, the standard-library swap() has always been carefully designed to avoid such overhead for string and vector. That is, effort has been made to avoid copying (taking advantage of the fact that string and vector objects really are just handles to their elements). Similar work must be done to avoid a serious performance problem for swap() of Matrixes. If the only operation we have is copy, similar work must be done for huge numbers of functions and data structures that are not part of the standard.

The fundamental problem is that we really didn’t want to do any copying at all: we just wanted to exchange pairs of values.

We can also look at the issue of copying from a completely different point of view: we don’t usually copy physical things unless we absolutely have to. If you want to borrow my phone, I pass my phone to you rather than making you your own copy. If I lend you my car, I give you a key and you drive away in my car, rather than in your freshly made copy of my car. Once I have given you an object, you have it and I no longer do. Consequently, we talk about “giving away,” “handing over,” “transferring ownership of,” and “moving” physical objects. Many objects in a computer resemble physical objects (which we don’t copy without need and only at considerable cost) more than integer values (which we typically copy because that’s easier and cheaper than alternatives). Examples are locks, sockets, file handles, threads, long strings, and large vectors.

To allow the user to avoid the logical and performance problems of copying, C++ directly supports the notion of moving as well as the notion of copying. In particular, we can define move constructors and move assignments to move rather than copy their argument. Consider again the simple two-dimensional Matrix from §17.5.1:

Click here to view code image

template<typename T>
class Matrix {
     std::array<int,2> dim;
     T elem;  // pointer to dim[0]*dim[1] elements of type T
public:
     Matrix(int d1, int d2) :dim{d1,d2}, elem{new T[d1*d2]} {}
     int size() const { return dim[0]*dim[1]; }

     Matrix(const Matrix&);              // copy constructor
     Matrix(Matrix&&);                   // move constructor (Matrix&& is an rvalue reference; §7.7.2).

     Matrix& operator=(const Matrix&);   // copy assignment
     Matrix& operator=(Matrix&&);        // move assignment

     ~Matrix() { delete[] elem; }        // destructor
      //...
};
The idea behind a move assignment is to handle lvalues separately from rvalues: copy assignment and copy constructors take lvalues whereas move assignment and move constructors take rvalues. For a return value, the move constructor is chosen.

We can define Matrix’s move constructor to simply take the representation from its source and replace it with an empty Matrix (which is cheap to destroy). For example:

Click here to view code image

template<typename T>
Matrix<T>::Matrix(Matrix&& a)       // move constructor
     :dim{a.dim}, elem{a.elem}      // grab a's representation
{
     a.dim = {0,0};                 // clear a's representation
     a.elem = nullptr;
}
For the move assignment, we can simply do a swap. The idea behind using a swap to implement a move assignment is that the source is just about to be destroyed, so we can just let the destructor for the source do the necessary cleanup work for us:

Click here to view code image

template<typename T>
Matrix<T>& Matrix<T>::operator=(Matrix&& a)            // move assignment
{
     swap(dim,a.dim);             // swap representations
     swap(elem,a.elem);
     return *this;
}
Move constructors and move assignments take non-const (rvalue) reference arguments: they can, and usually do, write to their argument. However, the argument of a move operation must always be left in a state that the destructor can cope with (and preferably deal with very cheaply and easily).

For resource handles, move operations tend to be significantly simpler and more efficient than copy operations. In particular, move operations typically do not throw exceptions; they don’t acquire resources or do complicated operations, so they don’t need to. In this, they differ from many copy operations (§17.5).

How does the compiler know when it can use a move operation rather than a copy operation? In a few cases, such as for a return value, the language rules say that it can (because the next action is defined to destroy the element). However, in general we have to tell it by giving an rvalue reference argument. For example:

Click here to view code image

template<typename T>
void swap(T& a, T& b)     //"perfect swap" (almost)
{
     T tmp = std::move(a);
     a = std::move(b);
     b = std::move(tmp);
}
The move() is a standard-library function returning an rvalue reference to its argument (§35.5.1): move(x) means “give me an rvalue reference to x.” That is, std::move(x) does not move anything; instead, it allows a user to move x. It would have been better if move() had been called rval(), but the name move() has been used for this operation for years.

Standard-library containers have move operations (§3.3.2, §35.5.1) and so have other standard-library types, such as pair (§5.4.3, §34.2.4.1) and unique_ptr (§5.2.1, §34.3.1). Furthermore, operations that insert new elements into standard-library containers, such as insert() and push_back(), have versions that take rvalue references (§7.7.2). The net result is that the standard containers and algorithms deliver better performance than they would have been able to if they had to copy.

What if we try to swap objects of a type that does not have a move constructor? We copy and pay the price. In general, a programmer is responsible for avoiding excessive copying. It is not the compiler’s job to decide what is excessive and what is necessary. To get the copy-to-move optimization for your own data structures, you have to provide move operations (either explicitly or implicitly; see §17.6).

Built-in types, such as int and double*, are considered to have move operations that simply copy. As usual, you have to be careful about data structures containing pointers (§3.3.1). In particular, don’t assume that a moved-from pointer is set to nullptr.

Having move operations affects the idiom for returning large objects from functions. Consider:

Click here to view code image

Matrix operator+(const Matrix& a, const Matrix& b)
      // res[i][j] = a[i][j]+b[i][j] for each i and j
{
     if (a.dim[0]!=b.dim[0] || a.dim[1]!=b.dim[1])
            throw std::runtime_error("unequal Matrix sizes in +");

     Matrix res{a.dim[0],a.dim[1]};
     constexpr auto n = a.size();
     for (int i = 0; i!=n; ++i)
           res.elem[i] = a.elem[i]+b.elem[i];
     return res;
}
Matrix has a move constructor so that “return by value” is simple and efficient as well as “natural.” Without move operations, we have performance problems and must resort to workarounds. We might have considered:

Click here to view code image

Matrix& operator+(const Matrix& a, const Matrix& b)         // beware!
{
     Matrix& res = *new Matrix;                // allocate on free store
      // res[i][j] = a[i][j]+b[i][j] for each i and j
     return res;
}
The use of new within operator+() is not obvious and forces the user of + to deal with tricky memory management issues:

• How does the object created by new get deleted?

• Do we need a garbage collector?

• Should we use a pool of Matrixes rather than the general new?

• Do we need use-counted Matrix representations?

• Should we redesign the interface of our Matrix addition?

• Must the caller of operator+() remember to delete the result?

• What happens to the newly allocated memory if the computation throws an exception?

None of the alternatives are elegant or general.

17.6. Generating Default Operations
Writing conventional operations, such as a copy and a destructor, can be tedious and error-prone, so the compiler can generate them for us as needed. By default, a class provides:

• A default constructor: X()

• A copy constructor: X(const X&)

• A copy assignment: X& operator=(const X&)

• A move constructor: X(X&&)

• A move assignment: X& operator=(X&&)

• A destructor: ~X()

By default, the compiler generates each of these operations if a program uses it. However, if the programmer takes control by defining one or more of those operations, the generation of related operations is suppressed:

• If the programmer declares any constructor for a class, the default constructor is not generated for that class.

• If the programmer declares a copy operation, a move operation, or a destructor for a class, no copy operation, move operation, or destructor is generated for that class.

Unfortunately, the second rule is only incompletely enforced: for backward compatibility, copy constructors and copy assignments are generated even if a destructor is defined. However, that generation is deprecated in the ISO standard (§iso.D), and you should expect a modern compiler to warn against it.

If necessary, we can be explicit about which functions are generated (§17.6.1) and which are not (§17.6.4).

17.6.1. Explicit Defaults
Since the generation of otherwise default operations can be suppressed, there has to be a way of getting back a default. Also, some people prefer to see a complete list of operations in the program text even if that complete list is not needed. For example, we can write:

Click here to view code image

class gslice {
     valarray<size_t> size;
     valarray<size_t> stride;
     valarray<size_t> d1;
public:
     gslice() = default;
     ~gslice() = default;
     gslice(const gslice&) = default;
     gslice(gslice&&) = default;
     gslice& operator=(const gslice&) = default;
     gslice& operator=(gslice&&) = default;
      //...
};
This fragment of the implementation of std::gslice (§40.5.6) is equivalent to:

class gslice {
     valarray<size_t> size;
     valarray<size_t> stride;
     valarray<size_t> d1;
public:
      //...
};
I prefer the latter, but I can see the point of using the former in code bases maintained by less experienced C++ programmers: what you don’t see, you might forget about.

Using =default is always better than writing your own implementation of the default semantics. Someone assuming that it is better to write something, rather than nothing, might write:

class gslice {
     valarray<size_t> size;
     valarray<size_t> stride;
     valarray<size_t> d1;
public:
      //...
     gslice(const gslice& a);
};

gslice::gslice(const gslice& a)
     : size{a.size },
     stride{a.stride},
     d1{a.d1}
{
}
This is not only verbose, making it harder to read the definition of gslice, but also opens the opportunity for making mistakes. For example, I might forget to copy one of the members and get it default initialized (rather than copied). Also, when the user provides a function, the compiler no longer knows the semantics of that function and some optimizations become inhibited. For the default operations, those optimizations can be significant.

17.6.2. Default Operations
The default meaning of each generated operation, as implemented when the compiler generates it, is to apply the operation to each base and non-static data member of the class. That is, we get memberwise copy, memberwise default construction, etc. For example:

Click here to view code image

struct S {
     string a;
     int b;
};

S f(S arg)
{
     S s0 {};    // default construction: {"",0}
     S s1 {s0};  // copy construction
     s1 = arg;   // copy assignment
     return s1;  // move construction
}
The copy construction of s1 copies s0.a and s0.b. The return of s1 moves s1.a and s1.b, leaving s1.a as the empty string and s1.b unchanged.

Note that the value of a moved-from object of a built-in type is unchanged. That’s the simplest and fastest thing for the compiler to do. If we want something else done for a member of a class, we have to write our move operations for that class.

The default moved-from state is one for which the default destructor and default copy assignment work correctly. It is not guaranteed (or required) that an arbitrary operation on a moved-from object will work correctly. If you need stronger guarantees, write your own operations.

17.6.3. Using Default Operations
This section presents a few examples demonstrating how copy, move, and destructors are logically linked. If they were not linked, errors that are obvious when you think about them would not be caught by the compiler.

17.6.3.1. Default Constructors
Consider:

Click here to view code image

struct X {
     X(int);      // require an int to initialize an X
};
By declaring a constructor that requires an integer argument, the programmer clearly states that a user needs to provide an int to initialize an X. Had we allowed the default constructor to be generated, that simple rule would have been violated. We have:

X a {1};     // OK
X b {};      // error: no default constructor
If we also want the default constructor, we can define one or declare that we want the default generated by the compiler. For example:

Click here to view code image

struct Y {
     string s;
     int n;
     Y(const string& s);   // initialize Y with a string
     Y() = default;        // allow default initialization with the default meaning
};
The default (i.e., generated) default constructor default constructs each member. Here, Y() sets s to the empty string. The “default initialization” of a built-in member leaves that member uninitialized. Sigh! Hope for a compiler warning.

17.6.3.2. Maintaining Invariants
Often, a class has an invariant. If so, we want copy and move operations to maintain it and the destructor to free any resources involved. Unfortunately, the compiler cannot in every case know what a programmer considers an invariant. Consider a somewhat far-fetched example:

Click here to view code image

struct Z {  // invariant:
            // my_favorite is the index of my favorite element of elem
            // largest points to the element with the highest value in elem
     vector<int> elem;
     int my_favorite;
     int* largest;
};
The programmer stated an invariant in the comment, but the compiler doesn’t read comments. Furthermore, the programmer did not leave a hint about how that invariant is to be established and maintained. In particular, there are no constructors or assignments declared. That invariant is implicit. The result is that a Z can be copied and moved using the default operations:

Click here to view code image

Z v0;                              // no initialization (oops! possibility of undefined values)
Z val {{1,2,3},1,&v0.elem[2]};         // OK, but ugly and error-prone
Z v2 = val;                        // copies: v2.largest points into val
Z v3 = move(val);                  // moves: val.elem becomes empty; v3.my_favorite is out of range
This is a mess. The root problem is that Z is badly designed because critical information is “hidden” in a comment or completely missing. The rules for the generation of default operations are heuristics intended to catch common mistakes and to encourage a systematic approach to construction, copy, move, and destruction. Wherever possible:

[1] Establish an invariant in a constructor (including possibly resource acquisition).

[2] Maintain the invariant with copy and move operations (with the usual names and types).

[3] Do any needed cleanup in the destructor (incl. possibly resource release).

17.6.3.3. Resource Invariants
Many of the most critical and obvious uses of invariants relate to resource management. Consider a simple Handle:

template<typename T> class Handle {
     T* p;
public:
     Handle(T* pp) :p{pp} { }
     T& operator*() { return *p; }
     ~Handle() { delete p; }
};
The idea is that you construct a Handle given a pointer to an object allocated using new. The Handle provides access to the object pointed to and eventually deletes that object. For example:

void f1()
{
     Handle<int> h {new int{99}};
      //...
}
Handle declares a constructor that takes an argument: this suppresses the generation of the default constructor. That’s good because a default constructor could leave Handle<T>::p uninitialized:

Click here to view code image

void f2()
{
     Handle<int> h;  // error: no default constructor
      //...
}
The absence of a default constructor saves us from the possibility of a delete with a random memory address.

Also, Handle declares a destructor: this suppresses the generation of copy and move operations. Again, that saves us from a nasty problem. Consider:

Click here to view code image

void f3()
{
     Handle<int> h1 {new int{7}};
     Handle<int> h2 {h1};            // error: no copy constructor
      //...
}
Had Handle had a default copy constructor, both h1 and h2 would have had a copy of the pointer and both would have deleted it. The results would be undefined and most likely disastrous (§3.3.1). Caveat: the generation of copy operations is only deprecated, not banned, so if you ignore warnings, you might get this example past the compiler. In general, if a class has a pointer member, the default copy and move operations should be considered suspicious. If that pointer member represents ownership, memberwise copy is wrong. If that pointer member does not represent ownership and memberwise copy is appropriate, explicit =default and a comment are most likely a good idea.

If we wanted copy construction, we could define something like:

Click here to view code image

template<typename T>
class Handle {
      //...
     Handle(const Handle& a) :p{new T{*a.p}} { }     // clone
};
17.6.3.4. Partially Specified Invariants
Troublesome examples that rely on invariants but only partially express them through constructors or destructors are rarer but not unheard of. Consider:

Click here to view code image

class Tic_tac_toe {
public:
     Tic_tac_toe(): pos(9) {}     // always 9 positions

     Tic_tac_toe& operator=(const Tic_tac_toe& arg)
     {
         for(int i = 0; i<9; ++i)
               pos.at(i) = arg.pos.at(i);
         return *this;
     }

      //... other operations ...

     enum State { empty, nought, cross };
private:
     vector<State> pos;
};
This was reported to have been part of a real program. It uses the “magic number” 9 to implement a copy assignment that accesses its argument arg without checking that the argument actually has nine elements. Also, it explicitly implements the copy assignment, but not the copy constructor. This is not what I consider good code.

We defined copy assignment, so we must also define the destructor. That destructor can be =default because all it needs to do is to ensure that the member pos is destroyed, which is what would have been done anyway had the copy assignment not been defined. At this point, we notice that the user-defined copy assignment is essentially the one we would have gotten by default, so we can =default that also. Add a copy constructor for completeness and we get:

Click here to view code image

class Tic_tac_toe {
public:
     Tic_tac_toe(): pos(9) {}    // always 9 positions
     Tic_tac_toe(const Tic_tac_toe&) = default;
     Tic_tac_toe& operator=(const Tic_tac_toe& arg) = default;
     ~Tic_tac_toe() = default;

      //... other operations ...

     enum State { empty, nought, cross };
private:
     vector<State> pos;
};
Looking at this, we realize that the net effect of these =defaults is just to eliminate move operations. Is that what we want? Probably not. When we made the copy assignment =default, we eliminated the nasty dependence on the magic constant 9. Unless other operations on Tic_tac_toe, not mentioned so far, are also “hardwired with magic numbers,” we can safely add move operations. The simplest way to do that is to remove the explicit =defaults, and then we see that Tic_tac_toe is really a perfectly ordinary type:

Click here to view code image

class Tic_tac_toe {
public:
      //... other operations ...
     enum State { empty, nought, cross };
private:
     vector<State> pos {Vector<State>(9)};         // always 9 positions
};
One conclusion that I draw from this and other examples where an “odd combination” of the default operations is defined is that we should be highly suspicious of such types: their irregularity often hides design flaws. For every class, we should ask:

[1] Is a default constructor needed (because the default one is not adequate or has been suppressed by another constructor)?

[2] Is a destructor needed (e.g., because some resource needs to be released)?

[3] Are copy operations needed (because the default copy semantics is not adequate, e.g., because the class is meant to be a base class or because it contains pointers to objects that must be deleted by the class)?

[4] Are move operations needed (because the default semantics is not adequate, e.g., because an empty object doesn’t make sense)?

In particular, we should never just consider one of these operations in isolation.

17.6.4. deleted Functions
We can “delete” a function; that is, we can state that a function does not exist so that it is an error to try to use it (implicitly or explicitly). The most obvious use is to eliminate otherwise defaulted functions. For example, it is common to want to prevent the copying of classes used as bases because such copying easily leads to slicing (§17.5.1.4):

Click here to view code image

class Base {
      //...
     Base& operator=(const Base&) = delete; // disallow copying
     Base(const Base&) = delete;

     Base& operator=(Base&&) = delete;           // disallow moving
     Base(Base&&) = delete;
};

Base x1;
Base x2 {x1};   // error: no copy constructor
Enabling and disabling copy and move is typically more conveniently done by saying what we want (using =default; §17.6.1) rather than saying what we don’t want (using =delete). However, we can delete any function that we can declare. For example, we can eliminate a specialization from the set of possible specializations of a function template:

Click here to view code image

template<typename T>
T* clone(T* p)  // return copy of *p
{
     return new T{*p};
};

Foo* clone(Foo*) = delete;          // don't try to clone a Foo

void f(Shape* ps, Foo* pf)
{
     Shape* ps2 = clone(ps);        // fine
     Foo* pf2 = clone(pf);          // error: clone(Foo*) deleted
}
Another application is to eliminate an undesired conversion. For example:

Click here to view code image

struct Z {
      //...
     Z(double);             // can initialize with a double
     Z(int) = delete;       // but not with an integer
};

void f()
{
     Z z1 {1};         // error: Z(int) deleted
     Z z2 {1.0};       // OK
}
A further use is to control where a class can be allocated:

Click here to view code image

class Not_on_stack {
      //...
     ~Not_on_stack() = delete;
};

class Not_on_free_store {
      //...
     void* operator new(size_t) = delete;
};
You can’t have a local variable that can’t be destroyed (§17.2.2), and you can’t allocate an object on the free store when you have =deleted its class’s memory allocation operator (§19.2.5). For example:

Click here to view code image

void f()
{
     Not_on_stack v1;         // error: can't destroy
     Not_on_free_store v2;    // OK

     Not_on_stack* p1 = new Not_on_stack;              // OK
     Not_on_free_store* p2 = new Not_on_free_store;    // error: can't allocate
}
However, we can never delete that Not_on_stack object. The alternative technique of making the destructor private (§17.2.2) can address that problem.

Note the difference between a =deleted function and one that simply has not been declared. In the former case, the compiler notes that the programmer has tried to use a deleted function and gives an error. In the latter case, the compiler looks for an alternative. For a “missing” destructor, it tries to generate one if one is needed. For a “missing” class operator new(), it tries to use a global operator new().

17.7. Advice
[1] Design constructors, assignments, and the destructor as a matched set of operations; §17.1.

[2] Use a constructor to establish an invariant for a class; §17.2.1.

[3] If a constructor acquires a resource, its class needs a destructor to release the resource; §17.2.2.

[4] If a class has a virtual function, it needs a virtual destructor; §17.2.5.

[5] If a class does not have a constructor, it can be initialized by memberwise initialization; §17.3.1.

[6] Prefer {} initialization over = and () initialization; §17.3.2.

[7] Give a class a default constructor if and only if there is a “natural” default value; §17.3.3.

[8] If a class is a container, give it an initializer-list constructor; §17.3.4.

[9] Initialize members and bases in their order of declaration; §17.4.1.

[10] If a class has a reference member, it probably needs copy operations (copy constructor and copy assignment); §17.4.1.1.

[11] Prefer member initialization over assignment in a constructor; §17.4.1.1.

[12] Use in-class initializers to provide default values; §17.4.4.

[13] If a class is a resource handle, it probably needs copy and move operations; §17.5.

[14] When writing a copy constructor, be careful to copy every element that needs to be copied (beware of default initializers); §17.5.1.1.

[15] A copy operation should provide equivalence and independence; §17.5.1.3.

[16] Beware of entangled data structures; §17.5.1.3.

[17] Prefer move semantics and copy-on-write to shallow copy; §17.5.1.3.

[18] If a class is used as a base class, protect against slicing; §17.5.1.4.

[19] If a class needs a copy operation or a destructor, it probably needs a constructor, a destructor, a copy assignment, and a copy constructor; §17.6.

[20] If a class has a pointer member, it probably needs a destructor and non-default copy operations; §17.6.3.3.

[21] If a class is a resource handle, it needs a constructor, a destructor, and non-default copy operations; §17.6.3.3.

[22] If a default constructor, assignment, or destructor is appropriate, let the compiler generate it (don’t rewrite it yourself); §17.6.

[23] Be explicit about your invariants; use constructors to establish them and assignments to maintain them; §17.6.3.2.

[24] Make sure that copy assignments are safe for self-assignment; §17.5.1.

[25] When adding a new member to a class, check to see if there are user-defined constructors that need to be updated to initialize the member; §17.5.1.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


17. Construction, Cleanup, Copy, and Move
18. Operator Overloading
19. Special Operators
47h 26m remaining
18. Operator Overloading
When I use a word it means just what I choose it to mean – neither more nor less.

– Humpty Dumpty

• Introduction

• Operator Functions

Binary and Unary Operators; Predefined Meanings for Operators; Operators and User-Defined Types; Passing Objects; Operators in Namespaces

• A Complex Number Type

Member and Nonmember Operators; Mixed-Mode Arithmetic; Conversions; Literals; Accessor Functions; Helper Functions

• Type Conversion

Conversion Operators; explicit Conversion Operators; Ambiguities

• Advice

18.1. Introduction
Every technical field – and most nontechnical fields – has developed conventional shorthand notation to make convenient the presentation and discussion involving frequently used concepts. For example, because of long acquaintance,

x+y*z
is clearer to us than

multiply y by z and add the result to x
It is hard to overestimate the importance of concise notation for common operations.

Like most languages, C++ supports a set of operators for its built-in types. However, most concepts for which operators are conventionally used are not built-in types in C++, so they must be represented as user-defined types. For example, if you need complex arithmetic, matrix algebra, logic signals, or character strings in C++, you use classes to represent these notions. Defining operators for such classes sometimes allows a programmer to provide a more conventional and convenient notation for manipulating objects than could be achieved using only the basic functional notation. Consider:

Click here to view code image

class complex {              // very simplified complex
     double re, im;
public:
     complex(double r, double i) :re{r}, im{i} { }
     complex operator+(complex);
     complex operator*(complex);
};
This defines a simple implementation of the concept of complex numbers. A complex is represented by a pair of double-precision floating-point numbers manipulated by the operators + and *. The programmer defines complex::operator+() and complex::operator*() to provide meanings for + and *, respectively. For example, if b and c are of type complex, b+c means b.operator+(c). We can now approximate the conventional interpretation of complex expressions:

void f()
{
     complex a = complex{1,3.1};
     complex b {1.2, 2};
     complex c {b};

     a = b+c;
     b = b+c*a;
     c = a*b+complex(1,2);
}
The usual precedence rules hold, so the second statement means b=b+(c*a), not b=(b+c)*a.

Note that the C++ grammar is written so that the {} notation can only be used for initializers and on the right-hand side of an assignment:

Click here to view code image

void g(complex a, complex b)
{
     a = {1,2};           // OK: right hand side of assignment
     a += {1,2};          // OK: right hand side of assignment
     b = a+{1,2};        // syntax error
     b = a+complex{1,2};  // OK
     g(a,{1,2});          // OK: a function argument is considered an initializer
     {a,b} = {b,a};       // syntax error
}
There seems to be no fundamental reason not to use {} in more places, but the technical problems of writing a grammar allowing {} everywhere in an expression (e.g., how would you know if a { after a semicolon was the start of an expression or a block?) and also giving good error messages led to a more limited use of {} in expressions.

Many of the most obvious uses of operator overloading are for numeric types. However, the usefulness of user-defined operators is not restricted to numeric types. For example, the design of general and abstract interfaces often leads to the use of operators such as –>, [], and ().

18.2. Operator Functions
Functions defining meanings for the following operators (§10.3) can be declared:

Click here to view code image

+         -         *        /         %         ^        &
|         ~         !        =         <         >        +=
-=        *=        /=       %=        ^=        &=       |=
<<        >>        >>=      <<=       ==        !=       <=
>=        &&        ||       ++        --        ->*      ,
->        []        ()       new       new[]     delete   delete[]
The following operators cannot be defined by a user:

::      scope resolution (§6.3.4, §16.2.12)

.        member selection (§8.2)

.*      member selection through pointer to member (§20.6)

They take a name, rather than a value, as their second operand and provide the primary means of referring to members. Allowing them to be overloaded would lead to subtleties [Stroustrup,1994]. The named “operators”cannot be overloaded because they report fundamental facts about their operands:

sizeof     size of object (§6.2.8)

alignof  alignment of object (§6.2.9)

typeid  type_info of an object (§22.5)

Finally, the ternary conditional expression operator cannot be overloaded (for no particularly fundamental reason):

?:        conditional evaluation (§9.4.1)

In addition, user-defined literals (§19.2.6) are defined by using the operator"" notation. This is a kind of syntactic subterfuge because there is no operator called "". Similarly, operator T() defines a conversion to a type T (§18.4).

It is not possible to define new operator tokens, but you can use the function call notation when this set of operators is not adequate. For example, use pow(), not **. These restrictions may seem Draconian, but more flexible rules can easily lead to ambiguities. For example, defining an operator ** to mean exponentiation may seem an obvious and easy task, but think again. Should ** bind to the left (as in Fortran) or to the right (as in Algol)? Should the expression a**p be interpreted as a*(*p) or as (a)**(p)? There are solutions to all such technical questions. However, it is most uncertain if applying subtle technical rules will lead to more readable and maintainable code. If in doubt, use a named function.

The name of an operator function is the keyword operator followed by the operator itself, for example, operator<<. An operator function is declared and can be called like any other function. A use of the operator is only a shorthand for an explicit call of the operator function. For example:

Click here to view code image

void f(complex a, complex b)
{
  complex c = a + b;            // shorthand
  complex d = a.operator+(b);   // explicit call
}
Given the previous definition of complex, the two initializers are synonymous.

18.2.1. Binary and Unary Operators
A binary operator can be defined by either a non-static member function taking one argument or a nonmember function taking two arguments. For any binary operator @, aa@bb can be interpreted as either aa.operator@(bb) or operator@(aa,bb). If both are defined, overload resolution (§12.3) determines which, if any, interpretation is used. For example:

class X {
public:
     void operator+(int);
     X(int);
};

void operator+(X,X);
void operator+(X,double);

void f(X a)
{
     a+1;      // a.operator+(1)
     1+a;      //::operator+(X(1),a)
     a+1.0;    //::operator+(a,1.0)
}
A unary operator, whether prefix or postfix, can be defined by either a non-static member function taking no arguments or a nonmember function taking one argument. For any prefix unary operator @, @aa can be interpreted as either aa.operator@() or operator@(aa). If both are defined, overload resolution (§12.3) determines which, if any, interpretation is used. For any postfix unary operator @, aa@ can be interpreted as either aa.operator@(int) or operator@(aa,int). This is explained further in §19.2.4. If both are defined, overload resolution (§12.3) determines which, if any, interpretation is used. An operator can be declared only for the syntax defined for it in the grammar (§iso.A). For example, a user cannot define a unary % or a ternary +. Consider:

Click here to view code image

class X {
public:      // members (with implicit this pointer):

    X* operator&();          // prefix unary & (address of)
    X operator&(X);          // binary & (and)
    X operator++(int);       // postfix increment (see §19.2.4)
    X operator&(X,X);        // error: ternary
    X operator/();           // error: unary /
};
     // nonmember functions :

    X operator–(X);          // prefix unary minus
    X operator–(X,X);        // binary minus
    X operator––(X&,int);    // postfix decrement
    X operator–();           // error: no operand
    X operator–(X,X,X);      // error: ternary
    X operator%(X);          // error: unary %
Operator [] is described in §19.2.1, operator () in §19.2.2, operator –> in §19.2.3, operators ++ and –– in §19.2.4, and the allocation and deallocation operators in §11.2.4 and §19.2.5.

The operators operator= (§18.2.2), operator[] (§19.2.1), operator() (§19.2.2), and operator–> (§19.2.3) must be non-static member functions.

The default meaning of &&, ||, and , (comma) involves sequencing: the first operand is evaluated before the second (and for && and || the second operand is not always evaluated). This special rule does not hold for user-defined versions of &&, ||, and , (comma); instead these operators are treated exactly like other binary operators.

18.2.2. Predefined Meanings for Operators
The meanings of some built-in operators are defined to be equivalent to some combination of other operators on the same arguments. For example, if a is an int, ++a means a+=1, which in turn means a=a+1. Such relations do not hold for user-defined operators unless the user defines them to. For example, a compiler will not generate a definition of Z::operator+=() from the definitions of Z::operator+() and Z::operator=().

The operators = (assignment), & (address-of), and , (sequencing; §10.3.2) have predefined meanings when applied to class objects. These predefined meanings can be eliminated (“deleted”; §17.6.4):

Click here to view code image

class X { 
public:
      //...
     void operator=(const X&) = delete;
     void operator&() = delete;
     void operator,(const X&) = delete;
      //...
};

void f(X a, X b)
{
     a = b;     // error: no operator=()
     &a;        // error: no operator&()
     a,b;       // error: no operator,()
}
Alternatively, they can be given new meanings by suitable definitions.

18.2.3. Operators and User-Defined Types
An operator function must either be a member or take at least one argument of a user-defined type (functions redefining the new and delete operators need not). This rule ensures that a user cannot change the meaning of an expression unless the expression contains an object of a user-defined type. In particular, it is not possible to define an operator function that operates exclusively on pointers. This ensures that C++ is extensible but not mutable (with the exception of operators =, &, and , for class objects).

An operator function intended to accept a built-in type (§6.2.1) as its first operand cannot be a member function. For example, consider adding a complex variable aa to the integer 2: aa+2 can, with a suitably declared member function, be interpreted as aa.operator+(2), but 2+aa cannot because there is no class int for which to define + to mean 2.operator+(aa). Even if there were, two different member functions would be needed to cope with 2+aa and aa+2. Because the compiler does not know the meaning of a user-defined +, it cannot assume that the operator is commutative and so interpret 2+aa as aa+2. This example is trivially handled using one or more nonmember functions (§18.3.2, §19.4).

Enumerations are user-defined types so that we can define operators for them. For example:

Click here to view code image

enum Day { sun, mon, tue, wed, thu, fri, sat };

Day& operator++(Day& d)
{
    return d = (sat==d) ? sun : static_cast<Day>(d+1);
}
Every expression is checked for ambiguities. Where a user-defined operator provides a possible interpretation, the expression is checked according to the overload resolution rules in §12.3.

18.2.4. Passing Objects
When we define an operator, we typically want to provide a conventional notation, for example, a=b+c. Consequently, we have limited choices of how to pass arguments to the operator function and how it returns its value. For example, we cannot require pointer arguments and expect programmers to use the address-of operator or return a pointer and expect the user to dereference it: *a=&b+&c is not acceptable.

For arguments, we have two main choices (§12.2):

• Pass-by-value

• Pass-by-reference

For small objects, say, one to four words, call-by-value is typically a viable alternative and often the one that gives the best performance. However, performance of argument passing and use depends on machine architecture, compiler interface conventions (Application Binary Interfaces; ABIs), and the number of times an argument is accessed (it almost always is faster to access an argument passed by value than one passed by reference). For example, assume that a Point is represented as a pair of ints:

void Point::operator+=(Point delta);    // pass-by-value
Larger objects, we pass by reference. For example, because a Matrix (a simple matrix of doubles; §17.5.1) is most likely larger than a few words, we use pass-by-reference:

Matrix operator+(const Matrix&, const Matrix&);   // pass-by-const-reference
In particular, we use const references to pass large objects that are not meant to be modified by the called function (§12.2.1).

Typically, an operator returns a result. Returning a pointer or a reference to a newly created object is usually a very bad idea: using a pointer gives notational problems, and referring to an object on the free store (whether by a pointer or by a reference) results in memory management problems. Instead, return objects by value. For large objects, such as a Matrix, define move operations to make such transfers of values efficient (§3.3.2, §17.5.2). For example:

Click here to view code image

Matrix operator+(const Matrix& a, const Matrix& b)   // return-by-value
{
     Matrix res {a};
     return res+=b;
}
Note that operators that return one of their argument objects can – and usually do – return a reference. For example, we could define Matrix’s operator += like this:

Click here to view code image

Matrix& Matrix::operator+=(const Matrix& a)        // return-by-reference

{
     if (dim[0]!=a.dim[0] || dim[1]!=a.dim[1])
           throw std::exception("bad Matrix += argument");

     double* p = elem;
     double* q = a.elem;
     double* end = *p+dim[0]*dim[1];
     while(p!=end)
           *p++ += *q++

     return *this;
 }
This is particularly common for operator functions that are implemented as members.

If a function simply passes an object to another function, an rvalue reference argument should be used (§17.4.3, §23.5.2.1, §28.6.3).

18.2.5. Operators in Namespaces
An operator is either a member of a class or defined in some namespace (possibly the global namespace). Consider this simplified version of string I/O from the standard library:

Click here to view code image

namespace std {      // simplified std

    class string {
         //...
    };
     class ostream {
        //...
       ostream& operator<<(const char*);            // output C-style string
    };

    extern ostream cout;

    ostream& operator<<(ostream&, const string&);   // output std::string
} // namespace std

int main()
{
    const char* p = "Hello";
    std::string s = "world";
    std::cout << p << ", " << s << "!\n";
}
Naturally, this writes out Hello, world!. But why? Note that I didn’t make everything from std accessible by writing:

using namespace std;
Instead, I used the std:: prefix for string and cout. In other words, I was on my best behavior and didn’t pollute the global namespace or in other ways introduce unnecessary dependencies.

The output operator for C-style strings is a member of std::ostream, so by definition

std::cout << p
means

std::cout.operator<<(p)
However, std::ostream doesn’t have a member function to output a std::string, so

std::cout << s
means

operator<<(std::cout,s)
Operators defined in namespaces can be found based on their operand types just as functions can be found based on their argument types (§14.2.4). In particular, cout is in namespace std, so std is considered when looking for a suitable definition of <<. In that way, the compiler finds and uses:

std::operator<<(std::ostream&, const std::string&)
Consider a binary operator @. If x is of type X and y is of type Y, x@y is resolved like this:

• If X is a class, look for operator@ as a member of X or as a member of a base of X; and

• look for declarations of operator@ in the context surrounding x@y; and

• if X is defined in namespace N, look for declarations of operator@ in N; and

• if Y is defined in namespace M, look for declarations of operator@ in M.

Declarations for several operator@s may be found and overload resolution rules (§12.3) are used to find the best match, if any. This lookup mechanism is applied only if the operator has at least one operand of a user-defined type. Therefore, user-defined conversions (§18.3.2, §18.4) will be considered. Note that a type alias is just a synonym and not a separate user-defined type (§6.5).

Unary operators are resolved analogously.

Note that in operator lookup no preference is given to members over nonmembers. This differs from lookup of named functions (§14.2.4). The lack of hiding of operators ensures that built-in operators are never inaccessible and that users can supply new meanings for an operator without modifying existing class declarations. For example:

Click here to view code image

X operator!(X);

struct Z {
     Z operator!();                           // does not hide ::operator!()
     X f(X x) { /* ... */ return !x; }        // invoke ::operator!(X)
     int f(int x) { /* ... */ return !x; }    // invoke the built-in ! for ints
};
In particular, the standard iostream library defines << member functions to output built-in types, and a user can define << to output user-defined types without modifying class ostream (§38.4.2).

18.3. A Complex Number Type
The implementation of complex numbers presented in §18.1 is too restrictive to please anyone. For example, we would expect this to work:

void f()
{
      complex a {1,2};
      complex b {3};
      complex c {a+2.3};
      complex d {2+b};
      b = c*2*c;
}
In addition, we would expect to be provided with a few additional operators, such as == for comparison and << for output, and a suitable set of mathematical functions, such as sin() and sqrt().

Class complex is a concrete type, so its design follows the guidelines from §16.3. In addition, users of complex arithmetic rely so heavily on operators that the definition of complex brings into play most of the basic rules for operator overloading.

The complex type developed in this section uses double for its scalars and is roughly equivalent to the standard-library complex<double> (§40.4).

18.3.1. Member and Nonmember Operators
I prefer to minimize the number of functions that directly manipulate the representation of an object. This can be achieved by defining only operators that inherently modify the value of their first argument, such as +=, in the class itself. Operators that simply produce a new value based on the values of their arguments, such as +, are then defined outside the class and use the essential operators in their implementation:

Click here to view code image

class complex {
      double re, im;
public:
      complex& operator+=(complex a);  // needs access to representation
      //...
};

complex operator+(complex a, complex b)
{
      return a += b;  // access representation through +=
}
The arguments to this operator+() are passed by value, so a+b does not modify its operands.

Given these declarations, we can write:

Click here to view code image

void f(complex x, complex y, complex z)
{
     complex r1 {x+y+z};  // r1 = operator+(operator+(x,y),z)

     complex r2 {x};      // r2 = x
     r2 += y;             // r2.operator+=(y)
     r2 += z;             // r2.operator+=(z)
}
Except for possible efficiency differences, the computations of r1 and r2 are equivalent.

Composite assignment operators such as += and *= tend to be simpler to define than their “simple” counterparts + and *. This surprises most people at first, but it follows from the fact that three objects are involved in a + operation (the two operands and the result), whereas only two objects are involved in a += operation. In the latter case, run-time efficiency is improved by eliminating the need for temporary variables. For example:

Click here to view code image

inline complex& complex::operator+=(complex a)
{
     re += a.re;
     im += a.im;
     return *this;
}
This does not require a temporary variable to hold the result of the addition and is simple for a compiler to inline perfectly.

A good optimizer will generate close to optimal code for uses of the plain + operator also. However, we don’t always have a good optimizer, and not all types are as simple as complex, so §19.4 discusses ways of defining operators with direct access to the representation of classes.

18.3.2. Mixed-Mode Arithmetic
To cope with 2+z, where z is a complex, we need to define operator + to accept operands of different types. In Fortran terminology, we need mixed-mode arithmetic. We can achieve that simply by adding appropriate versions of the operators:

Click here to view code image

class complex {
     double re, im;
public:
     complex& operator+=(complex a)
     {
         re += a.re;
         im += a.im;
         return *this;
     }

     complex& operator+=(double a)
     {
         re += a;
         return *this;
     }

      //...
};
The three variants of operator+() can be defined outside complex:

Click here to view code image

complex operator+(complex a, complex b)
{
    return a += b;  // calls complex::operator+=(complex)
}

complex operator+(complex a, double b)
{
    return {a.real()+b,a.imag()};
}

complex operator+(double a, complex b)
{
    return {a+b.real(),b.imag()};
}
The access functions real() and imag() are defined in §18.3.6.

Given these declarations of +, we can write:

Click here to view code image

void f(complex x, complex y)
{
     auto r1 = x+y;  // calls operator+(complex,complex)
     auto r2 = x+2;  // calls operator+(complex,double)
     auto r3 = 2+x;  // calls operator+(double,complex)
     auto r4 = 2+3;  // built-in integer addition
}
I added the integer addition for completeness.

18.3.3. Conversions
To cope with assignments and initialization of complex variables with scalars, we need a conversion of a scalar (integer or floating-point number) to a complex. For example:

Click here to view code image

complex b {3};  // should mean b.re=3, b.im=0

void comp(complex x)
{
     x = 4;     // should mean x.re=4, x.im=0
     //...
}
We can achieve that by providing a constructor that takes a single argument. A constructor taking a single argument specifies a conversion from its argument type to the constructor’s type. For example:

Click here to view code image

class complex {
     double re, im;
public:
     complex(double r) :re{r}, im{0} { }  // build a complex from a double
      //...
};
The constructor specifies the traditional embedding of the real line in the complex plane.

A constructor is a prescription for creating a value of a given type. The constructor is used when a value of a type is expected and when such a value can be created by a constructor from the value supplied as an initializer or assigned value. Thus, a constructor requiring a single argument need not be called explicitly. For example:

complex b {3};
means

complex b {3,0};
A user-defined conversion is implicitly applied only if it is unique (§12.3). If you don’t want a constructor to be used implicitly, declare it explicit (§16.2.6).

Naturally, we still need the constructor that takes two doubles, and a default constructor initializing a complex to {0,0} is also useful:

Click here to view code image

class complex {
     double re, im;
public:
     complex() : re{0}, im{0} { }
     complex(double r) : re{r}, im{0} { }
     complex(double r, double i) : re{r}, im{i} { }
      //...
};
Using default arguments, we can abbreviate:

Click here to view code image

class complex {
      double re, im;
public:
      complex(double r =0, double i =0) : re{r}, im{i} { }
       //...
};
By default, copying complex values is defined as copying the real and imaginary parts (§16.2.2). For example:

Click here to view code image

void f()
{
     complex z;
     complex x {1,2};
     complex y {x};  // y also has the value {1,2}
     z = x;          // z also has the value {1,2}
}
18.3.3.1. Conversions of Operands
We defined three versions of each of the four standard arithmetic operators:

Click here to view code image

complex operator+(complex,complex);
complex operator+(complex,double);
complex operator+(double,complex);
 //...
This can get tedious, and what is tedious easily becomes error-prone. What if we had three alternatives for the type of each argument for each function? We would need three versions of each single-argument function, nine versions of each two-argument function, 27 versions of each three-argument function, etc. Often these variants are very similar. In fact, almost all variants involve a simple conversion of arguments to a common type followed by a standard algorithm.

The alternative to providing different versions of a function for each combination of arguments is to rely on conversions. For example, our complex class provides a constructor that converts a double to a complex. Consequently, we could simply declare only one version of the equality operator for complex:

Click here to view code image

bool operator==(complex,complex);

void f(complex x, complex y)
{
     x==y;     // means operator==(x,y)
     x==3;     // means operator==(x,complex(3))
     3==y;     // means operator==(complex(3),y)
}
There can be reasons for preferring to define separate functions. For example, in some cases the conversion can impose overhead, and in other cases, a simpler algorithm can be used for specific argument types. Where such issues are not significant, relying on conversions and providing only the most general variant of a function – plus possibly a few critical variants – contain the combinatorial explosion of variants that can arise from mixed-mode arithmetic.

Where several variants of a function or an operator exist, the compiler must pick “the right” variant based on the argument types and the available (standard and user-defined) conversions. Unless a best match exists, an expression is ambiguous and is an error (see §12.3).

An object constructed by explicit or implicit use of a constructor in an expression is automatic and will be destroyed at the first opportunity (see §10.3.4).

No implicit user-defined conversions are applied to the left-hand side of a . (or a –>). This is the case even when the . is implicit. For example:

Click here to view code image

void g(complex z)
{
     3+z;                // OK: complex(3)+z
     3.operator+=(z);          // error: 3 is not a class object
     3+=z;               // error: 3 is not a class object
}
Thus, you can approximate the notion that an operator requires an lvalue as its left-hand operand by making that operator a member. However, that is only an approximation because it is possible to access a temporary with a modifying operation, such as operator+=():

Click here to view code image

complex x {4,5}
complex z {sqrt(x)+={1,2}};        // like tmp=sqrt(x), tmp+={1,2}
If we don’t want implicit conversions, we can use explicit to suppress them (§16.2.6, §18.4.2).

18.3.4. Literals
We have literals of built-in types. For example, 1.2 and 12e3 are literals of type double. For complex, we can come pretty close to that by declaring constructors constexpr (§10.4). For example:

Click here to view code image

class complex {
public:
     constexpr complex(double r =0, double i =0) : re{r}, im{i} { }
      //...
}
Given that, a complex can be constructed from its constituent parts at compile time just like a literal from a built-in type. For example:

Click here to view code image

complex z1 {1.2,12e3};
constexpr complex z2 {1.2,12e3};    // guaranteed compile-time initialization
When constructors are simple and inline, and especially when they are constexpr, it is quite reasonable to think of constructor invocations with literal arguments as literals.

It is possible to go further and introduce a user-defined literal (§19.2.6) in support of our complex type. In particular, we could define i to be a suffix meaning “imaginary.” For example:

Click here to view code image

constexpr complex<double> operator "" i(long double d)   // imaginary literal
{
     return {0,d};  // complex is a literal type
}
This would allow us to write:

complex z1 {1.2+12e3i};

complex f(double d)
{
    auto x {2.3i};
    return x+sqrt(d+12e3i)+12e3i;
}
This user-defined literal gives us one advantage over what we get from constexpr constructors: we can use user-defined literals in the middle of expressions where the {} notation can only be used when qualified by a type name. The example above is roughly equivalent to:

Click here to view code image

complex z1 {1.2,12e3};

complex f(double d)
{
    complex x {0,2.3};
    return x+sqrt(complex{d,12e3})+complex{0,12e3};
}
I suspect that the choice of style of literal depends on your sense of aesthetics and the conventions of your field of work. The standard-library complex uses constexpr constructors rather than a user-defined literal.

18.3.5. Accessor Functions
So far, we have provided class complex with constructors and arithmetic operators only. That is not quite sufficient for real use. In particular, we often need to be able to examine and change the value of the real and imaginary parts:

Click here to view code image

class complex {
     double re, im;
public:
     constexpr double real() const { return re; }
     constexpr double imag() const { return im; }

     void real(double r) { re = r; }
     void imag(double i) { im = i; }
      //...
};
I don’t consider it a good idea to provide individual access to all members of a class; in general, it is not. For many types, individual access (sometimes referred to as get-and-set functions) is an invitation to disaster. If we are not careful, individual access could compromise an invariant, and it typically complicates changes to the representation. For example, consider the opportunities for misuse from providing getters and setters for every member of the Date from §16.3 or (even more so) for the String from §19.3. However, for complex, real() and imag() are semantically significant: some algorithms are most cleanly written if they can set the real and imaginary parts independently.

For example, given real() and imag(), we can simplify simple, common, and useful operations, such as ==, as nonmember functions (without compromising performance):

Click here to view code image

inline bool operator==(complex a, complex b)
{
      return a.real()==b.real() && a.imag()==b.imag();
}
18.3.6. Helper Functions
If we put all the bits and pieces together, the complex class becomes:

Click here to view code image

class complex {
     double re, im;
public:
     constexpr complex(double r =0, double i =0) : re(r), im(i) { }

     constexpr double real() const { return re; }
     constexpr double imag() const { return im; }

     void real(double r) { re = r; }
     void imag(double i) { im = i; }

     complex& operator+=(complex);
     complex& operator+=(double);

     // -=, *=, and /=
};
In addition, we must provide a number of helper functions:

Click here to view code image

complex operator+(complex,complex);
complex operator+(complex,double);
complex operator+(double,complex);

 // binary -, *, and /

complex operator–(complex);  // unary minus 
complex operator+(complex);  // unary plus

bool operator==(complex,complex);
bool operator!=(complex,complex);

istream& operator>>(istream&,complex&);  // input
ostream& operator<<(ostream&,complex);   // output
Note that the members real() and imag() are essential for defining the comparisons. The definitions of most of the following helper functions similarly rely on real() and imag().

We might provide functions to allow users to think in terms of polar coordinates:

Click here to view code image

complex polar(double rho, double theta);
complex conj(complex);


double abs(complex);
double arg(complex);
double norm(complex);

double real(complex);         // for notational convenience
double imag(complex);         // for notational convenience
Finally, we must provide an appropriate set of standard mathematical functions:

complex acos(complex);
complex asin(complex);
complex atan(complex);
 //...
From a user’s point of view, the complex type presented here is almost identical to the complex<double> found in <complex> in the standard library (§5.6.2, §40.4).

18.4. Type Conversion
Type conversion can be accomplished by

• A constructor taking a single argument (§16.2.5)

• A conversion operator (§18.4.1)

In either case the conversion can be

• explicit; that is, the conversion is only performed in a direct initialization (§16.2.6), i.e., as an initializer not using a =.

• Implicit; that is, it will be applied wherever it can be used unambiguously (§18.4.3), e.g., as a function argument.

18.4.1. Conversion Operators
Using a constructor taking a single argument to specify type conversion is convenient but has implications that can be undesirable. Also, a constructor cannot specify

[1] an implicit conversion from a user-defined type to a built-in type (because the built-in types are not classes), or

[2] a conversion from a new class to a previously defined class (without modifying the declaration for the old class).

These problems can be handled by defining a conversion operator for the source type. A member function X::operator T(), where T is a type name, defines a conversion from X to T. For example, we could define a 6-bit non-negative integer, Tiny, that can mix freely with integers in arithmetic operations. Tiny throws Bad_range if its operations overflow or underflow:

Click here to view code image

class Tiny {
     char v;
     void assign(int i) { if (i&~077) throw Bad_range(); v=i; }
public:
     class Bad_range { };

     Tiny(int i) { assign(i); }
     Tiny& operator=(int i) { assign(i); return *this; }

     operator int() const { return v; }     // conversion to int function
};
The range is checked whenever a Tiny is initialized by an int and whenever an int is assigned to one. No range check is needed when we copy a Tiny, so the default copy constructor and assignment are just right.

To enable the usual integer operations on Tiny variables, we define the implicit conversion from Tiny to int, Tiny::operator int(). Note that the type being converted to is part of the name of the operator and cannot be repeated as the return value of the conversion function:

Click here to view code image

Tiny::operator int() const { return v; }       // right
int Tiny::operator int() const { return v; }   // error
In this respect also, a conversion operator resembles a constructor.

Whenever a Tiny appears where an int is needed, the appropriate int is used. For example:

Click here to view code image

int main()
{
     Tiny c1 = 2;
     Tiny c2 = 62;
     Tiny c3 = c2–c1;   // c3 = 60
     Tiny c4 = c3;      // no range check (not necessary)
     int i = c1+c2;     // i = 64

     c1 = c1+c2;        // range error: c1 can't be 64
     i = c3–64;         // i = -4
     c2 = c3–64;        // range error: c2 can't be -4
     c3 = c4;           // no range check (not necessary)
}
Conversion functions appear to be particularly useful for handling data structures when reading (implemented by a conversion operator) is trivial, while assignment and initialization are distinctly less trivial.

The istream and ostream types rely on a conversion function to enable statements such as:

while (cin>>x)
      cout<<x;
The input operation cin>>x returns an istream&. That value is implicitly converted to a value indicating the state of cin. This value can then be tested by the while (see §38.4.4). However, it is typically not a good idea to define an implicit conversion from one type to another in such a way that information is lost in the conversion.

In general, it is wise to be sparing in the introduction of conversion operators. When used in excess, they lead to ambiguities. Such ambiguities are caught by the compiler, but they can be a nuisance to resolve. Probably the best idea is initially to do conversions by named functions, such as X::make_int(). If such a function becomes popular enough to make explicit use inelegant, it can be replaced by a conversion operator X::operator int().

If both user-defined conversions and user-defined operators are defined, it is possible to get ambiguities between the user-defined operators and the built-in operators. For example:

Click here to view code image

int operator+(Tiny,Tiny);

void f(Tiny t, int i)
{
     t+i;  // error, ambiguous: "operator+(t,Tiny(i))" or "int(t)+i"?
}
It is therefore often best to rely on user-defined conversions or user-defined operators for a given type, but not both.

18.4.2. explicit Conversion Operators
Conversion operators tend to be defined so that they can be used everywhere. However, it is possible to declare a conversion operator explicit and have it apply only for direct initialization (§16.2.6), where an equivalent explicit constructor would have been used. For example, the standard-library unique_ptr (§5.2.1, §34.3.1) has an explicit conversion to bool:

Click here to view code image

template <typename T, typename D = default_delete<T>>
class unique_ptr {
public:
     //...
    explicit operator bool() const noexcept;    // does *this hold a pointer (that is not nullptr)?
     //...
};
This conversion operator is declared explicit to avoid its use in surprising contexts. Consider:

Click here to view code image

void use(unique_ptr<Record> p, unique_ptr<int> q)
{
     if (!p)        // OK: we want this use
           throw Invalid_unique_ptr{};

     bool b = p;    // error; suspicious use
     int x = p+q;   // error; we definitely don't want this
}
Had unique_ptr’s conversion to bool not been explicit, the last two definitions would have compiled. The value of b would have become true and the value of x would have become 1 or 2 (depending on whether q was valid or not).

18.4.3. Ambiguities
An assignment of a value of type V to an object of class X is legal if there is an assignment operator X::operator=(Z) so that V is Z or there is a unique conversion of V to Z. Initialization is treated equivalently.

In some cases, a value of the desired type can be constructed by repeated use of constructors or conversion operators. This must be handled by explicit conversions; only one level of user-defined implicit conversion is legal. In some cases, a value of the desired type can be constructed in more than one way; such cases are illegal. For example:

Click here to view code image

class X { /* ... */ X(int); X(const char*); };
class Y { /* ... */ Y(int); };
class Z { /* ... */ Z(X); };

X f(X);
Y f(Y);

Z g(Z);

void k1()
{
     f(1);                    // error: ambiguous f(X(1)) or f(Y(1))?
     f(X{1});                 // OK
     f(Y{1});                 // OK

     g("Mack");               // error: two user-defined conversions needed; g(Z{X{"Mack"}}) not tried
     g(X{"Doc"});             // OK: g(Z{X{"Doc"}})
     g(Z{"Suzy"});            // OK: g(Z{X{"Suzy"}})
}
User-defined conversions are considered only if a call cannot be resolved without them (i.e., using only built-in conversions). For example:

Click here to view code image

class XX { /* ... */ XX(int); };

void h(double);
void h(XX);

void k2()
{
     h(1);  // h(double{1}) or h(XX{1})? h(double{1})!
}
The call h(1) means h(double(1)) because that alternative uses only a standard conversion rather than a user-defined conversion (§12.3).

The rules for conversion are neither the simplest to implement, nor the simplest to document, nor the most general that could be devised. They are, however, considerably safer, and the resulting resolutions are typically less surprising than alternatives. It is far easier to manually resolve an ambiguity than to find an error caused by an unsuspected conversion.

The insistence on strict bottom-up analysis implies that the return type is not used in overload resolution. For example:

Click here to view code image

class Quad {
public:
     Quad(double);
      //...
};

Quad operator+(Quad,Quad);

void f(double a1, double a2)
{
     Quad r1 = a1+a2;        // double-precision floating-point add
     Quad r2 = Quad{a1}+a2;  // force quad arithmetic
}
The reason for this design choice is partly that strict bottom-up analysis is more comprehensible and partly that it is not considered the compiler’s job to decide which precision the programmer might want for the addition.

Once the types of both sides of an initialization or assignment have been determined, both types are used to resolve the initialization or assignment. For example:

class Real {
public:
     operator double();
     operator int();
      //...
};

void g(Real a)
{
     double d = a;    // d = a.double();
     int i = a;       // i = a.int();

     d = a;           // d = a.double();
     i = a;           // i = a.int();
}
In these cases, the type analysis is still bottom-up, with only a single operator and its argument types considered at any one time.

18.5. Advice
[1] Define operators primarily to mimic conventional usage; §18.1.

[2] Redefine or prohibit copying if the default is not appropriate for a type; §18.2.2.

[3] For large operands, use const reference argument types; §18.2.4.

[4] For large results, use a move constructor; §18.2.4.

[5] Prefer member functions over nonmembers for operations that need access to the representation; §18.3.1.

[6] Prefer nonmember functions over members for operations that do not need access to the representation; §18.3.2.

[7] Use namespaces to associate helper functions with “their” class; §18.2.5.

[8] Use nonmember functions for symmetric operators; §18.3.2.

[9] Use member functions to express operators that require an lvalue as their left-hand operand; §18.3.3.1.

[10] Use user-defined literals to mimic conventional notation; §18.3.4.

[11] Provide “set() and get() functions” for a data member only if the fundamental semantics of a class require them; §18.3.5.

[12] Be cautious about introducing implicit conversions; §18.4.

[13] Avoid value-destroying (“narrowing”) conversions; §18.4.1.

[14] Do not define the same conversion as both a constructor and a conversion operator; §18.4.3.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


18. Operator Overloading
19. Special Operators
20. Derived Classes
47h 26m remaining
19. Special Operators
We are all special cases.

– Albert Camus

• Introduction

• Special Operators

Subscripting; Function Call; Dereferencing; Increment and Decrement; Allocation and Deallocation; User-Defined Literals

• A String Class

Essential Operations; Access to Characters; Representation; Member Functions; Helper Functions; Using Our String

• Friends

Finding Friends; Friends and Members

• Advice

19.1. Introduction
Overloading is not just for arithmetic and logical operations. In fact, operators are crucial in the design of containers (e.g., vector and map; §4.4), “smart pointers” (e.g., unique_ptr and shared_ptr; §5.2.1), iterators (§4.5), and other classes concerned with resource management.

19.2. Special Operators
The operators

[] () –> ++ –– new delete
are special only in that the mapping from their use in the code to a programmer’s definition differs slightly from that used for conventional unary and binary operators, such as +, <, and ~ (§18.2.3). The [] (subscript) and () (call) operators are among the most useful user-defined operators.

19.2.1. Subscripting
An operator[] function can be used to give subscripts a meaning for class objects. The second argument (the subscript) of an operator[] function may be of any type. This makes it possible to define vectors, associative arrays, etc.

As an example, we can define a simple associative array type like this:

Click here to view code image

struct Assoc {
     vector<pair<string,int>> vec;  // vector of {name,value} pairs

     const int& operator[] (const string&) const;
     int& operator[](const string&);
};
An Assoc keeps a vector of std::pairs. The implementation uses the same trivial and inefficient search method as in §7.7:

Click here to view code image

int& Assoc::operator[](const string& s)
      // search for s; return a reference to its value if found;
      // otherwise, make a new pair {s,0} and return a reference to its value
{
     for (auto x : vec)
          if (s == x.first) return x.second;

     vec.push_back({s,0});              // initial value: 0

     return vec.back().second;          // return last element (§31.2.2)
}
We can use Assoc like this:

Click here to view code image

int main()     // count the occurrences of each word on input
{
     Assoc values;
     string buf;
     while (cin>>buf) ++values[buf];
     for (auto x : values.vec)
           cout << '{' << x.first << ',' << x.second << "}\n";
}
The standard-library map and unordered_map are further developments of the idea of an associative array (§4.4.3, §31.4.3) with less naive implementations.

An operator[]() must be a non-static member function.

19.2.2. Function Call
Function call, that is, the notation expression(expression-list), can be interpreted as a binary operation with the expression as the left-hand operand and the expression-list as the right-hand operand. The call operator, (), can be overloaded in the same way as other operators can. For example:

struct Action {
     int operator()(int);
     pair<int,int> operator()(int,int);
     double operator()(double);
      //... 
};

void f(Action act)
{
     int x = act(2);
     auto y = act(3,4);
     double z = act(2.3);
      //...
};
An argument list for an operator()() is evaluated and checked according to the usual argument-passing rules. Overloading the function call operator seems to be useful primarily for defining types that have only a single operation and for types for which one operation is predominant. The call operator is also known as the application operator.

The most obvious and also the most important, use of the () operator is to provide the usual function call syntax for objects that in some way behave like functions. An object that acts like a function is often called a function-like object or simply a function object (§3.4.3). Such function objects allow us to write code that takes nontrivial operations as parameters. In many cases, it is essential that function objects can hold data needed to perform their operation. For example, we can define a class with an operator()() that adds a stored value to its argument:

Click here to view code image

class Add {
     complex val;
public:
     Add(complex c) :val{c} { }                          // save a value
     Add(double r, double i) :val{{r,i}} { }

     void operator()(complex& c) const { c += val; }     // add a value to argument
};
An object of class Add is initialized with a complex number, and when invoked using (), it adds that number to its argument. For example:

Click here to view code image

void h(vector<complex>& vec, list<complex>& lst, complex z)
{
     for_each(vec.begin(),vec.end(),Add{2,3});
     for_each(lst.begin(),lst.end(),Add{z});
}
This will add complex{2,3} to every element of the vector and z to every element of the list. Note that Add{z} constructs an object that is used repeatedly by for_each(): Add{z}’s operator()() is called for each element of the sequence.

This all works because for_each is a template that applies () to its third argument without caring exactly what that third argument really is:

template<typename Iter, typename Fct>
Fct for_each(Iter b, Iter e, Fct f)
{
     while (b != e) f(*b++);
     return f;
}
At first glance, this technique may look esoteric, but it is simple, efficient, and extremely useful (§3.4.3, §33.4).

Note that a lambda expression (§3.4.3, §11.4) is basically a syntax for defining a function object. For example, we could have written:

Click here to view code image

void h2(vector<complex>& vec, list<complex>& lst, complex z)
{
     for_each(vec.begin(),vec.end(),[](complex& a){ a+={2,3}; });
     for_each(lst.begin(),lst.end(),[](complex& a){ a+=z; });
}
In this case, each of the lambda expressions generates the equivalent of the function object Add.

Other popular uses of operator()() are as a substring operator and as a subscripting operator for multidimensional arrays (§29.2.2, §40.5.2).

An operator()() must be a non-static member function.

Function call operators are often templates (§29.2.2, §33.5.3).

19.2.3. Dereferencing
The dereferencing operator, –> (also known as the arrow operator), can be defined as a unary postfix operator. For example:

class Ptr {
      //...
     X* operator–>();
};
Objects of class Ptr can be used to access members of class X in a very similar manner to the way pointers are used. For example:

Click here to view code image

void f(Ptr p)
{
     p–>m = 7;      //(p.operator->())->m = 7
}
The transformation of the object p into the pointer p.operator–>() does not depend on the member m pointed to. That is the sense in which operator–>() is a unary postfix operator. However, there is no new syntax introduced, so a member name is still required after the –>. For example:

Click here to view code image

void g(Ptr p)
{
     X* q1 = p–>;               // syntax error
     X* q2 = p.operator–>();    // OK
}
Overloading –> is primarily useful for creating “smart pointers,” that is, objects that act like pointers and in addition perform some action whenever an object is accessed through them. The standard-library “smart pointers” unique_ptr and shared_ptr (§5.2.1) provide operator –>.

As an example, we could define a class Disk_ptr for accessing objects stored on disk. Disk_ptr’s constructor takes a name that can be used to find the object on disk, Disk_ptr::operator–>() brings the object into main memory when accessed through its Disk_ptr, and Disk_ptr’s destructor eventually writes the updated object back out to disk:

Click here to view code image

template<typename T>
class Disk_ptr {
     string identifier;
     T* in_core_address;
      //...
public:
     Disk_ptr(const string& s) : identifier{s}, in_core_address{nullptr} { }
     ~Disk_ptr() { write_to_disk(in_core_address,identifier); }

     T* operator–>()
     {
          if (in_core_address == nullptr)
                in_core_address = read_from_disk(identifier);
          return in_core_address;
     }
};
Disk_ptr might be used like this:

Click here to view code image

struct Rec {
     string name;
      //...
};

void update(const string& s)
{
     Disk_ptr<Rec> p {s};         // get Disk_ptr for s

     p–>name = "Roscoe";          // update s; if necessary, first retrieve from disk
      //...
}                                 // p's destructor writes back to disk
Naturally, a realistic program would contain error-handling code and use a less naive way of interacting with the disk.

For ordinary pointers, use of –> is synonymous with some uses of unary * and []. Given a class Y for which –>, *, and [] have their default meaning and a Y* called p, then:

p–>m == (*p).m          // is true
(*p).m == p[0].m        // is true
p–>m == p[0].m          // is true
As usual, no such guarantee is provided for user-defined operators. The equivalence can be provided where desired:

Click here to view code image

template<typename T>
class Ptr {
     T* p;
public:
     T* operator–>() { return p; }           // dereference to access member
     T& operator*() { return *p; }           // dereference to access whole object
     T& operator[](int i) { return p[i]; }   // dereference to access element
      //...
};
If you provide more than one of these operators, it might be wise to provide the equivalence, just as it is wise to ensure that ++x and x+=1 have the same effect as x=x+1 for a simple variable x of some class X if ++, +=, =, and + are provided.

The overloading of –> is important to a class of interesting programs and is not just a minor curiosity. The reason is that indirection is a key concept and that overloading –> provides a clean, direct, and efficient way of representing indirection in a program. Iterators (Chapter 33) provide an important example of this.

Operator –> must be a non-static member function. If used, its return type must be a pointer or an object of a class to which you can apply –>. The body of a template class member function is only checked if the function is used (§26.2.1), so we can define operator–>() without worrying about types, such as Ptr<int>, for which –> does not make sense.

Despite the similarity between –> and . (dot), there is no way of overloading operator . (dot).

19.2.4. Increment and Decrement
Once people invent “smart pointers,” they often decide to provide the increment operator ++ and the decrement operator –– to mirror these operators’ use for built-in types. This is especially obvious and necessary where the aim is to replace an ordinary pointer type with a “smart pointer” type that has the same semantics, except that it adds a bit of run-time error checking. For example, consider a troublesome traditional program:

Click here to view code image

void f1(X a)             // traditional use
{
     X v[200];
     X* p = &v[0];
     p––;
     *p = a;    // oops: p out of range, uncaught
     ++p;
     *p = a;    // OK
}
Here, we might want to replace the X* with an object of a class Ptr<X> that can be dereferenced only if it actually points to an X. We would also like to ensure that p can be incremented and decremented only if it points to an object within an array and the increment and decrement operations yield an object within that array. That is, we would like something like this:

Click here to view code image

void f2(Ptr<X> a)           // checked
{
     X v[200];
     Ptr<X> p(&v[0],v);
     p––;
     *p = a;   // run-time error: p out of range
     ++p;
     *p = a;   // OK
}
The increment and decrement operators are unique among C++ operators in that they can be used as both prefix and postfix operators. Consequently, we must define prefix and postfix increment and decrement for Ptr<T>. For example:

Click here to view code image

template<typename T>
class Ptr {
     T* ptr;
     T* array;
     int sz;
public:
     template<int N>
         Ptr(T* p, T(&a)[N]);        // bind to array a, sz==N, initial value p
     Ptr(T* p, T* a, int s);         // bind to array a of size s, initial value p
     Ptr(T* p);                      // bind to single object, sz==0, initial value p

     Ptr& operator++();              // prefix
     Ptr& operator––();              // prefix
     Ptr operator++(int);            // postfix
     Ptr operator––(int);            // postfix

     T& operator*();                 // prefix
};
The int argument is used to indicate that the function is to be invoked for postfix application of ++. This int is never used; the argument is simply a dummy used to distinguish between prefix and postfix application. The way to remember which version of an operator++ is prefix is to note that the version without the dummy argument is prefix, exactly like all the other unary arithmetic and logical operators. The dummy argument is used only for the “odd” postfix ++ and ––.

Consider omitting postfix ++ and –– in a design. They are not only odd syntactically, they tend to be marginally harder to implement than the prefix versions, less efficient, and less frequently used. For example:

Click here to view code image

template<typename T>
Ptr& Ptr<T>::operator++()                // return the current object after incrementing
{
      //... check that ptr+1 can be pointed to ...
     ++ptr;
     return *this; 
}

template<typename T>
Ptr Ptr<T>::operator++(int)             // increment and return a Ptr with the old value
{
      //... check that ptr+1 can be pointed to ...
     Ptr<T> old {ptr,array,sz};
     ++ptr;
     return old;
}
The pre-increment operator can return a reference to its object. The post-increment operator must make a new object to return.

Using Ptr, f2() is equivalent to:

Click here to view code image

void f3(T a)        // checked
{
     T v[200];
     Ptr<T> p(&v[0],v);
     p.operator––(0);         // suffix: p--
     p.operator*() = a;       // run-time error: p out of range
     p.operator++();          // prefix: ++p
     p.operator*() = a;       // OK
}
Completing class Ptr is left as an exercise. A pointer template that behaves correctly with respect to inheritance is presented in §27.2.2.

19.2.5. Allocation and Deallocation
Operator new (§11.2.3) acquires its memory by calling an operator new(). Similarly, operator delete frees its memory by calling an operator delete(). A user can redefine the global operator new() and operator delete() or define operator new() and operator delete() for a particular class.

Using the standard-library type alias size_t (§6.2.8) for sizes, the declarations of the global versions look like this:

Click here to view code image

void* operator new(size_t);                // use for individual object
void* operator new[](size_t);              // use for array
void operator delete(void*, size_t);       // use for individual object
void operator delete[](void*, size_t);     // use for array

 // for more versions, see §11.2.4
That is, when new needs memory on the free store for an object of type X, it calls operator new(sizeof(X)). Similarly, when new needs memory on the free store for an array of N objects of type X, it calls operator new[](N*sizeof(X)). A new expression may ask for more memory than is indicated by N*sizeof(X), but it will always do so in terms of a number of characters (i.e., a number of bytes). Replacing the global operator new() and operator delete() is not for the fainthearted and not recommended. After all, someone else might rely on some aspect of the default behavior or might even have supplied other versions of these functions.

A more selective, and often better, approach is to supply these operations for a specific class. This class might be the base for many derived classes. For example, we might like to have a class Employee provide a specialized allocator and deallocator for itself and all of its derived classes:

Click here to view code image

class Employee {
public:
      //...

     void* operator new(size_t);
     void operator delete(void*, size_t);

     void* operator new[](size_t);
     void operator delete[](void*, size_t);
};
Member operator new()s and operator delete()s are implicitly static members. Consequently, they don’t have a this pointer and do not modify an object. They provide storage that a constructor can initialize and a destructor can clean up.

Click here to view code image

void* Employee::operator new(size_t s)
{
      // allocate s bytes of memory and return a pointer to it
}

void Employee::operator delete(void* p, size_t s)
{
     if (p) {     // delete only if p!=0; see §11.2, §11.2.3
             // assume p points to s bytes of memory allocated by Employee::operator new()
             // and free that memory for reuse
     }
}
The use of the hitherto mysterious size_t argument now becomes obvious. It is the size of the object being deleted. Deleting a “plain” Employee gives an argument value of sizeof(Employee); deleting a Manager derived from Employee that does not have its own operator delete() gives an argument value of sizeof(Manager). This allows a class-specific allocator to avoid storing size information with each allocation. Naturally, a class-specific allocator can store such information (as a general-purpose allocator must) and ignore the size_t argument to operator delete(). However, doing so makes it harder to improve significantly on the speed and memory consumption of a general-purpose allocator.

How does a compiler know how to supply the right size to operator delete()? The type specified in the delete operation matches the type of the object being deleted. If we delete an object through a pointer to a base class, that base class must have a virtual destructor (§17.2.5) for the correct size to be given:

Click here to view code image

Employee* p = new Manager;  // potential trouble (the exact type is lost)
 //...
delete p;                   // hope Employee has a virtual destructor
In principle, deallocation is then done by the destructor (which knows the size of its class).

19.2.6. User-defined Literals
C++ provides literals for a variety of built-in types (§6.2.6):

123         // int
1.2         // double
1.2F        // float
'a'         // char
1ULL        // unsigned long long
0xD0        // hexadecimal unsigned
"as"        // C-style string (const char[3])
In addition, we can define literals for user-defined types and new forms of literals for built-in types. For example:

Click here to view code image

"Hi!"s                 // string, not "zero-terminated array of char"
1.2i                   // imaginary
101010111000101b       // binary
123s                   // seconds
123.56km               // not miles! (units)
1234567890123456789012345678901234567890x    // extended-precision
Such user-defined literals are supported through the notion of literal operators that map literals with a given suffix into a desired type. The name of a literal operator is operator"" followed by the suffix. For example:

Click here to view code image

constexpr complex<double> operator"" i(long double d)      // imaginary literal
{
    return {0,d};  // complex is a literal type
}

std::string operator"" s(const char* p, size_t n)      // std::string literal
{
     return string{p,n};   // requires free-store allocation
}
These two operators define suffixes i and s, respectively. I use constexpr to enable compile-time evaluation. Given those, we can write:

Click here to view code image

template<typename T> void f(const T&);

void g()
{
     f("Hello");      // pass pointer to char*
     f("Hello"s);     // pass (five-character) string object
     f("Hello\n"s);   // pass (six-character) string object

     auto z = 2+1i;   // complex{2,1}
}
The basic (implementation) idea is that after parsing what could be a literal, the compiler always checks for a suffix. The user-defined literal mechanism simply allows the user to specify a new suffix and define what is to be done with the literal before it. It is not possible to redefine the meaning of a built-in literal suffix or to augment the syntax of literals.

There are four kinds of literals that can be suffixed to make a user-defined literal (§iso.2.14.8):

• An integer literal (§6.2.4.1): accepted by a literal operator taking an unsigned long long or a const char* argument or by a template literal operator, for example, 123m or 12345678901234567890X

• A floating-point literal (§6.2.5.1): accepted by a literal operator taking a long double or a const char* argument or by a template literal operator, for example, 12345678901234567890.976543210x or 3.99s

• A string literal (§7.3.2): accepted by a literal operator taking a (const char*, size_t) pair of arguments, for example, "string"s and R"(Foo\bar)"_path

• A character literal (§6.2.3.2): accepted by a literal operator taking a character argument of type char, wchar_t, char16_t, or char32_t, for example, 'f'_runic or u'BEEF'_w.

For example, we could define a literal operator to collect digits for integer values that cannot be represented in any of the built-in integer types:

Click here to view code image

Bignum operator"" x(const char* p)
{
    return Bignum(p);
}

void f(Bignum);

f(123456789012345678901234567890123456789012345x);
Here, the C-style string "123456789012345678901234567890123456789012345" is passed to operator"" x(). Note that I did not put those digits in double quotes. I requested a C-style string for my operator, and the compiler delivered it from the digits provided.

To get a C-style string from the program source text into a literal operator, we request both the string and its number of characters. For example:

Click here to view code image

string operator"" s(const char* p, size_t n);

string s12 = "one two"s;       // calls operator ""2("one two",7)
string s22 = "two\ntwo"s;      // calls operator ""s("two\ntwo",7)
string sxx = R"(two\ntwo)"s;   // calls operator ""s("two\\ntwo",8)
In the raw string (§7.3.2.1), "\n" represents the two characters '\' and 'n'.

The rationale for requiring the number of characters is that if we want to have “a different kind of string,” we almost always want to know the number of characters anyway.

A literal operator that takes just a const char* argument (and no size) can be applied to integer and floating-point literals. For example:

Click here to view code image

string operator"" SS(const char* p);      // warning: this will not work as expected

string s12 = "one two"SS;                 // error: no applicable literal operator
string s13 = 13SS;                        // OK, but why would anyone do that?
A literal operator converting numerical values to strings could be quite confusing.

A template literal operator is a literal operator that takes its argument as a template parameter pack, rather than as a function argument. For example:

Click here to view code image

template<char...>
constexpr int operator"" _b3();              // base 3, i.e., ternary
Given that, we get:

Click here to view code image

201_b3    // means operator"" b3<'2','0','1'>(); so 2*9+0*3+1 == 19
241_b3    // means operator"" b3<'2','4','1'>(); so error: 4 isn't a ternary digit
To define operator"" _b3(), we need some helpers:

Click here to view code image

constexpr int ipow(int x, int n)         // x to the power of n
{
    return n>0?x*ipow(x,n-1):1;
}

template<char...> struct helper;         // unused general template (primary template; §25.3.1.1)

template<char c>
struct helper<c> {                       // handle one digit
     static_assert('0'<=c&&c<'3',"not a ternary digit");
     static constexpr int value() { return c-'0'; }
};

template<char c, char... tail>
struct helper<c, tail...> {              // handle several digits
     static_assert('0'<=c&&c<'3',"not a ternary digit");
     static constexpr int value() { return (c-'0')*ipow(3,sizeof...(tail)) + helper<tail...>::value(); }
};
Given that, we can define our base 3 literal operator:

Click here to view code image

template<char... chars>
constexpr int operator"" _b3()
{
    return helper<chars...>::value();
}
The variadic templates and the metaprogramming techniques needed to use them (§28.6) can be disconcerting, but this is the only way of assigning nonstandard meanings to digits at compile time.

Many suffixes will be short (e.g., s for std::string, i for imaginary, m for meter (§28.7.3), and x for extended), so different uses could easily clash. Use namespaces to prevent clashes:

Click here to view code image

namespace Numerics {
     //...

    class Bignum { /* ... */ };

    namespace literals {
        Bignum operator"" x(char const*);
    }
     //...
}

using namespace Numerics::literals;
The standard library reserves all suffixes not starting with an initial underscore, so define your suffixes starting with an underscore or risk your code breaking in the future:

Click here to view code image

123km        // reserved by the standard library
123_km       // available for your use
19.3. A String Class
The relatively simple string class presented in this section illustrates several techniques that are useful for the design and implementation of classes using conventionally defined operators. This String is a simplified version of the standard-library string (§4.2, Chapter 36). String provides value semantics, checked and unchecked access to characters, stream I/O, support for range-for loops, equality operations, and concatenation operators. I also added a String literal, which std::string does not (yet) have.

To allow simple interoperability with C-style strings (including string literals (§7.3.2)), I represent strings as zero-terminated arrays of characters. For realism, I implement the short string optimization. That is, a String with only a few characters stores those characters in the class object itself, rather than on the free store. This optimizes string usage for small strings. Experience shows that for a huge number of applications most strings are short. This optimization is particularly important in multi-threaded systems where sharing through pointers (or references) is infeasible and free-store allocation and deallocation relatively expensive.

To allow Strings to efficiently “grow” by adding characters at the end, I implement a scheme for keeping extra space for such growth similar to the one used for vector (§13.6.1). This makes String a suitable target for various forms of input.

Writing a better string class and/or one that provides more facilities is a good exercise. That done, we can throw away our exercises and use std::string (Chapter 36).

19.3.1. Essential Operations
Class String provides the usual set of constructors, a destructor, and assignment operations (§17.1):

Click here to view code image

class String {
public:
     String();                                            // default constructor: x{""}

     String(const char* p);                      // constructor from C-style string: x{"Euler"}

     String(const String&);                               // copy constructor
     String& operator=(const String&);                    // copy assignment

     String(String&& x);                                  // move constructor
     String& operator=(String&& x);                       // move assignment

     ~String() { if (short_max<sz) delete[] ptr; }        // destructor
      //...
};
This String has value semantics. That is, after an assignment s1=s2, the two strings s1 and s2 are fully distinct, and subsequent changes to one have no effect on the other. The alternative would be to give String pointer semantics. That would be to let changes to s2 after s1=s2 also affect the value of s1. Where it makes sense, I prefer value semantics; examples are complex, vector, Matrix, and string. However, for value semantics to be affordable, we need to pass Strings by reference when we don’t need copies and to implement move semantics (§3.3.2, §17.5.2) to optimize returns.

The slightly nontrivial representation of String is presented in §19.3.3. Note that it requires user-defined versions of the copy and move operations.

19.3.2. Access to Characters
The design of access operators for a string is a difficult topic because ideally access is by conventional notation (that is, using []), maximally efficient, and range checked. Unfortunately, you cannot have all of these properties simultaneously. Here, I follow the standard library by providing efficient unchecked operations with the conventional [] subscript notation plus range-checked at() operations:

Click here to view code image

class String {
public:
      //...

     char& operator[](int n) { return ptr[n]; }                  // unchecked element access
     char operator[](int n) const { return ptr[n]; }

     char& at(int n) { check(n); return ptr[n]; }                // range-checked element access
     char at(int n) const { check(n); return ptr[n]; }

     String& operator+=(char c);                                 // add c at end

     const char* c_str() { return ptr; }                         // C-style string access
     const char* c_str() const { return ptr; }

     int size() const { return sz; }                             // number of elements
     int capacity() const                                        // elements plus available space
           { return (sz<=short_max) ? short_max : sz+space; }
      //...
};
The idea is to use [] for ordinary use. For example:

Click here to view code image

int hash(const String& s)
{
     if (s.size()==0) return 0;
     int h {s[0]};              // unchecked access to s
     for (int i {1}; i!=s.size(); ++i)
           h ^= s[i]>>1;        // unchecked access to s
     return h;
}
Here, using the checked at() would be redundant because we access s only from 0 to s.size()–1.

We can use at() where we see a possibility of mistakes. For example:

Click here to view code image

void print_in_order(const String& s,const vector<int>& index)
{
     for (auto x : index)
           cout << s.at(x) << '\n'; // checked access to s
}
Unfortunately, assuming that people will use at() consistently where mistakes can be made is overly optimistic, so some implementations of std::string (from which the []/at() convention is borrowed) also check []. I personally prefer a checked [] at least during development. However, for serious string manipulation tasks, a range check on each character access could impose quite noticeable overhead.

I provide const and non-const versions of the access functions to allow them to be used for const as well as other objects.

19.3.3. Representation
The representation for String was chosen to meet three goals:

• To make it easy to convert a C-style string (e.g., a string literal) to a String and to allow easy access to the characters of a String as a C-style string

• To minimize the use of the free store

• To make adding characters to the end of a String efficient

The result is clearly messier than a simple {pointer,size} representation, but much more realistic:

Click here to view code image

class String {
/*
     A simple string that implements the short string optimization

     size()==sz is the number of elements
     if size()<= short_max, the characters are held in the String object itself;
     otherwise the free store is used.

     ptr points to the start of the character sequence
     the character sequence is kept zero-terminated: ptr[size()]==0;
     this allows us to use C library string functions and to easily return a C-style string: c_str()

     To allow efficient addition of characters at end, String grows by doubling its allocation;
     capacity() is the amount of space available for characters
     (excluding the terminating 0): sz+space
*/
public:
      //...
private:
     static const int short_max = 15;
     int sz;                        // number of characters
     char* ptr;
     union {
         int space;                 // unused allocated space
         char ch[short_max+1];      // leave space for terminating 0
     };

     void check(int n) const        // range check
     {
         if (n<0 || sz<=n)
               throw std::out_of_range("String::at()");
     }

      // ancillary member functions:
     void copy_from(const String& x);
     void move_from(String& x);
};
This supports what is known as the short string optimization by using two string representations:

• If sz<=short_max, the characters are stored in the String object itself, in the array named ch.

• If !(sz<=short_max), the characters are stored on the free store and we may allocate extra space for expansion. The member named space is the number of such characters.

In both cases, the number of elements is kept in sz and we look at sz, to determine which implementation scheme is used for a given string.

In both cases, ptr points to the elements. This is essential for performance: the access functions do not need to test which representation is used; they simply use ptr. Only the constructors, assignments, moves, and the destructor (§19.3.4) must care about the two alternatives.

We use the array ch only if sz<=short_max and the integer space only if !(sz<=short_max). Consequently, it would be a waste to allocate space for both ch and space in a String object. To avoid such waste, I use a union (§8.3). In particular, I used a form of union called an anonymous union (§8.3.2), which is specifically designed to allow a class to manage alternative representations of objects. All members of an anonymous union are allocated in the same memory, starting at the same address. Only one member may be used at any one time, but otherwise they are accessed and used exactly as if they were separate members of the scope surrounding the anonymous union. It is the programmer’s job to make sure that they are never misused. For example, all member functions of String that use space must make sure that it really was space that was set and not ch. That is done by looking at sz<=short_max. In other words, String is (among other things) a discriminated union with sz<=short_max as the discriminant.

19.3.3.1. Ancillary Functions
In addition to functions intended for general use, I found that my code became cleaner when I provided three ancillary functions as “building blocks” to help me with the somewhat tricky representation and to minimize code replication. Two of those need to access the representation of String, so I made them members. However, I made them private members because they don’t represent operations that are generally useful and safe to use. For many interesting classes, the implementation is not just the representation plus the public functions. Ancillary functions can lead to less duplication of code, better design, and improved maintainability.

The first such function moves characters into newly allocated memory:

Click here to view code image

char* expand(const char* ptr, int n)       // expand into free store
{
     char* p = new char[n];
     strcpy(p,ptr);            //§43.4
     return p;
}
This function does not access the String representation, so I did not make it a member.

The second implementation function is used by copy operations to give a String a copy of the members of another:

Click here to view code image

void String::copy_from(const String& x)
      // make *this a copy of x
{
     if (x.sz<=short_max) {                 // copy *this
           memcpy(this,&x,sizeof(x));       //§43.5 
           ptr = ch;
     }
     else {                                 // copy the elements
           ptr = expand(x.ptr,x.sz+1);
           sz = x.sz;
           space = 0;
     }
}
Any necessary cleanup of the target String is the task of callers of copy_from(); copy_from() unconditionally overwrites its target. I use the standard-library memcpy() (§43.5) to copy the bytes of the source into the target. That’s a low-level and sometimes pretty nasty function. It should be used only where there are no objects with constructors or destructors in the copied memory because memcpy() knows nothing about types. Both String copy operations use copy_from().

The corresponding function for move operations is:

Click here to view code image

void String::move_from(String& x)
{
     if (x.sz<=short_max) {               // copy *this
           memcpy(this,&x,sizeof(x));     //§43.5
           ptr = ch;
     }

     else {                               // grab the elements
           ptr = x.ptr;
           sz = x.sz;
           space = x.space;
           x.ptr = x.ch;                  // x = ""
           x.sz = 0;
           x.ch[0]=0;
     }
}
It too unconditionally makes its target a copy of its argument. However, it does not leave its argument owning any free store. I could also have used memcpy() in the long string case, but since a long string representation uses only part of String’s representation, I decided to copy the used members individually.

19.3.4. Member Functions
The default constructor defines a String to be empty:

Click here to view code image

String::String()                // default constructor: x{""}
           : sz{0}, ptr{ch}     // ptr points to elements, ch is an initial location (§19.3.3)
     {
           ch[0] = 0;           // terminating 0
     }
Given copy_from() and move_from(), the constructors, moves, and assignments are fairly simple to implement. The constructor that takes a C-style string argument must determine the number of characters and store them appropriately:

Click here to view code image

String::String(const char* p)
     :sz{strlen(p)},
     ptr{(sz<=short_max) ? ch : new char[sz+1]},
     space{0}
{
     strcpy(ptr,p);   // copy characters into ptr from p
}
If the argument is a short string, ptr is set to point to ch; otherwise, space is allocated on the free store. In either case, the characters are copied from the argument string into the memory managed by String.

The copy constructor simply copies the representation of its arguments:

Click here to view code image

String::String(const String& x)     // copy constructor
{
     copy_from(x);   // copy representation from x
}
I didn’t bother trying to optimize the case where the size of the source equals the size of the target (as was done for vector; §13.6.3). I don’t know if that would be worthwhile.

Similarly, the move constructor moves the representation from its source (and possibly sets its argument to be the empty string):

Click here to view code image

String::String(String&& x)    // move constructor
{
     move_from(x);
}
Like the copy constructor, the copy assignment uses copy_from() to clone its argument’s representation. In addition, it has to delete any free store owned by the target and make sure it does not get into trouble with self-assignment (e.g., s=s):

Click here to view code image

String& String::operator=(const String& x)
{
     if (this==&x) return *this;          // deal with self-assignment
     char* p = (short_max<sz) ? ptr : 0;
     copy_from(x);
     delete[] p;
     return *this;
}
The String move assignment deletes its target’s free store (if there is any) and then moves:

Click here to view code image

String& String::operator=(String&& x)
{
     if (this==&x) return *this;         // deal with self-assignment (x = move(x) is insanity)
     if (short_max<sz) delete[] ptr;     // delete target
     move_from(x);                       // does not throw
     return *this;
}
It is logically possible to move a source into itself (e.g., s=std::move(s)), so again we have to protect against self-assignment (however unlikely).

The logically most complicated String operation is +=, which adds a character to the end of the string, increasing its size by one:

Click here to view code image

String& String::operator+=(char c)
{
     if (sz==short_max) {        // expand to long string
           int n = sz+sz+2;      // double the allocation (+2 because of the terminating 0)
           ptr = expand(ptr,n);
           space = n–sz–2;
     }
     else if (short_max<sz) {
          if (space==0) {            // expand in free store
                int n = sz+sz+2;     // double the allocation (+2 because of the terminating 0)
                char* p = expand(ptr,n);
                delete[] ptr;
                ptr = p;
                space = n–sz–2;
           }
           else
                ––space;
     }
     ptr[sz] = c;        // add c at end
     ptr[++sz] = 0;      // increase size and set terminator

     return *this;
}
There is a lot going on here: operator+=() has to keep track of which representation (short or long) is used and whether there is extra space available to expand into. If more space is needed, expand() is called to allocate that space and move the old characters into the new space. If there was an old allocation that needs deleting, it is returned, so that += can delete it. Once enough space is available, it is trivial to put the new character c into it and to add the terminating 0.

Note the calculation of available memory for space. Of all the String implementation that took the longest to get right: its a messy little calculation prone to off-by-one errors. That repeated constant 2 feels awfully like a “magic constant.”

All String members take care not to modify a new representation before they are certain that a new one can be put in place. In particular, they don’t delete until after any possible new operations have been done. In fact, the String members provide the strong exception guarantee (§13.2).

If you don’t like the kind of fiddly code presented as part of the implementation of String, simply use std::string. To a large extent, the standard-library facilities exist to save us from programming at this low level most of the time. Stronger: writing a string class, a vector class, or a map is an excellent exercise. However, once the exercise is done, one outcome should be an appreciation of what the standard offers and a desire not to maintain your own version.

19.3.5. Helper Functions
To complete class String, I provide a set of useful functions, stream I/O, support for range-for loops, comparison, and concatenation. These all mirror the design choices used for std::string. In particular, << just prints the characters without added formatting, and >> skips initial whitespace before reading until it finds terminating whitespace (or the end of the stream):

Click here to view code image

ostream& operator<<(ostream& os, const String& s)
{
     return os << s.c_str();  //§36.3.3
}

istream& operator>>(istream& is, String& s)
{
     s = "";     // clear the target string
     is>>ws;     // skip whitespace (§38.4.5.1)
     char ch = ' ';
     while(is.get(ch) && !isspace(ch))
          s += ch;
     return is;
}
I provide == and != for comparison:

Click here to view code image

bool operator==(const String& a, const String& b)
{
     if (a.size()!=b.size())
           return false;
     for (int i = 0; i!=a.size(); ++i)
           if (a[i]!=b[i])
                 return false;
     return true;
}

bool operator!=(const String& a, const String& b)
{
     return !(a==b);
}
Adding <, etc., would be trivial.

To support the range-for loop, we need begin() and end() (§9.5.1). Again, we can provide those as freestanding (nonmember) functions without direct access to the String implementation:

Click here to view code image

char* begin(String& x)           // C-string-style access
{
     return x.c_str();
}

char* end(String& x)
{
     return x.c_str()+x.size();
}

const char* begin(const String& x)
{
     return x.c_str();
}

const char* end(const String& x)
{
     return x.c_str()+x.size();
}
Given the member function += that adds a character at the end, concatenation operators are easily provided as nonmember functions:

Click here to view code image

String& operator+=(String& a, const String& b)       // concatenation
{
     for (auto x : b)
           a+=x;
     return a;
}
String operator+(const String& a, const String& b)   // concatenation
{
     String res {a};
     res += b;
     return res;
}
I feel that I may have slightly “cheated” here. Should I have provided a member += that added a C-style string to the end? The standard-library string does, but without it, concatenation with a C-style string still works. For example:

Click here to view code image

String s = "Njal ";
s += "Gunnar";       // concatenate: add to the end of s
This use of += is interpreted as operator+=(s,String("Gunnar")). My guess is that I could provide a more efficient String::operator+=(const char*), but I have no idea if the added performance would be worthwhile in real-world code. In such cases, I try to be conservative and deliver the minimal design. Being able to do something is not by itself a good reason for doing it.

Similarly, I do not try to optimize += by taking the size of a source string into account.

Adding _s as a string literal suffix meaning String is trivial:

Click here to view code image

String operator"" _s(const char* p, size_t)
{
     return String{p};
}
We can now write:

Click here to view code image

void f(const char*);         // C-style string
void f(const String&);       // our string

void g()
{
     f("Madden's");                // f(const char*)
     f("Christopher's"_s);         // f(const String&);
}
19.3.6. Using Our String
The main program simply exercises the String operators a bit:

Click here to view code image

int main()
{
     String s ("abcdefghij");
     cout << s << '\n';
     s += 'k';
     s += 'l';
     s += 'm';
     s += 'n';
     cout << s << '\n';
     String s2 = "Hell";
     s2 += " and high water";
     cout << s2 << '\n';

     String s3 = "qwerty";
     s3 = s3;
     String s4 ="the quick brown fox jumped over the lazy dog";
     s4 = s4;
     cout << s3 << " " << s4 << "\n";
     cout << s + ". " + s3 + String(". ") + "Horsefeathers\n";

     String buf;
     while (cin>>buf && buf!="quit")
           cout << buf << " " << buf.size() << " " << buf.capacity() << '\n';
}
This String lacks many features that you might consider important or even essential. However, for what it does it closely resembles std::string (Chapter 36) and illustrates techniques used for the implementation of the standard-library string.

19.4. Friends
An ordinary member function declaration specifies three logically distinct things:

[1] The function can access the private part of the class declaration.

[2] The function is in the scope of the class.

[3] The function must be invoked on an object (has a this pointer).

By declaring a member function static (§16.2.12), we can give it the first two properties only. By declaring a nonmember function a friend, we can give it the first property only. That is, a function declared friend is granted access to the implementation of a class just like a member function but is otherwise independent of that class.

For example, we could define an operator that multiplies a Matrix by a Vector. Naturally, Vector and Matrix hide their respective representations and provide a complete set of operations for manipulating objects of their type. However, our multiplication routine cannot be a member of both. Also, we don’t really want to provide low-level access functions to allow every user to both read and write the complete representation of both Matrix and Vector. To avoid this, we declare the operator* a friend of both:

Click here to view code image

constexpr int rc_max {4};  // row and column size

class Matrix;

class Vector {
     float v[rc_max];
      //...
     friend Vector operator*(const Matrix&, const Vector&);
};

class Matrix {
     Vector v[rc_max];
      //...
     friend Vector operator*(const Matrix&, const Vector&);
};
Now operator*() can reach into the implementation of both Vector and Matrix. That would allow sophisticated implementation techniques, but a simple implementation would be:

Click here to view code image

Vector operator*(const Matrix& m, const Vector& v)
{
     Vector r;
     for (int i = 0; i!=rc_max; ++i) {            // r[i] = m[i] * v;
           r.v[i] = 0;
           for (int j = 0; j!=rc_max; ++j)
                  r.v[i] += m.v[i].v[j] *v.v[j];
     }
     return r;
}
A friend declaration can be placed in either the private or the public part of a class declaration; it does not matter where. Like a member function, a friend function is explicitly declared in the declaration of the class of which it is a friend. It is therefore as much a part of that interface as is a member function.

A member function of one class can be the friend of another. For example:

class List_iterator {
      //...
     int* next();
};

class List {
     friend int* List_iterator::next();
      //...
};
There is a shorthand for making all functions of one class friends of another. For example:

class List {
     friend class List_iterator;
      //...
};
This friend declaration makes all of List_iterator’s member functions friends of List.

Declaring a class a friend grants access to every function of that class. That implies that we cannot know the set of functions that can access the granting class’s representation just by looking at the class itself. In this, a friend class declaration differs from the declaration of a member function and a friend function. Clearly, friend classes should be used with caution and only to express closely connected concepts.

It is possible to make a template argument a friend:

template<typename T>
class X {
     friend T;
     friend class T;    // redundant "class"
      //...
};
Often, we can choose between making a class a member or a nonmember friend (§18.3.1).

19.4.1. Finding Friends
A friend must be previously declared in an enclosing scope or defined in the non-class scope immediately enclosing the class that is declaring it to be a friend. Scopes outside the innermost enclosing namespace scope are not considered for a name first declared as a friend (§iso.7.3.1.2). Consider a technical example:

Click here to view code image

class C1 { };      // will become friend of N::C
void f1();         // will become friend of N::C

namespace N {
     class C2 { };           // will become friend of C
     void f2() { }           // will become friend of C

     class C {
          int x;
     public:
           friend class C1;         // OK (previously defined)
           friend void f1();
     friend class C2;         // OK (previously defined)
     friend void f2();
           friend class C3;         // OK (defined in enclosing namespace)
           friend void f3();
           friend class C4;         // First declared in N and assumed to be in N
           friend void f4();
     };

     class C3 {};                  // friend of C
     void f3() { C x; x.x = 1; }    // OK: friend of C
}  // namespace N

class C4 { };                       // not friend of N::C
void f4() { N::C x; x.x = 1; }      // error: x is private and f4() is not a friend of N::C
A friend function can be found through its arguments (§14.2.4) even if it was not declared in the immediately enclosing scope. For example:

Click here to view code image

void f(Matrix& m)
{
     invert(m);      // Matrix's friend invert()
}
Thus, a friend function should be explicitly declared in an enclosing scope or take an argument of its class or a class derived from that. If not, the friend cannot be called. For example:

Click here to view code image

 // no f() in this scope

class X {
     friend void f();           // useless
     friend void h(const X&);   // can be found through its argument
};

void g(const X& x)
{
     f();      // no f() in scope
     h(x);     // X's friend h()
}
19.4.2. Friends and Members
When should we use a friend function, and when is a member function the better choice for specifying an operation? First, we try to minimize the number of functions that access the representation of a class and try to make the set of access functions as appropriate as possible. Therefore, the first question is not “Should it be a member, a static member, or a friend?” but rather “Does it really need access?” Typically, the set of functions that need access is smaller than we are willing to believe at first. Some operations must be members – for example, constructors, destructors, and virtual functions (§3.2.3, §17.2.5) – but typically there is a choice. Because member names are local to the class, a function that requires direct access to the representation should be a member unless there is a specific reason for it to be a nonmember.

Consider a class X supplying alternative ways of presenting an operation:

Click here to view code image

class X {
      //...
     X(int);

     int m1();                // member
     int m2() const;

     friend int f1(X&);       // friend, not member
     friend int f2(const X&);
     friend int f3(X);
};
Member functions can be invoked for objects of their class only; no user-defined conversions are applied to the leftmost operand of a . or –> (but see §19.2.3). For example:

Click here to view code image

void g()
{
     99.m1();     // error: X(99).m1() not tried
     99.m2();     // error: X(99).m2() not tried
}
The global function f1() has a similar property because implicit conversions are not used for non-const reference arguments (§7.7). However, conversions may be applied to the arguments of f2() and f3():

Click here to view code image

void h()
{
     f1(99);     // error: f1(X(99)) not tried: non-const X& argument
     f2(99);     // OK: f2(X(99)); const X& argument
     f3(99);     // OK: f3(X(99)); X argument
}
An operation modifying the state of a class object should therefore be a member or a function taking a non-const reference argument (or a non-const pointer argument).

Operators that modify an operand (e.g., =, *=, and ++) are most naturally defined as members for user-defined types. Conversely, if implicit type conversion is desired for all operands of an operation, the function implementing it must be a nonmember function taking a const reference argument or a non-reference argument. This is often the case for the functions implementing operators that do not require lvalue operands when applied to fundamental types (e.g., +, –, and ||). However, such operators often need access to the representations of their operand class. Consequently, binary operators are the most common source of friend functions.

Unless type conversions are defined, there appears to be no compelling reason to choose a member over a friend taking a reference argument, or vice versa. In some cases, the programmer may have a preference for one call syntax over another. For example, most people seem to prefer the notation m2=inv(m) for producing an inverted Matrix from m to the alternative m2=m.inv(). On the other hand, if inv() inverts m itself, rather than producing a new Matrix that is the inverse of m, it should be a member.

All other things considered equal, implement operations that need direct access to a representation as member functions:

• It is not possible to know if someone someday will define a conversion operator.

• The member function call syntax makes it clear to the user that the object may be modified; a reference argument is far less obvious.

• Expressions in the body of a member can be noticeably shorter than the equivalent expressions in a global function; a nonmember function must use an explicit argument, whereas the member can use this implicitly.

• Member names are local to a class, so they tend to be shorter than the names of nonmember functions.

• If we have defined a member f() and we later feel the need for a nonmember f(x), we can simply define it to mean x.f().

Conversely, operations that do not need direct access to a representation are often best represented as nonmember functions, possibly in a namespace that makes their relationship with the class explicit (§18.3.6).

19.5. Advice
[1] Use operator[]() for subscripting and for selection based on a single value; §19.2.1.

[2] Use operator()() for call semantics, for subscripting, and for selection based on multiple values; §19.2.2.

[3] Use operator–>() to dereference “smart pointers”; §19.2.3.

[4] Prefer prefix ++ over suffix ++; §19.2.4.

[5] Define the global operator new() and operator delete() only if you really have to; §19.2.5.

[6] Define member operator new() and member operator delete() to control allocation and deallocation of objects of a specific class or hierarchy of classes; §19.2.5.

[7] Use user-defined literals to mimic conventional notation; §19.2.6.

[8] Place literal operators in separate namespaces to allow selective use; §19.2.6.

[9] For nonspecialized uses, prefer the standard string (Chapter 36) to the result of your own exercises; §19.3.

[10] Use a friend function if you need a nonmember function to have access to the representation of a class (e.g., to improve notation or to access the representation of two classes); §19.4.

[11] Prefer member functions to friend functions for granting access to the implementation of a class; §19.4.2.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


19. Special Operators
20. Derived Classes
21. Class Hierarchies
47h 26m remaining
20. Derived Classes
Do not multiply objects without necessity.

– William Occam

• Introduction

• Derived Classes

Member Functions; Constructors and Destructors

• Class Hierarchies

Type Fields; Virtual Functions; Explicit Qualification; Override Control; using Base Members; Return Type Relaxation

• Abstract Classes

• Access Control

protected Members; Access to Base Classes; using-Declarations and Access Control

• Pointers to Members

Pointers to Function Members; Pointers to Data Members; Base and Derived Members

• Advice

20.1. Introduction
From Simula, C++ borrowed the ideas of classes and class hierarchies. In addition, it borrowed the design idea that classes should be used to model concepts in the programmer’s and the application’s world. C++ provides language constructs that directly support these design notions. Conversely, using the language features in support of design ideas distinguishes effective use of C++. Using language constructs as just notational props for traditional types of programming is to miss key strengths of C++.

A concept (idea, notion, etc.) does not exist in isolation. It coexists with related concepts and derives much of its power from relationships with other concepts. For example, try to explain what a car is. Soon you’ll have introduced the notions of wheels, engines, drivers, pedestrians, trucks, ambulances, roads, oil, speeding tickets, motels, etc. Since we use classes to represent concepts, the issue becomes how to represent relationships among concepts. However, we can’t express arbitrary relationships directly in a programming language. Even if we could, we wouldn’t want to. To be useful, our classes should be more narrowly defined than our everyday concepts – and more precise.

The notion of a derived class and its associated language mechanisms are provided to express hierarchical relationships, that is, to express commonality between classes. For example, the concepts of a circle and a triangle are related in that they are both shapes; that is, they have the concept of a shape in common. Thus, we explicitly define class Circle and class Triangle to have class Shape in common. In that case, the common class, here Shape, is referred to as the base class or superclass and classes derived from that, here Circle and Triangle, are referred to as derived classes or subclasses. Representing a circle and a triangle in a program without involving the notion of a shape would be to miss something essential. This chapter is an exploration of the implications of this simple idea, which is the basis for what is commonly called object-oriented programming. The language features support building new classes from existing ones:

• Implementation inheritance: to save implementation effort by sharing facilities provided by a base class

• Interface inheritance: to allow different derived classes to be used interchangeably through the interface provided by a common base class Interface inheritance is often referred to as run-time polymorphism (or dynamic polymorphism).

In contrast, the uniform use of classes not related by inheritance provided by templates (§3.4, Chapter 23) is often referred to as compile-time polymorphism (or static polymorphism).

The discussion of class hierarchies is organized into three chapters:

• Derived Classes (Chapter 20): This chapter introduces the basic language features supporting object-oriented programming. Base and derived classes, virtual functions, and access control are covered.

• Class Hierarchies (Chapter 21): This chapter focuses on the use of base and derived classes to effectively organize code around the notion of class hierarchies. Most of this chapter is devoted to discussion of programming techniques, but technical aspects of multiple inheritance (classes with more than one base class) are also covered.

• Run-time Type Identification (Chapter 22): This chapter describes the techniques for explicitly navigating class hierarchies. In particular, the type conversion operations dynamic_cast and static_cast are presented, as is the operation for determining the type of an object given one of its base classes (typeid).

A brief introduction to the basic idea of hierarchical organization of types can be found in Chapter 3: base and derived classes (§3.2.2) and virtual functions (§3.2.3). These chapters examine these fundamental features and their associated programming and design techniques in greater detail.

20.2. Derived Classes
Consider building a program dealing with people employed by a firm. Such a program might have a data structure like this:

struct Employee {
     string first_name, family_name;
     char middle_initial;
     Date hiring_date;
     short department;
      //...
};
Next, we might try to define a manager:

Click here to view code image

struct Manager {
     Employee emp;                // manager's employee record
     list<Employee*> group;  // people managed
     short level;
      //...
};
A manager is also an employee; the Employee data is stored in the emp member of a Manager object. This may be obvious to a human reader – especially a careful reader – but there is nothing that tells the compiler and other tools that Manager is also an Employee. A Manager* is not an Employee*, so one cannot simply use one where the other is required. In particular, one cannot put a Manager onto a list of Employees without writing special code. We could either use explicit type conversion on a Manager* or put the address of the emp member onto a list of employees. However, both solutions are inelegant and can be quite obscure. The correct approach is to explicitly state that a Manager is an Employee, with a few pieces of information added:

Click here to view code image

struct Manager : public Employee {
     list<Employee*> group;
     short level;
      //...
};
The Manager is derived from Employee, and conversely, Employee is a base class for Manager. The class Manager has the members of class Employee (first_name, department, etc.) in addition to its own members (group, level, etc.).

Derivation is often represented graphically by a pointer from the derived class to its base class indicating that the derived class refers to its base (rather than the other way around):


A derived class is often said to inherit properties from its base, so the relationship is also called inheritance. A base class is sometimes called a superclass and a derived class a subclass. This terminology, however, is confusing to people who observe that the data in a derived class object is a superset of the data of an object of its base class. A derived class is typically larger (and never smaller) than its base class in the sense that it holds more data and provides more functions.

A popular and efficient implementation of the notion of derived classes has an object of the derived class represented as an object of the base class, with the information belonging specifically to the derived class added at the end. For example:



No memory overhead is implied by deriving a class. The space required is just the space required by the members.

Deriving Manager from Employee in this way makes Manager a subtype of Employee, so that a Manager can be used wherever an Employee is acceptable. For example, we can now create a list of Employees, some of whom are Managers:

Click here to view code image

void f(Manager m1, Employee e1)
{
     list<Employee*> elist {&m1,&e1};
      //...
}
A Manager is (also) an Employee, so a Manager* can be used as an Employee*. Similarly, a Manager& can be used as an Employee&. However, an Employee is not necessarily a Manager, so an Employee* cannot be used as a Manager*. In general, if a class Derived has a public base class (§20.5) Base, then a Derived* can be assigned to a variable of type Base* without the use of explicit type conversion. The opposite conversion, from Base* to Derived*, must be explicit. For example:

Click here to view code image

void g(Manager mm, Employee ee)
{
     Employee* pe = &mm;                // OK: every Manager is an Employee
     Manager* pm = &ee;                 // error: not every Employee is a Manager

     pm–>level = 2;                     // disaster: ee doesn't have a level

     pm = static_cast<Manager*>(pe);    // brute force: works because pe points
                                        // to the Manager mm

     pm–>level = 2;                     // fine: pm points to the Manager mm that has a level
}
In other words, an object of a derived class can be treated as an object of its base class when manipulated through pointers and references. The opposite is not true. The use of static_cast and dynamic_cast is discussed in §22.2.

Using a class as a base is equivalent to defining an (unnamed) object of that class. Consequently, a class must be defined in order to be used as a base (§8.2.2):

Click here to view code image

class Employee;      // declaration only, no definition

class Manager : public Employee {  // error: Employee not defined
      //...
};
20.2.1. Member Functions
Simple data structures, such as Employee and Manager, are really not that interesting and often not particularly useful. We need to provide a proper type with a suitable set of operations, and we need to do so without being tied to the details of a particular representation. For example:

Click here to view code image

class Employee {
public:
     void print() const;
     string full_name() const { return first_name + ' ' + middle_initial + ' ' + family_name; }
      //...
private:
     string first_name, family_name;
     char middle_initial;
      //...
};

class Manager : public Employee {
public:
     void print() const;
      //...
};
A member of a derived class can use the public – and protected (see §20.5) – members of a base class as if they were declared in the derived class itself. For example:

Click here to view code image

void Manager::print() const
{
     cout << "name is " << full_name() << '\n';
      //...
}
However, a derived class cannot access private members of a base class:

Click here to view code image

void Manager::print() const
{
     cout << " name is " << family_name << '\n';    // error!
      //...
}
This second version of Manager::print() will not compile because family_name is not accessible to Manager::print().

This comes as a surprise to some, but consider the alternative: that a member function of a derived class could access the private members of its base class. The concept of a private member would be rendered meaningless by allowing a programmer to gain access to the private part of a class simply by deriving a new class from it. Furthermore, one could no longer find all uses of a private name by looking at the functions declared as members and friends of that class. One would have to examine every source file of the complete program for derived classes, then examine every function of those classes, then find every class derived from those classes, etc. This is, at best, tedious and often impractical. Where it is acceptable, protected – rather than private – members can be used (§20.5).

Typically, the cleanest solution is for the derived class to use only the public members of its base class. For example:

Click here to view code image

void Manager::print() const
{
     Employee::print();      // print Employee information
     cout << level;          // print Manager-specific information
      //...
}
Note that :: must be used because print() has been redefined in Manager. Such reuse of names is typical. The unwary might write this:

Click here to view code image

void Manager::print() const
{
     print();    // oops!
      // print Manager-specific information
}
The result is a sequence of recursive calls ending with some form of program crash.

20.2.2. Constructors and Destructors
As usual, constructors and destructors are as essential:

• Objects are constructed from the bottom up (base before member and member before derived) and destroyed top-down (derived before member and member before base); §17.2.3.

• Each class can initialize its members and bases (but not directly members or bases of its bases); §17.4.1.

• Typically, destructors in a hierarchy need to be virtual; §17.2.5.

• Copy constructors of classes in a hierarchy should be used with care (if at all) to avoid slicing; §17.5.1.4.

• The resolution of a virtual function call, a dynamic_cast, or a typeid() in a constructor or destructor reflects the stage of construction and destruction (rather than the type of the yet-to-be-completed object); §22.4.

In computer science “up” and “down” can get very confused. In source text, definitions of base classes must occur before the definitions of their derived classes. This implies that for small examples, the bases appear above the derived classes on a screen. Furthermore, we tend to draw trees with the root on top. However, when I talk about constructing objects from the bottom up, I mean starting with the most fundamental (e.g., base classes) and building what depends on that (e.g., derived classes) later. We build from the roots (base classes) toward the leaves (derived classes).

20.3. Class Hierarchies
A derived class can itself be a base class. For example:

Click here to view code image

class Employee { /* ... */ };
class Manager : public Employee { /* ... */ };
class Director : public Manager { /* ... */ };
Such a set of related classes is traditionally called a class hierarchy. Such a hierarchy is most often a tree, but it can also be a more general graph structure. For example:

Click here to view code image

class Temporary { /* ... */ };
class Assistant : public Employee { /* ... */ };
class Temp : public Temporary, public Assistant { /* ... */ };
class Consultant : public Temporary, public Manager { /* ... */ };
or graphically:



Thus, as is explained in detail in §21.3, C++ can express a directed acyclic graph of classes.

20.3.1. Type Fields
To use derived classes as more than a convenient shorthand in declarations, we must solve the following problem: Given a pointer of type Base*, to which derived type does the object pointed to really belong? There are four fundamental solutions:

[1] Ensure that only objects of a single type are pointed to (§3.4, Chapter 23).

[2] Place a type field in the base class for the functions to inspect.

[3] Use dynamic_cast (§22.2, §22.6).

[4] Use virtual functions (§3.2.3, §20.3.2).

Unless you have used final (§20.3.4.2), solution 1 relies on more knowledge about the types involved than is available to the compiler. In general, it is not a good idea to try to be smarter than the type system, but (especially in combination with the use of templates) solution [1] can be used to implement homogeneous (e.g., the standard-library vector and map) with unsurpassed performance. Solutions [2], [3], and [4] can be used to build heterogeneous lists, that is, lists of (pointers to) objects of several different types. Solution [3] is a language-supported variant of solution [2]. Solution [4] is a special type-safe variation of solution [2]. Combinations of solutions [1] and [4] are particularly interesting and powerful; in almost all situations, they yield cleaner code than do solutions [2] and [3].

Let us first examine the simple type-field solution to see why it is typically best avoided. The manager/employee example could be redefined like this:

Click here to view code image

struct Employee {
     enum Empl_type { man, empl };
     Empl_type type;

     Employee() : type{empl} { }

     string first_name, family_name;
     char middle_initial;

     Date hiring_date;
     short department;
      //...
};

struct Manager : public Employee {
     Manager() { type = man; }

     list<Employee*> group;  // people managed
     short level;
      //...
};
Given this, we can now write a function that prints information about each Employee:

Click here to view code image

void print_employee(const Employee* e)
{
     switch (e–>type) {
     case Employee::empl:
          cout << e–>family_name << '\t' << e–>department << '\n';
           //...
          break;
     case Employee::man:
     {    cout << e–>family_name << '\t' << e–>department << '\n';
           //...
          const Manager* p = static_cast<const Manager*>(e);
          cout << " level " << p–>level << '\n';
           //...
          break;
     }
     }
}
and use it to print a list of Employees, like this:

Click here to view code image

void print_list(const list<Employee*>& elist)
{
     for (auto x : elist)
           print_employee(x);
}
This works fine, especially in a small program maintained by a single person. However, it has a fundamental weakness in that it depends on the programmer manipulating types in a way that cannot be checked by the compiler. This problem is usually made worse because functions such as print_employee() are often organized to take advantage of the commonality of the classes involved:

Click here to view code image

void print_employee(const Employee* e)
{
     cout << e–>family_name << '\t' << e–>department << '\n';
      //...
     if (e–>type == Employee::man) {
           const Manager* p = static_cast<const Manager*>(e);
           cout << " level " << p–>level << '\n';
            //...
     }
}
Finding all such tests on the type field buried in a large function that handles many derived classes can be difficult. Even when they have been found, understanding what is going on can be difficult. Furthermore, any addition of a new kind of Employee involves a change to all the key functions in a system – the ones containing the tests on the type field. The programmer must consider every function that could conceivably need a test on the type field after a change. This implies the need to access critical source code and the resulting necessary overhead of testing the affected code. The use of an explicit type conversion is a strong hint that improvement is possible.

In other words, use of a type field is an error-prone technique that leads to maintenance problems. The problems increase in severity as the size of the program increases because the use of a type field causes a violation of the ideals of modularity and data hiding. Each function using a type field must know about the representation and other details of the implementation of every class derived from the one containing the type field.

It also seems that any common data accessible from every derived class, such as a type field, tempts people to add more such data. The common base thus becomes the repository of all kinds of “useful information.” This, in turn, gets the implementation of the base and derived classes intertwined in ways that are most undesirable. In a large class hierarchy, accessible (not private) data in a common base class becomes the “global variables” of the hierarchy. For clean design and simpler maintenance, we want to keep separate issues separate and avoid mutual dependencies.

20.3.2. Virtual Functions
Virtual functions overcome the problems with the type-field solution by allowing the programmer to declare functions in a base class that can be redefined in each derived class. The compiler and linker will guarantee the correct correspondence between objects and the functions applied to them. For example:

Click here to view code image

class Employee {
public:
     Employee(const string& name, int dept);
     virtual void print() const;
      //...
private:
     string first_name, family_name;
     short department;
      //...
};
The keyword virtual indicates that print() can act as an interface to the print() function defined in this class and print() functions defined in classes derived from it. Where such print() functions are defined in derived classes, the compiler ensures that the right print() for the given Employee object is invoked in each case.

To allow a virtual function declaration to act as an interface to functions defined in derived classes, the argument types specified for a function in a derived class cannot differ from the argument types declared in the base, and only very slight changes are allowed for the return type (§20.3.6). A virtual member function is sometimes called a method.

A virtual function must be defined for the class in which it is first declared (unless it is declared to be a pure virtual function; see §20.4). For example:

Click here to view code image

void Employee::print() const
{
     cout << family_name << '\t' << department << '\n';
      //...
}
A virtual function can be used even if no class is derived from its class, and a derived class that does not need its own version of a virtual function need not provide one. When deriving a class, simply provide an appropriate function if it is needed. For example:

Click here to view code image

class Manager : public Employee {
public:
     Manager(const string& name, int dept, int lvl);
     void print() const;
      //...
private:
     list<Employee*> group;
     short level;
      //...
};

void Manager::print() const
{
     Employee::print();
     cout << "\tlevel " << level << '\n';
      //...
}
A function from a derived class with the same name and the same set of argument types as a virtual function in a base is said to override the base class version of the virtual function. Furthermore, it is possible to override a virtual function from a base with a more derived return type (§20.3.6).

Except where we explicitly say which version of a virtual function is called (as in the call Employee::print()), the overriding function is chosen as the most appropriate for the object for which it is called. Independently of which base class (interface) is used to access an object, we always get the same function when we use the virtual function call mechanism.

The global function print_employee() (§20.3.1) is now unnecessary because the print() member functions have taken its place. A list of Employees can be printed like this:

Click here to view code image

void print_list(const list<Employee*>& s)
{
     for (auto x : s)
           x–>print();
}
Each Employee will be written out according to its type. For example:

int main()
{
     Employee e {"Brown",1234};
     Manager m {"Smith",1234,2};

     print_list({&m,&e});
}
produced:

Smith 1234
    level 2
Brown 1234
Note that this will work even if print_list() was written and compiled before the specific derived class Manager was even conceived of! This is a key aspect of classes. When used properly, it becomes the cornerstone of object-oriented designs and provides a degree of stability to an evolving program.

Getting “the right” behavior from Employee’s functions independently of exactly what kind of Employee is actually used is called polymorphism. A type with virtual functions is called a polymorphic type or (more precisely) a run-time polymorphic type. To get runtime polymorphic behavior in C++, the member functions called must be virtual and objects must be manipulated through pointers or references. When manipulating an object directly (rather than through a pointer or reference), its exact type is known by the compiler so that run-time polymorphism is not needed.

By default, a function that overrides a virtual function itself becomes virtual. We can, but do not have to, repeat virtual in a derived class. I don’t recommend repeating virtual. If you want to be explicit, use override (§20.3.4.1).

Clearly, to implement polymorphism, the compiler must store some kind of type information in each object of class Employee and use it to call the right version of the virtual function print(). In a typical implementation, the space taken is just enough to hold a pointer (§3.2.3): the usual implementation technique is for the compiler to convert the name of a virtual function into an index into a table of pointers to functions. That table is usually called the virtual function table or simply the vtbl. Each class with virtual functions has its own vtbl identifying its virtual functions. This can be represented graphically like this:



The functions in the vtbl allow the object to be used correctly even when the size of the object and the layout of its data are unknown to the caller. The implementation of a caller need only know the location of the vtbl in an Employee and the index used for each virtual function. This virtual call mechanism can be made almost as efficient as the “normal function call” mechanism (within 25%), so efficiency concerns should not deter anyone from using a virtual function where an ordinary function call would be acceptably efficient. Its space overhead is one pointer in each object of a class with virtual functions plus one vtbl for each such class. You pay this overhead only for objects of a class with a virtual function. You choose to pay this overhead only if you need the added functionality virtual functions provide. Had you chosen to use the alternative type-field solution, a comparable amount of space would have been needed for the type field.

A virtual function invoked from a constructor or a destructor reflects that the object is partially constructed or partially destroyed (§22.4). It is therefore typically a bad idea to call a virtual function from a constructor or a destructor.

20.3.3. Explicit Qualification
Calling a function using the scope resolution operator, ::, as is done in Manager::print() ensures that the virtual mechanism is not used:

Click here to view code image

void Manager::print() const
{
     Employee::print();    // not a virtual call
     cout << "\tlevel " << level << '\n';
      //...
}
Otherwise, Manager::print() would suffer an infinite recursion. The use of a qualified name has another desirable effect. That is, if a virtual function is also inline (as is not uncommon), then inline substitution can be used for calls specified using ::. This provides the programmer with an efficient way to handle some important special cases in which one virtual function calls another for the same object. The Manager::print() function is an example of this. Because the type of the object is determined in the call of Manager::print(), it need not be dynamically determined again for the resulting call of Employee::print().

20.3.4. Override Control
If you declare a function in a derived class that has exactly the same name and type as a virtual function in a base class, then the function in the derived class overrides the one in the base class. That’s a simple and effective rule. However, for larger class hierarchies it can be difficult to be sure that you actually override the function you meant to override. Consider:

Click here to view code image

struct B0 {
     void f(int) const;
     virtual void g(double);
};

struct B1 : B0 { /* ... */ };
struct B2 : B1 { /* ... */ };
struct B3 : B2 { /* ... */ };
struct B4 : B3 { /* ... */ };
struct B5 : B4 { /* ... */ };

struct D : B5 {
     void f(int) const;         // override f() in base class
     void g(int);               // override g() in base class
     virtual int h();           // override h() in base class
};
This illustrates three errors that are far from obvious when they appear in a real class hierarchy where the classes B0...B5 have many members each and are scattered over many header files. Here:

• B0::f() is not virtual, so you can’t override it, only hide it (§20.3.5).

• D::g() doesn’t have the same argument type as B0::g(), so if it overrides anything it’s not the virtual function B0::g(). Most likely, D::g() just hides B0::g().

• There is no function called h() in B0, if D::h() overrides anything, it is not a function from B0. Most likely, it is introducing a brand-new virtual function.

I didn’t show you what was in B1...B5, so maybe something completely different is going on because of declarations in those classes. I personally don’t (redundantly) use virtual for a function that’s meant to override. For smaller programs (especially with a compiler with decent warnings against common mistakes) getting overriding done correctly isn’t hard. However, for larger hierarchies more specific controls are useful:

• virtual: The function may be overridden (§20.3.2).

• =0: The function must be virtual and must be overridden (§20.4).

• override: The function is meant to override a virtual function in a base class (§20.3.4.1).

• final: The function is not meant to be overridden (§20.3.4.2).

In the absence of any of these controls, a non-static member function is virtual if and only if it overrides a virtual function in a base class (§20.3.2).

A compiler can warn against inconsistent use of explicit override controls. For example, a class declaration that uses override for seven out of nine virtual functions from a base class could be confusing to maintainers

20.3.4.1. override
We can be explicit about our desire to override:

Click here to view code image

struct D : B5 {
     void f(int) const override;       // error: B0::f() is not virtual
     void g(int) override;             // error: B0::g() takes a double argument
     virtual int h() override;         // error: no function h() to override
};
Given this definition (and assuming that the intermediate base classes B1...B5 do not provide relevant functions), all three declarations give errors.

In a large or complicated class hierarchy with many virtual functions, it is best to use virtual only to introduce a new virtual function and to use override on all functions intended as overriders. Using override is a bit verbose but clarifies the programmer’s intent.

The override specifier comes last in a declaration, after all other parts. For example:

Click here to view code image

void f(int) const noexcept override; // OK (if there is a suitable f() to override)
override void f(int) const noexcept; // syntax error
void f(int) override const noexcept; // syntax error
And yes, it’s illogical that virtual is a prefix and override is a suffix. This is part of the price we pay for compatibility and stability over decades.

An override specifier is not part of the type of a function and cannot be repeated in an out-of-class definition. For example:

Click here to view code image

class Derived : public Base {
     void f() override;        // OK if Base has a virtual f()
     void g() override;        // OK if Base has a virtual g()
};

void Derived::f() override     // error: override out of class
{
      //...
}

void Derived::g()          // OK
{
       //...
}
Curiously, override is not a keyword; it is what is called a contextual keyword. That is, override has a special meaning in a few contexts but can be used as an identifier elsewhere. For example:

Click here to view code image

int override = 7;

struct Dx : Base {
     int override;

     int f() override
     {
           return override + ::override;
     }
};
Don’t indulge in such cleverness; it complicates maintenance. The only reason that override is a contextual keyword, rather than an ordinary keyword, is that there exists a significant amount of code that has used override as an ordinary identifier for decades. The other contextual keyword is final (§20.3.4.2).

20.3.4.2. final
When we declare a member function, we have a choice between virtual and not virtual (the default). We use virtual for functions we want writers of derived classes to be able to define or redefine. We base our choice on the meaning (semantics) of our class:

• Can we imagine the need for further derived classes?

• Does a designer of a derived class need to redefine the function to achieve a plausible aim?

• Is corectly overriding a function straightforward (i.e., is it reasonably simple for an overriding function to provide the expected semantics of a virtual function)?

If the answer is “no” to all three questions, we can leave the function non-virtual to gain simplicity of design and occasionally some performance (mostly from inlining). The standard library is full of examples of this.

Far more rarely, we have a class hierarchy that starts out with virtual functions, but after the definition of a set of derived classes, one of the answers becomes “no.” For example, we can imagine an abstract syntax tree for a language where all language constructs have been defined as concrete node classes derived from a few interfaces. We only need to derive a new class if we change the language. In that case, we might want to prevent our users from overriding virtual functions because the only thing such overrides could do would be to change the semantics of our language. That is, we might want to close our design to modification from its users. For example:

Click here to view code image

struct Node {   // interface class
     virtual Type type() = 0;
      //...
};

class If_statement : public Node {
public:
     Type type() override final;     // prevent further overriding
      //...
};
In a realistic class hierarchy, there would be several intermediate classes between the general interface (here, Node) and the derived class representing a specific language construct (here, If_statement). However, the key point about this example is that Node::type() is meant to be overridden (that’s why it’s declared virtual) and its overrider If_statement::type() is not (that’s why it’s declared final). After using final for a member function, it can no longer be overridden and an attempt to do so is an error. For example:

Click here to view code image

class Modified_if_statement : public If_statement {
public:
     Type type() override;     // error: If_statement::type() is final
      //...
};
We can make every virtual member function of a class final; just add final after the class name. For example:

Click here to view code image

class For_statement final : public Node {
public:
     Type type() override;
      //...
};

class Modified_for_statement : public For_statement {    // error: For_statement is final
      Type type() override;
       //...
};
For good and bad, adding final to the class not only prevents overriding, it also prevents further derivation from a class. There are people who use final to try to gain performance – after all, a non-virtual function is faster than a virtual one (by maybe 25% on a modern implementation) and offers greater opportunities for inlining (§12.1.5). However, do not blindly use final as an optimization aid; it affects the class hierarchy design (often negatively), and the performance improvements are rarely significant. Do some serious measurements before claiming efficiency improvements. Use final where it clearly reflects a class hierarchy design that you consider proper. That is, use final to reflect a semantic need.

A final specifier is not part of the type of a function and cannot be repeated in an out-of-class definition. For example:

Click here to view code image

class Derived : public Base {
     void f() final;      // OK if Base has a virtual f()
     void g() final;      // OK if Base has a virtual g()
      //...
};

void Derived::f() final   // error: final out of class
{
      //...
}
void Derived::g()         // OK
{
      //...
}
Like override (§20.3.4.1), final is a contextual keyword. That is, final has a special meaning in a few contexts but can be used as an ordinary identifier elsewhere. For example:

Click here to view code image

int final = 7;

struct Dx : Base {
     int final;

     int f() final
     {
           return final + ::final;
     }
};
Don’t indulge in such cleverness; it complicates maintenance. The only reason that final is a contextual keyword, rather than an ordinary keyword, is that there exists a significant amount of code that has used final as an ordinary identifier for decades. The other contextual keyword is override (§20.3.4.1).

20.3.5. using Base Members
Functions do not overload across scopes (§12.3.3). For example:

Click here to view code image

struct Base {
     void f(int);
};

struct Derived : Base {
     void f(double);
};

void use(Derived d)
{
     d.f(1);          // call Derived::f(double)
     Base& br = d
     br.f(1);         // call Base::f(int)
}
This can surprise people, and sometimes we want overloading to ensure that the best matching member function is used. As for namespaces, using-declarations can be used to add a function to a scope. For example:

Click here to view code image

struct D2 : Base {
     using Base::f;     // bring all fs from Base into D2
     void f(double);
};
void use2(D2 d)
{
     d.f(1);            // call D2::f(int), that is, Base::f(int)
     Base& br = d
     br.f(1);           // call Base::f(int)
}
This is a simple consequence of a class also being considered a namespace (§16.2).

Several using-declarations can bring in names from multiple base classes. For example:

Click here to view code image

struct B1 {
     void f(int);
};

struct B2 {
     void f(double);
};

struct D : B1, B2 {
     using B1::f;
     using B2::f;
     void f(char);
};

void use(D d)
{
     d.f(1);       // call D::f(int), that is, B1::f(int)
     d.f('a');     // call D::f(char)
     d.f(1.0);     // call D::f(double), that is, B2::f(double)
}
We can bring constructors into a derived class scope; see §20.3.5.1. A name brought into a derived class scope by a using-declaration has its access determined by the placement of the using-declaration; see §20.5.3. We cannot use using-directives to bring all members of a base class into a derived class.

20.3.5.1. Inheriting Constructors
Say I want a vector that’s just like std::vector, but with guaranteed range checking. I can try this:

Click here to view code image

template<typename T>
struct Vector : std::vector<T> {
     using size_type = typename std::vector<T>::size_type;          // use vector's size type

     T& operator[](size_type i) { return this->at(i); }             // use checked access
     const T& operator[](size_type i) const { return this->at(i); }
};
Unfortunately, we would soon find out that this definition is rather incomplete. For example:

Vector<int> v { 1, 2, 3, 5, 8 };    // error: no initializer-list constructor
A quick check will show that Vector failed to inherit any constructors from std::vector.

That’s not an unreasonable rule: if a class adds data members to a base or requires a stricter class invariant, it would be a disaster to inherit constructors. However, Vector did not do anything like that.

We solve the problem by simply saying that the constructors should be inherited:

Click here to view code image

template<typename T>
struct Vector : std::vector<T> {
     using size_type = typename std::vector<T>::size_type;            // use vector's size type

     using std::vector<T>::vector;                                    // inherit vector's constructors

     T& operator=[](size_type i) { return this->at(i); }              // use checked access
     const T& operator=(size_type i) const { return this->at(i); }
};

Vector<int> v { 1, 2, 3, 5, 8 };    // OK: use initializer-list constructor from std::vector
This use of using is exactly equivalent to its use for ordinary functions (§14.4.5, §20.3.5).

If you so choose, you can shoot yourself in the foot by inheriting constructors in a derived class in which you define new member variables needing explicit initialization:

Click here to view code image

struct B1 {
     B1(int) { }
};

struct D1 : B1 {
     using B1::B1;  // implicitly declares D1(int)
     string s;      // string has a default constructor
     int x;         // we "forgot" to provide for initialization of x
};

void test() {
     D1 d {6};      // oops: d.x is not initialized
     D1 e;          // error: D1 has no default constructor
}
The reason that D1::s is initialized and D1::x is not is that the inheriting constructor is equivalent to a constructor that simply initializes the base. In this case, we might equivalently have written:

Click here to view code image

struct D1 : B1 {
     D1(int i) : B1(i) { }
     string s;          // string has a default constructor
     int x;             // we "forgot" to provide for initialization of x
};
One way to remove the bullet from your foot is by adding an in-class member initializer (§17.4.4):

Click here to view code image

struct D1 : B1 {
     using B1::B1;   // implicitly declares D1(int)
     int x {0};      // note: x is initialized
};

void test()
{
     D1 d {6};  // d.x is zero
}
Most often it is best to avoid being clever and restrict the use of inheriting constructors to the simple cases where no data members are added.

20.3.6. Return Type Relaxation
There is a relaxation of the rule that the type of an overriding function must be the same as the type of the virtual function it overrides. That is, if the original return type was B*, then the return type of the overriding function may be D*, provided B is a public base of D. Similarly, a return type of B& may be relaxed to D&. This is sometimes called the covariant return rule.

This relaxation applies only to return types that are pointers or references, and not to “smart pointers” such as unique_ptr (§5.2.1). In particular, there is not a similar relaxation of the rules for argument types because that would lead to type violations.

Consider a class hierarchy representing different kinds of expressions. In addition to the operations for manipulating expressions, the base class Expr would provide facilities for making new expression objects of the various expression types:

Click here to view code image

class Expr {
public:
     Expr();                   // default constructor
     Expr(const Expr&);        // copy constructor
     virtual Expr* new_expr() =0;
     virtual Expr* clone() =0;
      //...
};
The idea is that new_expr() makes a default object of the type of the expression and clone() makes a copy of the object. Both will return an object of some specific class derived from Expr. They can never just return a “plain Expr” because Expr was deliberately and appropriately declared to be an abstract class.

A derived class can override new_expr() and/or clone() to return an object of its own type:

Click here to view code image

class Cond : public Expr {
public:
     Cond();
     Cond(const Cond&);
     Cond* new_expr() override { return new Cond(); }
     Cond* clone() override { return new Cond(*this); }
      //...
};
This means that given an object of class Expr, a user can create a new object of “just the same type.” For example:

void user(Expr* p)
{
     Expr* p2 = p–>new_expr();
      //...
}
The pointer assigned to p2 is declared to point to a “plain Expr,” but it will point to an object of a type derived from Expr, such as Cond.

The return type of Cond::new_expr() and Cond::clone() is Cond* rather than Expr*. This allows a Cond to be cloned without loss of type information. Similarly, a derived class Addition would have a clone() returning an Addition*. For example:

Click here to view code image

void user2(Cond* pc, Addition* pa)
{
     Cond* p1 = pc–>clone();
     Addition* p2 = pa–>clone();
      //...
}
If we use clone() for an Expr we only know that the result is an Expr*:

Click here to view code image

void user3(Cond* pc, Expr* pe)
{
     Cond* p1 = pc–>clone();
     Cond* p2 = pe–>clone();     // error: Expr::clone() returns an Expr*
      //...
}
Because functions such as new_expr() and clone() are virtual and they (indirectly) construct objects, they are often called virtual constructors. Each simply uses a constructor to create a suitable object.

To make an object, a constructor needs the exact type of the object it is to create. Consequently, a constructor cannot be virtual. Furthermore, a constructor is not quite an ordinary function. In particular, it interacts with memory management routines in ways ordinary member functions don’t. So, you cannot take a pointer to a constructor and pass that to an object creation function.

Both of these restrictions can be circumvented by defining a function that calls a constructor and returns a constructed object. This is fortunate because creating a new object without knowing its exact type is often useful. The Ival_box_maker (§21.2.4) is an example of a class designed specifically to do that.

20.4. Abstract Classes
Many classes resemble class Employee in that they are useful as themselves, as interfaces for derived classes, and as part of the implementation of derived classes. For such classes, the techniques described in §20.3.2 suffice. However, not all classes follow that pattern. Some classes, such as a class Shape, represent abstract concepts for which objects cannot exist. A Shape makes sense only as the base of some class derived from it. This can be seen from the fact that it is not possible to provide sensible definitions for its virtual functions:

Click here to view code image

class Shape {
public:
     virtual void rotate(int) { throw runtime_error{"Shape::rotate"}; }    // inelegant
     virtual void draw() const { throw runtime_error{"Shape::draw"}; }
      //...
};
Trying to make a shape of this unspecified kind is silly but legal:

Shape s;  // silly: "shapeless shape"
It is silly because every operation on s will result in an error.

A better alternative is to declare the virtual functions of class Shape to be pure virtual functions. A virtual function is “made pure” by the “pseudo initializer” = 0:

Click here to view code image

class Shape {          // abstract class
public:
     virtual void rotate(int) = 0;           // pure virtual function
     virtual void draw() const = 0;          // pure virtual function
     virtual bool is_closed() const = 0;     // pure virtual function
      //...
     virtual ~Shape();                       // virtual
};
A class with one or more pure virtual functions is an abstract class, and no objects of that abstract class can be created:

Shape s;  // error: variable of abstract class Shape
An abstract class is intended as an interface to objects accessed through pointers and references (to preserve polymorphic behavior). Consequently, it is usually important for an abstract class to have a virtual destructor (§3.2.4, §21.2.2). Because the interface provided by an abstract class cannot be used to create objects using a constructor, abstract classes don’t usually have constructors.

An abstract class can be used only as an interface to other classes. For example:

Click here to view code image

class Point { /* ... */ };

class Circle : public Shape {
public:
     Circle(Point p, int r);

     void rotate(int) override { }
     void draw() const override;
     bool is_closed() const override { return true; }

     Circle(Point p, int r);
private:
     Point center;
     int radius;
};
A pure virtual function that is not defined in a derived class remains a pure virtual function, so the derived class is also an abstract class. This allows us to build implementations in stages:

Click here to view code image

class Polygon : public Shape {            // abstract class
public:
     bool is_closed() const override { return true; }
      //... draw and rotate not overridden ...
};

Polygon b {p1,p2,p3,p4};           // error: declaration of object of abstract class Polygon
Polygon is still abstract because we did not override draw() and rotate(). Only when that is done do we have a class from which we can create objects:

Click here to view code image

class Irregular_polygon : public Polygon {
     list<Point> lp;
public:
     Irregular_polygon(initializer_list<Point>);

     void draw() const override;
     void rotate(int) override;
      //...
};

Irregular_polygon poly {p1,p2,p3,p4};    // assume that p1 .. p4 are Points defined somewhere
An abstract class provides an interface without exposing implementation details. For example, an operating system might hide the details of its device drivers behind an abstract class:

Click here to view code image

class Character_device {
public:
     virtual int open(int opt) = 0;
     virtual int close(int opt) = 0;
     virtual int read(char* p, int n) = 0;
     virtual int write(const char* p, int n) = 0;
     virtual int ioctl(int ...) = 0;        // device I/O control

     virtual ~Character_device() { }       // virtual destructor
};
We can then specify drivers as classes derived from Character_device and manipulate a variety of drivers through that interface.

The design style supported by abstract classes is called interface inheritance in contrast to the implementation inheritance supported by base classes with state and/or defined member functions. Combinations of the two approaches are possible. That is, we can define and use base classes with both state and pure virtual functions. However, such mixtures of approaches can be confusing and require extra care.

With the introduction of abstract classes, we have the basic facilities for writing a complete program in a modular fashion using classes as building blocks.

20.5. Access Control
A member of a class can be private, protected, or public:

• If it is private, its name can be used only by member functions and friends of the class in which it is declared.

• If it is protected, its name can be used only by member functions and friends of the class in which it is declared and by member functions and friends of classes derived from this class (see §19.4).

• If it is public, its name can be used by any function.

This reflects the view that there are three kinds of functions accessing a class: functions implementing the class (its friends and members), functions implementing a derived class (the derived class’s friends and members), and other functions. This can be presented graphically:



The access control is applied uniformly to names. What a name refers to does not affect the control of its use. This means that we can have private member functions, types, constants, etc., as well as private data members. For example, an efficient nonintrusive list class often requires data structures to keep track of elements. A list is nonintrusive if it does not require modification to its elements (e.g., by requiring element types to have link fields). The information and data structures used to organize the list can be kept private:

Click here to view code image

template<typename T>
class List {
public:
     void insert(T);
     T get();
      //...
private:
     struct Link { T val; Link* next; };

     struct Chunk {
          enum { chunk_size = 15 };
          Link v[chunk_size];
          Chunk* next;
     };
     Chunk* allocated;
     Link* free;
     Link* get_free();
     Link* head;
};
The definitions of the public functions are pretty straightforward:

Click here to view code image

template<typename T>
void List<T>::insert(T val)
{
     Link* lnk = get_free();
     lnk–>val = val;
     lnk–>next = head;
     head = lnk;
}

template<typename T>
T List<T>::get()
{
     if (head == nullptr)
           throw Underflow{};  // Underflow is my exception class

     Link* p= head;
     head = p–>next;
     p–>next = free;
     free = p;
     return p–>val;
}
As is common, the definition of the supporting (here, private) functions are a bit more tricky:

Click here to view code image

template<typename T>
typename List<T>::Link* List<T>::get_free()
{
     if (free == 0) {
            //... allocate a new chunk and place its Links on the free list ...
     }
     Link* p = free;
     free = free–>next;
     return p;
}
The List<T> scope is entered by saying List<T>:: in a member function definition. However, because the return type of get_free() is mentioned before the name List<T>::get_free() is mentioned, the full name List<T>::Link must be used instead of the abbreviation Link. The alternative is to use the suffix notation for return types (§12.1.4):

template<typename T>
auto List<T>::get_free() –> Link*
{
      //...
}
Nonmember functions (except friends) do not have such access:

Click here to view code image

template<typename T>
void would_be_meddler(List<T>* p)
{
     List<T>::Link* q = 0;                         // error: List<T>::Link is private
      //...
     q = p–>free;                                  // error: List<T>::free is private
      //...
     if (List<T>::Chunk::chunk_size > 31) {        // error: List<T>::Chunk::chunk_size is private
           //...
     }
}
In a class, members are by default private; in a struct, members are by default public (§16.2.4).

The obvious alternative to using a member type is to place the type in the surrounding namespace. For example:

template<typename T>
struct Link2 {
     T val;
     Link2* next;
};

template<typename T>
class List {
private:
     Link2<T>* free;
      //...
};
Link is implicitly parameterized with List<T>’s parameter T. For Link2, we must make that explicit.

If a member type does not depend on all the template class’s parameters, the nonmember version can be preferable; see §23.4.6.3.

If nesting is undesirable, but the nested class is not generally useful by itself, declaring the (former) member class a friend (§19.4.2) of the (former) enclosing class may be a good idea:

Click here to view code image

template<typename T> class List;

template<typename T>
class Link3 {
     friend class List<T>;      // only List<T> can access Link<T>
     T val;
     Link3* next;
};
template<typename T>
class List {
private:
     Link3<T>* free;
      //...
};
A compiler may reorder sections of a class with separate access specifiers (§16.2.4). For example:

class S {
public:
     int m1;
public:
     int m2;
};
The compiler may decide for m2 to precede m1 in the layout of an S object. Such reordering could come as a surprise to the programmer and is implementation-dependent, so don’t use multiple access specifiers for data members without good reason.

20.5.1. protected Members
When designing a class hierarchy, we sometimes provide functions designed to be used by implementers of derived classes but not by the general user. For example, we may provide an (efficient) unchecked access function for derived class implementers and (safe) checked access for others. Declaring the unchecked version protected achieves that. For example:

Click here to view code image

class Buffer {
public:
     char& operator[](int i);      // checked access
      //...
protected:
     char& access(int i);          // unchecked access
      //...
};

class Circular_buffer : public Buffer {
public:
     void reallocate(char* p, int s);      // change location and size
      //...
};

void Circular_buffer::reallocate(char* p, int s) // change location and size
{
      //...
     for (int i=0; i!=old_sz; ++i)
           p[i] = access(i);      // no redundant checking
      //...
}
void f(Buffer& b)
{
     b[3] = 'b';             // OK (checked)
     b.access(3) = 'c';      // error: Buffer::access() is protected
}
For another example, see Window_with_border in §21.3.5.2.

A derived class can access a base class’s protected members only for objects of its own type:

Click here to view code image

class Buffer {
protected:
     char a[128];
      //...
};

class Linked_buffer : public Buffer {
      //...
};


class Circular_buffer : public Buffer {
      //...
     void f(Linked_buffer* p)
     {
           a[0] = 0;       // OK: access to Circular_buffer's own protected member
           p–>a[0] = 0;    // error: access to protected member of different type
     }
};
This prevents subtle errors that would otherwise occur when one derived class corrupts data belonging to other derived classes.

20.5.1.1. Use of protected Members
The simple private/public model of data hiding serves the notion of concrete types (§16.3) well. However, when derived classes are used, there are two kinds of users of a class: derived classes and “the general public.” The members and friends that implement the operations on the class operate on the class objects on behalf of these users. The private/public model allows the programmer to distinguish clearly between the implementers and the general public, but it does not provide a way of catering specifically to derived classes.

Members declared protected are far more open to abuse than members declared private. In particular, declaring data members protected is usually a design error. Placing significant amounts of data in a common class for all derived classes to use leaves that data open to corruption. Worse, protected data, like public data, cannot easily be restructured because there is no good way of finding every use. Thus, protected data becomes a software maintenance problem.

Fortunately, you don’t have to use protected data; private is the default in classes and is usually the better choice. In my experience, there have always been alternatives to placing significant amounts of information in a common base class for derived classes to use directly.

However, none of these objections are significant for protected member functions; protected is a fine way of specifying operations for use in derived classes. The Ival_slider in §21.2.2 is an example of this. Had the implementation class been private in this example, further derivation would have been infeasible. On the other hand, making bases providing implementation details public invites mistakes and misuse.

20.5.2. Access to Base Classes
Like a member, a base class can be declared private, protected, or public. For example:

class X : public B { /* ... */ };
class Y : protected B { /* ... */ };
class Z : private B { /* ... */ };
The different access specifiers serve different design needs:

• public derivation makes the derived class a subtype of its base. For example, X is a kind of B. This is the most common form of derivation.

• private bases are most useful when defining a class by restricting the interface to a base so that stronger guarantees can be provided. For example, B is an implementation detail of Z. The Vector of pointers template that adds type checking to its Vector<void*> base from §25.3 is a good example.

• protected bases are useful in class hierarchies in which further derivation is the norm. Like private derivation, protected derivation is used to represent implementation details. The Ival_slider from §21.2.2 is a good example.

The access specifier for a base class can be left out. In that case, the base defaults to a private base for a class and a public base for a struct. For example:

Click here to view code image

class XX : B { /* ... */ };     // B is a private base
struct YY : B { /* ... */ };    // B is a public base
People expect base classes to be public (that is, to express a subtype relationship), so the absence of an access specifier for a base is likely to be surprising for a class but not for a struct.

The access specifier for a base class controls the access to members of the base class and the conversion of pointers and references from the derived class type to the base class type. Consider a class D derived from a base class B:

• If B is a private base, its public and protected members can be used only by member functions and friends of D. Only friends and members of D can convert a D* to a B*.

• If B is a protected base, its public and protected members can be used only by member functions and friends of D and by member functions and friends of classes derived from D. Only friends and members of D and friends and members of classes derived from D can convert a D* to a B*.

• If B is a public base, its public members can be used by any function. In addition, its protected members can be used by members and friends of D and members and friends of classes derived from D. Any function can convert a D* to a B*.

This basically restates the rules for member access (§20.5). When designing a class, we choose access for bases in the same way as we do for members. For an example, see Ival_slider in §21.2.2.

20.5.2.1. Multiple Inheritance and Access Control
If the name of a base class can be reached through multiple paths in a multiple-inheritance lattice (§21.3), it is accessible if it is accessible through any path. For example:

Click here to view code image

struct B {
     int m;
     static int sm;
      //...
};

class D1 : public virtual B { /* ... */ } ;
class D2 : public virtual B { /* ... */ } ;
class D12 : public D1, private D2 { /* ... */ };

D12* pd = new D12;
B* pb = pd;        // OK: accessible through D1
int i1 = pd–>m;    // OK: accessible through D1
If a single entity is reachable through several paths, we can still refer to it without ambiguity. For example:

Click here to view code image

class X1 : public B { /* ... */ } ;
class X2 : public B { /* ... */ } ;
class XX : public X1, public X2 { /* ... */ };

XX* pxx = new XX;
int i1 = pxx–>m;          // error, ambiguous: XX::X1::B::m or XX::X2::B::m?
int i2 = pxx–>sm;         // OK: there is only one B::sm in an XX (sm is a static member)
20.5.3. using-Declarations and Access Control
A using-declaration (§14.2.2, §20.3.5) cannot be used to gain access to additional information. It is simply a mechanism for making accessible information more convenient to use. On the other hand, once access is available, it can be granted to other users. For example:

Click here to view code image

class B {
private:
     int a;
protected:
     int b;
public:
     int c;
};

class D : public B {
public:
     using B::a;       // error: B::a is private
     using B::b;       // make B::b publicly available through D
};
When a using-declaration is combined with private or protected derivation, it can be used to specify interfaces to some, but not all, of the facilities usually offered by a class. For example:

Click here to view code image

class BB : private B {     // give access to B::b and B::c, but not B::a
public:
     using B::b;
     using B::c;
};
See also §20.3.5.

20.6. Pointers to Members
A pointer to member is an offset-like construct that allows a programmer to indirectly refer to a member of a class. The operators –>* and . * are arguably the most specialized and least used C++ operators. Using –>, we can access a member of a class, m, by naming it: p–>m. Using –>*, we can access a member that (conceptually) has its name stored in a pointer to member, ptom: p–> ptom. This allows us to access members with their names passed as arguments. In both cases, p must be a pointer to an object of an appropriate class.

A pointer to member cannot be assigned to a void* or any other ordinary pointer. A null pointer (e.g., nullptr) can be assigned to a pointer to member and then represents “no member.”

20.6.1. Pointers to Function Members
Many classes provide simple, very general interfaces intended to be invoked in several different ways. For example, many “object-oriented” user interfaces define a set of requests to which every object represented on the screen should be prepared to respond. In addition, such requests can be presented directly or indirectly from programs. Consider a simple variant of this idea:

Click here to view code image

class Std_interface {
public:
     virtual void start() = 0;
     virtual void suspend() = 0;
     virtual void resume() = 0;
     virtual void quit() = 0;
     virtual void full_size() = 0;
     virtual void small() = 0;

     virtual ~Std_interface() {}
};
The exact meaning of each operation is defined by the object on which it is invoked. Often, there is a layer of software between the person or program issuing the request and the object receiving it. Ideally, such intermediate layers of software should not have to know anything about the individual operations such as resume() and full_size(). If they did, the intermediate layers would have to be updated each time an operation changed. Consequently, such intermediate layers simply transmit data representing the operation to be invoked from the source of the request to its recipient.

One simple way of doing that is to send a string representing the operation to be invoked. For example, to invoke suspend() we could send the string "suspend". However, someone has to create that string and someone has to decode it to determine to which operation it corresponds – if any. Often, that seems indirect and tedious. Instead, we might simply send an integer representing the operation. For example, 2 might be used to mean suspend(). However, while an integer may be convenient for machines to deal with, it can get pretty obscure for people. We still have to write code to determine that 2 means suspend() and to invoke suspend().

Alternatively, we can use a pointer to member to indirectly refer to a member of a class. Consider Std_interface. If I want to invoke suspend() for some object without mentioning suspend() directly, I need a pointer to member referring to Std_interface::suspend(). I also need a pointer or reference to the object I want to suspend. Consider a trivial example:

Click here to view code image

using Pstd_mem = void (Std_interface::*)();    // pointer-to-member type

void f(Std_interface* p)
{
     Pstd_mem s = &Std_interface::suspend;            // pointer to suspend()
     p–>suspend();                                    // direct call
     p–>*s();                                         // call through pointer to member
}
A pointer to member can be obtained by applying the address-of operator, &, to a fully qualified class member name, for example, &Std_interface::suspend. A variable of type “pointer to member of class X” is declared using a declarator of the form X::*.

The use of an alias to compensate for the lack of readability of the C declarator syntax is typical. However, please note how the X::* declarator matches the traditional * declarator exactly.

A pointer to member m can be used in combination with an object. The operators –>* and .* allow the programmer to express such combinations. For example, p–>*m binds m to the object pointed to by p, and obj.*m binds m to the object obj. The result can be used in accordance with m’s type. It is not possible to store the result of a –>* or a .* operation for later use.

Naturally, if we knew which member we wanted to call, we would invoke it directly rather than mess with pointers to members. Just like ordinary pointers to functions, pointers to member functions are used when we need to refer to a function without having to know its name. However, a pointer to member isn’t a pointer to a piece of memory the way a pointer to a variable or a pointer to a function is. It is more like an offset into a structure or an index into an array, but of course an implementation takes into account the differences between data members, virtual functions, nonvirtual functions, etc. When a pointer to member is combined with a pointer to an object of the right type, it yields something that identifies a particular member of a particular object.

The p–>*s() call can be represented graphically like this:



Because a pointer to a virtual member (s in this example) is a kind of offset, it does not depend on an object’s location in memory. A pointer to a virtual member can therefore be passed between different address spaces as long as the same object layout is used in both. Like pointers to ordinary functions, pointers to non-virtual member functions cannot be exchanged between address spaces.

Note that a function invoked through a pointer to function can be virtual. For example, when we call suspend() through a pointer to function, we get the suspend() for the object to which the pointer to member function is applied. This is an essential aspect of pointers to member functions.

When writing an interpreter, we might use pointers to members to invoke functions presented as strings:

Click here to view code image

map<string,Std_interface*> variable;
map<string,Pstd_mem> operation;

void call_member(string var, string oper)
{
     (variable[var]–>*operation[oper])();  // var.oper()
}
A static member isn’t associated with a particular object, so a pointer to a static member is simply an ordinary pointer. For example:

Click here to view code image

class Task {
      //...
     static void schedule();
};

void (*p)() = &Task::schedule;             // OK
void (Task::* pm)() = &Task::schedule;     // error: ordinary pointer assigned
                                           // to pointer to member
Pointers to data members are described in §20.6.2.

20.6.2. Pointers to Data Members
Naturally, the notion of pointer to member applies to data members and to member functions with arguments and return types. For example:

Click here to view code image

struct C {
     const char* val;
     int i;

     void print(int x) { cout << val << x << '\n'; }
     int f1(int);
     void f2();
     C(const char* v) { val = v; }
};

using Pmfi = void (C::*)(int);   // pointer to member function of C taking an int
using Pm = const char* C::*;     // pointer to char* data member of C
void f(C& z1, C& z2)
{
     C* p = &z2;
     Pmfi pf = &C::print;
     Pm pm = &C::val;

     z1.print(1);
     (z1.*pf)(2);
     z1.*pm = "nv1 ";
     p–>*pm = "nv2 ";
     z2.print(3);
     (p–>*pf)(4);

     pf = &C::f1;    // error: return type mismatch
     pf = &C::f2;    // error: argument type mismatch
     pm = &C::i;     // error: type mismatch
     pm = pf;        // error: type mismatch
}
The type of a pointer to function is checked just like any other type.

20.6.3. Base and Derived Members
A derived class has at least the members that it inherits from its base classes. Often it has more. This implies that we can safely assign a pointer to a member of a base class to a pointer to a member of a derived class, but not the other way around. This property is often called contravariance. For example:

Click here to view code image

class Text : public Std_interface {
public:
     void start();
     void suspend();
      //...
     virtual void print();
private:
     vector s;
};

void (Std_interface::* pmi)() = &Text::print;    // error
void (Text::*pmt)() = &Std_interface::start;     // OK
This contravariance rule appears to be the opposite of the rule that says we can assign a pointer to a derived class to a pointer to its base class. In fact, both rules exist to preserve the fundamental guarantee that a pointer may never point to an object that doesn’t at least have the properties that the pointer promises. In this case, Std_interface::* can be applied to any Std_interface, and most such objects presumably are not of type Text. Consequently, they do not have the member Text::print with which we tried to initialize pmi. By refusing the initialization, the compiler saves us from a run-time error.

20.7. Advice
[1] Avoid type fields; §20.3.1.

[2] Access polymorphic objects through pointers and references; §20.3.2.

[3] Use abstract classes to focus design on the provision of clean interfaces; §20.4.

[4] Use override to make overriding explicit in large class hierarchies; §20.3.4.1.

[5] Use final only sparingly; §20.3.4.2.

[6] Use abstract classes to specify interfaces; §20.4.

[7] Use abstract classes to keep implementation details out of interfaces; §20.4.

[8] A class with a virtual function should have a virtual destructor; §20.4.

[9] An abstract class typically doesn’t need a constructor; §20.4.

[10] Prefer private members for implementation details; §20.5.

[11] Prefer public members for interfaces; §20.5.

[12] Use protected members only carefully when really needed; §20.5.1.1.

[13] Don’t declare data members protected; §20.5.1.1.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue
Skip to Content
Topics
Start Learning
Featured
Search 50,000+ courses, events, titles, and more


20. Derived Classes
21. Class Hierarchies
22. Run-Time Type Information
47h 26m remaining
21. Class Hierarchies
Abstraction is selective ignorance.

– Andrew Koenig

• Introduction

• Design of Class Hierarchies

Implementation Inheritance; Interface Inheritance; Alternative Implementations; Localizing Object Creation

• Multiple Inheritance

Multiple Interfaces; Multiple Implementation Classes; Ambiguity Resolution; Repeated Use of a Base Class; Virtual Base Classes; Replicated vs. Virtual Bases

• Advice

21.1. Introduction
The primary focus of this chapter is design techniques, rather than language features. The examples are taken from user-interface design, but I avoid the topic of event-driven programming as commonly used for graphical user interface (GUI) systems. A discussion of exactly how an action on the screen is transformed into a call of a member function would add little to the issues of class hierarchy design and has a huge potential for distraction: it is an interesting and important topic in its own right. For an understanding of GUI, have a look at one of the many C++ GUI libraries.

21.2. Design of Class Hierarchies
Consider a simple design problem: Provide a way for a program (“an application”) to get an integer value from a user. This can be done in a bewildering number of ways. To insulate our program from this variety, and also to get a chance to explore the possible design choices, let us start by defining our program’s model of this simple input operation.

The idea is to have a class Ival_box (“integer value input box”) that knows what range of input values it will accept. A program can ask an Ival_box for its value and ask it to prompt the user if necessary. In addition, a program can ask an Ival_box if a user changed the value since the program last looked at it:


Because there are many ways of implementing this basic idea, we must assume that there will be many different kinds of Ival_boxes, such as sliders, plain boxes in which a user can type a number, dials, and voice interaction.

The general approach is to build a “virtual user-interface system” for the application to use. This system provides some of the services provided by existing user-interface systems. It can be implemented on a wide variety of systems to ensure the portability of application code. Naturally, there are other ways of insulating an application from a user-interface system. I chose this approach because it is general, because it allows me to demonstrate a variety of techniques and design tradeoffs, because those techniques are also the ones used to build “real” user-interface systems, and – most important – because these techniques are applicable to problems far beyond the narrow domain of interface systems.

In addition to ignoring the topic of how to map user actions (events) to library calls, I also ignore the need for locking in a multi-threaded GUI system.

21.2.1. Implementation Inheritance
Our first solution is a class hierarchy using implementation inheritance (as is commonly found in older programs).

Class Ival_box defines the basic interface to all Ival_boxes and specifies a default implementation that more specific kinds of Ival_boxes can override with their own versions. In addition, we declare the data needed to implement the basic notion:

Click here to view code image

class Ival_box {
protected:
     int val;
     int low, high;
     bool changed {false};              // changed by user using set_value()
public:
     Ival_box(int ll, int hh) :val{ll}, low{ll}, high{hh} { }

     virtual int get_value() { changed = false; return val; }       // for application
     virtual void set_value(int i) { changed = true; val = i; }     // for user
     virtual void reset_value(int i) { changed = false; val = i; }  // for application
     virtual void prompt() { }
     virtual bool was_changed() const { return changed; }

     virtual ~Ival_box() {};
};
The default implementation of the functions is pretty sloppy and is provided here primarily to illustrate the intended semantics. A realistic class would, for example, provide some range checking.

A programmer might use these “ival classes” like this:

Click here to view code image

void interact(Ival_box* pb)
{
     int old_val = pb->get_value();
     pb–>prompt();  // alert user
      //...
     int i = pb–>get_value();
     if (i != old_val) {
            //... new value; do something ...
     }
     else {
           //... do something else ...
     }
}

void some_fct()
{
     unique_ptr<Ival_box> p1 {new Ival_slider{0,5}};    // Ival_slider derived from Ival_box
     interact(p1.get());
     unique_ptr<Ival_box> p2 {new Ival_dial{1,12}};
     interact(p2.get());
}
Most application code is written in terms of (pointers to) plain Ival_boxes the way interact() is. That way, the application doesn’t have to know about the potentially large number of variants of the Ival_box concept. The knowledge of such specialized classes is isolated in the relatively few functions that create such objects. This isolates users from changes in the implementations of the derived classes. Most code can be oblivious to the fact that there are different kinds of Ival_boxes.

I use unique_ptr (§5.2.1, §34.3.1) to avoid forgetting to delete the Ival_boxes.

To simplify the discussion, I do not address issues of how a program waits for input. Maybe the program really does wait for the user in get_value() (e.g., using a get() on a future; §5.3.5.1), maybe the program associates the Ival_box with an event and prepares to respond to a callback, or maybe the program spawns a thread for the Ival_box and later inquires about the state of that thread. Such decisions are crucial in the design of user-interface systems. However, discussing them here in any realistic detail would simply distract from the presentation of programming techniques and language facilities. The design techniques described here and the language facilities that support them are not specific to user interfaces. They apply to a far greater range of problems.

The different kinds of Ival_boxes are defined as classes derived from Ival_box. For example:

Click here to view code image

class Ival_slider : public Ival_box {
private:
      //... graphics stuff to define what the slider looks like, etc. ...
public:
     Ival_slider(int, int);
     int get_value() override;   // get value from user and deposit it in val
     void prompt() override;
};
The data members of Ival_box were declared protected to allow access from derived classes. Thus, Ival_slider::get_value() can deposit a value in Ival_box::val. A protected member is accessible from a class’s own members and from members of derived classes, but not to general users (see §20.5).

In addition to Ival_slider, we would define other variants of the Ival_box concept. These could include Ival_dial, which lets you select a value by turning a knob; Flashing_ival_slider, which flashes when you ask it to prompt(); and Popup_ival_slider, which responds to prompt() by appearing in some prominent place, thus making it hard for the user to ignore.

From where would we get the graphics stuff? Most user-interface systems provide a class defining the basic properties of being an entity on the screen. So, if we use the system from “Big Bucks Inc.,” we would have to make each of our Ival_slider, Ival_dial, etc., classes a kind of BBwidget. This would most simply be achieved by rewriting our Ival_box so that it derives from BBwidget. In that way, all our classes inherit all the properties of a BBwidget. For example, every Ival_box can be placed on the screen, obey the graphical style rules, be resized, be dragged around, etc., according to the standard set by the BBwidget system. Our class hierarchy would look like this:

Click here to view code image

class Ival_box : public BBwidget { /* ... */ };  // rewritten to use BBwidget
class Ival_slider : public Ival_box { /* ... */ };
class Ival_dial : public Ival_box { /* ... */ };
class Flashing_ival_slider : public Ival_slider { /* ... */ };
class Popup_ival_slider : public Ival_slider { /* ... */ };
or graphically:



21.2.1.1. Critique
This design works well in many ways, and for many problems this kind of hierarchy is a good solution. However, there are some awkward details that could lead us to look for alternative designs.

We retrofitted BBwidget as the base of Ival_box. This is not quite right (even if this style is common in real-world systems). The use of BBwidget isn’t part of our basic notion of an Ival_box; it is an implementation detail. Deriving Ival_box from BBwidget elevated an implementation detail to a first-level design decision. That can be right. For example, using the environment defined by “Big Bucks Inc.” may be a key decision based on how our organization conducts its business. However, what if we also wanted to have implementations of our Ival_boxes for systems from “Imperial Bananas,” “Liberated Software,” and “Compiler Whizzes”? We would have to maintain four distinct versions of our program:

Click here to view code image

class Ival_box : public BBwidget { /* ... */ };       // BB version
class Ival_box : public CWwidget { /* ... */ };       // CW version
class Ival_box : public IBwidget { /* ... */ };       // IB version
class Ival_box : public LSwindow { /* ... */ };       // LS version
Having many versions could result in a version control nightmare.

In reality, we are unlikely to find a simple, coherent, two-letter prefix scheme. More likely, the libraries from different purveyors would be in different namespaces and use different terminologies for similar concepts, such as BigBucks::Widget, Wizzies::control, and LS::window. But that does not affect our class hierarchy design discussion, so to simplify I ignore naming and namespace issues.

Another problem is that every derived class shares the basic data declared in Ival_box. That data is, of course, an implementation detail that also crept into our Ival_box interface. From a practical point of view, it is also the wrong data in many cases. For example, an Ival_slider doesn’t need the value stored specifically. It can easily be calculated from the position of the slider when someone executes get_value(). In general, keeping two related, but different, sets of data is asking for trouble. Sooner or later someone will get them out of sync. Also, experience shows that novice programmers tend to mess with protected data in ways that are unnecessary and that cause maintenance problems. Data members are better kept private so that writers of derived classes cannot mess with them. Better still, data should be in the derived classes, where it can be defined to match requirements exactly and cannot complicate the life of unrelated derived classes. In almost all cases, a protected interface should contain only functions, types, and constants.

Deriving from BBwidget gives the benefit of making the facilities provided by BBwidget available to users of Ival_box. Unfortunately, it also means that changes to class BBwidget may force users to recompile or even rewrite their code to recover from such changes. In particular, the way most C++ implementations work implies that a change in the size of a base class requires a recompilation of all derived classes.

Finally, our program may have to run in a mixed environment in which windows of different user-interface systems coexist. This could happen either because two systems somehow share a screen or because our program needs to communicate with users on different systems. Having our user-interface systems “wired in” as the one and only base of our one and only Ival_box interface just isn’t flexible enough to handle those situations.

21.2.2. Interface Inheritance
So, let’s start again and build a new class hierarchy that solves the problems presented in the critique of the traditional hierarchy:

[1] The user-interface system should be an implementation detail that is hidden from users who don’t want to know about it.

[2] The Ival_box class should contain no data.

[3] No recompilation of code using the Ival_box family of classes should be required after a change of the user-interface system.

[4] Ival_boxes for different interface systems should be able to coexist in our program.

Several alternative approaches can be taken to achieve this. Here, I present one that maps cleanly into the C++ language.

First, I specify class Ival_box as a pure interface:

Click here to view code image

class Ival_box {
public:
     virtual int get_value() = 0;
     virtual void set_value(int i) = 0;
     virtual void reset_value(int i) = 0;
     virtual void prompt() = 0;
     virtual bool was_changed() const = 0;
     virtual ~Ival_box() { }
};
This is much cleaner than the original declaration of Ival_box. The data is gone and so are the simplistic implementations of the member functions. Gone, too, is the constructor, since there is no data for it to initialize. Instead, I added a virtual destructor to ensure proper cleanup of the data that will be defined in the derived classes.

The definition of Ival_slider might look like this:

Click here to view code image

class Ival_slider : public Ival_box, protected BBwidget {
public:
     Ival_slider(int,int);
     ~Ival_slider() override;

     int get_value() override;
     void set_value(int i) override;
      //...
protected:
      //... functions overriding BBwidget virtual functions
      // e.g., BBwidget::draw(), BBwidget::mouse1hit() ...
private:
      //... data needed for slider ...
};
The derived class Ival_slider inherits from an abstract class (Ival_box) that requires it to implement the base class’s pure virtual functions. It also inherits from BBwidget which provides it with the means of doing so. Since Ival_box provides the interface for the derived class, it is derived using public. Since BBwidget is only an implementation aid, it is derived using protected (§20.5.2). This implies that a programmer using Ival_slider cannot directly use facilities defined by BBwidget. The interface provided by Ival_slider is the one inherited from Ival_box, plus what Ival_slider explicitly declares. I used protected derivation instead of the more restrictive (and usually safer) private derivation to make BBwidget available to classes derived from Ival_slider. I used explicit override because this “widget hierarchy” is exactly the kind of large, complicated hierachy where being explicit can help minimize confusion.

Deriving directly from more than one class is usually called multiple inheritance (§21.3). Note that Ival_slider must override functions from both Ival_box and BBwidget. Therefore, it must be derived directly or indirectly from both. As shown in §21.2.1.1, deriving Ival_slider indirectly from BBwidget by making BBwidget a base of Ival_box is possible, but doing so has undesirable side effects. Similarly, making the “implementation class” BBwidget a member of Ival_box is not a solution because a class cannot override virtual functions of its members. Representing the window by a BBwidget* member in Ival_box leads to a completely different design with a separate set of tradeoffs.

To some people, the words “multiple inheritance” indicate something complicated and scary. However, the use of one base class for implementation details and another for interface (the abstract class) is common to all languages supporting inheritance and compile-time checked interfaces. In particular, the use of the abstract class Ival_box is almost identical to the use of an interface in Java or C#.

Interestingly, this declaration of Ival_slider allows application code to be written exactly as before. All we have done is to restructure the implementation details in a more logical way.

Many classes require some form of cleanup for an object before it goes away. Since the abstract class Ival_box cannot know if a derived class requires such cleanup, it must assume that it does require some. We ensure proper cleanup by defining a virtual destructor Ival_box::~Ival_box() in the base and overriding it suitably in derived classes. For example:

void f(Ival_box* p)
{
      //...
     delete p;
}
The delete operator explicitly destroys the object pointed to by p. We have no way of knowing exactly to which class the object pointed to by p belongs, but thanks to Ival_box’s virtual destructor, proper cleanup as (optionally) defined by that class’ destructor will be done.

The Ival_box hierarchy can now be defined like this:

Click here to view code image

class Ival_box { /* ... */ };
class Ival_slider
     : public Ival_box, protected BBwidget { /* ... */ };
class Ival_dial
     : public Ival_box, protected BBwidget { /* ... */ };
class Flashing_ival_slider
     : public Ival_slider { /* ... */ };
class Popup_ival_slider
     : public Ival_slider { /* ... */ };
or graphically:



I used a dashed line to represent protected inheritance (§20.5.1). General users cannot access the protected bases because they are (correctly) considered part of the implementation.

21.2.3. Alternative Implementations
This design is cleaner and more easily maintainable than the traditional one – and no less efficient. However, it still fails to solve the version control problem:

Click here to view code image

class Ival_box { /* ... */ };  // common
class Ival_slider
     : public Ival_box, protected BBwidget { /* ... */ };  // for BB
class Ival_slider
     : public Ival_box, protected CWwidget { /* ... */ };  // for CW
 //...
There is no way of having the Ival_slider for BBwidgets coexist with the Ival_slider for CWwidgets, even if the two user-interface systems could themselves coexist. The obvious solution is to define several different Ival_slider classes with separate names:

Click here to view code image

class Ival_box { /* ... */ };
class BB_ival_slider
     : public Ival_box, protected BBwidget { /* ... */ };
class CW_ival_slider
     : public Ival_box, protected CWwidget { /* ... */ };
 //...
or graphically:



To further insulate our application-oriented Ival_box classes from implementation details, we can derive an abstract Ival_slider class from Ival_box and then derive the system-specific Ival_sliders from that:

Click here to view code image

class Ival_box { /* ... */ };
class Ival_slider
     : public Ival_box { /* ... */ };
class BB_ival_slider
     : public Ival_slider, protected BBwidget { /* ... */ };
class CW_ival_slider
     : public Ival_slider, protected CWwidget { /* ... */ };
 //...
or graphically:



Usually, we can do better yet by utilizing more specific classes in the implementation hierarchy. For example, if the “Big Bucks Inc.” system has a slider class, we can derive our Ival_slider directly from the BBslider:

Click here to view code image

class BB_ival_slider
     : public Ival_slider, protected BBslider { /* ... */ };
class CW_ival_slider
     : public Ival_slider, protected CWslider { /* ... */ };
or graphically:



This improvement becomes significant where – as is not uncommon – our abstractions are not too different from the ones provided by the system used for implementation. In that case, programming is reduced to mapping between similar concepts. Derivation from general base classes, such as BBwidget, is then done only rarely.

The complete hierarchy will consist of our original application-oriented conceptual hierarchy of interfaces expressed as derived classes:

class Ival_box { /* ... */ };
class Ival_slider
     : public Ival_box { /* ... */ };
class Ival_dial
     : public Ival_box { /* ... */ };
class Flashing_ival_slider
     : public Ival_slider { /* ... */ };
class Popup_ival_slider
     : public Ival_slider { /* ... */ };
followed by the implementations of this hierarchy for various graphical user interface systems, expressed as derived classes:

Click here to view code image

class BB_ival_slider
     : public Ival_slider, protected BBslider { /* ... */ };
class BB_flashing_ival_slider
     : public Flashing_ival_slider, protected BBwidget_with_bells_and_whistles { /* ... */ };
class BB_popup_ival_slider
     : public Popup_ival_slider, protected BBslider { /* ... */ }; class CW_ival_slider
     : public Ival_slider, protected CWslider { /* ... */ };
 //...
Using obvious abbreviations, this hierarchy can be represented graphically like this:



The original Ival_box class hierarchy appears unchanged surrounded by implementation classes.

21.2.3.1. Critique
The abstract class design is flexible and almost as simple to deal with as the equivalent design that relies on a common base defining the user-interface system. In the latter design, the windows class is the root of a tree. In the former, the original application class hierarchy appears unchanged as the root of classes that supply its implementations. From the application’s point of view, these designs are equivalent in the strong sense that almost all code works unchanged and in the same way in the two cases. In either case, you can look at the Ival_box family of classes without bothering with the window-related implementation details most of the time. For example, we would not need to rewrite interact() from §21.2.1 if we switched from one class hierarchy to the other.

In either case, the implementation of each Ival_box class must be rewritten when the public interface of the user-interface system changes. However, in the abstract class design, almost all user code is protected against changes to the implementation hierarchy and requires no recompilation after such a change. This is especially important when the supplier of the implementation hierarchy issues a new “almost compatible” release. In addition, users of the abstract class hierarchy are in less danger of being locked into a proprietary implementation than are users of a classical hierarchy. Users of the Ival_box abstract class application hierarchy cannot accidentally use facilities from the implementation because only facilities explicitly specified in the Ival_box hierarchy are accessible; nothing is implicitly inherited from an implementation-specific base class.

The logical conclusion of this line of thought is a system represented to users as a hierarchy of abstract classes and implemented by a classical hierarchy. In other words:

• Use abstract classes to support interface inheritance (§3.2.3, §20.1).

• Use base classes with implementations of virtual functions to support implementation inheritance (§3.2.3, §20.1).

21.2.4. Localizing Object Creation
Most of an application can be written using the Ival_box interface. Further, should the derived interfaces evolve to provide more facilities than plain Ival_box, then most of an application can be written using the Ival_box, Ival_slider, etc., interfaces. However, the creation of objects must be done using implementation-specific names such as CW_ival_dial and BB_flashing_ival_slider. We would like to minimize the number of places where such specific names occur, and object creation is hard to localize unless it is done systematically.

As usual, the solution is to introduce an indirection. This can be done in many ways. A simple one is to introduce an abstract class to represent the set of creation operations:

Click here to view code image

class Ival_maker {
public:
     virtual Ival_dial* dial(int, int) =0;                    // make dial
     virtual Popup_ival_slider* popup_slider(int, int) =0;    // make popup slider
      //...
};
For each interface from the Ival_box family of classes that a user should know about, class Ival_maker provides a function that makes an object. Such a class is sometimes called a factory, and its functions are (somewhat misleadingly) sometimes called virtual constructors (§20.3.6).

We now represent each user-interface system by a class derived from Ival_maker:

Click here to view code image

class BB_maker : public Ival_maker {         // make BB versions
public:
     Ival_dial* dial(int, int) override;
     Popup_ival_slider* popup_slider(int, int) override;
      //...
};

class LS_maker : public Ival_maker {        // make LS versions
public:
     Ival_dial* dial(int, int) override;
     Popup_ival_slider* popup_slider(int, int) override;
      //...
};
Each function creates an object of the desired interface and implementation type. For example:

Click here to view code image

Ival_dial* BB_maker::dial(int a, int b)
{
     return new BB_ival_dial(a,b);
}

Ival_dial* LS_maker::dial(int a, int b)
{
     return new LS_ival_dial(a,b);
}
Given an Ival_maker, a user can now create objects without having to know exactly which user-interface system is used. For example:

Click here to view code image

void user(Ival_maker& im)
{
     unique_ptr<Ival_box> pb {im.dial(0,99)};     // create appropriate dial
      //...
}

BB_maker BB_impl;       // for BB users
LS_maker LS_impl;       // for LS users

void driver()
{
     user(BB_impl);     // use BB
     user(LS_impl);     // use LS
}
Passing arguments to such “virtual constructors” is a bit tricky. In particular, we cannot override the base class functions that represent the interface with different arguments in different derived classes. This implies that a fair bit of foresight is required to design the factory class’s interface.

21.3. Multiple Inheritance
As described in §20.1, inheritance aims to provide one of two benefits:

• Shared interfaces: leading to less replication of code using classes and making such code more uniform. This is often called run-time polymorphism or interface inheritance.

• Shared implementation: leading to less code and more uniform implementation code. This is often called implementation inheritance.

A class can combine aspects of these two styles.

Here, we explore more general uses of multiple base classes and examine more technical issues related to combining and accessing features from multiple base classes.

21.3.1. Multiple Interfaces
An abstract class (e.g., Ival_box; §21.2.2) is the obvious way to represent an interface. For an abstract class without mutable state, there really is little difference between single and multiple uses of a base class in a class hierarchy. The resolution of potential ambiguities is discussed in §21.3.3, §21.3.4, and §21.3.5. In fact, any class without mutable state can be used as an interface in a multiple-inheritance lattice without significant complications and overhead. The key observation is that a class without mutable state can be replicated if necessary or shared if that is desired.

The use of multiple abstract classes as interfaces is almost universal in object-oriented designs (in any language with a notion of an interface).

21.3.2. Multiple Implementation Classes
Consider a simulation of bodies orbiting the Earth in which orbiting objects are represented as object of class Satellite. A Satellite object would contain orbital, size, shape, albedo, density parameters, etc., and provide operations for orbital calculations, modifying attributes, etc. Examples of satellites would be rocks, debris from old space vehicles, communication satellites, and the International Space Station. These kinds of satellites would be objects of classes derived from Satellite. Such derived classes would add data members and functions and would override some of Satellite’s virtual functions to adjust their meaning suitably.

Now assume that I want to display the results of these simulations graphically and that I had available a graphics system that used the (not uncommon) strategy of deriving objects to be displayed from a common base class holding graphical information. This graphics class would provide operations for placement on the screen, scaling, etc. For generality, simplicity, and to hide the details of the actual graphics system, I will refer to the class providing graphical (or in fact alternatively nongraphical) output Displayed.

We can now define a class of simulated communication satellites, class Comm_sat:

Click here to view code image

class Comm_sat : public Satellite, public Displayed {
public:
      //...
};
or graphically:


In addition to whatever operations are defined specifically for a Comm_sat, the union of operations on Satellite and Displayed can be applied. For example:

Click here to view code image

void f(Comm_sat& s)
{
     s.draw();            // Displayed::draw()
     Pos p = s.center();  // Satellite::center()
     s.transmit();        // Comm_sat::transmit()
}
Similarly, a Comm_sat can be passed to a function that expects a Satellite and to a function that expects Displayed. For example:

Click here to view code image

void highlight(Displayed*);
Pos center_of_gravity(const Satellite*);

void g(Comm_sat* p)
{
     highlight(p);                   // pass a pointer to the Displayed part of the Comm_sat
     Pos x = center_of_gravity(p);   // pass a pointer to the Satellite part of the Comm_sat
}
The implementation of this clearly involves some (simple) compiler technique to ensure that functions expecting a Satellite see a different part of a Comm_sat than do functions expecting a Displayed. Virtual functions work as usual. For example:

Click here to view code image

class Satellite {
public:
     virtual Pos center() const = 0;         // center of gravity
      //...
};

class Displayed {
public:
     virtual void draw() = 0;
      //...
};

class Comm_sat : public Satellite, public Displayed {
public:
     Pos center() const override;     // override Satellite::center()
     void draw() override;            // override Displayed::draw()
      //...
};
This ensures that Comm_sat::center() and Displayed::draw() will be called for a Comm_sat treated as a Satellite and a Displayed, respectively.

Why didn’t I just keep the Satellite and Displayed parts of a Comm_sat completely separate? I could have defined Comm_sat to have a Satellite member and a Displayed member. Alternatively, I could have defined Comm_sat to have a Satellite* member and a Displayed* member and let its constructor set up the proper connections. For many design problems, I would do just that. However, the system that inspired this example was built on the idea of a Satellite class with virtual functions and a (separately designed) Displayed class with virtual functions. You provided your own satellites and your own displayed objects through derivation. In particular, you had to override Satellite virtual member functions and Displayed virtual member functions to specify the behavior of your own objects. That is the situation in which multiple inheritance of base classes with state and implementation is hard to avoid. Workarounds can be painful and hard to maintain.

The use of multiple inheritance to “glue” two otherwise unrelated classes together as part of the implementation of a third class is crude, effective, and relatively important, but not very interesting. Basically, it saves the programmer from writing a lot of forwarding functions (to compensate for the fact that we can only override functions defined in bases). This technique does not affect the overall design of a program significantly and can occasionally clash with the wish to keep implementation details hidden. However, a technique doesn’t have to be clever to be useful.

I generally prefer to have a single implementation hierarchy and (where needed) several abstract classes providing interfaces. This is typically more flexible and leads to systems that are easier to evolve. However, you can’t always get that – especially if you need to use existing classes that you don’t want to modify (e.g., because they are parts of someone else’s library).

Note that with single inheritance (only), the programmer’s choices for implementing the classes Displayed, Satellite, and Comm_sat would be limited. A Comm_sat could be a Satellite or a Displayed, but not both (unless Satellite was derived from Displayed or vice versa). Either alternative involves a loss of flexibility.

Why would anyone want a class Comm_sat? Contrary to some people’s conjectures, the Satellite example is real. There really was – and maybe there still is – a program constructed along the lines used to describe multiple implementation inheritance here. It was used to study the design of communication systems involving satellites, ground stations, etc. In fact, Satellite was derived from an early notion of a concurrent task. Given such a simulation, we can answer questions about communication traffic flow, determine proper responses to a ground station that is being blocked by a rainstorm, consider tradeoffs between satellite connections and Earth-bound connections, etc.

21.3.3. Ambiguity Resolution
Two base classes may have member functions with the same name. For example:

class Satellite {
public:
     virtual Debug_info get_debug();
      //...
};

class Displayed {
public:
     virtual Debug_info get_debug();
      //...
};
When a Comm_sat is used, these functions must be disambiguated. This can be done simply by qualifying a member name by its class name:

Click here to view code image

void f(Comm_sat& cs)
{
     Debug_info di = cs.get_debug();       // error: ambiguous
     di = cs.Satellite::get_debug();       // OK
     di = cs.Displayed::get_debug();       // OK
}
However, explicit disambiguation is messy, so it is usually best to resolve such problems by defining a new function in the derived class:

Click here to view code image

class Comm_sat : public Satellite, public Displayed {
public:
     Debug_info get_debug()   // override Comm_sat::get_debug() and Displayed::get_debug()
     {
          Debug_info di1 = Satellite::get_debug();
          Debug_info di2 = Displayed::get_debug();
          return merge_info(di1,di2);
     }
      //...
};
A function declared in a derived class overrides all functions of the same name and type in its base classes. Typically, that is exactly the right thing to do because it is generally a bad idea to use the same name for operations with different semantics in a single class. The ideal for virtual is for a call to have the same effect independently of which interface was used to find the function (§20.3.2).

In the implementation of an overriding function, it is often necessary to explicitly qualify the name to get the right version from a base class. A qualified name, such as Telstar::draw, can refer to a draw declared either in Telstar or in one of its base classes. For example:

Click here to view code image

class Telstar : public Comm_sat {
public:
     void draw()
     {
          Comm_sat::draw();        // finds Displayed::draw
           //... own stuff ...
     }
      //...
};
or graphically:


If Comm_sat::draw doesn’t resolve to a draw declared in Comm_sat, the compiler recursively looks in its base classes; that is, it looks for Satellite::draw and Displayed::draw, and if necessary looks in their base classes. If exactly one match is found, that name will be used. Otherwise, Comm_sat::draw is either not found or is ambiguous.

If, in Telstar::draw(), I had said plain draw(), the result would have been an “infinite” recursive call of Telstar::draw().

I could have said Displayed::draw(), but now the code would be subtly broken if someone added a Comm_sat::draw(); it is generally better to refer to a direct base class than to an indirect base class. I could have said Comm_sat::Displayed::draw(), but that would have been redundant. Had I said Satellite::draw(), the result would have been an error because the draw is over on the Displayed branch of the class hierarchy.

The get_debug() example basically assumes that at least some parts of Satellite and Displayed have been designed together. Getting an exact match of names, return types, argument types, and semantics by accident is extremely unlikely. It is far more likely that similar functionality is provided in different ways so that it takes effort to merge it into something that can be used together. We might originally have been presented with two classes SimObj and Widget that we could not modify, didn’t exactly provide what we needed, and where they did provide what we needed, did so through incompatible interfaces. In that case, we might have designed Satellite and Displayed as our interface classes, providing a “mapping layer” for our higher-level classes to use:

Click here to view code image

class Satellite : public SimObj {
      // map SimObj facilities to something easier to use for Satellite simulation
public:
     virtual Debug_info get_debug();       // call SimObj::DBinf() and extract information
      //...
};

class Displayed : public Widget {
      // map Widget facilities to something easier to use to display Satellite simulation results
public:
     virtual Debug_info get_debug();      // read Widget data and compose Debug_info
      //...
};
or graphically:



Interestingly enough, this is exactly the technique we would use to disambiguate in the unlikely case where two base classes provided operations with exactly the same name, but with different semantics: add an interface layer. Consider the classical (but mostly hypothetical/theoretical) example of a class of a draw() member function in a video game involving cowboys:

Click here to view code image

class Window {
public:
     void draw();       // display image
      //...
};

class Cowboy {
public:
     void draw();       // pull gun from holster
      //...
};

class Cowboy_window : public Cowboy, public Window {
      //...
};
How do we override Cowboy::draw() and Window::draw()? These two functions have radically different meanings (semantics) but are identical in name and type; we need to override them by two separate functions. There is no direct language solution to this (exotic) problem, but adding intermediate classes will do:

Click here to view code image

struct WWindow : Window {
     using Window::Window;                             // inherit constructors
     virtual void win_draw() = 0;                      // force derived class to override
     void draw() override final { win_draw(); }        // display image
};

struct CCowboy : Cowboy{
     using Cowboy::Cowboy;                             // inherit constructors
     virtual void cow_draw() = 0;                      // force derived class to override
     void draw() override final { cow_draw(); }              // pull gun from holster
};

class Cowboy_window : public CCowboy, public WWindow {
public:
     void cow_draw() override;
     void win_draw() override;
      //...
};
Or graphically:


Had the designer of Window been a bit more careful and specified draw() to be const, the whole problem would have evaporated. I find that fairly typical.

21.3.4. Repeated Use of a Base Class
When each class has only one direct base class, the class hierarchy will be a tree, and a class can only occur once in the tree. When a class can have multiple base classes, a class can appear multiple times in the resulting hierarchy. Consider a class providing facilities for storing state in a file (e.g., for breakpointing, debug information, or persistence) and restoring it later:

struct Storable {     // persistent storage
     virtual string get_file() = 0;
     virtual void read() = 0;
     virtual void write() = 0;

     virtual ~Storable() { }
};
Such a useful class will naturally be used in several places in a class hierarchy. For example:

Click here to view code image

class Transmitter : public Storable {
public:
     void write() override;
      //...
};

class Receiver : public Storable {
public:
     void write() override;
      //...
};

class Radio : public Transmitter, public Receiver {
public:
     string get_file() override;
     void read() override;
     void write() override;
      //...
};
Given that, we could imagine two cases:

[1] A Radio object has two subobjects of class Storable (one for Transmitter and one for Receiver).

[2] A Radio object has one subobject of class Storable (shared by Transmitter and Receiver).

The default, provided for the example as written, is two subobjects. Unless you state otherwise, you get one copy for each time you mention a class as a base. Graphically, we can represent that like this:



A virtual function of a replicated base class can be overridden by a (single) function in a derived class. Typically, an overriding function calls its base class versions and then does the work specific to the derived class:

Click here to view code image

void Radio::write()
{
     Transmitter::write();
     Receiver::write();
      //... write radio-specific information ...
}
Casting from a replicated base class to a derived class is discussed in §22.2. For a technique for overriding each of the write() functions with separate functions from derived classes, see §21.3.3.

21.3.5. Virtual Base Classes
The Radio example in the previous subsection works because class Storable can be safely, conveniently, and efficiently replicated. The reason for that is simply that Storable is an abstract class providing a pure interface. A Storable object holds no data of its own. This is the simplest case and the one that offers the best separation of interface and implementation concerns. In fact, a class could not without some difficulty determine that there were two Storable subobjects on a Radio.

What if Storable did hold data and it was important that it should not be replicated? For example, we might define Storable to hold the name of the file to be used for storing the object:

Click here to view code image

class Storable {
public:
     Storable(const string& s);     // store in file named s
     virtual void read() = 0;
     virtual void write() = 0;
     virtual ~Storable();
protected:
     string file_name;

     Storable(const Storable&) = delete;
     Storable& operator=(const Storable&) = delete;
};
Given this apparently minor change to Storable, we must change the design of Radio. All parts of an object must share a single copy of Storable. Otherwise, we could get two parts of something derived from Storable multiple times using different files. We avoid replication by declaring a base virtual: every virtual base of a derived class is represented by the same (shared) object. For example:

Click here to view code image

class Transmitter : public virtual Storable {
public:
     void write() override;
      //...
};

class Receiver : public virtual Storable {
public:
     void write() override;
      //...
};

class Radio : public Transmitter, public Receiver {
public:
     void write() override;
      //...
};
Or graphically:



Compare this diagram with the drawing of the Storable object in §21.3.4 to see the difference between ordinary inheritance and virtual inheritance. In an inheritance graph, every base class of a given name that is specified to be virtual will be represented by a single object of that class. On the other hand, each base class not specified virtual will have its own subobject representing it.

Why would someone want to use a virtual base containing data? I can think of three obvious ways for two classes in a class hierarchy to share data:

[1] Make the data nonlocal (outside the class as a global or namespace variable).

[2] Put the data in a base class.

[3] Allocate an object somewhere and give each of the two classes a pointer.

Option [1], nonlocal data, is usually a poor choice because we cannot control what code accesses the data and how. It breaks all notions of encapsulation and locality.

Option [2], put the data in a base class, is usually the simplest. However, for single inheritance that solution makes useful data (and functions) “bubble up” to a common base class; often it “bubbles” all the way to the root of an inheritance tree. This means that every member of the class hierarchy gets access. That is logically very similar to using nonlocal data and suffers from the same problems. So we need a common base that is not the root of a tree – that is, a virtual base.

Option [3], sharing an object accessed through pointers, makes sense. However, then constructor(s) need to set aside memory for that shared object, initialize it, and provide pointers to the shared object to objects needing access. That is roughly what constructors do to implement a virtual base.

If you don’t need sharing, you can do without virtual bases, and your code is often better and typically simpler for it. However, if you do need sharing within a general class hierarchy, you basically have a choice between using a virtual base and laboriously constructing your own variants of the idea.

We can represent an object of a class with a virtual base like this:


The “pointers” to the shared object representing the virtual base, Storable, will be offsets, and often one of those can be optimized away by placing Storable in a fixed position relative to either the Receiver or the Transmitter subobject. Expect a storage overhead of one word for each virtual base.

21.3.5.1. Constructing Virtual Bases
Using virtual bases you can create complicated lattices. Naturally, we would prefer to keep the lattices simple, but however complicated we make them, the language ensures that a constructor of a virtual base is called exactly once. Furthermore, the constructor of a base (whether virtual or not) is called before its derived classes. Anything else would cause chaos (that is, an object might be used before it had been initialized). To avoid such chaos, the constructor of every virtual base is invoked (implicitly or explicitly) from the constructor for the complete object (the constructor for the most derived class). In particular, this ensures that a virtual base is constructed exactly once even if it is mentioned in many places in the class hierarchy. For example:

Click here to view code image

struct V {
     V(int i);
      //...
};

struct A {
     A();      // default constructor
      //...
};

struct B : virtual V, virtual A {
     B() :V{1} { /* ... */ };  // default constructor; must initialize base V
      //...
};

class C : virtual V {
public:
     C(int i) : V{i} { /* ... */ };  // must initialize base V
      //...
};

class D : virtual public B, virtual public C {
      // implicitly gets the virtual base V from B and C
      // implicitly gets virtual base A from B
public:
     D() { /* ... */ }                       // error: no default constructor for C or V
     D(int i) :C{i} { /* ... */ };           // error: no default constructor for V
     D(int i, int j) :V{i}, C{j} { /* ... */ }      // OK
      //...
};
Note that D can and must provide an initializer for V. The fact that V wasn’t explicitly mentioned as a base of D is irrelevant. Knowledge of a virtual base and the obligation to initialize it “bubbles up” to the most derived class. A virtual base is always considered a direct base of its most derived class. The fact that both B and C initialized V is irrelevant because the compiler has no idea which of those two initializers to prefer. Thus, only the initializer provided by the most derived class is used.

The constructor for a virtual base is called before the constructors for its derived classes.

In practice, this is not quite as localized as we would prefer. In particular, if we derive another class, DD, from D, then DD has to do work to initialize the virtual bases. Unless we can simply inherit D’s constructors (§20.3.5.1), that can be a nuisance. That ought to encourage us not to overuse virtual base classes.

This logical problem with constructors does not exist for destructors. They are simply invoked in reverse order of construction (§20.2.2). In particular, a destructor for a virtual base is invoked exactly once.

21.3.5.2. Calling a Virtual Class Member Once Only
When defining the functions for a class with a virtual base, the programmer in general cannot know whether the base will be shared with other derived classes. This can be a problem when implementing a service that requires a base class function to be called exactly once for each call of a derived function. Where needed, the programmer can simulate the scheme used for constructors by calling a virtual base class function only from the most derived class. For example, assume we have a basic Window class that knows how to draw its contents:

class Window {
public:
      // basic stuff
     virtual void draw();
};
In addition, we have various ways of decorating a window and adding facilities:

Click here to view code image

class Window_with_border : public virtual Window {
      // border stuff
protected:
     void own_draw();     // display the border
public:
     void draw() override;
};

class Window_with_menu : public virtual Window {
      // menu stuff
protected:
     void own_draw();    // display the menu
public:
     void draw() override;
};
The own_draw() functions need not be virtual because they are meant to be called from within a virtual draw() function that “knows” the type of the object for which it was called.

From this, we can compose a plausible Clock class:

Click here to view code image

class Clock : public Window_with_border, public Window_with_menu {
      // clock stuff
protected:
     void own_draw();    // display the clock face and hands
public:
     void draw() override;
};
or graphically:



The draw() functions can now be defined using the own_draw() functions, so that a caller of any draw() gets Window::draw() invoked exactly once. This is done independently of the kind of Window for which draw() is invoked:

Click here to view code image

void Window_with_border::draw()
{
     Window::draw();
     own_draw();    // display the border
}

void Window_with_menu::draw()
{
     Window::draw();
     own_draw();    // display the menu
}

void Clock::draw()
{
     Window::draw();
     Window_with_border::own_draw();
     Window_with_menu::own_draw();
     own_draw();   // display the clock face and hands
}
Note that a qualified call, such as Window::draw(), does not use the virtual call mechanism. Instead, it directly calls the explicitly named function, thus avoiding nasty infinite recursion.

Casting from a virtual base class to a derived class is discussed in §22.2.

21.3.6. Replicated vs. Virtual Bases
Using multiple inheritance to provide implementations for abstract classes representing pure interfaces affects the way a program is designed. Class BB_ival_slider (§21.2.3) is an example:

Click here to view code image

class BB_ival_slider
   : public Ival_slider,         // interface
     protected BBslider          // implementation
{
    // implementation of functions required by Ival_slider and BBslider, using facilities from BBslider
};
In this example, the two base classes play logically distinct roles. One base is a public abstract class providing the interface, and the other is a protected concrete class providing implementation “details.” These roles are reflected in both the style of the classes and in the access control (§20.5) provided. The use of multiple inheritance is close to essential here because the derived class needs to override virtual functions from both the interface and the implementation.

For example, consider again the Ival_box classes from §21.2.1. In the end (§21.2.2), I made all the Ival_box classes abstract to reflect their role as pure interfaces. Doing that allowed me to place all implementation details in specific implementation classes. Also, all sharing of implementation details was done in the classical hierarchy of the windows system used for the implementation.

When using an abstract class (without any shared data) as an interface, we have a choice:

• Replicate the interface class (one object per mention in the class hierarchy).

• Make the interface class virtual to share a simple object among all classes in the hierarchy that mention it.

Using Ival_slider as a virtual base gives us:

Click here to view code image

class BB_ival_slider
     : public virtual Ival_slider, protected BBslider { /* ... */ };
class Popup_ival_slider
     : public virtual Ival_slider { /* ... */ };
class BB_popup_ival_slider
     : public virtual Popup_ival_slider, protected BB_ival_slider { /* ... */ };
or graphically:



It is easy to imagine further interfaces derived from Popup_ival_slider and further implementation classes derived from such classes and BB_popup_ival_slider.

However, we also have this alternative using replicated Ival_slider objects:

Click here to view code image

class BB_ival_slider
     : public Ival_slider, protected BBslider { /* ... */ };
class Popup_ival_slider
     : public Ival_slider { /* ... */ };
class BB_popup_ival_slider
     : public Popup_ival_slider, protected BB_ival_slider { /* ... */ };
or graphically:



Surprisingly, there are no fundamental run-time or space advantages to one design over the other. There are logical differences, though. In the replicated Ival_slider design, a BB_popup_ival_slider can’t be implicitly converted to an Ival_slider (because that would be ambiguous):

Click here to view code image

void f(Ival_slider* p);

void g(BB_popup_ival_slider* p)
{
     f(p);  // error: Popup_ival_slider::Ival_slider or BB_ival_slider::Ival_slider?
}
On the other hand, it is possible to construct plausible scenarios where the sharing implied in the virtual base design causes ambiguities for casts from the base class (§22.2). However, such ambiguities are easily dealt with.

How do we choose between virtual base classes and replicated base classes for our interfaces? Most often, of course, we don’t get a choice because we have to conform to an existing design. When we do have a choice, we can take into account that (surprisingly) the replicated base solution tends to lead to slightly smaller objects (because there is no need for data structures supporting sharing) and that we often get our interface objects from “virtual constructors” or “factory functions” (§21.2.4). For example:

Click here to view code image

Popup_ival_slider* popup_slider_factory(args)
{
     //...
    return new BB_popup_ival_slider(args);
     //...
}
No explicit conversion is needed to get from an implementation (here, BB_popup_ival_slider) to its direct interfaces (here, Popup_ival_slider).

21.3.6.1. Overriding Virtual Base Functions
A derived class can override a virtual function of its direct or indirect virtual base class. In particular, two different classes might override different virtual functions from the virtual base. In that way, several derived classes can contribute implementations to the interface presented by a virtual base class. For example, the Window class might have functions set_color() and prompt(). In that case, Window_with_border might override set_color() as part of controlling the color scheme, and Window_with_menu might override prompt() as part of its control of user interactions:

Click here to view code image

class Window {
      //...
     virtual void set_color(Color) = 0;        // set background color
     virtual void prompt() = 0;
};

class Window_with_border : public virtual Window {
      //...
     void set_color(Color) override;           // control background color
};

class Window_with_menu : public virtual Window {
      //...
     void prompt() override;               // control user interactions
};

class My_window : public Window_with_menu, public Window_with_border {
      //...
};
What if different derived classes override the same function? This is allowed if and only if some overriding class is derived from every other class that overrides the function. That is, one function must override all others. For example, My_window could override prompt() to improve on what Window_with_menu provides:

Click here to view code image

class My_window : public Window_with_menu, public Window_with_border {
      //...
     void prompt() override;  // don't leave user interactions to base
};
or graphically:



If two classes override a base class function, but neither overrides the other, the class hierarchy is an error. The reason is that no single function can be used to give a consistent meaning for all calls independently of which class they use as an interface. Or, using implementation terminology, no virtual function table can be constructed because a call to that function on the complete object would be ambiguous. For example, had Radio in §21.3.5 not declared write(), the declarations of write() in Receiver and Transmitter would have caused an error when defining Radio. As with Radio, such a conflict is resolved by adding an overriding function to the most derived class.

A class that provides some – but not all – of the implementation for a virtual base class is often called a mixin.

21.4. Advice
[1] Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new; §21.2.1.

[2] Avoid data members in base classes intended as interfaces; §21.2.1.1.

[3] Use abstract classes to express interfaces; §21.2.2.

[4] Give an abstract class a virtual destructor to ensure proper cleanup; §21.2.2.

[5] Use override to make overriding explicit in large class hierarchies; §21.2.2.

[6] Use abstract classes to support interface inheritance; §21.2.2.

[7] Use base classes with data members to support implementation inheritance; §21.2.2.

[8] Use ordinary multiple inheritance to express a union of features; §21.3.

[9] Use multiple inheritance to separate implementation from interface; §21.3.

[10] Use a virtual base to represent something common to some, but not all, classes in a hierarchy; §21.3.5.


Copy
copy

Highlight
highlight

Add Note
note

Get Link
link
table of contents
search
Settings
queue

